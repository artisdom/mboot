; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--thumb --list --debug -c --asm --interleave --gnu -o.\output\mci_hs.o --asm_dir=.\output\ --list_dir=.\output\ --depend=.\output\mci_hs.d --cpu=ARM926EJ-S --apcs=interwork -O1 -I.\atmel -I.\ -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\Atmel\SAM9M10 -Dat91sam9m10 -Dddram -DNOFPUT -DTRACE_LEVEL=4 --omf_browse=.\output\mci_hs.crf atmel\mci_hs.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  AT91F_Prepare_Multiple_Transfer PROC
;;;153    #define     LAST_ROW            0x100
;;;154    static void AT91F_Prepare_Multiple_Transfer(unsigned int Channel,
000000  b5f0              PUSH     {r4-r7,lr}
;;;155                                                unsigned int LLI_rownumber,
;;;156                                                unsigned int LLI_Last_Row,
;;;157                                                unsigned int From_add,
;;;158                                                unsigned int To_add,
;;;159                                                unsigned int Ctrla,
;;;160                                                unsigned int Ctrlb)
;;;161    {
000002  ad05              ADD      r5,sp,#0x14
000004  cde0              LDM      r5,{r5-r7}
;;;162        LLI_MCI[LLI_rownumber].sourceAddress =  From_add;
000006  0008              MOVS     r0,r1
000008  2414              MOVS     r4,#0x14
00000a  4360              MULS     r0,r4,r0
00000c  4cfa              LDR      r4,|L1.1016|
00000e  5023              STR      r3,[r4,r0]
;;;163        LLI_MCI[LLI_rownumber].destAddress =  To_add;
000010  1900              ADDS     r0,r0,r4
000012  6045              STR      r5,[r0,#4]
;;;164        LLI_MCI[LLI_rownumber].controlA =  Ctrla;
000014  6086              STR      r6,[r0,#8]
;;;165        LLI_MCI[LLI_rownumber].controlB =  Ctrlb;
000016  60c7              STR      r7,[r0,#0xc]
;;;166        if (LLI_Last_Row != LAST_ROW)
000018  1fd3              SUBS     r3,r2,#7
00001a  3bf9              SUBS     r3,r3,#0xf9
00001c  d005              BEQ      |L1.42|
;;;167            LLI_MCI[LLI_rownumber].descriptor =
00001e  1c49              ADDS     r1,r1,#1
000020  2214              MOVS     r2,#0x14
000022  4351              MULS     r1,r2,r1
000024  1909              ADDS     r1,r1,r4
000026  6101              STR      r1,[r0,#0x10]
;;;168                 (unsigned int)&LLI_MCI[LLI_rownumber + 1] + 0;
;;;169        else {
;;;170            dmaLastLliNdx = LLI_rownumber;
;;;171            LLI_MCI[LLI_rownumber].descriptor = 0;
;;;172        }
;;;173    }
000028  bdf0              POP      {r4-r7,pc}
                  |L1.42|
00002a  4af4              LDR      r2,|L1.1020|
00002c  7011              STRB     r1,[r2,#0]            ;170
00002e  2100              MOVS     r1,#0                 ;171
000030  6101              STR      r1,[r0,#0x10]         ;171
000032  bdf0              POP      {r4-r7,pc}
;;;174    
                          ENDP

                  DMACH_MCI_P2M PROC
;;;176    // forceByte: 1 - byte count, 0 - word count
;;;177    static unsigned int DMACH_MCI_P2M(unsigned int   channel_index,
000034  b5ff              PUSH     {r0-r7,lr}
;;;178                                      unsigned char* src_addr,
;;;179                                      unsigned char* dest_addr,
;;;180                                      unsigned int   trans_size,
;;;181                                      unsigned char  addrIncMode,
;;;182                                      unsigned char  forceByte)
;;;183    {
000036  b08d              SUB      sp,sp,#0x34
000038  9816              LDR      r0,[sp,#0x58]
00003a  000f              MOVS     r7,r1
00003c  0014              MOVS     r4,r2
;;;184        unsigned int srcAddress;
;;;185        unsigned int destAddress;
;;;186        unsigned int buffSize;
;;;187        unsigned int LLI_rownumber = 0;
00003e  2100              MOVS     r1,#0
000040  9107              STR      r1,[sp,#0x1c]
;;;188        unsigned int srcAddressMode = addrIncMode ?
;;;189                                      (AT91C_HDMA_SRC_ADDRESS_MODE_INCR)
;;;190                                    : (AT91C_HDMA_SRC_ADDRESS_MODE_FIXED);
000042  2501              MOVS     r5,#1
000044  066d              LSLS     r5,r5,#25
000046  2800              CMP      r0,#0                 ;188
000048  d001              BEQ      |L1.78|
00004a  2600              MOVS     r6,#0                 ;189
00004c  e000              B        |L1.80|
                  |L1.78|
00004e  002e              MOVS     r6,r5
                  |L1.80|
;;;191        unsigned int scSize, dcSize, mWidth, perWidth, addrInc;
;;;192    
;;;193        // Disable dma channel
;;;194        DMA_DisableChannel(channel_index);
000050  980d              LDR      r0,[sp,#0x34]
000052  f7fffffe          BL       DMA_DisableChannel
;;;195    
;;;196        // DMA channel configuration
;;;197        srcAddress  = (unsigned int)src_addr;    // Set the data start address
000056  9709              STR      r7,[sp,#0x24]
;;;198        destAddress = (unsigned int)dest_addr; //(unsigned int)SSC_THR_ADD; 
;;;199        buffSize    = trans_size;
000058  9810              LDR      r0,[sp,#0x40]
00005a  9008              STR      r0,[sp,#0x20]
;;;200    
;;;201        // Memory width can be WORD if address is aligned
;;;202        mWidth = ((destAddress & 0x3) == 0) ? AT91C_HDMA_DST_WIDTH_WORD
00005c  07a0              LSLS     r0,r4,#30
00005e  d009              BEQ      |L1.116|
;;;203                                            : AT91C_HDMA_DST_WIDTH_BYTE;
000060  2700              MOVS     r7,#0
                  |L1.98|
;;;204        // Peripheral width is byte if FBYTE mode
;;;205        perWidth = forceByte ? AT91C_HDMA_SRC_WIDTH_BYTE
000062  9817              LDR      r0,[sp,#0x5c]
000064  2800              CMP      r0,#0
000066  d000              BEQ      |L1.106|
000068  2500              MOVS     r5,#0
                  |L1.106|
;;;206                             : AT91C_HDMA_SRC_WIDTH_WORD;
;;;207        addrInc  = forceByte ? 1 : 4;
00006a  9817              LDR      r0,[sp,#0x5c]
00006c  2800              CMP      r0,#0
00006e  d003              BEQ      |L1.120|
000070  2001              MOVS     r0,#1
000072  e002              B        |L1.122|
                  |L1.116|
000074  4fe2              LDR      r7,|L1.1024|
000076  e7f4              B        |L1.98|
                  |L1.120|
000078  2004              MOVS     r0,#4
                  |L1.122|
00007a  9004              STR      r0,[sp,#0x10]
;;;208      #if MCI_RD_FIFO_LIMIT
;;;209        if(buffSize >= DMA_TOTAL){
00007c  9808              LDR      r0,[sp,#0x20]
00007e  214b              MOVS     r1,#0x4b
000080  0209              LSLS     r1,r1,#8
000082  4288              CMP      r0,r1
000084  d314              BCC      |L1.176|
;;;210            TRACE_WARNING("SD DMA, size too big %d\n\r", buffSize);
000086  201b              MOVS     r0,#0x1b
000088  f7fffffe          BL       ShellPutByte
00008c  a0dd              ADR      r0,|L1.1028|
00008e  f7fffffe          BL       ShellPrintf
000092  201b              MOVS     r0,#0x1b
000094  f7fffffe          BL       ShellPutByte
000098  a0dd              ADR      r0,|L1.1040|
00009a  f7fffffe          BL       ShellPrintf
00009e  9908              LDR      r1,[sp,#0x20]
0000a0  a0dc              ADR      r0,|L1.1044|
0000a2  f7fffffe          BL       ShellPrintf
0000a6  a0e2              ADR      r0,|L1.1072|
0000a8  f7fffffe          BL       ShellPrintf
;;;211            buffSize = DMA_TOTAL;
0000ac  48e1              LDR      r0,|L1.1076|
0000ae  9008              STR      r0,[sp,#0x20]
                  |L1.176|
;;;212        }
;;;213      #endif
;;;214        // Set DMA channel source address
;;;215        DMA_SetSourceAddr(channel_index, srcAddress);
0000b0  980d              LDR      r0,[sp,#0x34]
0000b2  9909              LDR      r1,[sp,#0x24]
0000b4  0600              LSLS     r0,r0,#24
0000b6  0e00              LSRS     r0,r0,#24
0000b8  900c              STR      r0,[sp,#0x30]
0000ba  f7fffffe          BL       DMA_SetSourceAddr
;;;216    
;;;217        // Set DMA channel destination address
;;;218        DMA_SetDestinationAddr(channel_index,destAddress);
0000be  980c              LDR      r0,[sp,#0x30]
0000c0  0021              MOVS     r1,r4
0000c2  f7fffffe          BL       DMA_SetDestinationAddr
;;;219    
;;;220        // Set DMA channel DSCR
;;;221        DMA_SetDescriptorAddr(channel_index, (unsigned int)&LLI_MCI[0]);
0000c6  49cc              LDR      r1,|L1.1016|
0000c8  980c              LDR      r0,[sp,#0x30]
0000ca  f7fffffe          BL       DMA_SetDescriptorAddr
;;;222    
;;;223        // Set DMA channel control A 
;;;224        DMA_SetSourceBufferSize(channel_index, buffSize,
0000ce  2000              MOVS     r0,#0
0000d0  9000              STR      r0,[sp,#0]
0000d2  9908              LDR      r1,[sp,#0x20]
0000d4  980c              LDR      r0,[sp,#0x30]
0000d6  0f3b              LSRS     r3,r7,#28
0000d8  0e2a              LSRS     r2,r5,#24
0000da  f7fffffe          BL       DMA_SetSourceBufferSize
;;;225                (perWidth >> 24),
;;;226                (mWidth >> 28), 0);
;;;227    
;;;228    	//Set DMA channel control B
;;;229        DMA_SetSourceBufferMode(channel_index, DMA_TRANSFER_LLI,
0000de  980c              LDR      r0,[sp,#0x30]
0000e0  0e32              LSRS     r2,r6,#24
0000e2  2101              MOVS     r1,#1
0000e4  f7fffffe          BL       DMA_SetSourceBufferMode
;;;230                                srcAddressMode >> 24);
;;;231        DMA_SetDestBufferMode(channel_index, DMA_TRANSFER_LLI,
0000e8  980c              LDR      r0,[sp,#0x30]
0000ea  2200              MOVS     r2,#0
0000ec  2101              MOVS     r1,#1
0000ee  f7fffffe          BL       DMA_SetDestBufferMode
;;;232                                (AT91C_HDMA_DST_ADDRESS_MODE_INCR >> 28));
;;;233    
;;;234        // Set DMA channel config
;;;235        DMA_SetConfiguration(channel_index, BOARD_SD_DMA_HW_SRC_REQ_ID \
0000f2  49d1              LDR      r1,|L1.1080|
0000f4  980c              LDR      r0,[sp,#0x30]
0000f6  f7fffffe          BL       DMA_SetConfiguration
;;;236                                            | BOARD_SD_DMA_HW_DEST_REQ_ID \
;;;237                                            | AT91C_HDMA_SRC_H2SEL_HW \
;;;238                                            | AT91C_HDMA_DST_H2SEL_HW \
;;;239                                            | AT91C_HDMA_SOD_DISABLE \
;;;240                                            | AT91C_HDMA_FIFOCFG_ENOUGHSPACE);
;;;241    
;;;242        //scSize = (perChunkSize == 4) ? AT91C_HDMA_SCSIZE_4 : AT91C_HDMA_SCSIZE_1;
;;;243        //dcSize = (memChunkSize == 4) ? AT91C_HDMA_DCSIZE_4 : AT91C_HDMA_DCSIZE_1;
;;;244        scSize = AT91C_HDMA_SCSIZE_1;    dcSize = AT91C_HDMA_DCSIZE_4;
0000fa  2000              MOVS     r0,#0
0000fc  9006              STR      r0,[sp,#0x18]
0000fe  48cf              LDR      r0,|L1.1084|
000100  9005              STR      r0,[sp,#0x14]
;;;245    
;;;246        // Set link list
;;;247        buffSize *= addrInc;    // convert size to byte count
000102  9904              LDR      r1,[sp,#0x10]
000104  9808              LDR      r0,[sp,#0x20]
000106  4348              MULS     r0,r1,r0
;;;248        while(destAddress < ((unsigned int)(dest_addr + buffSize))) {
;;;249            if(((unsigned int)(dest_addr + buffSize)) - destAddress <= (DMA_XFR_SIZE*addrInc) )
000108  1820              ADDS     r0,r4,r0
;;;250            {
;;;251                AT91F_Prepare_Multiple_Transfer(channel_index, LLI_rownumber, LAST_ROW,
;;;252                                            srcAddress,
;;;253                                            destAddress,
;;;254                                            (((((unsigned int)(dest_addr + buffSize))
;;;255                                                   - destAddress)/addrInc)
;;;256                                                    | perWidth
;;;257                                                    | mWidth
;;;258                                                    | scSize
;;;259                                                    | dcSize
;;;260                                                        ),
;;;261                                            ( AT91C_HDMA_DST_DSCR_FETCH_FROM_MEM
;;;262                                               | AT91C_HDMA_DST_ADDRESS_MODE_INCR
;;;263                                               | AT91C_HDMA_SRC_DSCR_FETCH_DISABLE
;;;264                                               | srcAddressMode
;;;265                                               | AT91C_HDMA_FC_PER2MEM));
;;;266            }
;;;267            else
;;;268            {
;;;269                AT91F_Prepare_Multiple_Transfer(channel_index, LLI_rownumber, 0,
;;;270                                            srcAddress,
;;;271                                            destAddress,
;;;272                                            ( (DMA_XFR_SIZE)
;;;273                                                | perWidth
;;;274                                                | mWidth
;;;275                                                | scSize
;;;276                                                | dcSize
;;;277                                                    ),
;;;278                                            (  AT91C_HDMA_DST_DSCR_FETCH_FROM_MEM
;;;279                                                | AT91C_HDMA_DST_ADDRESS_MODE_INCR
;;;280                                                | AT91C_HDMA_SRC_DSCR_FETCH_DISABLE
;;;281                                                | srcAddressMode
;;;282                                                | AT91C_HDMA_FC_PER2MEM));
;;;283    
;;;284            }
;;;285    
;;;286            destAddress += DMA_XFR_SIZE*addrInc;
;;;287    
;;;288            LLI_rownumber++;
00010a  900a              STR      r0,[sp,#0x28]
00010c  e039              B        |L1.386|
                  |L1.270|
00010e  9904              LDR      r1,[sp,#0x10]         ;249
000110  220f              MOVS     r2,#0xf               ;249
000112  0212              LSLS     r2,r2,#8              ;249
000114  4351              MULS     r1,r2,r1              ;249
000116  980a              LDR      r0,[sp,#0x28]         ;249
000118  910b              STR      r1,[sp,#0x2c]         ;249
00011a  1b00              SUBS     r0,r0,r4              ;249
00011c  4288              CMP      r0,r1                 ;249
00011e  d816              BHI      |L1.334|
000120  9904              LDR      r1,[sp,#0x10]         ;251
000122  f7fffffe          BL       __aeabi_uidivmod
000126  9906              LDR      r1,[sp,#0x18]         ;251
000128  4328              ORRS     r0,r0,r5              ;251
00012a  4338              ORRS     r0,r0,r7              ;251
00012c  4308              ORRS     r0,r0,r1              ;251
00012e  9905              LDR      r1,[sp,#0x14]         ;251
000130  22ff              MOVS     r2,#0xff              ;251
000132  4308              ORRS     r0,r0,r1              ;251
000134  2141              MOVS     r1,#0x41              ;251
000136  0409              LSLS     r1,r1,#16             ;251
000138  4331              ORRS     r1,r1,r6              ;251
00013a  9102              STR      r1,[sp,#8]            ;251
00013c  9001              STR      r0,[sp,#4]            ;251
00013e  9b09              LDR      r3,[sp,#0x24]         ;251
000140  9907              LDR      r1,[sp,#0x1c]         ;251
000142  980d              LDR      r0,[sp,#0x34]         ;251
000144  3201              ADDS     r2,#1                 ;251
000146  9400              STR      r4,[sp,#0]            ;251
000148  f7fffffe          BL       AT91F_Prepare_Multiple_Transfer
00014c  e014              B        |L1.376|
                  |L1.334|
00014e  9a06              LDR      r2,[sp,#0x18]         ;269
000150  0028              MOVS     r0,r5                 ;269
000152  4338              ORRS     r0,r0,r7              ;269
000154  4310              ORRS     r0,r0,r2              ;269
000156  9a05              LDR      r2,[sp,#0x14]         ;269
000158  2141              MOVS     r1,#0x41              ;269
00015a  4310              ORRS     r0,r0,r2              ;269
00015c  220f              MOVS     r2,#0xf               ;269
00015e  0212              LSLS     r2,r2,#8              ;269
000160  0409              LSLS     r1,r1,#16             ;269
000162  4310              ORRS     r0,r0,r2              ;269
000164  4331              ORRS     r1,r1,r6              ;269
000166  9102              STR      r1,[sp,#8]            ;269
000168  9001              STR      r0,[sp,#4]            ;269
00016a  9b09              LDR      r3,[sp,#0x24]         ;269
00016c  9907              LDR      r1,[sp,#0x1c]         ;269
00016e  980d              LDR      r0,[sp,#0x34]         ;269
000170  2200              MOVS     r2,#0                 ;269
000172  9400              STR      r4,[sp,#0]            ;269
000174  f7fffffe          BL       AT91F_Prepare_Multiple_Transfer
                  |L1.376|
000178  980b              LDR      r0,[sp,#0x2c]         ;286
00017a  1904              ADDS     r4,r0,r4              ;286
00017c  9807              LDR      r0,[sp,#0x1c]
00017e  1c40              ADDS     r0,r0,#1
000180  9007              STR      r0,[sp,#0x1c]
                  |L1.386|
000182  980a              LDR      r0,[sp,#0x28]         ;248
000184  42a0              CMP      r0,r4                 ;248
000186  d8c2              BHI      |L1.270|
;;;289        }
;;;290    	//TRACE_INFO("DMACH_MCI_P2M()\n\r");
;;;291        return 0;
000188  2000              MOVS     r0,#0
;;;292    }
00018a  b011              ADD      sp,sp,#0x44
00018c  bdf0              POP      {r4-r7,pc}
;;;293    
                          ENDP

                  DMACH_MCI_M2P PROC
;;;295    // forceByte: 1 - byte count, 0 - word count
;;;296    static unsigned int DMACH_MCI_M2P(unsigned int   channel_index,
00018e  b5ff              PUSH     {r0-r7,lr}
;;;297                                      unsigned char* src_addr,
;;;298                                      unsigned char* dest_addr,
;;;299                                      unsigned int   trans_size,
;;;300                                      unsigned char  addrIncMode,
;;;301                                      unsigned char  forceByte)
;;;302    {
000190  b08b              SUB      sp,sp,#0x2c
000192  9814              LDR      r0,[sp,#0x50]
000194  000c              MOVS     r4,r1
000196  001d              MOVS     r5,r3
;;;303        unsigned int srcAddress;
;;;304        unsigned int destAddress;
;;;305        unsigned int buffSize;
;;;306        unsigned int LLI_rownumber = 0;
000198  2100              MOVS     r1,#0
00019a  9107              STR      r1,[sp,#0x1c]
;;;307        unsigned int dstAddressMode = addrIncMode ?
00019c  2800              CMP      r0,#0
00019e  d001              BEQ      |L1.420|
;;;308                                      (AT91C_HDMA_DST_ADDRESS_MODE_INCR)
0001a0  2700              MOVS     r7,#0
0001a2  e000              B        |L1.422|
                  |L1.420|
;;;309                                    : (AT91C_HDMA_DST_ADDRESS_MODE_FIXED);
0001a4  4f96              LDR      r7,|L1.1024|
                  |L1.422|
;;;310        unsigned int dcSize, scSize, mWidth, perWidth, addrInc;
;;;311    
;;;312        // Disable dma channel
;;;313        DMA_DisableChannel(channel_index);
0001a6  980b              LDR      r0,[sp,#0x2c]
0001a8  f7fffffe          BL       DMA_DisableChannel
;;;314    
;;;315        buffSize = trans_size;
;;;316        if(buffSize >= DMA_TOTAL){
0001ac  4ea1              LDR      r6,|L1.1076|
0001ae  42b5              CMP      r5,r6
0001b0  d313              BCC      |L1.474|
;;;317            TRACE_WARNING("SD DMA, size too big %d\n\r", buffSize);
0001b2  201b              MOVS     r0,#0x1b
0001b4  f7fffffe          BL       ShellPutByte
0001b8  a092              ADR      r0,|L1.1028|
0001ba  f7fffffe          BL       ShellPrintf
0001be  201b              MOVS     r0,#0x1b
0001c0  f7fffffe          BL       ShellPutByte
0001c4  a092              ADR      r0,|L1.1040|
0001c6  f7fffffe          BL       ShellPrintf
0001ca  0029              MOVS     r1,r5
0001cc  a091              ADR      r0,|L1.1044|
0001ce  f7fffffe          BL       ShellPrintf
0001d2  a097              ADR      r0,|L1.1072|
0001d4  f7fffffe          BL       ShellPrintf
;;;318            buffSize = DMA_TOTAL;
0001d8  0035              MOVS     r5,r6
                  |L1.474|
;;;319        }
;;;320    
;;;321        // DMA channel configuration
;;;322        srcAddress  = (unsigned int)src_addr;    // Set the data start address
;;;323        destAddress = (unsigned int)dest_addr;
0001da  980d              LDR      r0,[sp,#0x34]
0001dc  9008              STR      r0,[sp,#0x20]
;;;324    
;;;325        // Memory width
;;;326        mWidth = ((srcAddress & 0x3) == 0) ? AT91C_HDMA_SRC_WIDTH_WORD
0001de  07a0              LSLS     r0,r4,#30
0001e0  d005              BEQ      |L1.494|
;;;327                                           : AT91C_HDMA_SRC_WIDTH_BYTE;
0001e2  2600              MOVS     r6,#0
                  |L1.484|
;;;328        // One Transfer size (1 or 4)
;;;329        perWidth = forceByte ? AT91C_HDMA_DST_WIDTH_BYTE
0001e4  9815              LDR      r0,[sp,#0x54]
0001e6  2800              CMP      r0,#0
0001e8  d003              BEQ      |L1.498|
0001ea  2000              MOVS     r0,#0
0001ec  e002              B        |L1.500|
                  |L1.494|
0001ee  4e94              LDR      r6,|L1.1088|
0001f0  e7f8              B        |L1.484|
                  |L1.498|
;;;330                             : AT91C_HDMA_DST_WIDTH_WORD;
0001f2  4883              LDR      r0,|L1.1024|
                  |L1.500|
0001f4  9004              STR      r0,[sp,#0x10]
;;;331        //addrInc = forceByte ? 1 : 4;
;;;332        if (mWidth == AT91C_HDMA_SRC_WIDTH_BYTE) {
0001f6  2e00              CMP      r6,#0
0001f8  d031              BEQ      |L1.606|
;;;333            addrInc = 1;
;;;334            if (!forceByte) buffSize *= 4;
;;;335        }
;;;336        else
;;;337            addrInc = 4;
0001fa  2004              MOVS     r0,#4
0001fc  9003              STR      r0,[sp,#0xc]
                  |L1.510|
;;;338    
;;;339        // Set DMA channel source address
;;;340        DMA_SetSourceAddr(channel_index, srcAddress);
0001fe  980b              LDR      r0,[sp,#0x2c]
000200  0021              MOVS     r1,r4
000202  0600              LSLS     r0,r0,#24
000204  0e00              LSRS     r0,r0,#24
000206  900a              STR      r0,[sp,#0x28]
000208  f7fffffe          BL       DMA_SetSourceAddr
;;;341    
;;;342        // Set DMA channel destination address
;;;343        DMA_SetDestinationAddr(channel_index,destAddress);
00020c  9908              LDR      r1,[sp,#0x20]
00020e  980a              LDR      r0,[sp,#0x28]
000210  f7fffffe          BL       DMA_SetDestinationAddr
;;;344    
;;;345        // Set DMA channel DSCR
;;;346        DMA_SetDescriptorAddr(channel_index, (unsigned int)&LLI_MCI[0]);
000214  4978              LDR      r1,|L1.1016|
000216  980a              LDR      r0,[sp,#0x28]
000218  f7fffffe          BL       DMA_SetDescriptorAddr
;;;347    
;;;348        // Set DMA channel control A 
;;;349        DMA_SetSourceBufferSize(channel_index, buffSize,
00021c  2000              MOVS     r0,#0
00021e  9000              STR      r0,[sp,#0]
000220  9804              LDR      r0,[sp,#0x10]
000222  0e32              LSRS     r2,r6,#24
000224  0f03              LSRS     r3,r0,#28
000226  980a              LDR      r0,[sp,#0x28]
000228  0029              MOVS     r1,r5
00022a  f7fffffe          BL       DMA_SetSourceBufferSize
;;;350                                (mWidth   >> 24),
;;;351                                (perWidth >> 28), 0);
;;;352    
;;;353        //Set DMA channel control B
;;;354        DMA_SetSourceBufferMode(channel_index,
00022e  980a              LDR      r0,[sp,#0x28]
000230  2200              MOVS     r2,#0
000232  2101              MOVS     r1,#1
000234  f7fffffe          BL       DMA_SetSourceBufferMode
;;;355                                DMA_TRANSFER_LLI,
;;;356                                (AT91C_HDMA_SRC_ADDRESS_MODE_INCR >> 24));
;;;357        DMA_SetDestBufferMode(channel_index,
000238  980a              LDR      r0,[sp,#0x28]
00023a  0f3a              LSRS     r2,r7,#28
00023c  2101              MOVS     r1,#1
00023e  f7fffffe          BL       DMA_SetDestBufferMode
;;;358                              DMA_TRANSFER_LLI,
;;;359                              dstAddressMode >> 28);
;;;360    
;;;361        // Set DMA channel config
;;;362        DMA_SetConfiguration(channel_index, BOARD_SD_DMA_HW_SRC_REQ_ID \
000242  2101              MOVS     r1,#1
000244  980a              LDR      r0,[sp,#0x28]
000246  0349              LSLS     r1,r1,#13
000248  f7fffffe          BL       DMA_SetConfiguration
;;;363                                            | BOARD_SD_DMA_HW_DEST_REQ_ID \
;;;364                                            | AT91C_HDMA_SRC_H2SEL_SW \
;;;365                                            | AT91C_HDMA_DST_H2SEL_HW \
;;;366                                            | AT91C_HDMA_SOD_DISABLE \
;;;367                                            | AT91C_HDMA_FIFOCFG_LARGESTBURST);
;;;368        //dcSize = (perChunkSize == 4) ? AT91C_HDMA_DCSIZE_4 : AT91C_HDMA_DCSIZE_1;
;;;369        //scSize = (memChunkSize == 4) ? AT91C_HDMA_SCSIZE_4 : AT91C_HDMA_SCSIZE_1;
;;;370        dcSize = AT91C_HDMA_DCSIZE_1;    scSize = AT91C_HDMA_SCSIZE_4;
00024c  2000              MOVS     r0,#0
00024e  9006              STR      r0,[sp,#0x18]
000250  487c              LDR      r0,|L1.1092|
000252  9005              STR      r0,[sp,#0x14]
;;;371    
;;;372        // Set link list
;;;373        buffSize *= addrInc; // convert to byte address
000254  9803              LDR      r0,[sp,#0xc]
000256  4345              MULS     r5,r0,r5
;;;374        while(srcAddress < ((unsigned int)(src_addr + buffSize)))
;;;375        {
;;;376            if(((unsigned int)(src_addr + buffSize)) - srcAddress <= (DMA_XFR_SIZE*addrInc) )
000258  1960              ADDS     r0,r4,r5
;;;377            {
;;;378                AT91F_Prepare_Multiple_Transfer(channel_index, LLI_rownumber, LAST_ROW,
;;;379                                            srcAddress,
;;;380                                            destAddress,
;;;381                                            (((((unsigned int)(src_addr + buffSize))
;;;382                                                    - srcAddress)/addrInc)
;;;383                                                      | mWidth
;;;384                                                      | perWidth
;;;385                                                      | scSize
;;;386                                                      | dcSize
;;;387                                                          ),
;;;388                                            ( AT91C_HDMA_DST_DSCR_FETCH_DISABLE
;;;389                                            | dstAddressMode
;;;390                                            | AT91C_HDMA_SRC_DSCR_FETCH_FROM_MEM
;;;391                                            | AT91C_HDMA_SRC_ADDRESS_MODE_INCR
;;;392                                            | AT91C_HDMA_FC_MEM2PER));
;;;393            }
;;;394            else
;;;395            {
;;;396                AT91F_Prepare_Multiple_Transfer(channel_index, LLI_rownumber, 0,
;;;397                                            srcAddress,
;;;398                                            destAddress,
;;;399                                            ( (DMA_XFR_SIZE)
;;;400                                                | mWidth
;;;401                                                | perWidth
;;;402                                                | scSize
;;;403                                                | dcSize
;;;404                                                    ),
;;;405                                            ( AT91C_HDMA_DST_DSCR_FETCH_DISABLE
;;;406                                            | dstAddressMode
;;;407                                            | AT91C_HDMA_SRC_DSCR_FETCH_FROM_MEM
;;;408                                            | AT91C_HDMA_SRC_ADDRESS_MODE_INCR
;;;409                                            | AT91C_HDMA_FC_MEM2PER));
;;;410    
;;;411            }
;;;412    
;;;413            srcAddress += DMA_XFR_SIZE*addrInc;
;;;414    
;;;415            
;;;416            LLI_rownumber++;
00025a  9009              STR      r0,[sp,#0x24]
00025c  e043              B        |L1.742|
                  |L1.606|
00025e  2001              MOVS     r0,#1                 ;333
000260  9003              STR      r0,[sp,#0xc]          ;333
000262  9815              LDR      r0,[sp,#0x54]         ;334
000264  2800              CMP      r0,#0                 ;334
000266  d1ca              BNE      |L1.510|
000268  00ad              LSLS     r5,r5,#2              ;334
00026a  e7c8              B        |L1.510|
                  |L1.620|
00026c  9d03              LDR      r5,[sp,#0xc]          ;376
00026e  210f              MOVS     r1,#0xf               ;376
000270  0209              LSLS     r1,r1,#8              ;376
000272  9809              LDR      r0,[sp,#0x24]         ;376
000274  434d              MULS     r5,r1,r5              ;376
000276  1b00              SUBS     r0,r0,r4              ;376
000278  42a8              CMP      r0,r5                 ;376
00027a  d819              BHI      |L1.688|
00027c  9903              LDR      r1,[sp,#0xc]          ;378
00027e  f7fffffe          BL       __aeabi_uidivmod
000282  9904              LDR      r1,[sp,#0x10]         ;378
000284  4330              ORRS     r0,r0,r6              ;378
000286  4308              ORRS     r0,r0,r1              ;378
000288  9905              LDR      r1,[sp,#0x14]         ;378
00028a  2203              MOVS     r2,#3                 ;378
00028c  4308              ORRS     r0,r0,r1              ;378
00028e  9906              LDR      r1,[sp,#0x18]         ;378
000290  0512              LSLS     r2,r2,#20             ;378
000292  4308              ORRS     r0,r0,r1              ;378
000294  0039              MOVS     r1,r7                 ;378
000296  4311              ORRS     r1,r1,r2              ;378
000298  9a08              LDR      r2,[sp,#0x20]         ;378
00029a  9102              STR      r1,[sp,#8]            ;378
00029c  9200              STR      r2,[sp,#0]            ;378
00029e  22ff              MOVS     r2,#0xff              ;378
0002a0  9001              STR      r0,[sp,#4]            ;378
0002a2  9907              LDR      r1,[sp,#0x1c]         ;378
0002a4  980b              LDR      r0,[sp,#0x2c]         ;378
0002a6  0023              MOVS     r3,r4                 ;378
0002a8  3201              ADDS     r2,#1                 ;378
0002aa  f7fffffe          BL       AT91F_Prepare_Multiple_Transfer
0002ae  e016              B        |L1.734|
                  |L1.688|
0002b0  9a04              LDR      r2,[sp,#0x10]         ;396
0002b2  0030              MOVS     r0,r6                 ;396
0002b4  4310              ORRS     r0,r0,r2              ;396
0002b6  9a05              LDR      r2,[sp,#0x14]         ;396
0002b8  2103              MOVS     r1,#3                 ;396
0002ba  4310              ORRS     r0,r0,r2              ;396
0002bc  9a06              LDR      r2,[sp,#0x18]         ;396
0002be  0509              LSLS     r1,r1,#20             ;396
0002c0  4310              ORRS     r0,r0,r2              ;396
0002c2  220f              MOVS     r2,#0xf               ;396
0002c4  0212              LSLS     r2,r2,#8              ;396
0002c6  4310              ORRS     r0,r0,r2              ;396
0002c8  9a08              LDR      r2,[sp,#0x20]         ;396
0002ca  4339              ORRS     r1,r1,r7              ;396
0002cc  9200              STR      r2,[sp,#0]            ;396
0002ce  9102              STR      r1,[sp,#8]            ;396
0002d0  9001              STR      r0,[sp,#4]            ;396
0002d2  9907              LDR      r1,[sp,#0x1c]         ;396
0002d4  980b              LDR      r0,[sp,#0x2c]         ;396
0002d6  0023              MOVS     r3,r4                 ;396
0002d8  2200              MOVS     r2,#0                 ;396
0002da  f7fffffe          BL       AT91F_Prepare_Multiple_Transfer
                  |L1.734|
0002de  192c              ADDS     r4,r5,r4              ;413
0002e0  9807              LDR      r0,[sp,#0x1c]
0002e2  1c40              ADDS     r0,r0,#1
0002e4  9007              STR      r0,[sp,#0x1c]
                  |L1.742|
0002e6  9809              LDR      r0,[sp,#0x24]         ;374
0002e8  42a0              CMP      r0,r4                 ;374
0002ea  d8bf              BHI      |L1.620|
;;;417        }
;;;418    	//TRACE_INFO("DMACH_MCI_M2P()\n\r");
;;;419        return 0;
0002ec  2000              MOVS     r0,#0
;;;420    }
0002ee  b00f              ADD      sp,sp,#0x3c
0002f0  bdf0              POP      {r4-r7,pc}
;;;421    
                          ENDP

                  MCI_Reset PROC
;;;440    //------------------------------------------------------------------------------
;;;441    void MCI_Reset(AT91PS_MCI pMciHw, unsigned int keepSettings)
0002f2  b5f0              PUSH     {r4-r7,lr}
;;;442    {
;;;443        if (keepSettings) {
;;;444    
;;;445            unsigned int mciMr, mciSdcr, mciDtor, mciCstor;
;;;446            unsigned int mciDma, mciCfg;
;;;447    
;;;448            mciMr    = READ_MCI(pMciHw, MCI_MR);
;;;449            mciSdcr  = READ_MCI(pMciHw, MCI_SDCR);
;;;450            mciDtor  = READ_MCI(pMciHw, MCI_DTOR);
;;;451            mciCstor = READ_MCI(pMciHw, MCI_CSTOR);
;;;452    
;;;453            mciDma = READ_MCI(pMciHw, MCI_DMA);
;;;454            mciCfg = READ_MCI(pMciHw, MCI_CFG);
;;;455    
;;;456            WRITE_MCI(pMciHw, MCI_CR, AT91C_MCI_SWRST);
0002f4  2680              MOVS     r6,#0x80
0002f6  2900              CMP      r1,#0                 ;443
0002f8  d00f              BEQ      |L1.794|
0002fa  6841              LDR      r1,[r0,#4]            ;448
0002fc  68c2              LDR      r2,[r0,#0xc]          ;449
0002fe  6883              LDR      r3,[r0,#8]            ;450
000300  69c4              LDR      r4,[r0,#0x1c]         ;451
000302  6d05              LDR      r5,[r0,#0x50]         ;453
000304  6d47              LDR      r7,[r0,#0x54]         ;454
000306  6006              STR      r6,[r0,#0]
;;;457            WRITE_MCI(pMciHw, MCI_CR, AT91C_MCI_MCIDIS | AT91C_MCI_PWSDIS);
000308  260a              MOVS     r6,#0xa
00030a  6006              STR      r6,[r0,#0]
;;;458    
;;;459            WRITE_MCI(pMciHw, MCI_MR, mciMr);
00030c  6041              STR      r1,[r0,#4]
;;;460            WRITE_MCI(pMciHw, MCI_SDCR, mciSdcr);
00030e  60c2              STR      r2,[r0,#0xc]
;;;461            WRITE_MCI(pMciHw, MCI_DTOR, mciDtor);
000310  6083              STR      r3,[r0,#8]
;;;462            WRITE_MCI(pMciHw, MCI_CSTOR, mciCstor);
000312  61c4              STR      r4,[r0,#0x1c]
;;;463    
;;;464            WRITE_MCI(pMciHw, MCI_DMA, mciDma);
000314  6505              STR      r5,[r0,#0x50]
;;;465            WRITE_MCI(pMciHw, MCI_CFG, mciCfg);
000316  6547              STR      r7,[r0,#0x54]
;;;466        }
;;;467        else {
;;;468    
;;;469            WRITE_MCI(pMciHw, MCI_CR, AT91C_MCI_SWRST);
;;;470            WRITE_MCI(pMciHw, MCI_CR, AT91C_MCI_MCIDIS | AT91C_MCI_PWSDIS);
;;;471        }
;;;472    }
000318  bdf0              POP      {r4-r7,pc}
                  |L1.794|
00031a  6006              STR      r6,[r0,#0]            ;469
00031c  210a              MOVS     r1,#0xa               ;470
00031e  6001              STR      r1,[r0,#0]            ;470
000320  bdf0              POP      {r4-r7,pc}
;;;473    
                          ENDP

                  MCI_Enable PROC
;;;478    //------------------------------------------------------------------------------
;;;479    void MCI_Enable(Mci *pMci, unsigned char enb)
000322  6800              LDR      r0,[r0,#0]
;;;480    {
;;;481        AT91S_MCI *pMciHw = pMci->pMciHw;
;;;482    
;;;483        SANITY_CHECK(pMci);
;;;484        SANITY_CHECK(pMci->pMciHw);
;;;485    
;;;486        // Set the Control Register: Enable/Disable MCI interface clock
;;;487        if(enb == DISABLE) {
000324  2900              CMP      r1,#0
000326  d002              BEQ      |L1.814|
;;;488            MCI_DISABLE(pMciHw);
;;;489        }
;;;490        else {
;;;491            MCI_ENABLE(pMciHw);
000328  2101              MOVS     r1,#1
00032a  6001              STR      r1,[r0,#0]
;;;492        }
;;;493    }
00032c  4770              BX       lr
                  |L1.814|
00032e  2102              MOVS     r1,#2                 ;488
000330  6001              STR      r1,[r0,#0]            ;488
000332  4770              BX       lr
;;;494    
                          ENDP

                  MCI_Init PROC
;;;501    //------------------------------------------------------------------------------
;;;502    void MCI_Init(
000334  b570              PUSH     {r4-r6,lr}
;;;503        Mci *pMci,
;;;504        AT91PS_MCI pMciHw,
;;;505        unsigned char mciId,
;;;506        unsigned int mode,
;;;507        unsigned int bPolling)
;;;508    {
000336  9c04              LDR      r4,[sp,#0x10]
;;;509        unsigned short clkDiv;
;;;510        unsigned int mciCfg = 0;
;;;511    
;;;512        SANITY_CHECK(pMci);
;;;513        SANITY_CHECK(pMciHw);
;;;514        SANITY_CHECK(   (mode == MCI_MMC_SLOTA)  || (mode == MCI_SD_SLOTA)
;;;515                     || (mode == MCI_MMC_SLOTB)  || (mode == MCI_SD_SLOTB)
;;;516                     || (mode == MCI_MMC4_SLOTA) || (mode == MCI_MMC4_SLOTB));
;;;517    
;;;518    #if MCI_BUSY_CHECK_FIX
;;;519        pMci->pPinDAT0 = 0;
;;;520    #endif
;;;521    
;;;522        // Initialize the MCI driver structure
;;;523        pMci->pMciHw    = pMciHw;
000338  6001              STR      r1,[r0,#0]
;;;524        pMci->mciId     = mciId;
00033a  7202              STRB     r2,[r0,#8]
;;;525        pMci->mciMode   = mode;
00033c  7243              STRB     r3,[r0,#9]
;;;526        pMci->bPolling  = bPolling;
00033e  60c4              STR      r4,[r0,#0xc]
;;;527        pMci->semaphore = 1;
000340  2501              MOVS     r5,#1
000342  7285              STRB     r5,[r0,#0xa]
;;;528        pMci->pCommand  = 0;
000344  2600              MOVS     r6,#0
000346  6046              STR      r6,[r0,#4]
;;;529    
;;;530    #if !defined(OP_BOOTSTRAP_MCI_on)
;;;531        // Enable the MCI clock
;;;532        PERIPH_ENABLE(mciId);
000348  002c              MOVS     r4,r5
00034a  483f              LDR      r0,|L1.1096|
00034c  4094              LSLS     r4,r4,r2
00034e  6104              STR      r4,[r0,#0x10]
;;;533    
;;;534         // Reset the MCI
;;;535        WRITE_MCI(pMciHw, MCI_CR, AT91C_MCI_SWRST);
000350  2280              MOVS     r2,#0x80
000352  600a              STR      r2,[r1,#0]
;;;536    
;;;537        // Disable the MCI
;;;538        WRITE_MCI(pMciHw, MCI_CR, AT91C_MCI_MCIDIS | AT91C_MCI_PWSDIS);
000354  220a              MOVS     r2,#0xa
000356  600a              STR      r2,[r1,#0]
;;;539    
;;;540        // Disable all the interrupts
;;;541        WRITE_MCI(pMciHw, MCI_IDR, 0xFFFFFFFF);
000358  4a3c              LDR      r2,|L1.1100|
00035a  648a              STR      r2,[r1,#0x48]
;;;542    
;;;543        // Set the Data Timeout Register
;;;544        WRITE_MCI(pMciHw, MCI_DTOR, DTOR_1MEGA_CYCLES);
00035c  227f              MOVS     r2,#0x7f
00035e  608a              STR      r2,[r1,#8]
;;;545    
;;;546        // Set the Mode Register: 400KHz for MCK = 48MHz (CLKDIV = 58)
;;;547        clkDiv = (BOARD_MCK / (MCI_INITIAL_SPEED * 2)) - 1;
;;;548        WRITE_MCI(pMciHw, MCI_MR, (clkDiv | (AT91C_MCI_PWSDIV & (0x7 << 8))));
000360  4a3b              LDR      r2,|L1.1104|
000362  604a              STR      r2,[r1,#4]
;;;549    
;;;550        // Set the SDCard Register
;;;551        WRITE_MCI(pMciHw, MCI_SDCR, mode);
000364  60cb              STR      r3,[r1,#0xc]
;;;552    
;;;553        // Enable the MCI and the Power Saving
;;;554        WRITE_MCI(pMciHw, MCI_CR, AT91C_MCI_MCIEN);
000366  600d              STR      r5,[r1,#0]
;;;555    
;;;556        // Disable the DMA interface
;;;557        WRITE_MCI(pMciHw, MCI_DMA, AT91C_MCI_DMAEN_DISABLE);
000368  650e              STR      r6,[r1,#0x50]
;;;558    
;;;559        // Configure MCI
;;;560        mciCfg = AT91C_MCI_FIFOMODE_AMOUNTDATA | AT91C_MCI_FERRCTRL_RWCMD;
;;;561        //mciCfg = AT91C_MCI_FIFOMODE_ONEDATA | AT91C_MCI_FERRCTRL_RWCMD;
;;;562        
;;;563        WRITE_MCI(pMciHw, MCI_CFG, mciCfg);
00036a  654e              STR      r6,[r1,#0x54]
;;;564    
;;;565        // Disable the MCI peripheral clock.
;;;566        WRITE_PMC(AT91C_BASE_PMC, PMC_PCDR, (1 << mciId));
00036c  6144              STR      r4,[r0,#0x14]
;;;567    #else
;;;568        // Assume ROM code initialize the MCI already
;;;569        TRACE_INFO("SD bootstrap not init mci!\n\r");
;;;570    #endif
;;;571    
;;;572    }
00036e  bd70              POP      {r4-r6,pc}
;;;573    
                          ENDP

                  MCI_Close PROC
;;;587    //------------------------------------------------------------------------------
;;;588    void MCI_Close(Mci *pMci)
000370  6801              LDR      r1,[r0,#0]
;;;589    {
;;;590        AT91S_MCI *pMciHw = pMci->pMciHw;
;;;591    
;;;592        SANITY_CHECK(pMci);
;;;593        if (!pMciHw) return;
000372  2900              CMP      r1,#0
000374  d00c              BEQ      |L1.912|
;;;594    
;;;595        // Disable all the interrupts
;;;596        WRITE_MCI(pMciHw, MCI_IDR, 0xFFFFFFFF);
000376  4a35              LDR      r2,|L1.1100|
000378  648a              STR      r2,[r1,#0x48]
;;;597    
;;;598        // Disable the MCI
;;;599        WRITE_MCI(pMciHw, MCI_CR, AT91C_MCI_MCIDIS);
00037a  2202              MOVS     r2,#2
00037c  600a              STR      r2,[r1,#0]
;;;600    
;;;601        // Disable the MCI peripheral clock.
;;;602        WRITE_PMC(AT91C_BASE_PMC, PMC_PCDR, (1 << pMci->mciId));
00037e  7a02              LDRB     r2,[r0,#8]
000380  2301              MOVS     r3,#1
000382  0019              MOVS     r1,r3
000384  4091              LSLS     r1,r1,r2
000386  4a30              LDR      r2,|L1.1096|
000388  6151              STR      r1,[r2,#0x14]
;;;603    
;;;604        // Initialize the MCI driver structure
;;;605        pMci->semaphore = 1;
00038a  7283              STRB     r3,[r0,#0xa]
;;;606        pMci->pCommand = 0;
00038c  2100              MOVS     r1,#0
00038e  6041              STR      r1,[r0,#4]
                  |L1.912|
;;;607    }
000390  4770              BX       lr
;;;608    
                          ENDP

                  MCI_GetSpeed PROC
;;;614    //------------------------------------------------------------------------------
;;;615    unsigned int MCI_GetSpeed(Mci *pMci, unsigned int *mciDiv)
000392  b510              PUSH     {r4,lr}
;;;616    {
000394  000a              MOVS     r2,r1
;;;617        AT91S_MCI *pMciHw = pMci->pMciHw;
000396  6800              LDR      r0,[r0,#0]
;;;618        unsigned int mciMr;
;;;619    
;;;620        SANITY_CHECK(pMci);
;;;621        SANITY_CHECK(pMci->pMciHw);
;;;622    
;;;623        // Get the Mode Register
;;;624        mciMr  = READ_MCI(pMciHw, MCI_MR);
000398  6840              LDR      r0,[r0,#4]
;;;625        mciMr &= AT91C_MCI_CLKDIV;
00039a  0601              LSLS     r1,r0,#24
00039c  0e09              LSRS     r1,r1,#24
;;;626        if (mciDiv) *mciDiv = mciMr;
00039e  2a00              CMP      r2,#0
0003a0  d000              BEQ      |L1.932|
0003a2  6011              STR      r1,[r2,#0]
                  |L1.932|
;;;627        return (BOARD_MCK / 2 / (mciMr + 1));
0003a4  482b              LDR      r0,|L1.1108|
0003a6  1c49              ADDS     r1,r1,#1
0003a8  f7fffffe          BL       __aeabi_uidivmod
;;;628    }
0003ac  bd10              POP      {r4,pc}
;;;629    
                          ENDP

                  MCI_SetSpeed PROC
;;;638    //------------------------------------------------------------------------------
;;;639    unsigned int MCI_SetSpeed(Mci *pMci,
0003ae  b5fe              PUSH     {r1-r7,lr}
;;;640                              unsigned int mciSpeed,
;;;641                              unsigned int mciLimit,
;;;642                              unsigned int mck)
;;;643    {
0003b0  000c              MOVS     r4,r1
0003b2  0017              MOVS     r7,r2
;;;644        AT91S_MCI *pMciHw = pMci->pMciHw;
0003b4  6806              LDR      r6,[r0,#0]
;;;645        unsigned int mciMr;
;;;646        unsigned int clkdiv;
;;;647        unsigned int divLimit = 0;
0003b6  2500              MOVS     r5,#0
;;;648    
;;;649        SANITY_CHECK(pMci);
;;;650        SANITY_CHECK(pMci->pMciHw);
;;;651    
;;;652        mciMr = READ_MCI(pMciHw, MCI_MR) & (~(unsigned int)AT91C_MCI_CLKDIV);
0003b8  6870              LDR      r0,[r6,#4]
0003ba  0a00              LSRS     r0,r0,#8
0003bc  0200              LSLS     r0,r0,#8
0003be  9000              STR      r0,[sp,#0]
;;;653    
;;;654        // Multimedia Card Interface clock (MCCK or MCI_CK) is Master Clock (MCK)
;;;655        // divided by (2*(CLKDIV+1))
;;;656        // mciSpeed = MCK / (2*(CLKDIV+1))
;;;657        if (mciLimit) {
;;;658            divLimit = (mck / 2 / mciLimit);
0003c0  0858              LSRS     r0,r3,#1
0003c2  2f00              CMP      r7,#0                 ;657
0003c4  9001              STR      r0,[sp,#4]            ;657
0003c6  d007              BEQ      |L1.984|
0003c8  9801              LDR      r0,[sp,#4]
0003ca  0039              MOVS     r1,r7
0003cc  f7fffffe          BL       __aeabi_uidivmod
0003d0  0005              MOVS     r5,r0
;;;659            if ((mck / 2) % mciLimit) divLimit ++;
0003d2  2900              CMP      r1,#0
0003d4  d000              BEQ      |L1.984|
0003d6  1c6d              ADDS     r5,r5,#1
                  |L1.984|
;;;660        }
;;;661        if (mciSpeed > 0) {
0003d8  2c00              CMP      r4,#0
0003da  d03d              BEQ      |L1.1112|
;;;662            clkdiv = (mck / 2 / mciSpeed);
0003dc  9801              LDR      r0,[sp,#4]
0003de  0021              MOVS     r1,r4
0003e0  f7fffffe          BL       __aeabi_uidivmod
0003e4  0004              MOVS     r4,r0
;;;663            if (mciLimit && clkdiv < divLimit)
0003e6  2f00              CMP      r7,#0
0003e8  d002              BEQ      |L1.1008|
0003ea  42ac              CMP      r4,r5
0003ec  d200              BCS      |L1.1008|
;;;664                clkdiv = divLimit;
0003ee  002c              MOVS     r4,r5
                  |L1.1008|
;;;665            if (clkdiv > 0) 
0003f0  2c00              CMP      r4,#0
0003f2  d032              BEQ      |L1.1114|
;;;666                clkdiv -= 1;
0003f4  1e64              SUBS     r4,r4,#1
0003f6  e030              B        |L1.1114|
                  |L1.1016|
                          DCD      ||.bss||
                  |L1.1020|
                          DCD      ||.data||
                  |L1.1024|
                          DCD      0x20000000
                  |L1.1028|
000404  5b313b31          DCB      "[1;1;33m!: ",0
000408  3b33336d
00040c  213a2000
                  |L1.1040|
000410  5b6d00            DCB      "[m",0
000413  00                DCB      0
                  |L1.1044|
000414  53442044          DCB      "SD DMA, size too big %d\n\r",0
000418  4d412c20
00041c  73697a65
000420  20746f6f
000424  20626967
000428  2025640a
00042c  0d00    
00042e  00                DCB      0
00042f  00                DCB      0
                  |L1.1072|
000430  0a0d00            DCB      "\n\r",0
000433  00                DCB      0
                  |L1.1076|
                          DCD      0x00004b00
                  |L1.1080|
                          DCD      0x20002200
                  |L1.1084|
                          DCD      0x00100000
                  |L1.1088|
                          DCD      0x02000000
                  |L1.1092|
                          DCD      0x00010000
                  |L1.1096|
                          DCD      0xfffffc00
                  |L1.1100|
                          DCD      0xffffffff
                  |L1.1104|
                          DCD      0x000007a5
                  |L1.1108|
                          DCD      0x03f94068
                  |L1.1112|
;;;667            ASSERT( (clkdiv & 0xFFFFFF00) == 0, "mciSpeed too small");
;;;668        }
;;;669        else    clkdiv = 0;
000458  2400              MOVS     r4,#0
                  |L1.1114|
;;;670    
;;;671        // Actual MCI speed
;;;672        mciSpeed = mck / 2 / (clkdiv + 1);
00045a  9801              LDR      r0,[sp,#4]
00045c  1c61              ADDS     r1,r4,#1
00045e  f7fffffe          BL       __aeabi_uidivmod
;;;673    
;;;674        // Set the Data Timeout Register & Completion Timeout
;;;675        // Data timeout is 500ms, completion timeout 1s.
;;;676        //MCI_SetTimeout(pMciHw, mciSpeed / 2, mciSpeed);
;;;677    
;;;678        WRITE_MCI(pMciHw, MCI_MR, mciMr | clkdiv);
000462  9900              LDR      r1,[sp,#0]
000464  4321              ORRS     r1,r1,r4
000466  6071              STR      r1,[r6,#4]
;;;679        return (mciSpeed);
;;;680    }
000468  bdfe              POP      {r1-r7,pc}
;;;681    
                          ENDP

                  MCI_EnableHsMode PROC
;;;686    //------------------------------------------------------------------------------
;;;687    void MCI_EnableHsMode(Mci *pMci, unsigned char hsEnable)
00046a  6802              LDR      r2,[r0,#0]
;;;688    {
;;;689        AT91S_MCI *pMciHw = pMci->pMciHw;
;;;690        unsigned int cfgr;
;;;691    
;;;692        SANITY_CHECK(pMci);
;;;693        SANITY_CHECK(pMci->pMciHw);
;;;694    
;;;695        cfgr = READ_MCI(pMciHw, MCI_CFG);
00046c  6d50              LDR      r0,[r2,#0x54]
;;;696        if (hsEnable)   cfgr |=  AT91C_MCI_HSMODE_ENABLE;
00046e  23ff              MOVS     r3,#0xff
000470  3301              ADDS     r3,#1
000472  2900              CMP      r1,#0
000474  d001              BEQ      |L1.1146|
000476  4318              ORRS     r0,r0,r3
000478  e000              B        |L1.1148|
                  |L1.1146|
;;;697        else            cfgr &= ~(unsigned int)AT91C_MCI_HSMODE_ENABLE;
00047a  4398              BICS     r0,r0,r3
                  |L1.1148|
;;;698        WRITE_MCI(pMciHw, MCI_CFG, cfgr);
00047c  6550              STR      r0,[r2,#0x54]
;;;699    }
00047e  4770              BX       lr
;;;700    
                          ENDP

                  MCI_SetBusWidth PROC
;;;706    //------------------------------------------------------------------------------
;;;707    void MCI_SetBusWidth(Mci *pMci, unsigned char busWidth)
000480  6800              LDR      r0,[r0,#0]
;;;708    {
;;;709        AT91S_MCI *pMciHw = pMci->pMciHw;
;;;710        unsigned int mciSdcr;
;;;711    
;;;712        SANITY_CHECK(pMci);
;;;713        SANITY_CHECK(pMci->pMciHw);
;;;714    
;;;715        mciSdcr = (READ_MCI(pMciHw, MCI_SDCR) & ~((unsigned int)AT91C_MCI_SCDBUS));
000482  68c2              LDR      r2,[r0,#0xc]
000484  23c0              MOVS     r3,#0xc0
000486  439a              BICS     r2,r2,r3
;;;716    
;;;717        WRITE_MCI(pMciHw, MCI_SDCR, mciSdcr | busWidth);
000488  430a              ORRS     r2,r2,r1
00048a  60c2              STR      r2,[r0,#0xc]
;;;718    }
00048c  4770              BX       lr
;;;719    
                          ENDP

                  MCI_SendCommand PROC
;;;727    //------------------------------------------------------------------------------
;;;728    unsigned char MCI_SendCommand(Mci *pMci, MciCmd *pCommand)
00048e  b5f0              PUSH     {r4-r7,lr}
;;;729    {
000490  000c              MOVS     r4,r1
000492  b085              SUB      sp,sp,#0x14
;;;730        AT91PS_MCI pMciHw = pMci->pMciHw;
000494  6805              LDR      r5,[r0,#0]
;;;731        unsigned int mciIer, mciMr;
;;;732        unsigned int transSize;
;;;733        unsigned int mciBlkr;
;;;734    
;;;735      #if defined(MCI_DMA_ENABLE)
;;;736        unsigned int mciDma;
;;;737      #endif
;;;738    
;;;739        SANITY_CHECK(pMci);
;;;740        SANITY_CHECK(pMciHw);
;;;741        SANITY_CHECK(pCommand);
;;;742    
;;;743        // Try to acquire the MCI semaphore
;;;744        if (pMci->semaphore == 0) {
000496  7a81              LDRB     r1,[r0,#0xa]
000498  2900              CMP      r1,#0
00049a  d02b              BEQ      |L1.1268|
;;;745    
;;;746            return MCI_ERROR_LOCK;
;;;747        }
;;;748        pMci->semaphore--;
00049c  7a81              LDRB     r1,[r0,#0xa]
00049e  1e49              SUBS     r1,r1,#1
0004a0  7281              STRB     r1,[r0,#0xa]
;;;749    
;;;750        // Command is now being executed
;;;751        pMci->pCommand = pCommand;
0004a2  6044              STR      r4,[r0,#4]
;;;752        pCommand->status = MCI_STATUS_PENDING;
0004a4  2101              MOVS     r1,#1
0004a6  6221              STR      r1,[r4,#0x20]
;;;753    
;;;754        // Enable the MCI peripheral clock
;;;755        PERIPH_ENABLE(pMci->mciId);
0004a8  7a00              LDRB     r0,[r0,#8]
0004aa  4081              LSLS     r1,r1,r0
0004ac  48ed              LDR      r0,|L1.2148|
0004ae  6101              STR      r1,[r0,#0x10]
;;;756    
;;;757        // Set Default Mode register value
;;;758        mciMr = READ_MCI(pMciHw, MCI_MR) & (~( AT91C_MCI_WRPROOF
0004b0  686f              LDR      r7,[r5,#4]
0004b2  48ed              LDR      r0,|L1.2152|
0004b4  4007              ANDS     r7,r7,r0
;;;759                                              |AT91C_MCI_RDPROOF
;;;760                                              |AT91C_MCI_BLKLEN));
;;;761    										  
;;;762    	//TRACE_MSG("mciDma: 0x%08X", mciDma);
;;;763    	//TRACE_MSG("transSize: 0x%08X", transSize);		  
;;;764    	
;;;765        // Command with DATA stage
;;;766        if (pCommand->blockSize && pCommand->nbBlock) {
0004b6  89a1              LDRH     r1,[r4,#0xc]
0004b8  2900              CMP      r1,#0
0004ba  d06f              BEQ      |L1.1436|
0004bc  89e0              LDRH     r0,[r4,#0xe]
0004be  2800              CMP      r0,#0
0004c0  d06c              BEQ      |L1.1436|
;;;767            // Enable dma
;;;768          #if defined(MCI_DMA_ENABLE)
;;;769            mciDma = READ_MCI(pMciHw, MCI_DMA) | AT91C_MCI_DMAEN_ENABLE;
0004c2  6d28              LDR      r0,[r5,#0x50]
0004c4  21ff              MOVS     r1,#0xff
0004c6  3101              ADDS     r1,#1
0004c8  4308              ORRS     r0,r0,r1
;;;770            WRITE_MCI(pMciHw, MCI_DMA, mciDma);
0004ca  6528              STR      r0,[r5,#0x50]
;;;771    		//TRACE_MSG("data mciDma: 0x%08X", mciDma);
;;;772          #endif
;;;773    
;;;774    		
;;;775            transSize = (pCommand->nbBlock * pCommand->blockSize);
0004cc  89e0              LDRH     r0,[r4,#0xe]
0004ce  89a1              LDRH     r1,[r4,#0xc]
0004d0  0006              MOVS     r6,r0
0004d2  434e              MULS     r6,r1,r6
0004d4  9103              STR      r1,[sp,#0xc]
;;;776    		//TRACE_MSG("data transSize: 0x%08X", transSize);
;;;777          #if defined(MCI_DMA_ENABLE)
;;;778            if (pCommand->isRead) {
0004d6  7fe1              LDRB     r1,[r4,#0x1f]
0004d8  2900              CMP      r1,#0
0004da  d011              BEQ      |L1.1280|
;;;779              #if MCI_RD_FIFO_LIMIT
;;;780                if (transSize > MCI_FIFO_SIZE) {
0004dc  220f              MOVS     r2,#0xf
0004de  0292              LSLS     r2,r2,#10
0004e0  4296              CMP      r6,r2
0004e2  d90a              BLS      |L1.1274|
;;;781                    xfredBlocks = MCI_FIFO_SIZE/pCommand->blockSize;
0004e4  0016              MOVS     r6,r2
0004e6  9903              LDR      r1,[sp,#0xc]
0004e8  0030              MOVS     r0,r6
0004ea  f7fffffe          BL       __aeabi_uidivmod
0004ee  49df              LDR      r1,|L1.2156|
0004f0  8048              STRH     r0,[r1,#2]
;;;782                    transSize = MCI_FIFO_SIZE;
0004f2  e007              B        |L1.1284|
                  |L1.1268|
0004f4  2001              MOVS     r0,#1                 ;746
                  |L1.1270|
;;;783                }
;;;784                else
;;;785              #endif
;;;786                {
;;;787                    xfredBlocks = pCommand->nbBlock;
;;;788                }
;;;789            }
;;;790            else {
;;;791                xfredBlocks = pCommand->nbBlock;
;;;792            }
;;;793          #endif
;;;794            if ((pCommand->blockSize & 0x3) != 0) {
;;;795                // Force byte, DataReg & DMA should be BYTE based
;;;796                mciMr |= AT91C_MCI_PDCFBYTE;
;;;797            }
;;;798            else
;;;799                transSize = toWCOUNT(transSize);
;;;800    
;;;801            // New transfer
;;;802            if(pCommand->tranType == MCI_NEW_TRANSFER)
;;;803            {
;;;804    
;;;805                // Set block size
;;;806                WRITE_MCI(pMciHw, MCI_MR, mciMr | AT91C_MCI_RDPROOF
;;;807                                                | AT91C_MCI_WRPROOF
;;;808                                                |(pCommand->blockSize << 16));
;;;809    
;;;810                mciBlkr = READ_MCI(pMciHw, MCI_BLKR)
;;;811                            & (~(unsigned int)AT91C_MCI_BCNT);
;;;812                WRITE_MCI(pMciHw, MCI_BLKR, mciBlkr
;;;813                                            | (transSize/pCommand->blockSize));
;;;814            }
;;;815    
;;;816            // DATA transfer from card to host
;;;817            if (pCommand->isRead) {
;;;818                
;;;819              #if defined(MCI_DMA_ENABLE)
;;;820                DMACH_MCI_P2M(BOARD_MCI_DMA_CHANNEL,
;;;821                              (unsigned char*)&pMciHw->MCI_FIFO,
;;;822                              (unsigned char*) pCommand->pData,
;;;823                              transSize, 0,
;;;824                              (mciMr & AT91C_MCI_PDCFBYTE) > 0);
;;;825                DMACH_EnableIt(pMciHw, BOARD_MCI_DMA_CHANNEL);
;;;826                DMA_EnableChannel(BOARD_MCI_DMA_CHANNEL);
;;;827                mciIer = AT91C_MCI_DMADONE | STATUS_ERRORS;
;;;828              #else 
;;;829                mciIer = AT91C_MCI_CMDRDY | STATUS_ERRORS;
;;;830              #endif
;;;831            }
;;;832            // DATA transfer from host to card
;;;833            else {
;;;834    
;;;835              #if defined(MCI_DMA_ENABLE)
;;;836                if ((mciMr & AT91C_MCI_PDCFBYTE) > 0) {
;;;837                    #if 1
;;;838                    // Still using WORD mode to write FIFO
;;;839                    DMACH_MCI_M2P(BOARD_MCI_DMA_CHANNEL,
;;;840                                  (unsigned char*) pCommand->pData,
;;;841                                  (unsigned char*)&pMciHw->MCI_FIFO,
;;;842                                  toWCOUNT(transSize), 0,
;;;843                                  0);
;;;844                    #else
;;;845                    // Still write to TDR with WORD!
;;;846                    DMACH_MCI_M2P(BOARD_MCI_DMA_CHANNEL,
;;;847                                  (unsigned char*) pCommand->pData,
;;;848                                  (unsigned char*)&pMciHw->MCI_TDR,
;;;849                                  toWCOUNT(transSize), 0,
;;;850                                  0);
;;;851                    #endif
;;;852                }
;;;853                else {
;;;854                     DMACH_MCI_M2P(BOARD_MCI_DMA_CHANNEL,
;;;855                                  (unsigned char*) pCommand->pData,
;;;856                                  (unsigned char*)&pMciHw->MCI_FIFO,
;;;857                                  transSize, 0,
;;;858                                  0);
;;;859                }
;;;860                DMACH_EnableIt(pMciHw, BOARD_MCI_DMA_CHANNEL);
;;;861                DMA_EnableChannel(BOARD_MCI_DMA_CHANNEL);
;;;862                mciIer = AT91C_MCI_DMADONE | STATUS_ERRORS;
;;;863              #else
;;;864                mciIer = AT91C_MCI_CMDRDY | STATUS_ERRORS;
;;;865              #endif
;;;866            }
;;;867        }
;;;868        // Start an infinite block transfer (but no data in current command)
;;;869        else if (pCommand->dataTran) {
;;;870            // Set block size
;;;871            WRITE_MCI(pMciHw, MCI_MR, mciMr | AT91C_MCI_RDPROOF
;;;872                                            | AT91C_MCI_WRPROOF
;;;873                                            |(pCommand->blockSize << 16));
;;;874            // Set data length: 0
;;;875            mciBlkr = READ_MCI(pMciHw, MCI_BLKR) & (~(unsigned int)AT91C_MCI_BCNT);
;;;876            WRITE_MCI(pMciHw, MCI_BLKR, mciBlkr);
;;;877            mciIer = AT91C_MCI_CMDRDY | STATUS_ERRORS;
;;;878    		
;;;879    		//TRACE_MSG("dataTran mciIer: 0x%08X", mciIer);
;;;880    		//TRACE_MSG("dataTran mciBlkr: 0x%08X", mciBlkr);
;;;881        }
;;;882        // No data transfer: stop at the end of the command
;;;883        else{
;;;884            WRITE_MCI(pMciHw, MCI_MR, mciMr);
;;;885            mciIer = AT91C_MCI_CMDRDY | STATUS_ERRORS;
;;;886    		//TRACE_MSG("else mciMr: 0x%08X", mciMr);
;;;887        }
;;;888    
;;;889        // Enable MCI
;;;890        MCI_ENABLE(pMciHw);
;;;891    
;;;892        // Send the command
;;;893        if((pCommand->tranType != MCI_CONTINUE_TRANSFER)
;;;894            || (pCommand->blockSize == 0)) {
;;;895    
;;;896            WRITE_MCI(pMciHw, MCI_ARGR, pCommand->arg);
;;;897            WRITE_MCI(pMciHw, MCI_CMDR, pCommand->cmd);
;;;898    		//TRACE_MSG("pCommand->cmd: 0x%08X", pCommand->cmd);
;;;899    		//TRACE_MSG("pCommand->cmd: 0x%08X", READ_MCI(pMciHw, MCI_CMDR));
;;;900        }
;;;901    
;;;902        // Ignore CRC error for R3 & R4
;;;903        if (pCommand->resType == 3 || pCommand->resType == 4)
;;;904    	{
;;;905            mciIer &= ~((unsigned int)AT91C_MCI_RCRCE);
;;;906    		//TRACE_MSG("mciIer: 0x%08X", mciIer);
;;;907        }
;;;908        // Ignore errors for stop command :)
;;;909        if (pCommand->tranType == MCI_STOP_TRANSFER) {
;;;910            mciIer &= ~((unsigned int)(AT91C_MCI_DCRCE
;;;911                                        |AT91C_MCI_BLKOVRE
;;;912                                        |AT91C_MCI_DTOE
;;;913                                        |AT91C_MCI_CSTOE));
;;;914    		//TRACE_MSG("mciIer: 0x%08X", mciIer);
;;;915        }
;;;916    
;;;917        // Ignore data error
;;;918        mciIer &= ~(  0
;;;919                    | AT91C_MCI_UNRE
;;;920                    | AT91C_MCI_OVRE
;;;921                    | AT91C_MCI_DTOE
;;;922                    | AT91C_MCI_DCRCE
;;;923                    | AT91C_MCI_BLKOVRE
;;;924                    | AT91C_MCI_CSTOE
;;;925                    );
;;;926    
;;;927        // Interrupt enable shall be done after PDC TXTEN and RXTEN
;;;928        WRITE_MCI(pMciHw, MCI_IER, mciIer);
;;;929    
;;;930    	//TRACE_WRN("MCI_SendCommand(): ch: 0x%08X, mciIer: 0x%08X, mciMr: 0x%08X, transSize: 0x%08X, mciBlkr: 0x%08X, mciDma: 0x%08X\n\r", 0, mciIer, mciMr, transSize, mciBlkr, mciDma);
;;;931    
;;;932    	
;;;933    
;;;934        return 0;
;;;935    }
0004f6  b005              ADD      sp,sp,#0x14
0004f8  bdf0              POP      {r4-r7,pc}
                  |L1.1274|
0004fa  49dc              LDR      r1,|L1.2156|
0004fc  8048              STRH     r0,[r1,#2]            ;787
0004fe  e001              B        |L1.1284|
                  |L1.1280|
000500  49da              LDR      r1,|L1.2156|
000502  8048              STRH     r0,[r1,#2]            ;791
                  |L1.1284|
000504  9803              LDR      r0,[sp,#0xc]          ;794
000506  0780              LSLS     r0,r0,#30             ;794
000508  d003              BEQ      |L1.1298|
00050a  2001              MOVS     r0,#1                 ;796
00050c  0340              LSLS     r0,r0,#13             ;796
00050e  4307              ORRS     r7,r7,r0              ;796
000510  e005              B        |L1.1310|
                  |L1.1298|
000512  07b0              LSLS     r0,r6,#30             ;799
000514  d002              BEQ      |L1.1308|
000516  08b6              LSRS     r6,r6,#2              ;799
000518  1c76              ADDS     r6,r6,#1              ;799
00051a  e000              B        |L1.1310|
                  |L1.1308|
00051c  08b6              LSRS     r6,r6,#2              ;799
                  |L1.1310|
00051e  7fa0              LDRB     r0,[r4,#0x1e]         ;802
000520  2800              CMP      r0,#0                 ;802
000522  d111              BNE      |L1.1352|
000524  9803              LDR      r0,[sp,#0xc]          ;806
000526  2103              MOVS     r1,#3                 ;806
000528  0400              LSLS     r0,r0,#16             ;806
00052a  4338              ORRS     r0,r0,r7              ;806
00052c  02c9              LSLS     r1,r1,#11             ;806
00052e  4308              ORRS     r0,r0,r1              ;806
000530  6068              STR      r0,[r5,#4]            ;806
000532  69a8              LDR      r0,[r5,#0x18]         ;810
000534  0c01              LSRS     r1,r0,#16             ;810
000536  0409              LSLS     r1,r1,#16             ;810
000538  9102              STR      r1,[sp,#8]            ;810
00053a  89a1              LDRH     r1,[r4,#0xc]          ;812
00053c  0030              MOVS     r0,r6                 ;812
00053e  f7fffffe          BL       __aeabi_uidivmod
000542  9902              LDR      r1,[sp,#8]            ;812
000544  4308              ORRS     r0,r0,r1              ;812
000546  61a8              STR      r0,[r5,#0x18]         ;812
                  |L1.1352|
000548  7fe1              LDRB     r1,[r4,#0x1f]         ;817
00054a  2000              MOVS     r0,#0                 ;766
00054c  2900              CMP      r1,#0                 ;817
00054e  d013              BEQ      |L1.1400|
000550  04b9              LSLS     r1,r7,#18             ;820
000552  0fc9              LSRS     r1,r1,#31             ;820
000554  9101              STR      r1,[sp,#4]            ;820
000556  1de9              ADDS     r1,r5,#7              ;820
000558  31ff              ADDS     r1,r1,#0xff           ;820
00055a  9000              STR      r0,[sp,#0]            ;820
00055c  68a2              LDR      r2,[r4,#8]            ;820
00055e  0033              MOVS     r3,r6                 ;820
000560  31fa              ADDS     r1,r1,#0xfa           ;820
000562  f7fffffe          BL       DMACH_MCI_P2M
000566  2100              MOVS     r1,#0                 ;825
000568  0028              MOVS     r0,r5                 ;825
00056a  f7fffffe          BL       DMACH_EnableIt
00056e  2000              MOVS     r0,#0                 ;826
000570  f7fffffe          BL       DMA_EnableChannel
000574  48be              LDR      r0,|L1.2160|
000576  e035              B        |L1.1508|
                  |L1.1400|
000578  04b9              LSLS     r1,r7,#18             ;836
00057a  d510              BPL      |L1.1438|
00057c  9000              STR      r0,[sp,#0]            ;839
00057e  9001              STR      r0,[sp,#4]            ;839
000580  07b0              LSLS     r0,r6,#30             ;839
000582  d002              BEQ      |L1.1418|
000584  08b3              LSRS     r3,r6,#2              ;842
000586  1c5b              ADDS     r3,r3,#1              ;842
000588  e000              B        |L1.1420|
                  |L1.1418|
00058a  08b3              LSRS     r3,r6,#2              ;842
                  |L1.1420|
00058c  1dea              ADDS     r2,r5,#7              ;842
00058e  32ff              ADDS     r2,r2,#0xff           ;842
000590  68a1              LDR      r1,[r4,#8]            ;842
000592  32fa              ADDS     r2,r2,#0xfa           ;842
000594  2000              MOVS     r0,#0                 ;842
000596  f7fffffe          BL       DMACH_MCI_M2P
00059a  e00a              B        |L1.1458|
                  |L1.1436|
00059c  e012              B        |L1.1476|
                  |L1.1438|
00059e  1dea              ADDS     r2,r5,#7              ;854
0005a0  9000              STR      r0,[sp,#0]            ;854
0005a2  9001              STR      r0,[sp,#4]            ;854
0005a4  32ff              ADDS     r2,r2,#0xff           ;854
0005a6  68a1              LDR      r1,[r4,#8]            ;854
0005a8  0033              MOVS     r3,r6                 ;854
0005aa  32fa              ADDS     r2,r2,#0xfa           ;854
0005ac  2000              MOVS     r0,#0                 ;854
0005ae  f7fffffe          BL       DMACH_MCI_M2P
                  |L1.1458|
0005b2  2100              MOVS     r1,#0                 ;860
0005b4  0028              MOVS     r0,r5                 ;860
0005b6  f7fffffe          BL       DMACH_EnableIt
0005ba  2000              MOVS     r0,#0                 ;861
0005bc  f7fffffe          BL       DMA_EnableChannel
0005c0  48ab              LDR      r0,|L1.2160|
0005c2  e00f              B        |L1.1508|
                  |L1.1476|
0005c4  7f62              LDRB     r2,[r4,#0x1d]         ;869
0005c6  48ab              LDR      r0,|L1.2164|
0005c8  2a00              CMP      r2,#0                 ;869
0005ca  d00a              BEQ      |L1.1506|
0005cc  0409              LSLS     r1,r1,#16             ;871
0005ce  2203              MOVS     r2,#3                 ;871
0005d0  4339              ORRS     r1,r1,r7              ;871
0005d2  02d2              LSLS     r2,r2,#11             ;871
0005d4  4311              ORRS     r1,r1,r2              ;871
0005d6  6069              STR      r1,[r5,#4]            ;871
0005d8  69a9              LDR      r1,[r5,#0x18]         ;875
0005da  0c09              LSRS     r1,r1,#16             ;875
0005dc  0409              LSLS     r1,r1,#16             ;875
0005de  61a9              STR      r1,[r5,#0x18]         ;876
0005e0  e000              B        |L1.1508|
                  |L1.1506|
0005e2  606f              STR      r7,[r5,#4]            ;884
                  |L1.1508|
0005e4  2101              MOVS     r1,#1                 ;890
0005e6  6029              STR      r1,[r5,#0]            ;890
0005e8  7fa1              LDRB     r1,[r4,#0x1e]         ;893
0005ea  2901              CMP      r1,#1                 ;893
0005ec  d102              BNE      |L1.1524|
0005ee  89a1              LDRH     r1,[r4,#0xc]          ;894
0005f0  2900              CMP      r1,#0                 ;894
0005f2  d103              BNE      |L1.1532|
                  |L1.1524|
0005f4  6861              LDR      r1,[r4,#4]            ;896
0005f6  6129              STR      r1,[r5,#0x10]         ;896
0005f8  6821              LDR      r1,[r4,#0]            ;897
0005fa  6169              STR      r1,[r5,#0x14]         ;897
                  |L1.1532|
0005fc  7f21              LDRB     r1,[r4,#0x1c]         ;903
0005fe  2903              CMP      r1,#3                 ;903
000600  d001              BEQ      |L1.1542|
000602  2904              CMP      r1,#4                 ;903
000604  d102              BNE      |L1.1548|
                  |L1.1542|
000606  2101              MOVS     r1,#1                 ;905
000608  0489              LSLS     r1,r1,#18             ;905
00060a  4388              BICS     r0,r0,r1              ;905
                  |L1.1548|
00060c  7fa1              LDRB     r1,[r4,#0x1e]         ;909
00060e  2902              CMP      r1,#2                 ;909
000610  d102              BNE      |L1.1560|
000612  210f              MOVS     r1,#0xf               ;910
000614  0549              LSLS     r1,r1,#21             ;910
000616  4388              BICS     r0,r0,r1              ;910
                  |L1.1560|
000618  4997              LDR      r1,|L1.2168|
00061a  4008              ANDS     r0,r0,r1              ;918
00061c  6468              STR      r0,[r5,#0x44]         ;928
00061e  2000              MOVS     r0,#0                 ;934
000620  e769              B        |L1.1270|
;;;936    
                          ENDP

                  MCI_CheckBusy PROC
;;;941    //------------------------------------------------------------------------------
;;;942    unsigned char MCI_CheckBusy(Mci *pMci)
000622  b530              PUSH     {r4,r5,lr}
;;;943    {
;;;944        AT91S_MCI *pMciHw = pMci->pMciHw;
000624  6801              LDR      r1,[r0,#0]
;;;945        volatile unsigned int status;
;;;946    
;;;947        // Enable MCI clock
;;;948        PERIPH_ENABLE(pMci->mciId);
000626  7a04              LDRB     r4,[r0,#8]
000628  2301              MOVS     r3,#1
00062a  001a              MOVS     r2,r3
00062c  40a2              LSLS     r2,r2,r4
00062e  4c8d              LDR      r4,|L1.2148|
000630  6122              STR      r2,[r4,#0x10]
;;;949        MCI_ENABLE(pMciHw);
000632  600b              STR      r3,[r1,#0]
;;;950    
;;;951        status = READ_MCI(pMciHw, MCI_SR);
000634  6c0a              LDR      r2,[r1,#0x40]
;;;952    
;;;953    #if MCI_BUSY_CHECK_FIX
;;;954        if ((status & AT91C_MCI_DTIP) == 0) {
;;;955            unsigned char isBusy = 1;
;;;956            if (pMci->pPinDAT0) {
;;;957                Pin pinBsy;
;;;958                pinBsy.mask      = pMci->pPinDAT0->mask;
;;;959                pinBsy.pio       = pMci->pPinDAT0->pio;
;;;960                pinBsy.id        = pMci->pPinDAT0->id;
;;;961                pinBsy.type      = PIO_INPUT;
;;;962                pinBsy.attribute = PIO_PULLUP;
;;;963                PIO_Configure(&pinBsy, 1);
;;;964                isBusy = (PIO_Get(&pinBsy) == 0);
;;;965                PIO_Configure(pMci->pPinDAT0, 1);
;;;966            }
;;;967            else {
;;;968                isBusy = ((status & AT91C_MCI_NOTBUSY) == 0);
;;;969            }
;;;970            if (isBusy == 0) {
;;;971                MCI_DISABLE(pMciHw);
;;;972                PERIPH_DISABLE(pMci->mciId);
;;;973            }
;;;974            return isBusy;
;;;975        }
;;;976        
;;;977        return 1;
;;;978    #else
;;;979    
;;;980        if(    ((status & AT91C_MCI_NOTBUSY)!=0)
000636  0695              LSLS     r5,r2,#26
000638  d508              BPL      |L1.1612|
;;;981            && ((status & AT91C_MCI_DTIP)==0)
00063a  06d2              LSLS     r2,r2,#27
00063c  d406              BMI      |L1.1612|
;;;982            ) {
;;;983    
;;;984            // Disable MCI clock
;;;985            MCI_DISABLE(pMciHw);
00063e  2202              MOVS     r2,#2
000640  600a              STR      r2,[r1,#0]
;;;986            PERIPH_DISABLE(pMci->mciId);
000642  7a00              LDRB     r0,[r0,#8]
000644  4083              LSLS     r3,r3,r0
000646  6163              STR      r3,[r4,#0x14]
;;;987            return 0;
000648  2000              MOVS     r0,#0
;;;988        }
;;;989        else {
;;;990            return 1;
;;;991        }
;;;992    #endif
;;;993    }
00064a  bd30              POP      {r4,r5,pc}
                  |L1.1612|
00064c  2001              MOVS     r0,#1                 ;990
00064e  bd30              POP      {r4,r5,pc}
;;;994    
                          ENDP

                  MCI_Handler PROC
;;;998    //------------------------------------------------------------------------------
;;;999    void MCI_Handler(Mci *pMci)
000650  b5f1              PUSH     {r0,r4-r7,lr}
;;;1000   {
000652  b086              SUB      sp,sp,#0x18
;;;1001       AT91S_MCI *pMciHw = pMci->pMciHw;
000654  9806              LDR      r0,[sp,#0x18]
000656  6804              LDR      r4,[r0,#0]
;;;1002       MciCmd *pCommand = pMci->pCommand;
000658  9806              LDR      r0,[sp,#0x18]
00065a  6845              LDR      r5,[r0,#4]
;;;1003       volatile unsigned int status;
;;;1004       unsigned int status0, mask;
;;;1005       unsigned char i;
;;;1006   
;;;1007       SANITY_CHECK(pMci);
;;;1008       SANITY_CHECK(pMciHw);
;;;1009       SANITY_CHECK(pCommand);
;;;1010   
;;;1011       // Read the status register
;;;1012       status0 = READ_MCI(pMciHw, MCI_SR);
00065c  6c27              LDR      r7,[r4,#0x40]
;;;1013       mask    = READ_MCI(pMciHw, MCI_IMR);
00065e  6ce6              LDR      r6,[r4,#0x4c]
;;;1014   
;;;1015       status  = status0 & mask;
000660  0038              MOVS     r0,r7
000662  4030              ANDS     r0,r0,r6
;;;1016   	
;;;1017   //	TRACE_WRN("iST 0x%08X", status0);
;;;1018   //	TRACE_WRN("iMK 0x%08X", mask);
;;;1019   //	TRACE_WRN("iSM 0x%08X", status);
;;;1020   
;;;1021       // Check if an error has occured
;;;1022       if ((status & STATUS_ERRORS) != 0) {
000664  4983              LDR      r1,|L1.2164|
000666  1e49              SUBS     r1,r1,#1
000668  4001              ANDS     r1,r1,r0
00066a  d008              BEQ      |L1.1662|
;;;1023   
;;;1024           // Check error code
;;;1025           if ((status & STATUS_ERRORS) == AT91C_MCI_RTOE) {
00066c  2201              MOVS     r2,#1
00066e  0512              LSLS     r2,r2,#20
000670  4291              CMP      r1,r2
000672  d102              BNE      |L1.1658|
;;;1026   
;;;1027               pCommand->status = MCI_STATUS_NORESPONSE;
000674  2103              MOVS     r1,#3
000676  6229              STR      r1,[r5,#0x20]
000678  e001              B        |L1.1662|
                  |L1.1658|
;;;1028           }
;;;1029           else {
;;;1030   
;;;1031               pCommand->status = MCI_STATUS_ERROR;
00067a  2102              MOVS     r1,#2
00067c  6229              STR      r1,[r5,#0x20]
                  |L1.1662|
;;;1032           }
;;;1033           DEBUG_MSG("iErr 0x%08X", (status & STATUS_ERRORS));
;;;1034       }
;;;1035       mask &= ~STATUS_ERRORS;
00067e  497d              LDR      r1,|L1.2164|
000680  4249              RSBS     r1,r1,#0
000682  400e              ANDS     r6,r6,r1
;;;1036   
;;;1037       // Check if a command has been completed
;;;1038       if (status & AT91C_MCI_CMDRDY) {
;;;1039   
;;;1040           WRITE_MCI(pMciHw, MCI_IDR, AT91C_MCI_CMDRDY);
;;;1041           if (pCommand->isRead == 0 &&
;;;1042               pCommand->tranType == MCI_STOP_TRANSFER) {
;;;1043               if (status0 & AT91C_MCI_XFRDONE) {
;;;1044                   MCI_DISABLE(pMciHw);
;;;1045               }
;;;1046               else {
;;;1047                   WRITE_MCI(pMciHw, MCI_IER, AT91C_MCI_XFRDONE);
000684  497d              LDR      r1,|L1.2172|
000686  07c2              LSLS     r2,r0,#31             ;1038
000688  d016              BEQ      |L1.1720|
00068a  2201              MOVS     r2,#1                 ;1040
00068c  64a2              STR      r2,[r4,#0x48]         ;1040
00068e  7fea              LDRB     r2,[r5,#0x1f]         ;1041
000690  2a00              CMP      r2,#0                 ;1041
000692  d102              BNE      |L1.1690|
000694  7faa              LDRB     r2,[r5,#0x1e]         ;1042
000696  2a02              CMP      r2,#2                 ;1042
000698  d005              BEQ      |L1.1702|
                  |L1.1690|
;;;1048               }
;;;1049           }
;;;1050           else {
;;;1051               mask &= ~(unsigned int)AT91C_MCI_CMDRDY;
00069a  0876              LSRS     r6,r6,#1
00069c  0076              LSLS     r6,r6,#1
;;;1052               if (pCommand->dataTran == 0) {
00069e  7f6a              LDRB     r2,[r5,#0x1d]
0006a0  2a00              CMP      r2,#0
0006a2  d007              BEQ      |L1.1716|
0006a4  e008              B        |L1.1720|
                  |L1.1702|
0006a6  013a              LSLS     r2,r7,#4              ;1043
0006a8  d502              BPL      |L1.1712|
0006aa  2202              MOVS     r2,#2                 ;1044
0006ac  6022              STR      r2,[r4,#0]            ;1044
0006ae  e003              B        |L1.1720|
                  |L1.1712|
0006b0  6461              STR      r1,[r4,#0x44]         ;1047
0006b2  e001              B        |L1.1720|
                  |L1.1716|
;;;1053                   MCI_DISABLE(pMciHw);
0006b4  2202              MOVS     r2,#2
0006b6  6022              STR      r2,[r4,#0]
                  |L1.1720|
;;;1054               }
;;;1055           }
;;;1056       }
;;;1057   
;;;1058       // Check if transfer stopped
;;;1059       if (status & AT91C_MCI_XFRDONE) {
0006b8  0102              LSLS     r2,r0,#4
0006ba  d502              BPL      |L1.1730|
;;;1060           mask &= ~(unsigned int)AT91C_MCI_XFRDONE;
0006bc  438e              BICS     r6,r6,r1
;;;1061           MCI_DISABLE(pMciHw);
0006be  2102              MOVS     r1,#2
0006c0  6021              STR      r1,[r4,#0]
                  |L1.1730|
;;;1062       }
;;;1063   
;;;1064   #if defined(MCI_DMA_ENABLE)
;;;1065   
;;;1066       // Check FIFOEMPTY
;;;1067       if (status & AT91C_MCI_FIFOEMPTY) {
0006c2  0141              LSLS     r1,r0,#5
0006c4  d50b              BPL      |L1.1758|
;;;1068           
;;;1069           WRITE_MCI(pMciHw, MCI_IDR, AT91C_MCI_FIFOEMPTY);
0006c6  496e              LDR      r1,|L1.2176|
0006c8  64a1              STR      r1,[r4,#0x48]
;;;1070           if ( pCommand->isRead == 0 &&
0006ca  7fea              LDRB     r2,[r5,#0x1f]
0006cc  2108              MOVS     r1,#8
0006ce  003b              MOVS     r3,r7
0006d0  400b              ANDS     r3,r3,r1
0006d2  431a              ORRS     r2,r2,r3
0006d4  d02c              BEQ      |L1.1840|
;;;1071               (status0 & AT91C_MCI_BLKE) == 0 ) {
;;;1072               WRITE_MCI(pMciHw, MCI_IER, AT91C_MCI_BLKE);
;;;1073           }
;;;1074           else {
;;;1075               mask &= ~(unsigned int)AT91C_MCI_FIFOEMPTY;
0006d6  05c9              LSLS     r1,r1,#23
0006d8  438e              BICS     r6,r6,r1
;;;1076               MCI_DISABLE(pMciHw);
0006da  2102              MOVS     r1,#2
0006dc  6021              STR      r1,[r4,#0]
                  |L1.1758|
;;;1077           }
;;;1078       }
;;;1079       if (status & AT91C_MCI_BLKE) {
0006de  0701              LSLS     r1,r0,#28
0006e0  d503              BPL      |L1.1770|
;;;1080           mask &= ~(unsigned int)AT91C_MCI_BLKE;
0006e2  2108              MOVS     r1,#8
0006e4  438e              BICS     r6,r6,r1
;;;1081           MCI_DISABLE(pMciHw);
0006e6  2102              MOVS     r1,#2
0006e8  6021              STR      r1,[r4,#0]
                  |L1.1770|
;;;1082       }
;;;1083   
;;;1084       // Check if a DMA transfer has been completed
;;;1085       if (   (status & AT91C_MCI_DMADONE)
0006ea  0180              LSLS     r0,r0,#6
0006ec  d558              BPL      |L1.1952|
;;;1086           && (LLI_MCI[dmaLastLliNdx].controlA & AT91C_HDMA_DONE)) {
0006ee  485f              LDR      r0,|L1.2156|
0006f0  2114              MOVS     r1,#0x14
0006f2  7800              LDRB     r0,[r0,#0]  ; dmaLastLliNdx
0006f4  4348              MULS     r0,r1,r0
0006f6  4963              LDR      r1,|L1.2180|
0006f8  1840              ADDS     r0,r0,r1
0006fa  6880              LDR      r0,[r0,#8]
0006fc  2800              CMP      r0,#0
0006fe  da4f              BGE      |L1.1952|
;;;1087   
;;;1088           unsigned int intFlag;
;;;1089           intFlag = DMA_GetInterruptMask();
000700  f7fffffe          BL       DMA_GetInterruptMask
;;;1090           intFlag = ~intFlag;
000704  43c0              MVNS     r0,r0
;;;1091           intFlag |= (AT91C_HDMA_BTC0 << BOARD_MCI_DMA_CHANNEL);
000706  2101              MOVS     r1,#1
000708  4308              ORRS     r0,r0,r1
;;;1092           DMA_DisableIt(intFlag);
00070a  f7fffffe          BL       DMA_DisableIt
;;;1093   
;;;1094           // All data transferred
;;;1095           if (xfredBlocks >= pCommand->nbBlock) {
00070e  4857              LDR      r0,|L1.2156|
000710  89e9              LDRH     r1,[r5,#0xe]
000712  8840              LDRH     r0,[r0,#2]  ; xfredBlocks
000714  4281              CMP      r1,r0
000716  9005              STR      r0,[sp,#0x14]
000718  d80e              BHI      |L1.1848|
;;;1096   
;;;1097               WRITE_MCI(pMciHw, MCI_IDR, AT91C_MCI_DMADONE);
00071a  495b              LDR      r1,|L1.2184|
00071c  64a1              STR      r1,[r4,#0x48]
;;;1098               if ( pCommand->isRead == 0 &&
00071e  7fea              LDRB     r2,[r5,#0x1f]
000720  4857              LDR      r0,|L1.2176|
000722  4007              ANDS     r7,r7,r0
000724  433a              ORRS     r2,r2,r7
000726  d005              BEQ      |L1.1844|
;;;1099                   (status0 & AT91C_MCI_FIFOEMPTY) == 0 ) {
;;;1100                   WRITE_MCI(pMciHw, MCI_IER, AT91C_MCI_FIFOEMPTY);
;;;1101               }
;;;1102               else {
;;;1103                   MCI_DISABLE(pMciHw);
000728  2002              MOVS     r0,#2
00072a  6020              STR      r0,[r4,#0]
;;;1104                   mask &= ~(unsigned int)AT91C_MCI_DMADONE;
00072c  438e              BICS     r6,r6,r1
00072e  e037              B        |L1.1952|
                  |L1.1840|
000730  6461              STR      r1,[r4,#0x44]         ;1072
000732  e7d4              B        |L1.1758|
                  |L1.1844|
000734  6460              STR      r0,[r4,#0x44]         ;1100
000736  e033              B        |L1.1952|
                  |L1.1848|
;;;1105               }
;;;1106           }
;;;1107           // Start later part of DMA
;;;1108           else {
;;;1109               unsigned int transSize;
;;;1110               unsigned char* p;
;;;1111               p = &pCommand->pData[xfredBlocks*pCommand->blockSize];
000738  89a8              LDRH     r0,[r5,#0xc]
00073a  9a05              LDR      r2,[sp,#0x14]
00073c  68ab              LDR      r3,[r5,#8]
00073e  4342              MULS     r2,r0,r2
000740  9004              STR      r0,[sp,#0x10]
000742  189a              ADDS     r2,r3,r2
000744  9203              STR      r2,[sp,#0xc]
;;;1112               transSize = ((pCommand->nbBlock - xfredBlocks)
000746  9a05              LDR      r2,[sp,#0x14]
000748  1a8f              SUBS     r7,r1,r2
00074a  4347              MULS     r7,r0,r7
;;;1113                               * pCommand->blockSize);
;;;1114               if (transSize > MCI_FIFO_SIZE) {
00074c  200f              MOVS     r0,#0xf
00074e  0280              LSLS     r0,r0,#10
000750  4287              CMP      r7,r0
000752  d908              BLS      |L1.1894|
;;;1115                   transSize = MCI_FIFO_SIZE;
000754  0007              MOVS     r7,r0
;;;1116                   xfredBlocks += MCI_FIFO_SIZE/pCommand->blockSize;
000756  9904              LDR      r1,[sp,#0x10]
000758  f7fffffe          BL       __aeabi_uidivmod
00075c  9905              LDR      r1,[sp,#0x14]
00075e  4a43              LDR      r2,|L1.2156|
000760  1840              ADDS     r0,r0,r1
000762  8050              STRH     r0,[r2,#2]
000764  e001              B        |L1.1898|
                  |L1.1894|
;;;1117               }
;;;1118               else {
;;;1119                   xfredBlocks  = pCommand->nbBlock;
000766  4841              LDR      r0,|L1.2156|
000768  8041              STRH     r1,[r0,#2]
                  |L1.1898|
;;;1120               }
;;;1121               #if 0
;;;1122               WRITE_MCI(pMciHw, MCI_BLKR, (READ_MCI(pMciHw, MCI_BLKR)
;;;1123                                            & (~(unsigned int)AT91C_MCI_BCNT))
;;;1124                                              | (transSize/pCommand->blockSize));
;;;1125               #endif
;;;1126               if ((pCommand->blockSize & 0x3) == 0) {
00076a  9804              LDR      r0,[sp,#0x10]
00076c  0780              LSLS     r0,r0,#30
00076e  d105              BNE      |L1.1916|
;;;1127                   transSize = toWCOUNT(transSize);
000770  07b8              LSLS     r0,r7,#30
000772  d002              BEQ      |L1.1914|
000774  08bf              LSRS     r7,r7,#2
000776  1c7f              ADDS     r7,r7,#1
000778  e000              B        |L1.1916|
                  |L1.1914|
00077a  08bf              LSRS     r7,r7,#2
                  |L1.1916|
;;;1128               }
;;;1129               DMACH_MCI_P2M(BOARD_MCI_DMA_CHANNEL,
00077c  9804              LDR      r0,[sp,#0x10]
00077e  0780              LSLS     r0,r0,#30
000780  d000              BEQ      |L1.1924|
000782  2001              MOVS     r0,#1
                  |L1.1924|
000784  2100              MOVS     r1,#0
000786  9100              STR      r1,[sp,#0]
000788  1de1              ADDS     r1,r4,#7
00078a  31ff              ADDS     r1,r1,#0xff
00078c  9001              STR      r0,[sp,#4]
00078e  9a03              LDR      r2,[sp,#0xc]
000790  003b              MOVS     r3,r7
000792  31fa              ADDS     r1,r1,#0xfa
000794  2000              MOVS     r0,#0
000796  f7fffffe          BL       DMACH_MCI_P2M
;;;1130                             (unsigned char*)&pMciHw->MCI_FIFO,
;;;1131                             (unsigned char*) p,
;;;1132                             transSize, 0,
;;;1133                             (pCommand->blockSize & 0x3) > 0);
;;;1134               DMA_EnableChannel(BOARD_MCI_DMA_CHANNEL);
00079a  2000              MOVS     r0,#0
00079c  f7fffffe          BL       DMA_EnableChannel
                  |L1.1952|
;;;1135           }
;;;1136       }
;;;1137   #endif
;;;1138   
;;;1139       // All non-error mask done, complete the command
;;;1140       if (!mask || pCommand->status != MCI_STATUS_PENDING) {
0007a0  2e00              CMP      r6,#0
0007a2  d002              BEQ      |L1.1962|
0007a4  6a28              LDR      r0,[r5,#0x20]
0007a6  2801              CMP      r0,#1
0007a8  d03a              BEQ      |L1.2080|
                  |L1.1962|
;;;1141   
;;;1142           // Store the card response in the provided buffer
;;;1143           if (pCommand->pResp) {
0007aa  6928              LDR      r0,[r5,#0x10]
0007ac  2800              CMP      r0,#0
0007ae  d018              BEQ      |L1.2018|
;;;1144               unsigned char resSize;
;;;1145               switch (pCommand->resType) {
0007b0  7f28              LDRB     r0,[r5,#0x1c]
0007b2  0003              MOVS     r3,r0
0007b4  f7fffffe          BL       __ARM_common_switch8
0007b8  08090507          DCB      0x08,0x09,0x05,0x07
0007bc  05050505          DCB      0x05,0x05,0x05,0x05
0007c0  0509              DCB      0x05,0x09
;;;1146               case 1: case 3: case 4: case 5: case 6: case 7:
;;;1147                        resSize = 1;           break;
0007c2  2101              MOVS     r1,#1
0007c4  e002              B        |L1.1996|
;;;1148               case 2:  resSize = 4;           break;
0007c6  2104              MOVS     r1,#4
0007c8  e000              B        |L1.1996|
;;;1149               default: resSize = 0;           break;
0007ca  2100              MOVS     r1,#0
                  |L1.1996|
;;;1150               }
;;;1151               for (i=0; i < resSize; i++) {
0007cc  2000              MOVS     r0,#0
0007ce  e006              B        |L1.2014|
                  |L1.2000|
;;;1152                   pCommand->pResp[i] = READ_MCI(pMciHw, MCI_RSPR[0]);
0007d0  6a22              LDR      r2,[r4,#0x20]
0007d2  692b              LDR      r3,[r5,#0x10]
0007d4  0086              LSLS     r6,r0,#2
0007d6  519a              STR      r2,[r3,r6]
0007d8  1c40              ADDS     r0,r0,#1              ;1151
0007da  0600              LSLS     r0,r0,#24             ;1151
0007dc  0e00              LSRS     r0,r0,#24             ;1151
                  |L1.2014|
0007de  4288              CMP      r0,r1                 ;1151
0007e0  d3f6              BCC      |L1.2000|
                  |L1.2018|
;;;1153               }
;;;1154           }
;;;1155   
;;;1156           // If no error occured, the transfer is successful
;;;1157           if (pCommand->status == MCI_STATUS_PENDING)
0007e2  6a28              LDR      r0,[r5,#0x20]
0007e4  2801              CMP      r0,#1
0007e6  d01d              BEQ      |L1.2084|
;;;1158               pCommand->status = 0;
;;;1159           // Any error, reset registers
;;;1160           else {
;;;1161               MCI_Reset(pMciHw, 1);
0007e8  2101              MOVS     r1,#1
0007ea  0020              MOVS     r0,r4
0007ec  f7fffffe          BL       MCI_Reset
                  |L1.2032|
;;;1162           }
;;;1163   
;;;1164           // Disable interrupts
;;;1165           WRITE_MCI(pMciHw, MCI_IDR, READ_MCI(pMciHw, MCI_IMR));
0007f0  6ce0              LDR      r0,[r4,#0x4c]
0007f2  64a0              STR      r0,[r4,#0x48]
;;;1166         #if defined(MCI_DMA_ENABLE)
;;;1167           DMA_DisableChannel(BOARD_MCI_DMA_CHANNEL);
0007f4  2000              MOVS     r0,#0
0007f6  f7fffffe          BL       DMA_DisableChannel
;;;1168         #endif
;;;1169   
;;;1170           // Disable peripheral
;;;1171           PERIPH_DISABLE(pMci->mciId);
0007fa  9806              LDR      r0,[sp,#0x18]
0007fc  7a01              LDRB     r1,[r0,#8]
0007fe  2001              MOVS     r0,#1
000800  4088              LSLS     r0,r0,r1
000802  4918              LDR      r1,|L1.2148|
000804  6148              STR      r0,[r1,#0x14]
;;;1172           
;;;1173           // Release the semaphore
;;;1174           pMci->semaphore++;
000806  9806              LDR      r0,[sp,#0x18]
000808  7a80              LDRB     r0,[r0,#0xa]
00080a  9906              LDR      r1,[sp,#0x18]
00080c  1c40              ADDS     r0,r0,#1
00080e  7288              STRB     r0,[r1,#0xa]
;;;1175   
;;;1176           // Invoke the callback associated with the current command (if any)
;;;1177           if (pCommand->callback) {
000810  696a              LDR      r2,[r5,#0x14]
000812  2a00              CMP      r2,#0
000814  d004              BEQ      |L1.2080|
;;;1178               (pCommand->callback)(pCommand->status, (void*)pCommand);
000816  6a28              LDR      r0,[r5,#0x20]
000818  0600              LSLS     r0,r0,#24
00081a  0e00              LSRS     r0,r0,#24
00081c  0029              MOVS     r1,r5
00081e  4790              BLX      r2
                  |L1.2080|
;;;1179           }
;;;1180       }
;;;1181   }
000820  b007              ADD      sp,sp,#0x1c
000822  bdf0              POP      {r4-r7,pc}
                  |L1.2084|
000824  2000              MOVS     r0,#0                 ;1158
000826  6228              STR      r0,[r5,#0x20]         ;1158
000828  e7e2              B        |L1.2032|
;;;1182   
                          ENDP

                  MCI_IsTxComplete PROC
;;;1186   //------------------------------------------------------------------------------
;;;1187   unsigned char MCI_IsTxComplete(Mci *pMci)
00082a  b510              PUSH     {r4,lr}
;;;1188   {
;;;1189       MciCmd *pCommand = pMci->pCommand;		
00082c  6844              LDR      r4,[r0,#4]
;;;1190   	
;;;1191       if(pMci->bPolling == MCI_POLLING_MODE) {
00082e  68c1              LDR      r1,[r0,#0xc]
000830  2901              CMP      r1,#1
000832  d101              BNE      |L1.2104|
;;;1192           MCI_Handler(pMci);
000834  f7fffffe          BL       MCI_Handler
                  |L1.2104|
;;;1193       }
;;;1194     
;;;1195       if (pCommand->status != MCI_STATUS_PENDING) {
000838  6a20              LDR      r0,[r4,#0x20]
00083a  2801              CMP      r0,#1
00083c  d002              BEQ      |L1.2116|
;;;1196           if (pCommand->status != 0) {
00083e  6a20              LDR      r0,[r4,#0x20]
;;;1197               TRACE_DEBUG("MCI_IsTxComplete %d\n\r", pCommand->status);
;;;1198           }
;;;1199           return 1;
000840  2001              MOVS     r0,#1
;;;1200       }
;;;1201       else {
;;;1202           return 0;
;;;1203       }
;;;1204   }
000842  bd10              POP      {r4,pc}
                  |L1.2116|
000844  2000              MOVS     r0,#0                 ;1202
000846  bd10              POP      {r4,pc}
;;;1205   
                          ENDP

                  MCI_FifoTransfer PROC
;;;1210   //------------------------------------------------------------------------------
;;;1211   unsigned int MCI_FifoTransfer(Mci *pMci, MciCmd *pCommand)
000848  2000              MOVS     r0,#0
;;;1212   {
;;;1213       // If using DMA mode, return
;;;1214   #if defined(MCI_DMA_ENABLE)
;;;1215       return 0;
;;;1216   #else
;;;1217   
;;;1218       unsigned int status=0;
;;;1219       unsigned int nbTransfer=0;
;;;1220       unsigned int i;
;;;1221       AT91S_MCI *pMciHw = pMci->pMciHw;
;;;1222       unsigned int *pMem;
;;;1223   
;;;1224       SANITY_CHECK(pMci);
;;;1225       SANITY_CHECK(pCommand);
;;;1226   
;;;1227   
;;;1228       TRACE_DEBUG("MCIFifo:%d,%d\n\r", pCommand->isRead, pCommand->nbBlock);
;;;1229   
;;;1230       if (pCommand->nbBlock == 0 || pCommand->blockSize == 0)
;;;1231           return 0;
;;;1232   
;;;1233       pMem = (unsigned int*)pCommand->pData;
;;;1234   
;;;1235       // Get transfer size
;;;1236       nbTransfer = (pCommand->blockSize) * (pCommand->nbBlock) / 4;
;;;1237       if((pCommand->blockSize) * (pCommand->nbBlock) % 4) {
;;;1238           nbTransfer++;
;;;1239       }
;;;1240   
;;;1241       if (pCommand->isRead) {
;;;1242   
;;;1243           // Read RDR loop
;;;1244           for(i=0; i<nbTransfer; i++) {
;;;1245               while(1) {
;;;1246                   status = READ_MCI(pMciHw, MCI_SR);
;;;1247                   if (status & AT91C_MCI_RXRDY)
;;;1248                       break;
;;;1249                 #if 1
;;;1250                   if (status & STATUS_ERRORS_DATA) {
;;;1251                       TRACE_ERROR("MCI_FifoTransfer.R: 0x%x\n\r", status);
;;;1252                       return status;
;;;1253                   }
;;;1254                 #endif
;;;1255               }
;;;1256               *pMem = READ_MCI(pMciHw, MCI_RDR);
;;;1257               pMem++;
;;;1258           }
;;;1259       }
;;;1260       else {
;;;1261   
;;;1262           // Write TDR loop
;;;1263           for(i=0; i<nbTransfer; i++) {
;;;1264               while(1) {
;;;1265                   status = READ_MCI(pMciHw, MCI_SR);
;;;1266                   if (status & (AT91C_MCI_TXRDY | AT91C_MCI_NOTBUSY))
;;;1267                       break;
;;;1268                 #if 0
;;;1269                   if (status & STATUS_ERRORS_DATA) {
;;;1270                       TRACE_ERROR("MCI_FifoTransfer.W: 0x%x\n\r", status);
;;;1271                       return status;
;;;1272                   }
;;;1273                 #endif
;;;1274               }
;;;1275               WRITE_MCI(pMciHw, MCI_TDR, *pMem);
;;;1276               pMem++;
;;;1277           }
;;;1278       }
;;;1279   
;;;1280       status = READ_MCI(pMciHw, MCI_SR);
;;;1281       TRACE_DEBUG("MCI_FifoTransfer : All status %x\n\r", status);
;;;1282       status &= READ_MCI(pMciHw, MCI_IMR);
;;;1283       TRACE_DEBUG("MCI_FifoTransfer : Masked status %x\n\r", status);
;;;1284   
;;;1285     #if 0
;;;1286     { unsigned int old = status;
;;;1287       while(status & AT91C_MCI_DTIP) {
;;;1288           status = READ_MCI(pMciHw, MCI_SR);
;;;1289           if (status != old) {
;;;1290               old = status;
;;;1291               TRACE_DEBUG_WP(" -> %x", status);
;;;1292           }
;;;1293       }
;;;1294       TRACE_DEBUG_WP("\n\r");
;;;1295       TRACE_DEBUG(" DPIT 0 stat %x\n\r", status);
;;;1296       while((status & (AT91C_MCI_FIFOEMPTY
;;;1297                           | AT91C_MCI_BLKE
;;;1298                           | AT91C_MCI_XFRDONE)) == 0) {
;;;1299           status = READ_MCI(pMciHw, MCI_SR);
;;;1300       }
;;;1301       TRACE_DEBUG(" FIFO EMPTY stat %x\n\r", status);
;;;1302     }
;;;1303     #endif
;;;1304   
;;;1305     return status;
;;;1306   #endif
;;;1307   }
00084a  4770              BX       lr
                          ENDP

                  DMACH_EnableIt PROC
;;;421    
;;;422    static inline void DMACH_EnableIt(AT91S_MCI *pMciHw,
00084c  b510              PUSH     {r4,lr}
;;;423                                     unsigned int channel)
;;;424    {
00084e  000c              MOVS     r4,r1
;;;425        unsigned int intFlag;
;;;426    
;;;427        intFlag = DMA_GetInterruptMask();
000850  f7fffffe          BL       DMA_GetInterruptMask
000854  0002              MOVS     r2,r0
;;;428        intFlag |= (AT91C_HDMA_BTC0 << channel);
000856  2001              MOVS     r0,#1
000858  40a0              LSLS     r0,r0,r4
00085a  4310              ORRS     r0,r0,r2
;;;429        DMA_EnableIt(intFlag);
00085c  f7fffffe          BL       DMA_EnableIt
;;;430    }
000860  bd10              POP      {r4,pc}
;;;431    #endif
                          ENDP

000862  0000              DCW      0x0000
                  |L1.2148|
                          DCD      0xfffffc00
                  |L1.2152|
                          DCD      0x0000e7ff
                  |L1.2156|
                          DCD      ||.data||
                  |L1.2160|
                          DCD      0xc3ff0000
                  |L1.2164|
                          DCD      0xc1ff0001
                  |L1.2168|
                          DCD      0x3e1fffff
                  |L1.2172|
                          DCD      0x08000000
                  |L1.2176|
                          DCD      0x04000000
                  |L1.2180|
                          DCD      ||.bss||
                  |L1.2184|
                          DCD      0x02000000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  LLI_MCI
                          %        100

                          AREA ||.data||, DATA, ALIGN=1

                  dmaLastLliNdx
000000  0000              DCB      0x00,0x00
                  xfredBlocks
000002  ffff              DCW      0xffff

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=2

                          ARM
                  __ARM_common_switch8 PROC
000000  e55ec001          LDRB     r12,[lr,#-1]
000004  e153000c          CMP      r3,r12
000008  3a000001          BCC      |L16.20|
00000c  e7de300c          LDRB     r3,[lr,r12]
000010  ea000000          B        |L16.24|
                  |L16.20|
000014  e7de3003          LDRB     r3,[lr,r3]
                  |L16.24|
000018  e08ec083          ADD      r12,lr,r3,LSL #1
00001c  e12fff1c          BX       r12
                          ENDP

