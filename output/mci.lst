L 1 "mci.c"
N/* ----------------------------------------------------------------------------
N *		 
N *        mboot for Lophilo embedded system
N *        I am so lazy that I will add something here later.
N *	
N * ----------------------------------------------------------------------------
N * GPLv2
N * ----------------------------------------------------------------------------
N */
N
N#include "def.h"
L 1 "def.h" 1
N/*
N *------------------------------------------------------------------------------
N *
N *------------------------------------------------------------------------------
N */
N
N#ifndef __DEF_H__
N#define __DEF_H__
N
Ntypedef float F32;
Ntypedef unsigned int U32;
Ntypedef int S32;
Ntypedef unsigned short U16;
Ntypedef short int S16;
Ntypedef unsigned char U8;
Ntypedef char S8;
N
Ntypedef enum { FALSE = 0, TRUE } BOOL;
N
N#endif /* __DEF_H__ */
L 12 "mci.c" 2
N#include "trace.h"
L 1 "trace.h" 1
N/*
N *------------------------------------------------------------------------------
N *
N *------------------------------------------------------------------------------
N */
N
N#ifndef __TRACE_H__
N#define __TRACE_H__
N
N#include "shell.h"
L 1 "shell.h" 1
N/*
N *------------------------------------------------------------------------------
N *
N *------------------------------------------------------------------------------
N */
N
N#ifndef __SHELL_H__
N#define __SHELL_H__
N
N#define SHELL_INF(...)		{ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N#define SHELL_DATA(...)		{ShellPrintf(__VA_ARGS__);}
N#define SHELL_EMPTY()		{ShellPrintf("\n\r");}
N#define SHELL_BNNER()		{ShellPrintf("==========================================\n\r");}
N
Nvoid ShellAllClear(void);
N
NU32 ShellPrintf(const char* format,...);
Nvoid ShellSendString(S8 *pt);
Nvoid ShellGetString(S8 *string);
NS32 ShellGetIntNum(void);
N
Nvoid ShellPutByte(S8 c);
NS8 ShellGetByte(void);
NS8 ShellGetKey(void);
N
N#endif /* __SHELL_H__ */
L 11 "trace.h" 2
N
N#define DEBUG_ENABLE		0
N
N#if (DEBUG_ENABLE == 1)
X#if (0 == 1)
S#define DEBUG_MSG(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;34mD: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
S#define DEBUG_MSG_WP(...)	{ShellPutByte(0x1B); ShellPrintf("[1;1;34mD: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__);}
N#else
N#define DEBUG_MSG(...)		{ }
N#define DEBUG_MSG_WP(...)	{ }
N#endif
N
N#define TRACE_MSG(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N#define TRACE_FIN(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;32mF: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N#define TRACE_WRN(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N#define TRACE_ERR(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N
N
N
N#endif /* __TRACE_H__ */
L 13 "mci.c" 2
N#include "soc.h"
L 1 "soc.h" 1
N/*
N *------------------------------------------------------------------------------
N *
N *------------------------------------------------------------------------------
N */
N
N#ifndef __SOC_H__
N#define __SOC_H__
N
N#define BOARD_MAINOSC	12000000
N#define BOARD_MCK		((unsigned long)((BOARD_MAINOSC / 3 / 2 / 3) * 200 )) // 133MHz
N
N#define rWDT_SR			(*(volatile U32 *)(0xFFFFFD44))
N#define rSHDW_MR		(*(volatile U32 *)(0xFFFFFD14))
N#define rSYS_RSTC		(*(volatile U32 *)(0xFFFFFD08))
N#define rSCKCR			(*(volatile U32 *)(0xFFFFFD50))
N
N#define rCKGR_MOR		(*(volatile U32 *)(0xFFFFFC20))
N#define rCKGR_PLLAR		(*(volatile U32 *)(0xFFFFFC28))
N#define rCKGR_UCKR		(*(volatile U32 *)(0xFFFFFC1C))
N
N#define rPMC_MCKR		(*(volatile U32 *)(0xFFFFFC30))
N#define rPMC_PLLICPR	(*(volatile U32 *)(0xFFFFFC80))
N#define rPMC_SR			(*(volatile U32 *)(0xFFFFFC68))
N#define rPMC_SCER		(*(volatile U32 *)(0xFFFFFC00))
N#define rPMC_SCDR		(*(volatile U32 *)(0xFFFFFC04))
N#define rPMC_SCSR		(*(volatile U32 *)(0xFFFFFC08))
N#define rPMC_USB		(*(volatile U32 *)(0xFFFFFC38))
N#define rPMC_PCER		(*(volatile U32 *)(0xFFFFFC10))
N#define rPMC_PCDR		(*(volatile U32 *)(0xFFFFFC14))
N#define rPMC_PCSR		(*(volatile U32 *)(0xFFFFFC18))
N#define rPMC_PCK0		(*(volatile U32 *)(0xFFFFFC40))
N#define rPMC_PCK1		(*(volatile U32 *)(0xFFFFFC44))
N
N#define rAIC_SMR(id)	(*(volatile U32 *)(0xFFFFF000+id*0x4))
N#define rAIC_SVR(id)	(*(volatile U32 *)(0xFFFFF000+id*0x4+0x80))
N#define rAIC_IECR		(*(volatile U32 *)(0xFFFFF120))
N#define rAIC_IDCR		(*(volatile U32 *)(0xFFFFF124))
N#define rAIC_ICCR		(*(volatile U32 *)(0xFFFFF128))
N#define rAIC_EOICR		(*(volatile U32 *)(0xFFFFF130))
N#define rAIC_SPU		(*(volatile U32 *)(0xFFFFF134))
N
N#define rRTT_MR			(*(volatile U32 *)(0xFFFFFD20)) // Mode Register Read-write 0x0000_8000
N#define rRTT_AR			(*(volatile U32 *)(0xFFFFFD24)) // Alarm Register Read-write 0xFFFF_FFFF
N#define rRTT_VR			(*(volatile U32 *)(0xFFFFFD28)) // Value Register Read-only 0x0000_0000
N#define rRTT_SR			(*(volatile U32 *)(0xFFFFFD2C)) // Status Register Read-only 0x0000_0000
N
N#define rPIT_MR			(*(volatile U32 *)(0xFFFFFD30)) // Mode Register Read-write 0x000F_FFFF
N#define rPIT_SR			(*(volatile U32 *)(0xFFFFFD34)) // Status Register Read-only 0x0000_0000
N#define rPIT_PIVR		(*(volatile U32 *)(0xFFFFFD38)) // Periodic Interval Value Register Read-only 0x0000_0000
N#define rPIT_PIIR		(*(volatile U32 *)(0xFFFFFD3C)) // Periodic Interval Image Register Read-only 0x0000_0000
N
N#define rMATRIX_MCFG0	(*(volatile U32 *)(0xFFFFEA00)) // Master Configuration Register 0  Read-write 0x00000001
N#define rMATRIX_MCFG1	(*(volatile U32 *)(0xFFFFEA04)) // Master Configuration Register 1 Read-write 0x00000000
N#define rMATRIX_MCFG2	(*(volatile U32 *)(0xFFFFEA08)) // Master Configuration Register 2 Read-write 0x00000000
N#define rMATRIX_MCFG3	(*(volatile U32 *)(0xFFFFEA0C)) // Master Configuration Register 3 Read-write 0x00000000
N#define rMATRIX_MCFG4	(*(volatile U32 *)(0xFFFFEA10)) // Master Configuration Register 4 Read-write 0x00000000
N#define rMATRIX_MCFG5	(*(volatile U32 *)(0xFFFFEA14)) // Master Configuration Register 5 Read-write 0x00000000
N#define rMATRIX_MCFG6	(*(volatile U32 *)(0xFFFFEA18)) // Master Configuration Register 6 Read-write 0x00000000
N#define rMATRIX_MCFG7	(*(volatile U32 *)(0xFFFFEA1C)) // Master Configuration Register 7 Read-write 0x00000000
N#define rMATRIX_MCFG8	(*(volatile U32 *)(0xFFFFEA20)) // Master Configuration Register 8 Read-write 0x00000000
N#define rMATRIX_MCFG9	(*(volatile U32 *)(0xFFFFEA24)) // Master Configuration Register 9 Read-write 0x00000000
N#define rMATRIX_MCFG10	(*(volatile U32 *)(0xFFFFEA28)) // Master Configuration Register 10 Read-write 0x00000000
N#define rMATRIX_MCFG11	(*(volatile U32 *)(0xFFFFEA2C)) // Master Configuration Register 11 Read-write 0x00000000
N#define rMATRIX_SCFG0	(*(volatile U32 *)(0xFFFFEA40)) // Slave Configuration Register 0 Read-write 0x000001FF
N#define rMATRIX_SCFG1	(*(volatile U32 *)(0xFFFFEA44)) // Slave Configuration Register 1 Read-write 0x000001FF
N#define rMATRIX_SCFG2	(*(volatile U32 *)(0xFFFFEA48)) // Slave Configuration Register 2 Read-write 0x000001FF
N#define rMATRIX_SCFG3	(*(volatile U32 *)(0xFFFFEA4C)) // Slave Configuration Register 3 Read-write 0x000001FF
N#define rMATRIX_SCFG4	(*(volatile U32 *)(0xFFFFEA50)) // Slave Configuration Register 4 Read-write 0x000001FF
N#define rMATRIX_SCFG5	(*(volatile U32 *)(0xFFFFEA54)) // Slave Configuration Register 5 Read-write 0x000001FF
N#define rMATRIX_SCFG6	(*(volatile U32 *)(0xFFFFEA58)) // Slave Configuration Register 6 Read-write 0x000001FF
N#define rMATRIX_SCFG7	(*(volatile U32 *)(0xFFFFEA5C)) // Slave Configuration Register 7 Read-write 0x000001FF
N#define rMATRIX_PRAS0	(*(volatile U32 *)(0xFFFFEA80)) // Priority Register A for Slave 0 Read-write 0x00000000
N#define rMATRIX_PRBS0	(*(volatile U32 *)(0xFFFFEA84)) // Priority Register B for Slave 0 Read-write 0x00000000
N#define rMATRIX_PRAS1	(*(volatile U32 *)(0xFFFFEA88)) // Priority Register A for Slave 1 Read-write 0x00000000
N#define rMATRIX_PRBS1	(*(volatile U32 *)(0xFFFFEA8C)) // Priority Register B for Slave 1 Read-write 0x00000000
N#define rMATRIX_PRAS2	(*(volatile U32 *)(0xFFFFEA90)) // Priority Register A for Slave 2 Read-write 0x00000000
N#define rMATRIX_PRBS2	(*(volatile U32 *)(0xFFFFEA94)) // Priority Register B for Slave 2 Read-write 0x00000000
N#define rMATRIX_PRAS3	(*(volatile U32 *)(0xFFFFEA98)) // Priority Register A for Slave 3 Read-write 0x00000000
N#define rMATRIX_PRBS3	(*(volatile U32 *)(0xFFFFEA9C)) // Priority Register B for Slave 3 Read-write 0x00000000
N#define rMATRIX_PRAS4	(*(volatile U32 *)(0xFFFFEAA0)) // Priority Register A for Slave 4 Read-write 0x00000000
N#define rMATRIX_PRBS4	(*(volatile U32 *)(0xFFFFEAA4)) // Priority Register B for Slave 4 Read-write 0x00000000
N#define rMATRIX_PRAS5	(*(volatile U32 *)(0xFFFFEAA8)) // Priority Register A for Slave 5 Read-write 0x00000000
N#define rMATRIX_PRBS5	(*(volatile U32 *)(0xFFFFEAAC)) // Priority Register B for Slave 5 Read-write 0x00000000
N#define rMATRIX_PRAS6	(*(volatile U32 *)(0xFFFFEAB0)) // Priority Register A for Slave 6 Read-write 0x00000000
N#define rMATRIX_PRBS6	(*(volatile U32 *)(0xFFFFEAB4)) // Priority Register B for Slave 6 Read-write 0x00000000
N#define rMATRIX_PRAS7	(*(volatile U32 *)(0xFFFFEAB8)) // Priority Register A for Slave 7 Read-write 0x00000000
N#define rMATRIX_PRBS7	(*(volatile U32 *)(0xFFFFEABC)) // Priority Register B for Slave 7 Read-write 0x00000000
N#define rMATRIX_MRCR	(*(volatile U32 *)(0xFFFFEB00)) // Master Remap Control Register Read-write 0x00000000
N#define rMATRIX_WPMR	(*(volatile U32 *)(0xFFFFEBE4)) // Write Protect Mode Register Read-write 0x00000000
N#define rMATRIX_WPSR	(*(volatile U32 *)(0xFFFFEBE8)) // Write Protect Status Register Read-only 0x00000000
N
N#define rDMAC_GCFG		(*(volatile U32 *)(0xFFFFEC00))
N#define rDMAC_EN		(*(volatile U32 *)(0xFFFFEC04))
N#define rDMAC_SREQ		(*(volatile U32 *)(0xFFFFEC08))
N#define rDMAC_CREQ		(*(volatile U32 *)(0xFFFFEC0C))
N#define rDMAC_LAST		(*(volatile U32 *)(0xFFFFEC10))
N#define rDMAC_EBCIER	(*(volatile U32 *)(0xFFFFEC18))
N#define rDMAC_EBCIDR	(*(volatile U32 *)(0xFFFFEC1C))
N#define rDMAC_EBCIMR	(*(volatile U32 *)(0xFFFFEC20))
N#define rDMAC_EBCISR	(*(volatile U32 *)(0xFFFFEC24))
N#define rDMAC_CHER		(*(volatile U32 *)(0xFFFFEC28))
N#define rDMAC_CHDR		(*(volatile U32 *)(0xFFFFEC2C))
N#define rDMAC_CHSR		(*(volatile U32 *)(0xFFFFEC30))
N#define rDMAC_SADDR(ch)	(*(volatile U32 *)(0xFFFFEC3C+ch*(0x28)+(0x0)))
N#define rDMAC_DADDR(ch)	(*(volatile U32 *)(0xFFFFEC3C+ch*(0x28)+(0x4)))
N#define rDMAC_DSCR(ch)	(*(volatile U32 *)(0xFFFFEC3C+ch*(0x28)+(0x8)))
N#define rDMAC_CTRLA(ch)	(*(volatile U32 *)(0xFFFFEC3C+ch*(0x28)+(0xC)))
N#define rDMAC_CTRLB(ch)	(*(volatile U32 *)(0xFFFFEC3C+ch*(0x28)+(0x10)))
N#define rDMAC_CFG(ch)	(*(volatile U32 *)(0xFFFFEC3C+ch*(0x28)+(0x14)))
N#define rDMAC_SPIP(ch)	(*(volatile U32 *)(0xFFFFEC3C+ch*(0x28)+(0x18)))
N#define rDMAC_DPIP(ch)	(*(volatile U32 *)(0xFFFFEC3C+ch*(0x28)+(0x1C)))
N
N#define rPIOA_PER		(*(volatile U32 *)(0xFFFFF200)) // PIO Enable Register Write-only
N#define rPIOA_PDR		(*(volatile U32 *)(0xFFFFF204)) // PIO Disable Register Write-only
N#define rPIOA_PSR		(*(volatile U32 *)(0xFFFFF208)) // PIO Status Register Read-only
N#define rPIOA_OER		(*(volatile U32 *)(0xFFFFF210)) // Output Enable Register Write-only
N#define rPIOA_ODR		(*(volatile U32 *)(0xFFFFF214)) // Output Disable Register Write-only
N#define rPIOA_OSR		(*(volatile U32 *)(0xFFFFF218)) // Output Status Register Read-only 0x00000000
N#define rPIOA_IFER		(*(volatile U32 *)(0xFFFFF220)) // Glitch Input Filter Enable Register Write-only
N#define rPIOA_IFDR		(*(volatile U32 *)(0xFFFFF224)) // Glitch Input Filter Disable Register Write-only
N#define rPIOA_IFSR		(*(volatile U32 *)(0xFFFFF228)) // Glitch Input Filter Status Register Read-only 0x00000000
N#define rPIOA_SODR		(*(volatile U32 *)(0xFFFFF230)) // Set Output Data Register Write-only
N#define rPIOA_CODR		(*(volatile U32 *)(0xFFFFF234)) // Clear Output Data Register Write-only
N#define rPIOA_ODSR		(*(volatile U32 *)(0xFFFFF238)) // Output Data Status Register 
N#define rPIOA_PDSR		(*(volatile U32 *)(0xFFFFF23C)) // Pin Data Status Register Read-only
N#define rPIOA_IER		(*(volatile U32 *)(0xFFFFF240)) // Interrupt Enable Register Write-only
N#define rPIOA_IDR		(*(volatile U32 *)(0xFFFFF244)) // Interrupt Disable Register Write-only
N#define rPIOA_IMR		(*(volatile U32 *)(0xFFFFF248)) // Interrupt Mask Register  Read-only 0x00000000
N#define rPIOA_ISR		(*(volatile U32 *)(0xFFFFF24C)) // Interrupt Status Register Read-only 0x00000000
N#define rPIOA_MDER		(*(volatile U32 *)(0xFFFFF250)) // Multi-driver Enable Register Write-only
N#define rPIOA_MDDR		(*(volatile U32 *)(0xFFFFF254)) // Multi-driver Disable Register Write-only
N#define rPIOA_MDSR		(*(volatile U32 *)(0xFFFFF258)) // Multi-driver Status Register Read-only 0x00000000
N#define rPIOA_PUDR		(*(volatile U32 *)(0xFFFFF260)) // Pull-up Disable Register Write-only
N#define rPIOA_PUER		(*(volatile U32 *)(0xFFFFF264)) // Pull-up Enable Register Write-only
N#define rPIOA_PUSR		(*(volatile U32 *)(0xFFFFF268)) // Pad Pull-up Status Register Read-only 0x00000000
N#define rPIOA_ASR		(*(volatile U32 *)(0xFFFFF270)) // Peripheral A Select Register Write-only
N#define rPIOA_BSR		(*(volatile U32 *)(0xFFFFF274)) // Peripheral B Select Register Write-only
N#define rPIOA_ABSR		(*(volatile U32 *)(0xFFFFF278)) // AB Status Register Read-only 0x00000000
N#define rPIOA_OWER		(*(volatile U32 *)(0xFFFFF2A0)) // Output Write Enable Write-only
N#define rPIOA_OWDR		(*(volatile U32 *)(0xFFFFF2A4)) // Output Write Disable Write-only
N#define rPIOA_OWSR		(*(volatile U32 *)(0xFFFFF2A8)) // Output Write Status Register Read-only 0x00000000
N#define rPIOA_DELAYR0	(*(volatile U32 *)(0xFFFFF2C0)) // I/O Delay Register 0 Read/Write 0x00000000
N#define rPIOA_DELAYR1	(*(volatile U32 *)(0xFFFFF2C4)) // I/O Delay Register 1 Read/Write 0x00000000
N#define rPIOA_DELAYR2	(*(volatile U32 *)(0xFFFFF2C8)) // I/O Delay Register 2 Read/Write 0x00000000
N#define rPIOA_DELAYR3	(*(volatile U32 *)(0xFFFFF2CC)) // I/O Delay Register 3 Read/Write 0x00000000
N#define rPIOA_WPMR		(*(volatile U32 *)(0xFFFFF2E4)) // Write Protect Mode Register  Read-write 0x00000000
N#define rPIOA_WPSR		(*(volatile U32 *)(0xFFFFF2E8)) // Write Protect Status Register 
N
N#define rPIOB_PER		(*(volatile U32 *)(0xFFFFF400)) // PIO Enable Register Write-only
N#define rPIOB_PDR		(*(volatile U32 *)(0xFFFFF404)) // PIO Disable Register Write-only
N#define rPIOB_PSR		(*(volatile U32 *)(0xFFFFF408)) // PIO Status Register Read-only
N#define rPIOB_OER		(*(volatile U32 *)(0xFFFFF410)) // Output Enable Register Write-only
N#define rPIOB_ODR		(*(volatile U32 *)(0xFFFFF414)) // Output Disable Register Write-only
N#define rPIOB_OSR		(*(volatile U32 *)(0xFFFFF418)) // Output Status Register Read-only 0x00000000
N#define rPIOB_IFER		(*(volatile U32 *)(0xFFFFF420)) // Glitch Input Filter Enable Register Write-only
N#define rPIOB_IFDR		(*(volatile U32 *)(0xFFFFF424)) // Glitch Input Filter Disable Register Write-only
N#define rPIOB_IFSR		(*(volatile U32 *)(0xFFFFF428)) // Glitch Input Filter Status Register Read-only 0x00000000
N#define rPIOB_SODR		(*(volatile U32 *)(0xFFFFF430)) // Set Output Data Register Write-only
N#define rPIOB_CODR		(*(volatile U32 *)(0xFFFFF434)) // Clear Output Data Register Write-only
N#define rPIOB_ODSR		(*(volatile U32 *)(0xFFFFF438)) // Output Data Status Register 
N#define rPIOB_PDSR		(*(volatile U32 *)(0xFFFFF43C)) // Pin Data Status Register Read-only
N#define rPIOB_IER		(*(volatile U32 *)(0xFFFFF440)) // Interrupt Enable Register Write-only
N#define rPIOB_IDR		(*(volatile U32 *)(0xFFFFF444)) // Interrupt Disable Register Write-only
N#define rPIOB_IMR		(*(volatile U32 *)(0xFFFFF448)) // Interrupt Mask Register  Read-only 0x00000000
N#define rPIOB_ISR		(*(volatile U32 *)(0xFFFFF44C)) // Interrupt Status Register Read-only 0x00000000
N#define rPIOB_MDER		(*(volatile U32 *)(0xFFFFF450)) // Multi-driver Enable Register Write-only
N#define rPIOB_MDDR		(*(volatile U32 *)(0xFFFFF454)) // Multi-driver Disable Register Write-only
N#define rPIOB_MDSR		(*(volatile U32 *)(0xFFFFF458)) // Multi-driver Status Register Read-only 0x00000000
N#define rPIOB_PUDR		(*(volatile U32 *)(0xFFFFF460)) // Pull-up Disable Register Write-only
N#define rPIOB_PUER		(*(volatile U32 *)(0xFFFFF464)) // Pull-up Enable Register Write-only
N#define rPIOB_PUSR		(*(volatile U32 *)(0xFFFFF468)) // Pad Pull-up Status Register Read-only 0x00000000
N#define rPIOB_ASR		(*(volatile U32 *)(0xFFFFF470)) // Peripheral A Select Register Write-only
N#define rPIOB_BSR		(*(volatile U32 *)(0xFFFFF474)) // Peripheral B Select Register Write-only
N#define rPIOB_ABSR		(*(volatile U32 *)(0xFFFFF478)) // AB Status Register Read-only 0x00000000
N#define rPIOB_OWER		(*(volatile U32 *)(0xFFFFF4A0)) // Output Write Enable Write-only
N#define rPIOB_OWDR		(*(volatile U32 *)(0xFFFFF4A4)) // Output Write Disable Write-only
N#define rPIOB_OWSR		(*(volatile U32 *)(0xFFFFF4A8)) // Output Write Status Register Read-only 0x00000000
N#define rPIOB_DELAYR0	(*(volatile U32 *)(0xFFFFF4C0)) // I/O Delay Register 0 Read/Write 0x00000000
N#define rPIOB_DELAYR1	(*(volatile U32 *)(0xFFFFF4C4)) // I/O Delay Register 1 Read/Write 0x00000000
N#define rPIOB_DELAYR2	(*(volatile U32 *)(0xFFFFF4C8)) // I/O Delay Register 2 Read/Write 0x00000000
N#define rPIOB_DELAYR3	(*(volatile U32 *)(0xFFFFF4CC)) // I/O Delay Register 3 Read/Write 0x00000000
N#define rPIOB_WPMR		(*(volatile U32 *)(0xFFFFF4E4)) // Write Protect Mode Register  Read-write 0x00000000
N#define rPIOB_WPSR		(*(volatile U32 *)(0xFFFFF4E8)) // Write Protect Status Register 
N
N#define rPIOC_PER		(*(volatile U32 *)(0xFFFFF600)) // PIO Enable Register Write-only
N#define rPIOC_PDR		(*(volatile U32 *)(0xFFFFF604)) // PIO Disable Register Write-only
N#define rPIOC_PSR		(*(volatile U32 *)(0xFFFFF608)) // PIO Status Register Read-only
N#define rPIOC_OER		(*(volatile U32 *)(0xFFFFF610)) // Output Enable Register Write-only
N#define rPIOC_ODR		(*(volatile U32 *)(0xFFFFF614)) // Output Disable Register Write-only
N#define rPIOC_OSR		(*(volatile U32 *)(0xFFFFF618)) // Output Status Register Read-only 0x00000000
N#define rPIOC_IFER		(*(volatile U32 *)(0xFFFFF620)) // Glitch Input Filter Enable Register Write-only
N#define rPIOC_IFDR		(*(volatile U32 *)(0xFFFFF624)) // Glitch Input Filter Disable Register Write-only
N#define rPIOC_IFSR		(*(volatile U32 *)(0xFFFFF628)) // Glitch Input Filter Status Register Read-only 0x00000000
N#define rPIOC_SODR		(*(volatile U32 *)(0xFFFFF630)) // Set Output Data Register Write-only
N#define rPIOC_CODR		(*(volatile U32 *)(0xFFFFF634)) // Clear Output Data Register Write-only
N#define rPIOC_ODSR		(*(volatile U32 *)(0xFFFFF638)) // Output Data Status Register 
N#define rPIOC_PDSR		(*(volatile U32 *)(0xFFFFF63C)) // Pin Data Status Register Read-only
N#define rPIOC_IER		(*(volatile U32 *)(0xFFFFF640)) // Interrupt Enable Register Write-only
N#define rPIOC_IDR		(*(volatile U32 *)(0xFFFFF644)) // Interrupt Disable Register Write-only
N#define rPIOC_IMR		(*(volatile U32 *)(0xFFFFF648)) // Interrupt Mask Register  Read-only 0x00000000
N#define rPIOC_ISR		(*(volatile U32 *)(0xFFFFF64C)) // Interrupt Status Register Read-only 0x00000000
N#define rPIOC_MDER		(*(volatile U32 *)(0xFFFFF650)) // Multi-driver Enable Register Write-only
N#define rPIOC_MDDR		(*(volatile U32 *)(0xFFFFF654)) // Multi-driver Disable Register Write-only
N#define rPIOC_MDSR		(*(volatile U32 *)(0xFFFFF658)) // Multi-driver Status Register Read-only 0x00000000
N#define rPIOC_PUDR		(*(volatile U32 *)(0xFFFFF660)) // Pull-up Disable Register Write-only
N#define rPIOC_PUER		(*(volatile U32 *)(0xFFFFF664)) // Pull-up Enable Register Write-only
N#define rPIOC_PUSR		(*(volatile U32 *)(0xFFFFF668)) // Pad Pull-up Status Register Read-only 0x00000000
N#define rPIOC_ASR		(*(volatile U32 *)(0xFFFFF670)) // Peripheral A Select Register Write-only
N#define rPIOC_BSR		(*(volatile U32 *)(0xFFFFF674)) // Peripheral B Select Register Write-only
N#define rPIOC_ABSR		(*(volatile U32 *)(0xFFFFF678)) // AB Status Register Read-only 0x00000000
N#define rPIOC_OWER		(*(volatile U32 *)(0xFFFFF6A0)) // Output Write Enable Write-only
N#define rPIOC_OWDR		(*(volatile U32 *)(0xFFFFF6A4)) // Output Write Disable Write-only
N#define rPIOC_OWSR		(*(volatile U32 *)(0xFFFFF6A8)) // Output Write Status Register Read-only 0x00000000
N#define rPIOC_DELAYR0	(*(volatile U32 *)(0xFFFFF6C0)) // I/O Delay Register 0 Read/Write 0x00000000
N#define rPIOC_DELAYR1	(*(volatile U32 *)(0xFFFFF6C4)) // I/O Delay Register 1 Read/Write 0x00000000
N#define rPIOC_DELAYR2	(*(volatile U32 *)(0xFFFFF6C8)) // I/O Delay Register 2 Read/Write 0x00000000
N#define rPIOC_DELAYR3	(*(volatile U32 *)(0xFFFFF6CC)) // I/O Delay Register 3 Read/Write 0x00000000
N#define rPIOC_WPMR		(*(volatile U32 *)(0xFFFFF6E4)) // Write Protect Mode Register  Read-write 0x00000000
N#define rPIOC_WPSR		(*(volatile U32 *)(0xFFFFF6E8)) // Write Protect Status Register 
N
N#define rPIOD_PER		(*(volatile U32 *)(0xFFFFF800)) // PIO Enable Register Write-only
N#define rPIOD_PDR		(*(volatile U32 *)(0xFFFFF804)) // PIO Disable Register Write-only
N#define rPIOD_PSR		(*(volatile U32 *)(0xFFFFF808)) // PIO Status Register Read-only
N#define rPIOD_OER		(*(volatile U32 *)(0xFFFFF810)) // Output Enable Register Write-only
N#define rPIOD_ODR		(*(volatile U32 *)(0xFFFFF814)) // Output Disable Register Write-only
N#define rPIOD_OSR		(*(volatile U32 *)(0xFFFFF818)) // Output Status Register Read-only 0x00000000
N#define rPIOD_IFER		(*(volatile U32 *)(0xFFFFF820)) // Glitch Input Filter Enable Register Write-only
N#define rPIOD_IFDR		(*(volatile U32 *)(0xFFFFF824)) // Glitch Input Filter Disable Register Write-only
N#define rPIOD_IFSR		(*(volatile U32 *)(0xFFFFF828)) // Glitch Input Filter Status Register Read-only 0x00000000
N#define rPIOD_SODR		(*(volatile U32 *)(0xFFFFF830)) // Set Output Data Register Write-only
N#define rPIOD_CODR		(*(volatile U32 *)(0xFFFFF834)) // Clear Output Data Register Write-only
N#define rPIOD_ODSR		(*(volatile U32 *)(0xFFFFF838)) // Output Data Status Register 
N#define rPIOD_PDSR		(*(volatile U32 *)(0xFFFFF83C)) // Pin Data Status Register Read-only
N#define rPIOD_IER		(*(volatile U32 *)(0xFFFFF840)) // Interrupt Enable Register Write-only
N#define rPIOD_IDR		(*(volatile U32 *)(0xFFFFF844)) // Interrupt Disable Register Write-only
N#define rPIOD_IMR		(*(volatile U32 *)(0xFFFFF848)) // Interrupt Mask Register  Read-only 0x00000000
N#define rPIOD_ISR		(*(volatile U32 *)(0xFFFFF84C)) // Interrupt Status Register Read-only 0x00000000
N#define rPIOD_MDER		(*(volatile U32 *)(0xFFFFF850)) // Multi-driver Enable Register Write-only
N#define rPIOD_MDDR		(*(volatile U32 *)(0xFFFFF854)) // Multi-driver Disable Register Write-only
N#define rPIOD_MDSR		(*(volatile U32 *)(0xFFFFF858)) // Multi-driver Status Register Read-only 0x00000000
N#define rPIOD_PUDR		(*(volatile U32 *)(0xFFFFF860)) // Pull-up Disable Register Write-only
N#define rPIOD_PUER		(*(volatile U32 *)(0xFFFFF864)) // Pull-up Enable Register Write-only
N#define rPIOD_PUSR		(*(volatile U32 *)(0xFFFFF868)) // Pad Pull-up Status Register Read-only 0x00000000
N#define rPIOD_ASR		(*(volatile U32 *)(0xFFFFF870)) // Peripheral A Select Register Write-only
N#define rPIOD_BSR		(*(volatile U32 *)(0xFFFFF874)) // Peripheral B Select Register Write-only
N#define rPIOD_ABSR		(*(volatile U32 *)(0xFFFFF878)) // AB Status Register Read-only 0x00000000
N#define rPIOD_OWER		(*(volatile U32 *)(0xFFFFF8A0)) // Output Write Enable Write-only
N#define rPIOD_OWDR		(*(volatile U32 *)(0xFFFFF8A4)) // Output Write Disable Write-only
N#define rPIOD_OWSR		(*(volatile U32 *)(0xFFFFF8A8)) // Output Write Status Register Read-only 0x00000000
N#define rPIOD_DELAYR0	(*(volatile U32 *)(0xFFFFF8C0)) // I/O Delay Register 0 Read/Write 0x00000000
N#define rPIOD_DELAYR1	(*(volatile U32 *)(0xFFFFF8C4)) // I/O Delay Register 1 Read/Write 0x00000000
N#define rPIOD_DELAYR2	(*(volatile U32 *)(0xFFFFF8C8)) // I/O Delay Register 2 Read/Write 0x00000000
N#define rPIOD_DELAYR3	(*(volatile U32 *)(0xFFFFF8CC)) // I/O Delay Register 3 Read/Write 0x00000000
N#define rPIOD_WPMR		(*(volatile U32 *)(0xFFFFF8E4)) // Write Protect Mode Register  Read-write 0x00000000
N#define rPIOD_WPSR		(*(volatile U32 *)(0xFFFFF8E8)) // Write Protect Status Register 
N
N#define rPIOE_PER		(*(volatile U32 *)(0xFFFFFA00)) // PIO Enable Register Write-only
N#define rPIOE_PDR		(*(volatile U32 *)(0xFFFFFA04)) // PIO Disable Register Write-only
N#define rPIOE_PSR		(*(volatile U32 *)(0xFFFFFA08)) // PIO Status Register Read-only
N#define rPIOE_OER		(*(volatile U32 *)(0xFFFFFA10)) // Output Enable Register Write-only
N#define rPIOE_ODR		(*(volatile U32 *)(0xFFFFFA14)) // Output Disable Register Write-only
N#define rPIOE_OSR		(*(volatile U32 *)(0xFFFFFA18)) // Output Status Register Read-only 0x00000000
N#define rPIOE_IFER		(*(volatile U32 *)(0xFFFFFA20)) // Glitch Input Filter Enable Register Write-only
N#define rPIOE_IFDR		(*(volatile U32 *)(0xFFFFFA24)) // Glitch Input Filter Disable Register Write-only
N#define rPIOE_IFSR		(*(volatile U32 *)(0xFFFFFA28)) // Glitch Input Filter Status Register Read-only 0x00000000
N#define rPIOE_SODR		(*(volatile U32 *)(0xFFFFFA30)) // Set Output Data Register Write-only
N#define rPIOE_CODR		(*(volatile U32 *)(0xFFFFFA34)) // Clear Output Data Register Write-only
N#define rPIOE_ODSR		(*(volatile U32 *)(0xFFFFFA38)) // Output Data Status Register 
N#define rPIOE_PDSR		(*(volatile U32 *)(0xFFFFFA3C)) // Pin Data Status Register Read-only
N#define rPIOE_IER		(*(volatile U32 *)(0xFFFFFA40)) // Interrupt Enable Register Write-only
N#define rPIOE_IDR		(*(volatile U32 *)(0xFFFFFA44)) // Interrupt Disable Register Write-only
N#define rPIOE_IMR		(*(volatile U32 *)(0xFFFFFA48)) // Interrupt Mask Register  Read-only 0x00000000
N#define rPIOE_ISR		(*(volatile U32 *)(0xFFFFFA4C)) // Interrupt Status Register Read-only 0x00000000
N#define rPIOE_MDER		(*(volatile U32 *)(0xFFFFFA50)) // Multi-driver Enable Register Write-only
N#define rPIOE_MDDR		(*(volatile U32 *)(0xFFFFFA54)) // Multi-driver Disable Register Write-only
N#define rPIOE_MDSR		(*(volatile U32 *)(0xFFFFFA58)) // Multi-driver Status Register Read-only 0x00000000
N#define rPIOE_PUDR		(*(volatile U32 *)(0xFFFFFA60)) // Pull-up Disable Register Write-only
N#define rPIOE_PUER		(*(volatile U32 *)(0xFFFFFA64)) // Pull-up Enable Register Write-only
N#define rPIOE_PUSR		(*(volatile U32 *)(0xFFFFFA68)) // Pad Pull-up Status Register Read-only 0x00000000
N#define rPIOE_ASR		(*(volatile U32 *)(0xFFFFFA70)) // Peripheral A Select Register Write-only
N#define rPIOE_BSR		(*(volatile U32 *)(0xFFFFFA74)) // Peripheral B Select Register Write-only
N#define rPIOE_ABSR		(*(volatile U32 *)(0xFFFFFA78)) // AB Status Register Read-only 0x00000000
N#define rPIOE_OWER		(*(volatile U32 *)(0xFFFFFAA0)) // Output Write Enable Write-only
N#define rPIOE_OWDR		(*(volatile U32 *)(0xFFFFFAA4)) // Output Write Disable Write-only
N#define rPIOE_OWSR		(*(volatile U32 *)(0xFFFFFAA8)) // Output Write Status Register Read-only 0x00000000
N#define rPIOE_DELAYR0	(*(volatile U32 *)(0xFFFFFAC0)) // I/O Delay Register 0 Read/Write 0x00000000
N#define rPIOE_DELAYR1	(*(volatile U32 *)(0xFFFFFAC4)) // I/O Delay Register 1 Read/Write 0x00000000
N#define rPIOE_DELAYR2	(*(volatile U32 *)(0xFFFFFAC8)) // I/O Delay Register 2 Read/Write 0x00000000
N#define rPIOE_DELAYR3	(*(volatile U32 *)(0xFFFFFACC)) // I/O Delay Register 3 Read/Write 0x00000000
N#define rPIOE_WPMR		(*(volatile U32 *)(0xFFFFFAE4)) // Write Protect Mode Register  Read-write 0x00000000
N#define rPIOE_WPSR		(*(volatile U32 *)(0xFFFFFAE8)) // Write Protect Status Register 
N
N#define rDDRSDRC_MR		(*(volatile U32 *)(0xFFFFE600)) // DDRSDRC Mode Register Read-write 0x00000000
N#define rDDRSDRC_RTR	(*(volatile U32 *)(0xFFFFE604)) // DDRSDRC Refresh Timer Register  Read-write 0x00000000
N#define rDDRSDRC_CR		(*(volatile U32 *)(0xFFFFE608)) // DDRSDRC Configuration Register  Read-write 0x7024
N#define rDDRSDRC_TPR0	(*(volatile U32 *)(0xFFFFE60C)) // DDRSDRC Timing Parameter 0 Register Read-write 0x20227225
N#define rDDRSDRC_TPR1	(*(volatile U32 *)(0xFFFFE610)) // DDRSDRC Timing Parameter 1 Register Read-write 0x3c80808
N#define rDDRSDRC_TPR2	(*(volatile U32 *)(0xFFFFE614)) // DDRSDRC Timing Parameter 2 Register Read-write 0x2062
N#define rDDRSDRC_LPR	(*(volatile U32 *)(0xFFFFE61C)) // DDRSDRC Low-power Register Read-write 0x10000
N#define rDDRSDRC_MD		(*(volatile U32 *)(0xFFFFE620)) // DDRSDRC Memory Device Register Read-write 0x10
N#define rDDRSDRC_DLL	(*(volatile U32 *)(0xFFFFE624)) // DDRSDRC DLL Information Register Read-only 0x00000001
N#define rDDRSDRC_HS		(*(volatile U32 *)(0xFFFFE62C)) // DDRSDRC High Speed Register Read-write 0x0
N#define rDDRSDRC_DELAY1	(*(volatile U32 *)(0xFFFFE640)) // DDRSDRC Delay I/O Register Read-write 0x00000000
N#define rDDRSDRC_DELAY2	(*(volatile U32 *)(0xFFFFE644)) // DDRSDRC Delay I/O Register Read-write 0x00000000
N#define rDDRSDRC_DELAY3	(*(volatile U32 *)(0xFFFFE648)) // DDRSDRC Delay I/O Register Read-write 0x00000000
N#define rDDRSDRC_DELAY4	(*(volatile U32 *)(0xFFFFE64C)) // DDRSDRC Delay I/O Register Read-write 0x00000000
N#define rDDRSDRC_WPMR	(*(volatile U32 *)(0xFFFFE6E4)) // DDRSDRC Write Protect Mode Register Read-write 0x00000000
N#define rDDRSDRC_WPSR	(*(volatile U32 *)(0xFFFFE6E8)) // DDRSDRC Write Protect Status Register
N#define rDDRSD_BASE0	(*(volatile U32 *)(0x70000000)) // DDRSDRC Write Protect Status Register
N#define rDDRSD_BASE1	(*(volatile U32 *)(0x72000000)) // DDRSDRC Write Protect Status Register
N#define rDDRSD_BASE2	(*(volatile U32 *)(0x74000000)) // DDRSDRC Write Protect Status Register
N#define rDDRSD_BASE3	(*(volatile U32 *)(0x76000000)) // DDRSDRC Write Protect Status Register
N
N#define rDBGU_CR		(*(volatile U32 *)(0xFFFFEE00)) // Control Register Write-only
N#define rDBGU_MR		(*(volatile U32 *)(0xFFFFEE04)) // Mode Register Read-write 0x0
N#define rDBGU_IER		(*(volatile U32 *)(0xFFFFEE08)) // Interrupt Enable Register Write-only
N#define rDBGU_IDR		(*(volatile U32 *)(0xFFFFEE0C)) // Interrupt Disable Register Write-only
N#define rDBGU_IMR		(*(volatile U32 *)(0xFFFFEE10)) // Interrupt Mask Register Read-only 0x0
N#define rDBGU_SR		(*(volatile U32 *)(0xFFFFEE14)) // Status Register Read-only
N#define rDBGU_RHR		(*(volatile U32 *)(0xFFFFEE18)) // Receive Holding Register Read-only 0x0
N#define rDBGU_THR		(*(volatile U32 *)(0xFFFFEE1C)) // Transmit Holding Register Write-only
N#define rDBGU_BRGR		(*(volatile U32 *)(0xFFFFEE20)) // Baud Rate Generator Register Read-write 0x0
N#define rDBGU_CIDR		(*(volatile U32 *)(0xFFFFEE40)) // Chip ID Register Read-only
N#define rDBGU_EXID		(*(volatile U32 *)(0xFFFFEE44)) // Chip ID Extension Register  Read-only
N#define rDBGU_FNR		(*(volatile U32 *)(0xFFFFEE48)) // Force NTRST Register Read-write 0x0
N#define rDBGU_RPR		(*(volatile U32 *)(0xFFFFEF00)) // Receive Pointer Register
N#define rDBGU_RCR		(*(volatile U32 *)(0xFFFFEF04)) // Receive Counter Register
N#define rDBGU_TPR		(*(volatile U32 *)(0xFFFFEF08)) // Transmit Pointer Register
N#define rDBGU_TCR		(*(volatile U32 *)(0xFFFFEF0C)) // Transmit Counter Register
N#define rDBGU_RNPR		(*(volatile U32 *)(0xFFFFEF10)) // Receive Next Pointer Register
N#define rDBGU_RNCR		(*(volatile U32 *)(0xFFFFEF14)) // Receive Next Counter Register
N#define rDBGU_TNPR		(*(volatile U32 *)(0xFFFFEF18)) // Transmit Next Pointer Register
N#define rDBGU_TNCR		(*(volatile U32 *)(0xFFFFEF1C)) // Transmit Next Counter Register
N#define rDBGU_PTCR		(*(volatile U32 *)(0xFFFFEF20)) // PDC Transfer Control Register
N#define rDBGU_PTSR		(*(volatile U32 *)(0xFFFFEF24))	// PDC Transfer Status Register
N
N#define rUS_CR(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0000))
N#define rUS_MR(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0004))
N#define rUS_IER(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0008))
N#define rUS_IDR(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x000C))
N#define rUS_IMR(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0010))
N#define rUS_CSR(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0014))
N#define rUS_RHR(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0018))
N#define rUS_THR(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x001C))
N#define rUS_BRGR(ch)	(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0020))
N#define rUS_RTOR(ch)	(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0024))
N#define rUS_TTGR(ch)	(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0028))
N#define rUS_FIDI(ch)	(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0040))
N#define rUS_NER(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0044))
N#define rUS_IF(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x004C))
N#define rUS_MAN(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0050))
N#define rUS_LINMR(ch)	(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0054))
N#define rUS_LINIR(ch)	(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0058))
N
N#define rSPI_CR(ch)		(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x00)) // Control Register  Write-only ---
N#define rSPI_MR(ch)		(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x04)) // Mode Register  Read-write 0x0
N#define rSPI_RDR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x08)) // Receive Data Register  Read-only 0x0
N#define rSPI_TDR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x0C)) // Transmit Data Register  Write-only ---
N#define rSPI_SR(ch)		(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x10)) // Status Register  Read-only 
N#define rSPI_IER(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x14)) // Interrupt Enable Register  Write-only ---
N#define rSPI_IDR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x18)) // Interrupt Disable Register  Write-only ---
N#define rSPI_IMR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x1C)) // Interrupt Mask Register  Read-only 0x0
N#define rSPI_CSR0(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x30)) // Chip Select Register 0  Read-write 0x0
N#define rSPI_RPR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x100)) // Receive Pointer Register
N#define rSPI_RCR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x104)) // Receive Counter Register
N#define rSPI_TPR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x108)) // Transmit Pointer Register
N#define rSPI_TCR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x10C)) // Transmit Counter Register
N#define rSPI_RNPR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x110)) // Receive Next Pointer Register
N#define rSPI_RNCR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x114)) // Receive Next Counter Register
N#define rSPI_TNPR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x118)) // Transmit Next Pointer Register
N#define rSPI_TNCR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x11C)) // Transmit Next Counter Register
N#define rSPI_PTCR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x120)) // PDC Transfer Control Register
N#define rSPI_PTSR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x124))	// PDC Transfer Status Register
N
N#define rHSMCI_CR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x00)) // Control Register 
N#define rHSMCI_MR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x04)) // Mode Register Read-write 0x0
N#define rHSMCI_DTOR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x08)) // Data Timeout Register Read-write 0x0
N#define rHSMCI_SDCR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x0C)) // SD/SDIO Card Register Read-write 0x0
N#define rHSMCI_ARGR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x10)) // Argument Register  Read-write 0x0
N#define rHSMCI_CMDR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x14)) // Command Register  Write
N#define rHSMCI_BLKR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x18)) // Block Register  Read-write 0x0
N#define rHSMCI_CSTOR(ch)	(*(volatile U32 *)(0xFFF80000+ch*50000+0x1C)) // Completion Signal Timeout Register  Read-write 0x0
N#define rHSMCI_RSPR0(ch)	(*(volatile U32 *)(0xFFF80000+ch*50000+0x20)) // Response Register Read 0x0
N#define rHSMCI_RSPR1(ch)	(*(volatile U32 *)(0xFFF80000+ch*50000+0x24)) // Response Register Read 0x0
N#define rHSMCI_RSPR2(ch)	(*(volatile U32 *)(0xFFF80000+ch*50000+0x28)) // Response Register Read 0x0
N#define rHSMCI_RSPR3(ch)	(*(volatile U32 *)(0xFFF80000+ch*50000+0x2C)) // Response Register Read 0x0
N#define rHSMCI_RDR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x30)) // Receive Data Register Read 0x0
N#define rHSMCI_TDR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x34)) // Transmit Data Register Write
N#define rHSMCI_SR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x40)) // Status Register Read 0xC0E5
N#define rHSMCI_IER(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x44)) // Interrupt Enable Register Write
N#define rHSMCI_IDR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x48)) // Interrupt Disable Register Write
N#define rHSMCI_IMR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x4C)) // Interrupt Mask Register Read 0x0
N#define rHSMCI_DMA(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x50)) // DMA Configuration Register Read-write 0x00
N#define rHSMCI_CFG(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x54)) // Configuration Register Read-write 0x00
N#define rHSMCI_WPMR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0xE4)) // Write Protection Mode Register Read-write
N#define rHSMCI_WPSR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0xE8)) // Write Protection Status Register Read-only
N#define HSMCI_FIFO(ch)		(0xFFF80000+ch*50000+0x200) // FIFO Memory Aperture 0x200-0x3FFC
N
N#define rPWM_MR 		(*(volatile U32 *)(0xFFFB8000))
N#define rPWM_ENA		(*(volatile U32 *)(0xFFFB8000+0x04))
N#define rPWM_DIS		(*(volatile U32 *)(0xFFFB8000+0x08))
N#define rPWM_SR			(*(volatile U32 *)(0xFFFB8000+0x0C))
N#define rPWM_IER		(*(volatile U32 *)(0xFFFB8000+0x10))
N#define rPWM_IDR		(*(volatile U32 *)(0xFFFB8000+0x14))
N#define rPWM_IMR		(*(volatile U32 *)(0xFFFB8000+0x18))
N#define rPWM_ISR		(*(volatile U32 *)(0xFFFB8000+0x1C))
N#define rPWM_CMR(ch)	(*(volatile U32 *)(0xFFFB8000+0x200+ch*0x20+0x00))
N#define rPWM_CDTY(ch)	(*(volatile U32 *)(0xFFFB8000+0x200+ch*0x20+0x04))
N#define rPWM_CPRD(ch)	(*(volatile U32 *)(0xFFFB8000+0x200+ch*0x20+0x08))
N#define rPWM_CCNT(ch)	(*(volatile U32 *)(0xFFFB8000+0x200+ch*0x20+0x0C))
N#define rPWM_CUPD(ch)	(*(volatile U32 *)(0xFFFB8000+0x200+ch*0x20+0x10))
N
N#endif /*__SOC_H__*/
N
L 14 "mci.c" 2
N#include "init_hw.h"
L 1 "init_hw.h" 1
N#ifndef __INIT_HW_H__
N#define __INIT_HW_H__
N
N#define PERIF_ID_FIQ    ( 0) // Advanced Interrupt Controller (FIQ)
N#define PERIF_ID_SYS    ( 1) // System Controller
N#define PERIF_ID_PIOA   ( 2) // Parallel IO Controller A
N#define PERIF_ID_PIOB   ( 3) // Parallel IO Controller B
N#define PERIF_ID_PIOC   ( 4) // Parallel IO Controller C
N#define PERIF_ID_PIOD_E ( 5) // Parallel IO Controller D and E
N#define PERIF_ID_TRNG   ( 6) // True Random Number Generator
N#define PERIF_ID_US0    ( 7) // USART 0
N#define PERIF_ID_US1    ( 8) // USART 1
N#define PERIF_ID_US2    ( 9) // USART 2
N#define PERIF_ID_US3    (10) // USART 2
N#define PERIF_ID_MCI0   (11) // Multimedia Card Interface 0
N#define PERIF_ID_TWI0   (12) // TWI 0
N#define PERIF_ID_TWI1   (13) // TWI 1
N#define PERIF_ID_SPI0   (14) // Serial Peripheral Interface
N#define PERIF_ID_SPI1   (15) // Serial Peripheral Interface
N#define PERIF_ID_SSC0   (16) // Serial Synchronous Controller 0
N#define PERIF_ID_SSC1   (17) // Serial Synchronous Controller 1
N#define PERIF_ID_TC     (18) // Timer Counter 0, 1, 2, 3, 4, 5
N#define PERIF_ID_PWMC   (19) // Pulse Width Modulation Controller
N#define PERIF_ID_TSADC  (20) // Touch Screen Controller
N#define PERIF_ID_HDMA   (21) // HDMA
N#define PERIF_ID_UHPHS  (22) // USB Host High Speed
N#define PERIF_ID_LCDC   (23) // LCD Controller
N#define PERIF_ID_AC97C  (24) // AC97 Controller
N#define PERIF_ID_EMAC   (25) // Ethernet MAC
N#define PERIF_ID_ISI    (26) // Image Sensor Interface
N#define PERIF_ID_UDPHS  (27) // USB Device HS
N
N#define PERIF_ID_MCI1   (29) // Multimedia Card Interface 1
N#define PERIF_ID_VDEC   (30) // Video Decoder
N#define PERIF_ID_IRQ0   (31) // Advanced Interrupt Controller (IRQ0)
N
Nvoid InitHW(void);
N
N#endif /* __INIT_HW_H__ */
L 15 "mci.c" 2
N#include "system.h"
L 1 "system.h" 1
N/*
N *------------------------------------------------------------------------------
N *
N *------------------------------------------------------------------------------
N */
N
N#ifndef __SYSTEM_H__
N#define __SYSTEM_H__
N
N//------------------------------------------------------------------------------
N//         Global definitions
N//------------------------------------------------------------------------------
N/// DMA driver is currently busy.
N#define DMAD_ERROR_BUSY              1
N/// Using the default interrupt handler of the DMAD
N#define DMAD_USE_DEFAULT_IT          1
N#define DMAD_NO_DEFAULT_IT           0
N
N//------------------------------------------------------------------------------
N//         Types
N//------------------------------------------------------------------------------
N
N/// DMA driver callback function.
Ntypedef void (*DmaCallback)();
N
N//------------------------------------------------------------------------------
N/// DMA multi buffer transfer Linker List Item structure.
N//------------------------------------------------------------------------------
Ntypedef struct _DmaLinkList {
N    /// Source address.
N    U32 sourceAddress;
N    /// Destination address.
N    U32 destAddress;
N    /// Control A value.
N    U32 controlA;
N    /// Control B value.
N    U32 controlB;
N    /// Descriptor Address.
N    U32 descriptor;
N} DmaLinkList;
N
N//------------------------------------------------------------------------------
N/// DMA picture-in-picture mode configuration structure. 
N//------------------------------------------------------------------------------
Ntypedef struct _PictureInPicture {
N    /// Size in byte add to the source address in PIP.
N    U16 pipSourceHoleSize;
N    /// Number of transfer in byte to perform before the source address increase.
N    U16 pipSourceBoundarySize;
N    /// Size in byte add to the destination address in PIP.
N    U16 pipDestHoleSize;
N    /// Number of transfer in byte to perform before the destination address increase.
N    U16 pipDestBoundarySize;
N} PictureInPicture;
N
N
N//------------------------------------------------------------------------------
N//         Global functions
N//------------------------------------------------------------------------------
Nvoid DMAD_Initialize(U8 channel, U8 defaultHandler);
NU8 DMAD_Configure_Buffer(U8 channel, U8 sourceTransferMode, U8 destTransferMode, DmaLinkList *lli, PictureInPicture *pip);
NU8 DMAD_Configure_TransferController(U8 channel, U32 bufSize, U8 sourceWidth, U8 destWidth, U32 sourceAddress, U32 destAddress);                
NU8 DMAD_BufferTransfer(U8 channel, U32 size, DmaCallback callback, U8 polling);
NU8 DMAD_IsFinished(U8 channel);
N
Nvoid PMC_PeriEn(U32 id);
Nvoid PMC_PeriDis(U32 id);
Nvoid IRQ_PeriConf(U32 id, U32 mode, void( *handler )( void ));
Nvoid IRQ_PeriEn(U32 id);
Nvoid IRQ_PeriDis(U32 id);
N
Nvoid ResetOut(BOOL reset);
Nvoid SFR_WR32(U32 ioaddr, U32 data);
NU32 SFR_RD32(U32 ioaddr);
Nvoid SFR_WR16(U32 ioaddr, U16 data);
NU16 SFR_RD16(U32 ioaddr);
Nvoid SFR_WR8(U32 ioaddr, U8 data);
NU8 SFR_RD8(U32 ioaddr);
N
N#endif /* __SYSTEM_H__ */
L 16 "mci.c" 2
N#include "dma.h"
L 1 "dma.h" 1
N/*
N *------------------------------------------------------------------------------
N *
N *------------------------------------------------------------------------------
N */
N
N#ifndef __DMA_H__
N#define __DMA_H__
N
N#define DMA_TRANSFER_SINGLE      0
N#define DMA_TRANSFER_LLI         1  
N#define DMA_TRANSFER_RELOAD      2
N#define DMA_TRANSFER_CONTIGUOUS  3
N
N
N
N#define AT91C_HDMA_BTC0       (0x1 <<  0) // (HDMA) Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_BTC1       (0x1 <<  1) // (HDMA) Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_BTC2       (0x1 <<  2) // (HDMA) Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_BTC3       (0x1 <<  3) // (HDMA) Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_BTC4       (0x1 <<  4) // (HDMA) Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_BTC5       (0x1 <<  5) // (HDMA) Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_BTC6       (0x1 <<  6) // (HDMA) Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_BTC7       (0x1 <<  7) // (HDMA) Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N
N// -------- HDMA_CTRLA : (HDMA_CH Offset: 0xc)  -------- 
N#define AT91C_HDMA_BTSIZE     (0xFFFF <<  0) // (HDMA_CH) Buffer Transfer Size.
N#define AT91C_HDMA_SCSIZE     (0x7 << 16) // (HDMA_CH) Source Chunk Transfer Size.
N#define AT91C_HDMA_SCSIZE_1                    (0x0 << 16) // (HDMA_CH) 1.
N#define AT91C_HDMA_SCSIZE_4                    (0x1 << 16) // (HDMA_CH) 4.
N#define AT91C_HDMA_SCSIZE_8                    (0x2 << 16) // (HDMA_CH) 8.
N#define AT91C_HDMA_SCSIZE_16                   (0x3 << 16) // (HDMA_CH) 16.
N#define AT91C_HDMA_SCSIZE_32                   (0x4 << 16) // (HDMA_CH) 32.
N#define AT91C_HDMA_SCSIZE_64                   (0x5 << 16) // (HDMA_CH) 64.
N#define AT91C_HDMA_SCSIZE_128                  (0x6 << 16) // (HDMA_CH) 128.
N#define AT91C_HDMA_SCSIZE_256                  (0x7 << 16) // (HDMA_CH) 256.
N#define AT91C_HDMA_DCSIZE     (0x7 << 20) // (HDMA_CH) Destination Chunk Transfer Size
N#define AT91C_HDMA_DCSIZE_1                    (0x0 << 20) // (HDMA_CH) 1.
N#define AT91C_HDMA_DCSIZE_4                    (0x1 << 20) // (HDMA_CH) 4.
N#define AT91C_HDMA_DCSIZE_8                    (0x2 << 20) // (HDMA_CH) 8.
N#define AT91C_HDMA_DCSIZE_16                   (0x3 << 20) // (HDMA_CH) 16.
N#define AT91C_HDMA_DCSIZE_32                   (0x4 << 20) // (HDMA_CH) 32.
N#define AT91C_HDMA_DCSIZE_64                   (0x5 << 20) // (HDMA_CH) 64.
N#define AT91C_HDMA_DCSIZE_128                  (0x6 << 20) // (HDMA_CH) 128.
N#define AT91C_HDMA_DCSIZE_256                  (0x7 << 20) // (HDMA_CH) 256.
N#define AT91C_HDMA_SRC_WIDTH  (0x3 << 24) // (HDMA_CH) Source Single Transfer Size
N#define AT91C_HDMA_SRC_WIDTH_BYTE                 (0x0 << 24) // (HDMA_CH) BYTE.
N#define AT91C_HDMA_SRC_WIDTH_HALFWORD             (0x1 << 24) // (HDMA_CH) HALF-WORD.
N#define AT91C_HDMA_SRC_WIDTH_WORD                 (0x2 << 24) // (HDMA_CH) WORD.
N#define AT91C_HDMA_DST_WIDTH  (0x3 << 28) // (HDMA_CH) Destination Single Transfer Size
N#define AT91C_HDMA_DST_WIDTH_BYTE                 (0x0 << 28) // (HDMA_CH) BYTE.
N#define AT91C_HDMA_DST_WIDTH_HALFWORD             (0x1 << 28) // (HDMA_CH) HALF-WORD.
N#define AT91C_HDMA_DST_WIDTH_WORD                 (0x2 << 28) // (HDMA_CH) WORD.
N#define AT91C_HDMA_DONE       (0x80000000) // (0x1U << 31) // (HDMA_CH) 
N// -------- HDMA_CTRLB : (HDMA_CH Offset: 0x10)  -------- 
N#define AT91C_HDMA_SIF        (0x3 <<  0) // (HDMA_CH) Source Interface Selection Field.
N#define AT91C_HDMA_SIF_0                    (0x0) // (HDMA_CH) The Source Transfer is done via AHB-Lite Interface 0.
N#define AT91C_HDMA_SIF_1                    (0x1) // (HDMA_CH) The Source Transfer is done via AHB-Lite Interface 1.
N#define AT91C_HDMA_SIF_2                    (0x2) // (HDMA_CH) The Source Transfer is done via AHB-Lite Interface 2.
N#define AT91C_HDMA_SIF_3                    (0x3) // (HDMA_CH) The Source Transfer is done via AHB-Lite Interface 3.
N#define AT91C_HDMA_DIF        (0x3 <<  4) // (HDMA_CH) Destination Interface Selection Field.
N#define AT91C_HDMA_DIF_0                    (0x0 <<  4) // (HDMA_CH) The Destination Transfer is done via AHB-Lite Interface 0.
N#define AT91C_HDMA_DIF_1                    (0x1 <<  4) // (HDMA_CH) The Destination Transfer is done via AHB-Lite Interface 1.
N#define AT91C_HDMA_DIF_2                    (0x2 <<  4) // (HDMA_CH) The Destination Transfer is done via AHB-Lite Interface 2.
N#define AT91C_HDMA_DIF_3                    (0x3 <<  4) // (HDMA_CH) The Destination Transfer is done via AHB-Lite Interface 3.
N#define AT91C_HDMA_SRC_PIP    (0x1 <<  8) // (HDMA_CH) Source Picture-in-Picture Mode
N#define AT91C_HDMA_SRC_PIP_DISABLE              (0x0 <<  8) // (HDMA_CH) Source Picture-in-Picture mode is disabled.
N#define AT91C_HDMA_SRC_PIP_ENABLE               (0x1 <<  8) // (HDMA_CH) Source Picture-in-Picture mode is enabled.
N#define AT91C_HDMA_DST_PIP    (0x1 << 12) // (HDMA_CH) Destination Picture-in-Picture Mode
N#define AT91C_HDMA_DST_PIP_DISABLE              (0x0 << 12) // (HDMA_CH) Destination Picture-in-Picture mode is disabled.
N#define AT91C_HDMA_DST_PIP_ENABLE               (0x1 << 12) // (HDMA_CH) Destination Picture-in-Picture mode is enabled.
N#define AT91C_HDMA_SRC_DSCR   (0x1 << 16) // (HDMA_CH) Source Buffer Descriptor Fetch operation
N#define AT91C_HDMA_SRC_DSCR_FETCH_FROM_MEM       (0x0 << 16) // (HDMA_CH) Source address is updated when the descriptor is fetched from the memory.
N#define AT91C_HDMA_SRC_DSCR_FETCH_DISABLE        (0x1 << 16) // (HDMA_CH) Buffer Descriptor Fetch operation is disabled for the Source.
N#define AT91C_HDMA_DST_DSCR   (0x1 << 20) // (HDMA_CH) Destination Buffer Descriptor operation
N#define AT91C_HDMA_DST_DSCR_FETCH_FROM_MEM       (0x0 << 20) // (HDMA_CH) Destination address is updated when the descriptor is fetched from the memory.
N#define AT91C_HDMA_DST_DSCR_FETCH_DISABLE        (0x1 << 20) // (HDMA_CH) Buffer Descriptor Fetch operation is disabled for the destination.
N#define AT91C_HDMA_FC         (0x7 << 21) // (HDMA_CH) This field defines which devices controls the size of the buffer transfer, also referred as to the Flow Controller.
N#define AT91C_HDMA_FC_MEM2MEM              (0x0 << 21) // (HDMA_CH) Memory-to-Memory (DMA Controller).
N#define AT91C_HDMA_FC_MEM2PER              (0x1 << 21) // (HDMA_CH) Memory-to-Peripheral (DMA Controller).
N#define AT91C_HDMA_FC_PER2MEM              (0x2 << 21) // (HDMA_CH) Peripheral-to-Memory (DMA Controller).
N#define AT91C_HDMA_FC_PER2PER              (0x3 << 21) // (HDMA_CH) Peripheral-to-Peripheral (DMA Controller).
N#define AT91C_HDMA_FC_PER2MEM_PER          (0x4 << 21) // (HDMA_CH) Peripheral-to-Memory (Peripheral).
N#define AT91C_HDMA_FC_MEM2PER_PER          (0x5 << 21) // (HDMA_CH) Memory-to-Peripheral (Peripheral).
N#define AT91C_HDMA_FC_PER2PER_PER          (0x6 << 21) // (HDMA_CH) Peripheral-to-Peripheral (Source Peripheral).
N#define AT91C_HDMA_SRC_ADDRESS_MODE (0x3 << 24) // (HDMA_CH) Type of addressing mode
N#define AT91C_HDMA_SRC_ADDRESS_MODE_INCR                 (0x0 << 24) // (HDMA_CH) Incrementing Mode.
N#define AT91C_HDMA_SRC_ADDRESS_MODE_DECR                 (0x1 << 24) // (HDMA_CH) Decrementing Mode.
N#define AT91C_HDMA_SRC_ADDRESS_MODE_FIXED                (0x2 << 24) // (HDMA_CH) Fixed Mode.
N#define AT91C_HDMA_DST_ADDRESS_MODE (0x3 << 28) // (HDMA_CH) Type of addressing mode
N#define AT91C_HDMA_DST_ADDRESS_MODE_INCR                 (0x0 << 28) // (HDMA_CH) Incrementing Mode.
N#define AT91C_HDMA_DST_ADDRESS_MODE_DECR                 (0x1 << 28) // (HDMA_CH) Decrementing Mode.
N#define AT91C_HDMA_DST_ADDRESS_MODE_FIXED                (0x2 << 28) // (HDMA_CH) Fixed Mode.
N#define AT91C_HDMA_AUTO       (0x1 << 31) // (HDMA_CH) Automatic multiple buffer transfer enable
N#define AT91C_HDMA_AUTO_DISABLE              (0x0 << 31) // (HDMA_CH) Automatic multiple buffer transfer is disabled.
N#define AT91C_HDMA_AUTO_ENABLE               (0x1 << 31) // (HDMA_CH) Automatic multiple buffer transfer is enabled. This enables replay mode or contiguous mode when several buffers are transferred.
N// -------- HDMA_CFG : (HDMA_CH Offset: 0x14)  -------- 
N#define AT91C_HDMA_SRC_PER    (0xF <<  0) // (HDMA_CH) Channel Source Request is associated with peripheral identifier coded SRC_PER handshaking interface.
N#define 	AT91C_HDMA_SRC_PER_0                    (0x0) // (HDMA_CH) HW Handshaking Interface number 0.
N#define 	AT91C_HDMA_SRC_PER_1                    (0x1) // (HDMA_CH) HW Handshaking Interface number 1.
N#define 	AT91C_HDMA_SRC_PER_2                    (0x2) // (HDMA_CH) HW Handshaking Interface number 2.
N#define 	AT91C_HDMA_SRC_PER_3                    (0x3) // (HDMA_CH) HW Handshaking Interface number 3.
N#define 	AT91C_HDMA_SRC_PER_4                    (0x4) // (HDMA_CH) HW Handshaking Interface number 4.
N#define 	AT91C_HDMA_SRC_PER_5                    (0x5) // (HDMA_CH) HW Handshaking Interface number 5.
N#define 	AT91C_HDMA_SRC_PER_6                    (0x6) // (HDMA_CH) HW Handshaking Interface number 6.
N#define 	AT91C_HDMA_SRC_PER_7                    (0x7) // (HDMA_CH) HW Handshaking Interface number 7.
N#define 	AT91C_HDMA_SRC_PER_8                    (0x8) // (HDMA_CH) HW Handshaking Interface number 8.
N#define 	AT91C_HDMA_SRC_PER_9                    (0x9) // (HDMA_CH) HW Handshaking Interface number 9.
N#define 	AT91C_HDMA_SRC_PER_10                   (0xA) // (HDMA_CH) HW Handshaking Interface number 10.
N#define 	AT91C_HDMA_SRC_PER_11                   (0xB) // (HDMA_CH) HW Handshaking Interface number 11.
N#define 	AT91C_HDMA_SRC_PER_12                   (0xC) // (HDMA_CH) HW Handshaking Interface number 12.
N#define 	AT91C_HDMA_SRC_PER_13                   (0xD) // (HDMA_CH) HW Handshaking Interface number 13.
N#define 	AT91C_HDMA_SRC_PER_14                   (0xE) // (HDMA_CH) HW Handshaking Interface number 14.
N#define 	AT91C_HDMA_SRC_PER_15                   (0xF) // (HDMA_CH) HW Handshaking Interface number 15.
N#define AT91C_HDMA_DST_PER    (0xF <<  4) // (HDMA_CH) Channel Destination Request is associated with peripheral identifier coded DST_PER handshaking interface.
N#define 	AT91C_HDMA_DST_PER_0                    (0x0 <<  4) // (HDMA_CH) HW Handshaking Interface number 0.
N#define 	AT91C_HDMA_DST_PER_1                    (0x1 <<  4) // (HDMA_CH) HW Handshaking Interface number 1.
N#define 	AT91C_HDMA_DST_PER_2                    (0x2 <<  4) // (HDMA_CH) HW Handshaking Interface number 2.
N#define 	AT91C_HDMA_DST_PER_3                    (0x3 <<  4) // (HDMA_CH) HW Handshaking Interface number 3.
N#define 	AT91C_HDMA_DST_PER_4                    (0x4 <<  4) // (HDMA_CH) HW Handshaking Interface number 4.
N#define 	AT91C_HDMA_DST_PER_5                    (0x5 <<  4) // (HDMA_CH) HW Handshaking Interface number 5.
N#define 	AT91C_HDMA_DST_PER_6                    (0x6 <<  4) // (HDMA_CH) HW Handshaking Interface number 6.
N#define 	AT91C_HDMA_DST_PER_7                    (0x7 <<  4) // (HDMA_CH) HW Handshaking Interface number 7.
N#define 	AT91C_HDMA_DST_PER_8                    (0x8 <<  4) // (HDMA_CH) HW Handshaking Interface number 8.
N#define 	AT91C_HDMA_DST_PER_9                    (0x9 <<  4) // (HDMA_CH) HW Handshaking Interface number 9.
N#define 	AT91C_HDMA_DST_PER_10                   (0xA <<  4) // (HDMA_CH) HW Handshaking Interface number 10.
N#define 	AT91C_HDMA_DST_PER_11                   (0xB <<  4) // (HDMA_CH) HW Handshaking Interface number 11.
N#define 	AT91C_HDMA_DST_PER_12                   (0xC <<  4) // (HDMA_CH) HW Handshaking Interface number 12.
N#define 	AT91C_HDMA_DST_PER_13                   (0xD <<  4) // (HDMA_CH) HW Handshaking Interface number 13.
N#define 	AT91C_HDMA_DST_PER_14                   (0xE <<  4) // (HDMA_CH) HW Handshaking Interface number 14.
N#define 	AT91C_HDMA_DST_PER_15                   (0xF <<  4) // (HDMA_CH) HW Handshaking Interface number 15.
N#define AT91C_HDMA_SRC_REP    (0x1 <<  8) // (HDMA_CH) Source Replay Mode
N#define 	AT91C_HDMA_SRC_REP_CONTIGUOUS_ADDR      (0x0 <<  8) // (HDMA_CH) When automatic mode is activated, source address is contiguous between two buffers.
N#define 	AT91C_HDMA_SRC_REP_RELOAD_ADDR          (0x1 <<  8) // (HDMA_CH) When automatic mode is activated, the source address and the control register are reloaded from previous transfer..
N#define AT91C_HDMA_SRC_H2SEL  (0x1 <<  9) // (HDMA_CH) Source Handshaking Mode
N#define 	AT91C_HDMA_SRC_H2SEL_SW                   (0x0 <<  9) // (HDMA_CH) Software handshaking interface is used to trigger a transfer request.
N#define 	AT91C_HDMA_SRC_H2SEL_HW                   (0x1 <<  9) // (HDMA_CH) Hardware handshaking interface is used to trigger a transfer request.
N#define AT91C_HDMA_DST_REP    (0x1 << 12) // (HDMA_CH) Destination Replay Mode
N#define 	AT91C_HDMA_DST_REP_CONTIGUOUS_ADDR      (0x0 << 12) // (HDMA_CH) When automatic mode is activated, destination address is contiguous between two buffers.
N#define 	AT91C_HDMA_DST_REP_RELOAD_ADDR          (0x1 << 12) // (HDMA_CH) When automatic mode is activated, the destination address and the control register are reloaded from previous transfer..
N#define AT91C_HDMA_DST_H2SEL  (0x1 << 13) // (HDMA_CH) Destination Handshaking Mode
N#define 	AT91C_HDMA_DST_H2SEL_SW                   (0x0 << 13) // (HDMA_CH) Software handshaking interface is used to trigger a transfer request.
N#define 	AT91C_HDMA_DST_H2SEL_HW                   (0x1 << 13) // (HDMA_CH) Hardware handshaking interface is used to trigger a transfer request.
N#define AT91C_HDMA_SOD        (0x1 << 16) // (HDMA_CH) STOP ON DONE
N#define 	AT91C_HDMA_SOD_DISABLE              (0x0 << 16) // (HDMA_CH) STOP ON DONE disabled, the descriptor fetch operation ignores DONE Field of CTRLA register.
N#define 	AT91C_HDMA_SOD_ENABLE               (0x1 << 16) // (HDMA_CH) STOP ON DONE activated, the DMAC module is automatically disabled if DONE FIELD is set to 1.
N#define AT91C_HDMA_LOCK_IF    (0x1 << 20) // (HDMA_CH) Interface Lock
N#define 	AT91C_HDMA_LOCK_IF_DISABLE              (0x0 << 20) // (HDMA_CH) Interface Lock capability is disabled.
N#define 	AT91C_HDMA_LOCK_IF_ENABLE               (0x1 << 20) // (HDMA_CH) Interface Lock capability is enabled.
N#define AT91C_HDMA_LOCK_B     (0x1 << 21) // (HDMA_CH) AHB Bus Lock
N#define 	AT91C_HDMA_LOCK_B_DISABLE              (0x0 << 21) // (HDMA_CH) AHB Bus Locking capability is disabled.
N#define 	AT91C_HDMA_LOCK_B_ENABLE               (0x1 << 21) // (HDMA_CH) AHB Bus Locking capability is enabled.
N#define AT91C_HDMA_LOCK_IF_L  (0x1 << 22) // (HDMA_CH) Master Interface Arbiter Lock
N#define 	AT91C_HDMA_LOCK_IF_L_CHUNK                (0x0 << 22) // (HDMA_CH) The Master Interface Arbiter is locked by the channel x for a chunk transfer.
N#define 	AT91C_HDMA_LOCK_IF_L_BUFFER               (0x1 << 22) // (HDMA_CH) The Master Interface Arbiter is locked by the channel x for a buffer transfer.
N#define AT91C_HDMA_AHB_PROT   (0x7 << 24) // (HDMA_CH) AHB Prot
N#define AT91C_HDMA_FIFOCFG    (0x3 << 28) // (HDMA_CH) FIFO Request Configuration
N#define 	AT91C_HDMA_FIFOCFG_LARGESTBURST         (0x0 << 28) // (HDMA_CH) The largest defined length AHB burst is performed on the destination AHB interface.
N#define 	AT91C_HDMA_FIFOCFG_HALFFIFO             (0x1 << 28) // (HDMA_CH) When half fifo size is available/filled a source/destination request is serviced.
N#define 	AT91C_HDMA_FIFOCFG_ENOUGHSPACE          (0x2 << 28) // (HDMA_CH) When there is enough space/data available to perfom a single AHB access then the request is serviced.
N
N
Nvoid DMA_Config(U32 flag);
Nvoid DMA_Enable(void);
Nvoid DMA_Disable(void);
Nvoid DMA_EnableIt(U32 flag);
Nvoid DMA_DisableIt(U32 flag);
NU32 DMA_GetStatus(void);
NU32 DMA_GetInterruptMask(void);
NU32 DMA_GetMaskedStatus(void);
Nvoid DMA_EnableChannel(U32 channel);
Nvoid DMA_EnableChannels(U32 bmChannels);
Nvoid DMA_DisableChannel(U32 channel);
Nvoid DMA_DisableChannels(U32 bmChannels);
Nvoid DMA_KeeponChannel(U32 channel);
Nvoid DMA_ClearAutoMode(U32 channel);
NU32 DMA_GetChannelStatus(void);
Nvoid DMA_SetSourceAddr(U8 channel, U32 address);
Nvoid DMA_SetDestinationAddr(U8 channel, U32 address);
Nvoid DMA_SetDescriptorAddr(U8 channel, U32 address);
Nvoid DMA_SetSourceBufferSize(U8 channel, U32 size, U8 sourceWidth, U8 destWidth, U8 done);
Nvoid DMA_SetSourceBufferMode(U8 channel, U8 transferMode, U8 addressingType);
Nvoid DMA_SetDestBufferMode(U8 channel, U8 transferMode, U8 addressingType);
Nvoid DMA_SetConfiguration(U8 channel, U32 value);
Nvoid DMA_SPIPconfiguration(U8 channel, U32 pipHole, U32 pipBoundary);
Nvoid DMA_SetFlowControl(U8 channel, U32 flow);
N
N#endif /* __DMA_H__ */
L 17 "mci.c" 2
N#include "mci.h"
L 1 "mci.h" 1
N/*
N *------------------------------------------------------------------------------
N *
N *------------------------------------------------------------------------------
N */
N
N#ifndef __MCI_H__
N#define __MCI_H__
N
N
N
N
N#define MCI2_INTERFACE
N/// MCI using DMA?
N#define MCI_DMA_ENABLE          1
N/// MCI BUSY Check Fix
N#define MCI_BUSY_CHECK_FIX      0
N/// MCI support SDIO
N#define MCI_SDIO_ENABLE         0
N
N#define MCI_RD_FIFO_LIMIT    1
N
N
N
N
N
N#define SDMMC_DMA_CHANNEL       0
N
N
N
N#define MCI_NEW_TRANSFER		0 /// Start new data transfer
N#define MCI_CONTINUE_TRANSFER	1 /// Continue data transfer
N#define MCI_STOP_TRANSFER		2 /// Stop data transfer
N
N#define MCI_STATUS_PENDING		1 /// Transfer is pending.
N#define MCI_STATUS_ERROR		2 /// Transfer has been aborted because an error occured.
N#define MCI_STATUS_NORESPONSE	3 /// Card did not answer command.
N
N#define MCI_ERROR_LOCK			1 /// MCI driver is currently in use.
N
N#define MCI_SDCBUS_1BIT			(0 << 7) /// MCI SD Bus Width 1-bit
N#define MCI_SDCBUS_4BIT			(1 << 7) /// MCI SD Bus Width 4-bit
N#define MCI_SDCBUS_8BIT			(3 << 6) /// MCI SD Bus Width 8-bit
N
N#define MCI_INTERRUPT_MODE		0
N#define MCI_POLLING_MODE		1
N
N// -------- MCI_CR : (MCI Offset: 0x0) MCI Control Register -------- 
N#define HSMCI_MCIEN				(0x1 <<  0) // (MCI) Multimedia Interface Enable
N#define HSMCI_MCIEN_0			(0x0) // (MCI) No effect
N#define HSMCI_MCIEN_1			(0x1) // (MCI) Enable the MultiMedia Interface if MCIDIS is 0
N#define HSMCI_MCIDIS 			(0x1 <<  1) // (MCI) Multimedia Interface Disable
N#define HSMCI_MCIDIS_0			(0x0 <<  1) // (MCI) No effect
N#define HSMCI_MCIDIS_1 			(0x1 <<  1) // (MCI) Disable the MultiMedia Interface
N#define HSMCI_PWSEN       		(0x1 <<  2) // (MCI) Power Save Mode Enable
N#define HSMCI_PWSEN_0  			(0x0 <<  2) // (MCI) No effect
N#define HSMCI_PWSEN_1			(0x1 <<  2) // (MCI) Enable the Power-saving mode if PWSDIS is 0.
N#define HSMCI_PWSDIS			(0x1 <<  3) // (MCI) Power Save Mode Disable
N#define HSMCI_PWSDIS_0			(0x0 <<  3) // (MCI) No effect
N#define HSMCI_PWSDIS_1			(0x1 <<  3) // (MCI) Disable the Power-saving mode.
N#define HSMCI_IOWAITEN			(0x1 <<  4) // (MCI) SDIO Read Wait Enable
N#define HSMCI_IOWAITEN_0		(0x0 <<  4) // (MCI) No effect
N#define HSMCI_IOWAITEN_1		(0x1 <<  4) // (MCI) Enables the SDIO Read Wait Operation.
N#define HSMCI_IOWAITDIS			(0x1 <<  5) // (MCI) SDIO Read Wait Disable
N#define HSMCI_IOWAITDIS_0		(0x0 <<  5) // (MCI) No effect
N#define HSMCI_IOWAITDIS_1		(0x1 <<  5) // (MCI) Disables the SDIO Read Wait Operation.
N#define HSMCI_SWRST				(0x1 <<  7) // (MCI) MCI Software reset
N#define HSMCI_SWRST_0			(0x0 <<  7) // (MCI) No effect
N#define HSMCI_SWRST_1			(0x1 <<  7) // (MCI) Resets the MCI
N
N// -------- MCI_MR : (MCI Offset: 0x4) MCI Mode Register -------- 
N#define HSMCI_CLKDIV			(0xFF <<  0) // (MCI) Clock Divider
N#define HSMCI_PWSDIV			(0x7 <<  8) // (MCI) Power Saving Divider
N#define HSMCI_RDPROOF			(0x1 << 11) // (MCI) Read Proof Enable
N#define HSMCI_RDPROOF_DISABLE	(0x0 << 11) // (MCI) Disables Read Proof
N#define HSMCI_RDPROOF_ENABLE	(0x1 << 11) // (MCI) Enables Read Proof
N#define HSMCI_WRPROOF			(0x1 << 12) // (MCI) Write Proof Enable
N#define HSMCI_WRPROOF_DISABLE	(0x0 << 12) // (MCI) Disables Write Proof
N#define HSMCI_WRPROOF_ENABLE	(0x1 << 12) // (MCI) Enables Write Proof
N#define HSMCI_PDCFBYTE			(0x1 << 13) // (MCI) PDC Force Byte Transfer
N#define HSMCI_PDCFBYTE_DISABLE	(0x0 << 13) // (MCI) Disables PDC Force Byte Transfer
N#define HSMCI_PDCFBYTE_ENABLE	(0x1 << 13) // (MCI) Enables PDC Force Byte Transfer
N#define HSMCI_PDCPADV			(0x1 << 14) // (MCI) PDC Padding Value
N#define HSMCI_PDCMODE			(0x1 << 15) // (MCI) PDC Oriented Mode
N#define HSMCI_PDCMODE_DISABLE	(0x0 << 15) // (MCI) Disables PDC Transfer
N#define HSMCI_PDCMODE_ENABLE	(0x1 << 15) // (MCI) Enables PDC Transfer
N#define HSMCI_BLKLEN			(0xFFFF0000) //(0xFFFF << 16) // (MCI) Data Block Length
N
N// -------- MCI_DTOR : (MCI Offset: 0x8) MCI Data Timeout Register -------- 
N#define HSMCI_DTOCYC			(0xF <<  0) // (MCI) Data Timeout Cycle Number
N#define HSMCI_DTOMUL			(0x7 <<  4) // (MCI) Data Timeout Multiplier
N#define HSMCI_DTOMUL_1			(0x0 <<  4) // (MCI) DTOCYC x 1
N#define HSMCI_DTOMUL_16			(0x1 <<  4) // (MCI) DTOCYC x 16
N#define HSMCI_DTOMUL_128		(0x2 <<  4) // (MCI) DTOCYC x 128
N#define HSMCI_DTOMUL_256		(0x3 <<  4) // (MCI) DTOCYC x 256
N#define HSMCI_DTOMUL_1024		(0x4 <<  4) // (MCI) DTOCYC x 1024
N#define HSMCI_DTOMUL_4096		(0x5 <<  4) // (MCI) DTOCYC x 4096
N#define HSMCI_DTOMUL_65536		(0x6 <<  4) // (MCI) DTOCYC x 65536
N#define HSMCI_DTOMUL_1048576	(0x7 <<  4) // (MCI) DTOCYC x 1048576
N// -------- MCI_SDCR : (MCI Offset: 0xc) MCI SD Card Register -------- 
N#define HSMCI_SCDSEL			(0x3 <<  0) // (MCI) SD Card/SDIO Selector
N#define HSMCI_SCDSEL_SLOTA		(0x0) // (MCI) Slot A selected
N#define HSMCI_SCDSEL_SLOTB		(0x1) // (MCI) Slot B selected
N#define HSMCI_SCDSEL_SLOTC		(0x2) // (MCI) Slot C selected
N#define HSMCI_SCDSEL_SLOTD		(0x3) // (MCI) Slot D selected
N#define HSMCI_SCDBUS			(0x3 <<  6) // (MCI) SDCard/SDIO Bus Width
N#define HSMCI_SCDBUS_1BIT		(0x0 <<  6) // (MCI) 1-bit data bus
N#define HSMCI_SCDBUS_4BITS		(0x2 <<  6) // (MCI) 4-bits data bus
N#define HSMCI_SCDBUS_8BITS		(0x3 <<  6) // (MCI) 8-bits data bus
N// -------- MCI_CMDR : (MCI Offset: 0x14) MCI Command Register -------- 
N#define HSMCI_CMDNB				(0x3F <<  0) // (MCI) Command Number
N#define HSMCI_RSPTYP			(0x3 <<  6) // (MCI) Response Type
N#define HSMCI_RSPTYP_NO			(0x0 <<  6) // (MCI) No response
N#define HSMCI_RSPTYP_48			(0x1 <<  6) // (MCI) 48-bit response
N#define HSMCI_RSPTYP_136		(0x2 <<  6) // (MCI) 136-bit response
N#define HSMCI_RSPTYP_R1B		(0x3 <<  6) // (MCI) R1b response
N#define HSMCI_SPCMD				(0x7 <<  8) // (MCI) Special CMD
N#define HSMCI_SPCMD_NONE		(0x0 <<  8) // (MCI) Not a special CMD
N#define HSMCI_SPCMD_INIT 		(0x1 <<  8) // (MCI) Initialization CMD
N#define HSMCI_SPCMD_SYNC		(0x2 <<  8) // (MCI) Synchronized CMD
N#define HSMCI_SPCMD_CE_ATA		(0x3 <<  8) // (MCI) CE-ATA Completion Signal disable CMD
N#define HSMCI_SPCMD_IT_CMD		(0x4 <<  8) // (MCI) Interrupt command
N#define HSMCI_SPCMD_IT_REP		(0x5 <<  8) // (MCI) Interrupt response
N#define HSMCI_OPDCMD			(0x1 << 11) // (MCI) Open Drain Command
N#define HSMCI_OPDCMD_PUSHPULL	(0x0 << 11) // (MCI) Push/pull command
N#define HSMCI_OPDCMD_OPENDRAIN	(0x1 << 11) // (MCI) Open drain command
N#define HSMCI_MAXLAT			(0x1 << 12) // (MCI) Maximum Latency for Command to respond
N#define HSMCI_MAXLAT_5			(0x0 << 12) // (MCI) 5 cycles maximum latency
N#define HSMCI_MAXLAT_64			(0x1 << 12) // (MCI) 64 cycles maximum latency
N#define HSMCI_TRCMD				(0x3 << 16) // (MCI) Transfer CMD
N#define HSMCI_TRCMD_NO 			(0x0 << 16) // (MCI) No transfer
N#define HSMCI_TRCMD_START		(0x1 << 16) // (MCI) Start transfer
N#define HSMCI_TRCMD_STOP		(0x2 << 16) // (MCI) Stop transfer
N#define HSMCI_TRDIR				(0x1 << 18) // (MCI) Transfer Direction
N#define HSMCI_TRDIR_WRITE		(0x0 << 18) // (MCI) Write
N#define HSMCI_TRDIR_READ		(0x1 << 18) // (MCI) Read
N#define HSMCI_TRTYP				(0x7 << 19) // (MCI) Transfer Type
N#define HSMCI_TRTYP_BLOCK		(0x0 << 19) // (MCI) MMC/SDCard Single Block Transfer type
N#define HSMCI_TRTYP_MULTIPLE	(0x1 << 19) // (MCI) MMC/SDCard Multiple Block transfer type
N#define HSMCI_TRTYP_STREAM		(0x2 << 19) // (MCI) MMC Stream transfer type
N#define HSMCI_TRTYP_SDIO_BYTE	(0x4 << 19) // (MCI) SDIO Byte transfer type
N#define HSMCI_TRTYP_SDIO_BLOCK	(0x5 << 19) // (MCI) SDIO Block transfer type
N#define HSMCI_IOSPCMD			(0x3 << 24) // (MCI) SDIO Special Command
N#define HSMCI_IOSPCMD_NONE		(0x0 << 24) // (MCI) NOT a special command
N#define HSMCI_IOSPCMD_SUSPEND	(0x1 << 24) // (MCI) SDIO Suspend Command
N#define HSMCI_IOSPCMD_RESUME	(0x2 << 24) // (MCI) SDIO Resume Command
N#define HSMCI_ATACS				(0x1 << 26) // (MCI) ATA with command completion signal
N#define HSMCI_ATACS_NORMAL		(0x0 << 26) // (MCI) normal operation mode
N#define HSMCI_ATACS_COMPLETION	(0x1 << 26) // (MCI) completion signal is expected within MCI_CSTOR
N// -------- MCI_BLKR : (MCI Offset: 0x18) MCI Block Register -------- 
N#define HSMCI_BCNT				(0xFFFF <<  0) // (MCI) MMC/SDIO Block Count / SDIO Byte Count
N// -------- MCI_CSTOR : (MCI Offset: 0x1c) MCI Completion Signal Timeout Register -------- 
N#define HSMCI_CSTOCYC			(0xF <<  0) // (MCI) Completion Signal Timeout Cycle Number
N#define HSMCI_CSTOMUL			(0x7 <<  4) // (MCI) Completion Signal Timeout Multiplier
N#define HSMCI_CSTOMUL_1			(0x0 <<  4) // (MCI) CSTOCYC x 1
N#define HSMCI_CSTOMUL_16		(0x1 <<  4) // (MCI) CSTOCYC x  16
N#define HSMCI_CSTOMUL_128		(0x2 <<  4) // (MCI) CSTOCYC x  128
N#define HSMCI_CSTOMUL_256		(0x3 <<  4) // (MCI) CSTOCYC x  256
N#define HSMCI_CSTOMUL_1024		(0x4 <<  4) // (MCI) CSTOCYC x  1024
N#define HSMCI_CSTOMUL_4096		(0x5 <<  4) // (MCI) CSTOCYC x  4096
N#define HSMCI_CSTOMUL_65536		(0x6 <<  4) // (MCI) CSTOCYC x  65536
N#define HSMCI_CSTOMUL_1048576	(0x7 <<  4) // (MCI) CSTOCYC x  1048576
N// -------- MCI_SR : (MCI Offset: 0x40) MCI Status Register -------- 
N#define HSMCI_CMDRDY			(0x1 <<  0) // (MCI) Command Ready flag
N#define HSMCI_RXRDY       		(0x1 <<  1) // (MCI) RX Ready flag
N#define HSMCI_TXRDY       		(0x1 <<  2) // (MCI) TX Ready flag
N#define HSMCI_BLKE        		(0x1 <<  3) // (MCI) Data Block Transfer Ended flag
N#define HSMCI_DTIP        		(0x1 <<  4) // (MCI) Data Transfer in Progress flag
N#define HSMCI_NOTBUSY     		(0x1 <<  5) // (MCI) Data Line Not Busy flag
N#define HSMCI_ENDRX       		(0x1 <<  6) // (MCI) End of RX Buffer flag
N#define HSMCI_ENDTX       		(0x1 <<  7) // (MCI) End of TX Buffer flag
N#define HSMCI_SDIOIRQA    		(0x1 <<  8) // (MCI) SDIO Interrupt for Slot A
N#define HSMCI_SDIOIRQB    		(0x1 <<  9) // (MCI) SDIO Interrupt for Slot B
N#define HSMCI_SDIOIRQC    		(0x1 << 10) // (MCI) SDIO Interrupt for Slot C
N#define HSMCI_SDIOIRQD    		(0x1 << 11) // (MCI) SDIO Interrupt for Slot D
N#define HSMCI_SDIOWAIT    		(0x1 << 12) // (MCI) SDIO Read Wait operation flag
N#define HSMCI_CSRCV       		(0x1 << 13) // (MCI) CE-ATA Completion Signal flag
N#define HSMCI_RXBUFF      		(0x1 << 14) // (MCI) RX Buffer Full flag
N#define HSMCI_TXBUFE      		(0x1 << 15) // (MCI) TX Buffer Empty flag
N#define HSMCI_RINDE       		(0x1 << 16) // (MCI) Response Index Error flag
N#define HSMCI_RDIRE       		(0x1 << 17) // (MCI) Response Direction Error flag
N#define HSMCI_RCRCE       		(0x1 << 18) // (MCI) Response CRC Error flag
N#define HSMCI_RENDE       		(0x1 << 19) // (MCI) Response End Bit Error flag
N#define HSMCI_RTOE        		(0x1 << 20) // (MCI) Response Time-out Error flag
N#define HSMCI_DCRCE       		(0x1 << 21) // (MCI) data CRC Error flag
N#define HSMCI_DTOE        		(0x1 << 22) // (MCI) Data timeout Error flag
N#define HSMCI_CSTOE       		(0x1 << 23) // (MCI) Completion Signal timeout Error flag
N#define HSMCI_BLKOVRE     		(0x1 << 24) // (MCI) DMA Block Overrun Error flag
N#define HSMCI_DMADONE     		(0x1 << 25) // (MCI) DMA Transfer Done flag
N#define HSMCI_FIFOEMPTY   		(0x1 << 26) // (MCI) FIFO Empty flag
N#define HSMCI_XFRDONE     		(0x1 << 27) // (MCI) Transfer Done flag
N#define HSMCI_OVRE        		(0x1 << 30) // (MCI) Overrun flag
N#define HSMCI_UNRE        		(0x80000000) // (0x1 << 31) // (MCI) Underrun flag
N// -------- MCI_IER : (MCI Offset: 0x44) MCI Interrupt Enable Register -------- 
N// -------- MCI_IDR : (MCI Offset: 0x48) MCI Interrupt Disable Register -------- 
N// -------- MCI_IMR : (MCI Offset: 0x4c) MCI Interrupt Mask Register -------- 
N// -------- MCI_DMA : (MCI Offset: 0x50) MCI DMA Configuration Register -------- 
N#define HSMCI_OFFSET			(0x3 <<  0) // (MCI) DMA Write Buffer Offset
N#define HSMCI_CHKSIZE			(0x7 <<  4) // (MCI) DMA Channel Read/Write Chunk Size
N#define HSMCI_CHKSIZE_1			(0x0 <<  4) // (MCI) Number of data transferred is 1
N#define HSMCI_CHKSIZE_4			(0x1 <<  4) // (MCI) Number of data transferred is 4
N#define HSMCI_CHKSIZE_8			(0x2 <<  4) // (MCI) Number of data transferred is 8
N#define HSMCI_CHKSIZE_16		(0x3 <<  4) // (MCI) Number of data transferred is 16
N#define HSMCI_CHKSIZE_32		(0x4 <<  4) // (MCI) Number of data transferred is 32
N#define HSMCI_DMAEN				(0x1 <<  8) // (MCI) DMA Hardware Handshaking Enable
N#define HSMCI_DMAEN_DISABLE		(0x0 <<  8) // (MCI) DMA interface is disabled
N#define HSMCI_DMAEN_ENABLE		(0x1 <<  8) // (MCI) DMA interface is enabled
N// -------- MCI_CFG : (MCI Offset: 0x54) MCI Configuration Register -------- 
N#define HSMCI_FIFOMODE				(0x1 <<  0) // (MCI) MCI Internal FIFO Control Mode
N#define HSMCI_FIFOMODE_AMOUNTDATA	(0x0) // (MCI) A write transfer starts when a sufficient amount of datas is written into the FIFO
N#define HSMCI_FIFOMODE_ONEDATA		(0x1) // (MCI) A write transfer starts as soon as one data is written into the FIFO
N#define HSMCI_FERRCTRL				(0x1 <<  4) // (MCI) Flow Error Flag Reset Control Mode
N#define HSMCI_FERRCTRL_RWCMD		(0x0 <<  4) // (MCI) When an underflow/overflow condition flag is set, a new Write/Read command is needed to reset the flag
N#define HSMCI_FERRCTRL_READSR		(0x1 <<  4) // (MCI) When an underflow/overflow condition flag is set, a read status resets the flag
N#define HSMCI_HSMODE				(0x1 <<  8) // (MCI) High Speed Mode
N#define HSMCI_HSMODE_DISABLE		(0x0 <<  8) // (MCI) Default Bus Timing Mode
N#define HSMCI_HSMODE_ENABLE			(0x1 <<  8) // (MCI) High Speed Mode
N#define HSMCI_LSYNC					(0x1 << 12) // (MCI) Synchronize on last block
N#define HSMCI_LSYNC_CURRENT			(0x0 << 12) // (MCI) Pending command sent at end of current data block
N#define HSMCI_LSYNC_INFINITE		(0x1 << 12) // (MCI) Pending command sent at end of block transfer when transfer length is not infinite
N// -------- MCI_WPCR : (MCI Offset: 0xe4) Write Protection Control Register -------- 
N#define HSMCI_WP_EN				(0x1 <<  0) // (MCI) Write Protection Enable
N#define HSMCI_WP_EN_DISABLE		(0x0) // (MCI) Write Operation is disabled (if WP_KEY corresponds)
N#define HSMCI_WP_EN_ENABLE		(0x1) // (MCI) Write Operation is enabled (if WP_KEY corresponds)
N#define HSMCI_WP_KEY			(0xFFFFFF <<  8) // (MCI) Write Protection Key
N// -------- MCI_WPSR : (MCI Offset: 0xe8) Write Protection Status Register -------- 
N#define HSMCI_WP_VS					(0xF <<  0) // (MCI) Write Protection Violation Status
N#define HSMCI_WP_VS_NO_VIOLATION	(0x0) // (MCI) No Write Protection Violation detected since last read
N#define HSMCI_WP_VS_ON_WRITE		(0x1) // (MCI) Write Protection Violation detected since last read
N#define HSMCI_WP_VS_ON_RESET		(0x2) // (MCI) Software Reset Violation detected since last read
N#define HSMCI_WP_VS_ON_BOTH			(0x3) // (MCI) Write Protection and Software Reset Violation detected since last read
N#define HSMCI_WP_VSRC				(0xF <<  8) // (MCI) Write Protection Violation Source
N#define HSMCI_WP_VSRC_NO_VIOLATION	(0x0 <<  8) // (MCI) No Write Protection Violation detected since last read
N#define HSMCI_WP_VSRC_MCI_MR		(0x1 <<  8) // (MCI) Write Protection Violation detected on MCI_MR since last read
N#define HSMCI_WP_VSRC_MCI_DTOR		(0x2 <<  8) // (MCI) Write Protection Violation detected on MCI_DTOR since last read
N#define HSMCI_WP_VSRC_MCI_SDCR		(0x3 <<  8) // (MCI) Write Protection Violation detected on MCI_SDCR since last read
N#define HSMCI_WP_VSRC_MCI_CSTOR		(0x4 <<  8) // (MCI) Write Protection Violation detected on MCI_CSTOR since last read
N#define HSMCI_WP_VSRC_MCI_DMA		(0x5 <<  8) // (MCI) Write Protection Violation detected on MCI_DMA since last read
N#define HSMCI_WP_VSRC_MCI_CFG		(0x6 <<  8) // (MCI) Write Protection Violation detected on MCI_CFG since last read
N#define HSMCI_WP_VSRC_MCI_DEL		(0x7 <<  8) // (MCI) Write Protection Violation detected on MCI_DEL since last read
N// -------- MCI_VER : (MCI Offset: 0xfc)  VERSION  Register -------- 
N#define HSMCI_VER				(0xF <<  0) // (MCI)  VERSION  Register
N
N//------------------------------------------------------------------------------
N//         Types
N//------------------------------------------------------------------------------
N
N/// MCI end-of-transfer callback function.
Ntypedef void (*MciCallback)(U8 status, void *pCommand);
N
N//------------------------------------------------------------------------------
N/// MCI Transfer Request prepared by the application upper layer. This structure
N/// is sent to the MCI_SendCommand function to start the transfer. At the end of
N/// the transfer, the callback is invoked by the interrupt handler.
N//------------------------------------------------------------------------------
Ntypedef struct _MciCmd {
N
N    /// Command code.
N    U32 cmd;
N    /// Command argument.
N    U32 arg;
N    /// Data buffer, with MCI_DMA_ENABLE defined 1, the buffer can be
N    /// 1, 2 or 4 bytes aligned. It has to be 4 byte aligned if no DMA.
N    U8 *pData;
N    /// Size of data block in bytes.
N    U16 blockSize;
N    /// Number of blocks to be transfered
N    U16 nbBlock;
N    /// Response buffer.
N    U32  *pResp;
N    /// Optional user-provided callback function.
N    MciCallback callback;
N    /// Optional argument to the callback function.
N    void *pArg;
N    /// SD card response type.
N    U8  resType;
N    /// Indicate if there is data transfer
N    U8 dataTran;
N    /// Indicate if continue to transfer data
N    U8 tranType;
N    /// Indicates if the command is a read operation.
N    U8 isRead;
N    /// Command status.
N    volatile S32 status;
N	
N} MciCmd;
N
N//------------------------------------------------------------------------------
N/// MCI driver structure. Holds the internal state of the MCI driver and
N/// prevents parallel access to a MCI peripheral.
N//------------------------------------------------------------------------------
Ntypedef struct {
N
N	/// channel number.
N	U8 mciChan;
N    /// Pointer to currently executing command.
N    MciCmd *pCommand;
N    /// MCI peripheral identifier.
N    U8 mciId;
N    /// MCI HW mode
N    U8 mciMode;
N    /// Mutex.
N    volatile S8 semaphore;
N    /// interrupt or polling mode
N    U32 bPolling;
N	
N} Mci;
N
N
Nvoid MCI_DrvInit(Mci *pMci, U8 ch, U32 bPolling);
NU8 MCI_SendCommand(Mci *pMci, MciCmd *pCommand);
NU8 MCI_IsTxComplete(Mci *pMci);
NU32 MCI_GetSpeed(Mci *pMci, U32 *mciDiv);
NU32 MCI_SetSpeed(Mci *pMci, U32 mciSpeed, U32 mciLimit, U32 mck);
Nvoid MCI_EnableHsMode(Mci *pMci, U8 hsEnable);
Nvoid MCI_SetBusWidth(Mci *pMci, U8 busWidth);
Nvoid MCI_Close(Mci *pMci);
N
Nvoid MCI_Handler(Mci *pMci);
Nvoid MCI_Reset(U8 ch, U32 keepSettings);
N
N#endif /* __MCI_H__ */
L 18 "mci.c" 2
N
Nstatic void AT91F_Prepare_Multiple_Transfer(U32 Channel, U32 LLI_rownumber, U32 LLI_Last_Row, U32 From_add, U32 To_add, U32 Ctrla, U32 Ctrlb);
Nstatic U32 DMACH_MCI_M2P(U32 channel_index, U8* src_addr, U32 dest_addr, U32 trans_size, U8 addrIncMode, U8 forceByte);
Nstatic U32 DMACH_MCI_P2M(U32 channel_index, U32 src_addr, U8* dest_addr, U32 trans_size, U8  addrIncMode, U8 forceByte);
Nstatic void DMACH_EnableIt(U8 ch, U32 channel);
N
N/// Return word count from byte count
N#define toHWCOUNT(byteCnt) (((byteCnt)&0x1) ? (((byteCnt)/2)+1) : ((byteCnt)/2))
N#define toWCOUNT(byteCnt)  (((byteCnt)&0x3) ? (((byteCnt)/4)+1) : ((byteCnt)/4))
N
N/// Bit mask for status register errors.
N#define STATUS_ERRORS ((U32)(HSMCI_UNRE  \
N                       | HSMCI_OVRE \
N                       | HSMCI_BLKOVRE \
N                       | HSMCI_CSTOE \
N                       | HSMCI_DTOE \
N                       | HSMCI_DCRCE \
N                       | HSMCI_RTOE \
N                       | HSMCI_RENDE \
N                       | HSMCI_RCRCE \
N                       | HSMCI_RDIRE \
N                       | HSMCI_RINDE))
X#define STATUS_ERRORS ((U32)(HSMCI_UNRE                         | HSMCI_OVRE                        | HSMCI_BLKOVRE                        | HSMCI_CSTOE                        | HSMCI_DTOE                        | HSMCI_DCRCE                        | HSMCI_RTOE                        | HSMCI_RENDE                        | HSMCI_RCRCE                        | HSMCI_RDIRE                        | HSMCI_RINDE))
N					   
N#define MCI_RD_FIFO_LIMIT	1
N#define MCI_FIFO_SIZE		(0x4000-0x400)     // 15.5K
N#define DMA_XFR_SIZE		(0xF00)    // SAM3: 0xFFF, 9M10: 0xFFFF
N#define NUM_LLI				(5)
N#define DMA_TOTAL			(DMA_XFR_SIZE*NUM_LLI)
N#define LAST_ROW			0x100
N
Nstatic U16 xfredBlocks = 0xFFFF;
Nstatic U8  dmaLastLliNdx = 0;
Nstatic DmaLinkList  LLI_MCI [NUM_LLI];   // Max: > 64K Bytes
Xstatic DmaLinkList  LLI_MCI [(5)];   
N
N
N
Nvoid MCI_DrvInit(Mci *pMci, U8 ch, U32 bPolling)
N{
N	U32 mciId;
N
N	if(ch == 0) mciId = PERIF_ID_MCI0;
X	if(ch == 0) mciId = (11);
N	else mciId = PERIF_ID_MCI1;
X	else mciId = (29);
N	
N    // Initialize the MCI driver structure
N	pMci->mciChan   = ch;
N	pMci->mciId     = (U8)mciId;
N	pMci->mciMode   = (0x0) | (0x2 << 6);
N	pMci->bPolling  = bPolling;
N	pMci->semaphore = 1;
N	pMci->pCommand  = 0;
N
N	PMC_PeriEn(mciId);
N	rHSMCI_CR(ch)	= (1 << 7);
X	(*(volatile U32 *)(0xFFF80000+ch*50000+0x00))	= (1 << 7);
N	rHSMCI_CR(ch)	= (1 << 1) | (1 << 3);
X	(*(volatile U32 *)(0xFFF80000+ch*50000+0x00))	= (1 << 1) | (1 << 3);
N	rHSMCI_IDR(ch)	= 0xFFFFFFFF;
X	(*(volatile U32 *)(0xFFF80000+ch*50000+0x48))	= 0xFFFFFFFF;
N	rHSMCI_DTOR(ch)	= (0xF << 0) | (0x7 << 4);
X	(*(volatile U32 *)(0xFFF80000+ch*50000+0x08))	= (0xF << 0) | (0x7 << 4);
N	rHSMCI_MR(ch)	= 0x000007A5; //(((((unsigned long)((12000000 / 3 / 2 / 3) * 200 )) / (400000 * 2)) - 1) | ((0x7 <<  8) & (0x7 << 8)));
X	(*(volatile U32 *)(0xFFF80000+ch*50000+0x04))	= 0x000007A5; 
N	rHSMCI_SDCR(ch)	= (0x0) | (0x2 << 6);
X	(*(volatile U32 *)(0xFFF80000+ch*50000+0x0C))	= (0x0) | (0x2 << 6);
N	rHSMCI_CR(ch)	= (0x1 << 0);
X	(*(volatile U32 *)(0xFFF80000+ch*50000+0x00))	= (0x1 << 0);
N	rHSMCI_DMA(ch)	= (0x0 << 8);
X	(*(volatile U32 *)(0xFFF80000+ch*50000+0x50))	= (0x0 << 8);
N	rHSMCI_CFG(ch)	= (0x0) | (0x0 << 4);
X	(*(volatile U32 *)(0xFFF80000+ch*50000+0x54))	= (0x0) | (0x0 << 4);
N	PMC_PeriDis(mciId);
N}
N
N//------------------------------------------------------------------------------
N/// Starts a MCI  transfer. This is a non blocking function. It will return
N/// as soon as the transfer is started.
N/// Return 0 if successful; otherwise returns MCI_ERROR_LOCK if the driver is
N/// already in use.
N/// \param pMci  Pointer to an MCI driver instance.
N/// \param pCommand  Pointer to the command to execute.
N//------------------------------------------------------------------------------
NU8 
NMCI_SendCommand(Mci *pMci, MciCmd *pCommand)
N{
N	U8 ch = pMci-> mciChan;
N	U32 mciIer, mciMr;
N	U32 transSize = 0x7100F0BC;
N	U32 mciBlkr = 0x7100F014;
N	U32 mciDma = 0x7100F014;
N
N	// Try to acquire the MCI semaphore
N	if (pMci->semaphore == 0) return MCI_ERROR_LOCK;
X	if (pMci->semaphore == 0) return 1;
N	pMci->semaphore--;
N
N	// Command is now being executed
N	pMci->pCommand = pCommand;
N	pCommand->status = MCI_STATUS_PENDING;
X	pCommand->status = 1;
N
N	// Enable the MCI peripheral clock
N	if(ch == 0) PMC_PeriEn(PERIF_ID_MCI0);
X	if(ch == 0) PMC_PeriEn((11));
N	else PMC_PeriEn(PERIF_ID_MCI1);
X	else PMC_PeriEn((29));
N
N	// Set Default Mode register value
N	mciMr = rHSMCI_MR(ch) & (~(HSMCI_WRPROOF|HSMCI_RDPROOF|HSMCI_BLKLEN));
X	mciMr = (*(volatile U32 *)(0xFFF80000+ch*50000+0x04)) & (~((0x1 << 12)|(0x1 << 11)|(0xFFFF0000)));
N	
N	//TRACE_MSG("mciDma: 0x%08X", mciDma);
N	//TRACE_MSG("transSize: 0x%08X", transSize);
N	
N	// Command with DATA stage
N	if (pCommand->blockSize && pCommand->nbBlock)
N	{
N		// Enable dma		
N		mciDma = rHSMCI_DMA(ch) | HSMCI_DMAEN_ENABLE;
X		mciDma = (*(volatile U32 *)(0xFFF80000+ch*50000+0x50)) | (0x1 << 8);
N		rHSMCI_DMA(ch) = mciDma;
X		(*(volatile U32 *)(0xFFF80000+ch*50000+0x50)) = mciDma;
N		transSize = (pCommand->nbBlock * pCommand->blockSize);
N		
N		//TRACE_MSG("data mciDma: 0x%08X", mciDma);
N		//TRACE_MSG("data transSize: 0x%08X", transSize);
N		
N		if (pCommand->isRead)
N		{
N			if (transSize > MCI_FIFO_SIZE)
X			if (transSize > (0x4000-0x400))
N			{
N				xfredBlocks = MCI_FIFO_SIZE/pCommand->blockSize;
X				xfredBlocks = (0x4000-0x400)/pCommand->blockSize;
N				transSize = MCI_FIFO_SIZE;
X				transSize = (0x4000-0x400);
N			}
N			else
N			{
N				xfredBlocks = pCommand->nbBlock;
N			}
N		}
N		else
N		{
N			xfredBlocks = pCommand->nbBlock;
N		}
N
N		if ((pCommand->blockSize & 0x3) != 0)
N		{
N			// Force byte, DataReg & DMA should be BYTE based
N			mciMr |= HSMCI_PDCFBYTE;
X			mciMr |= (0x1 << 13);
N		}
N 		else transSize = toWCOUNT(transSize);
X 		else transSize = (((transSize)&0x3) ? (((transSize)/4)+1) : ((transSize)/4));
N
N		// New transfer
N		if(pCommand->tranType == MCI_NEW_TRANSFER)
X		if(pCommand->tranType == 0)
N		{
N			// Set block size
N			rHSMCI_MR(ch) = mciMr | HSMCI_RDPROOF | HSMCI_WRPROOF |(pCommand->blockSize << 16);
X			(*(volatile U32 *)(0xFFF80000+ch*50000+0x04)) = mciMr | (0x1 << 11) | (0x1 << 12) |(pCommand->blockSize << 16);
N			mciBlkr = rHSMCI_BLKR(ch) & (~(U32)HSMCI_BCNT);
X			mciBlkr = (*(volatile U32 *)(0xFFF80000+ch*50000+0x18)) & (~(U32)(0xFFFF << 0));
N			rHSMCI_BLKR(ch) = mciBlkr | (transSize/pCommand->blockSize);
X			(*(volatile U32 *)(0xFFF80000+ch*50000+0x18)) = mciBlkr | (transSize/pCommand->blockSize);
N		}
N
N		// DATA transfer from card to host
N		if (pCommand->isRead)
N		{
N			DMACH_MCI_P2M(SDMMC_DMA_CHANNEL, HSMCI_FIFO(ch), (U8*) pCommand->pData, transSize, 0, (mciMr & HSMCI_PDCFBYTE) > 0);
X			DMACH_MCI_P2M(0, (0xFFF80000+ch*50000+0x200), (U8*) pCommand->pData, transSize, 0, (mciMr & (0x1 << 13)) > 0);
N			DMACH_EnableIt(ch, SDMMC_DMA_CHANNEL);
X			DMACH_EnableIt(ch, 0);
N			DMA_EnableChannel(0);
N			mciIer = HSMCI_DMADONE | STATUS_ERRORS;
X			mciIer = (0x1 << 25) | ((U32)((0x80000000) | (0x1 << 30) | (0x1 << 24) | (0x1 << 23) | (0x1 << 22) | (0x1 << 21) | (0x1 << 20) | (0x1 << 19) | (0x1 << 18) | (0x1 << 17) | (0x1 << 16)));
N		}
N		// DATA transfer from host to card
N		else
N		{
N			if ((mciMr & HSMCI_PDCFBYTE) > 0) DMACH_MCI_M2P(SDMMC_DMA_CHANNEL, (U8*) pCommand->pData, HSMCI_FIFO(ch), toWCOUNT(transSize), 0, 0); // Still using WORD mode to write FIFO
X			if ((mciMr & (0x1 << 13)) > 0) DMACH_MCI_M2P(0, (U8*) pCommand->pData, (0xFFF80000+ch*50000+0x200), (((transSize)&0x3) ? (((transSize)/4)+1) : ((transSize)/4)), 0, 0); 
N			else DMACH_MCI_M2P(SDMMC_DMA_CHANNEL, (U8*) pCommand->pData, HSMCI_FIFO(ch), transSize, 0, 0);
X			else DMACH_MCI_M2P(0, (U8*) pCommand->pData, (0xFFF80000+ch*50000+0x200), transSize, 0, 0);
N			DMACH_EnableIt(ch, SDMMC_DMA_CHANNEL);
X			DMACH_EnableIt(ch, 0);
N			DMA_EnableChannel(SDMMC_DMA_CHANNEL);
X			DMA_EnableChannel(0);
N			mciIer = HSMCI_DMADONE | STATUS_ERRORS;
X			mciIer = (0x1 << 25) | ((U32)((0x80000000) | (0x1 << 30) | (0x1 << 24) | (0x1 << 23) | (0x1 << 22) | (0x1 << 21) | (0x1 << 20) | (0x1 << 19) | (0x1 << 18) | (0x1 << 17) | (0x1 << 16)));
N		}
N	}
N	// Start an infinite block transfer (but no data in current command)
N	else if (pCommand->dataTran)
N	{
N		// Set block size
N		rHSMCI_MR(ch) = mciMr | HSMCI_RDPROOF | HSMCI_WRPROOF |(pCommand->blockSize << 16);
X		(*(volatile U32 *)(0xFFF80000+ch*50000+0x04)) = mciMr | (0x1 << 11) | (0x1 << 12) |(pCommand->blockSize << 16);
N		// Set data length: 0
N		mciBlkr = rHSMCI_BLKR(ch) & (~(U32)HSMCI_BCNT);
X		mciBlkr = (*(volatile U32 *)(0xFFF80000+ch*50000+0x18)) & (~(U32)(0xFFFF << 0));
N		rHSMCI_BLKR(ch) = mciBlkr;
X		(*(volatile U32 *)(0xFFF80000+ch*50000+0x18)) = mciBlkr;
N		mciIer = HSMCI_CMDRDY | STATUS_ERRORS;
X		mciIer = (0x1 << 0) | ((U32)((0x80000000) | (0x1 << 30) | (0x1 << 24) | (0x1 << 23) | (0x1 << 22) | (0x1 << 21) | (0x1 << 20) | (0x1 << 19) | (0x1 << 18) | (0x1 << 17) | (0x1 << 16)));
N		
N		//TRACE_MSG("dataTran mciIer: 0x%08X", mciIer);
N		//TRACE_MSG("dataTran mciBlkr: 0x%08X", mciBlkr);
N	}
N	// No data transfer: stop at the end of the command
N	else
N	{
N		rHSMCI_MR(ch) = mciMr;
X		(*(volatile U32 *)(0xFFF80000+ch*50000+0x04)) = mciMr;
N		mciIer = HSMCI_CMDRDY | STATUS_ERRORS;
X		mciIer = (0x1 << 0) | ((U32)((0x80000000) | (0x1 << 30) | (0x1 << 24) | (0x1 << 23) | (0x1 << 22) | (0x1 << 21) | (0x1 << 20) | (0x1 << 19) | (0x1 << 18) | (0x1 << 17) | (0x1 << 16)));
N		//TRACE_MSG("else mciMr: 0x%08X", mciMr);
N	}
N
N	// Enable MCI
N	rHSMCI_CR(ch) = HSMCI_MCIEN;
X	(*(volatile U32 *)(0xFFF80000+ch*50000+0x00)) = (0x1 << 0);
N
N
N	// Send the command
N	if((pCommand->tranType != MCI_CONTINUE_TRANSFER) || (pCommand->blockSize == 0))
X	if((pCommand->tranType != 1) || (pCommand->blockSize == 0))
N	{
N		rHSMCI_ARGR(ch) = pCommand->arg;
X		(*(volatile U32 *)(0xFFF80000+ch*50000+0x10)) = pCommand->arg;
N		rHSMCI_CMDR(ch) = pCommand->cmd;
X		(*(volatile U32 *)(0xFFF80000+ch*50000+0x14)) = pCommand->cmd;
N		//TRACE_MSG("pCommand->cmd: 0x%08X", pCommand->cmd);
N		//TRACE_MSG("pCommand->cmd: 0x%08X", rHSMCI_CMDR(ch));
N	}
N
N	// Ignore CRC error for R3 & R4
N	if (pCommand->resType == 3 || pCommand->resType == 4) mciIer &= ~((U32)HSMCI_RCRCE);
X	if (pCommand->resType == 3 || pCommand->resType == 4) mciIer &= ~((U32)(0x1 << 18));
N	
N	// Ignore errors for stop command :)
N	if (pCommand->tranType == MCI_STOP_TRANSFER) mciIer &= ~((U32)(HSMCI_DCRCE|HSMCI_BLKOVRE|HSMCI_DTOE|HSMCI_CSTOE));
X	if (pCommand->tranType == 2) mciIer &= ~((U32)((0x1 << 21)|(0x1 << 24)|(0x1 << 22)|(0x1 << 23)));
N
N	// Ignore data error
N	mciIer &= ~( 0 | HSMCI_UNRE | HSMCI_OVRE | HSMCI_DTOE | HSMCI_DCRCE | HSMCI_BLKOVRE | HSMCI_CSTOE );
X	mciIer &= ~( 0 | (0x80000000) | (0x1 << 30) | (0x1 << 22) | (0x1 << 21) | (0x1 << 24) | (0x1 << 23) );
N
N	// Interrupt enable shall be done after PDC TXTEN and RXTEN
N	rHSMCI_IER(ch) = mciIer;
X	(*(volatile U32 *)(0xFFF80000+ch*50000+0x44)) = mciIer;
N
N	TRACE_WRN("MCI_SendCommand(): ch: 0x%08X, mciIer: 0x%08X, mciMr: 0x%08X, transSize: 0x%08X, mciBlkr: 0x%08X, mciDma: 0x%08X", ch, mciIer, mciMr, transSize, mciBlkr, mciDma);
X	{ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("MCI_SendCommand(): ch: 0x%08X, mciIer: 0x%08X, mciMr: 0x%08X, transSize: 0x%08X, mciBlkr: 0x%08X, mciDma: 0x%08X", ch, mciIer, mciMr, transSize, mciBlkr, mciDma); ShellPrintf("\n\r");};
N
N	
N	return 0;
N}
N
N//------------------------------------------------------------------------------
N/// Returns 1 if the given MCI transfer is complete; otherwise returns 0.
N/// \param pCommand  Pointer to a MciCmd instance.
N//------------------------------------------------------------------------------
NU8 MCI_IsTxComplete(Mci *pMci)
N{
N    MciCmd *pCommand = pMci->pCommand;		
N	
N    if(pMci->bPolling == MCI_POLLING_MODE) {
X    if(pMci->bPolling == 1) {
N        MCI_Handler(pMci);
N    }
N  
N    if (pCommand->status != MCI_STATUS_PENDING) {
X    if (pCommand->status != 1) {
N        if (pCommand->status != 0) {
N            DEBUG_MSG("MCI_IsTxComplete %d", pCommand->status);
X            { };
N        }
N        return 1;
N    }
N    else {
N        return 0;
N    }
N}
N
N//------------------------------------------------------------------------------
N/// Get the  MCI CLKDIV in the MCI_MR register. The max. for MCI clock is
N/// MCK/2 and corresponds to CLKDIV = 0
N/// \param pMci  Pointer to the low level MCI driver.
N/// \param mciSpeed  MCI clock speed in Hz.
N//------------------------------------------------------------------------------
NU32 MCI_GetSpeed(Mci *pMci, U32 *mciDiv)
N{
N	U8 ch = pMci-> mciChan;
N    U32 mciMr;
N
N    // Get the Mode Register
N	
N    mciMr  = rHSMCI_MR(ch);
X    mciMr  = (*(volatile U32 *)(0xFFF80000+ch*50000+0x04));
N    mciMr &= HSMCI_CLKDIV;
X    mciMr &= (0xFF << 0);
N    if (mciDiv) *mciDiv = mciMr;
N    return (BOARD_MCK / 2 / (mciMr + 1));
X    return (((unsigned long)((12000000 / 3 / 2 / 3) * 200 )) / 2 / (mciMr + 1));
N}
N
N//------------------------------------------------------------------------------
N/// Configure the  MCI CLKDIV in the MCI_MR register. The max. for MCI clock is
N/// MCK/2 and corresponds to CLKDIV = 0
N/// \param pMci  Pointer to the low level MCI driver.
N/// \param mciSpeed  MCI clock speed in Hz.
N/// \param mciLimit  MCI clock limit in Hz, if not limit, set mciLimit to zero.
N/// \param mck       MCK to generate MCI Clock, in Hz
N/// \return The actual speed used, 0 for fail.
N//------------------------------------------------------------------------------
NU32 MCI_SetSpeed(Mci *pMci, U32 mciSpeed, U32 mciLimit, U32 mck)
N{
N	U8 ch = pMci-> mciChan;
N    U32 mciMr;
N    U32 clkdiv;
N    U32 divLimit = 0;
N
N    mciMr = rHSMCI_MR(ch) & (~(U32)HSMCI_CLKDIV);
X    mciMr = (*(volatile U32 *)(0xFFF80000+ch*50000+0x04)) & (~(U32)(0xFF << 0));
N
N    // Multimedia Card Interface clock (MCCK or MCI_CK) is Master Clock (MCK)
N    // divided by (2*(CLKDIV+1))
N    // mciSpeed = MCK / (2*(CLKDIV+1))
N    if (mciLimit) {
N        divLimit = (mck / 2 / mciLimit);
N        if ((mck / 2) % mciLimit) divLimit ++;
N    }
N    if (mciSpeed > 0) {
N        clkdiv = (mck / 2 / mciSpeed);
N        if (mciLimit && clkdiv < divLimit)
N            clkdiv = divLimit;
N        if (clkdiv > 0) 
N            clkdiv -= 1;
N    }
N    else    clkdiv = 0;
N
N    // Actual MCI speed
N    mciSpeed = mck / 2 / (clkdiv + 1);
N
N    // Set the Data Timeout Register & Completion Timeout
N    // Data timeout is 500ms, completion timeout 1s.
N    //MCI_SetTimeout(pMciHw, mciSpeed / 2, mciSpeed);
N
N	rHSMCI_MR(ch) = (mciMr | clkdiv);
X	(*(volatile U32 *)(0xFFF80000+ch*50000+0x04)) = (mciMr | clkdiv);
N
N    return (mciSpeed);
N}
N
N//------------------------------------------------------------------------------
N/// Configure the MCI_CFG to enable the HS mode
N/// \param pMci     Pointer to the low level MCI driver.
N/// \param hsEnable 1 to enable, 0 to disable HS mode.
N//------------------------------------------------------------------------------
Nvoid MCI_EnableHsMode(Mci *pMci, U8 hsEnable)
N{
N	U8 ch = pMci-> mciChan;
N    U32 cfgr;
N
N    cfgr = rHSMCI_CFG(ch);
X    cfgr = (*(volatile U32 *)(0xFFF80000+ch*50000+0x54));
N
N    if (hsEnable)   cfgr |=  HSMCI_HSMODE_ENABLE;
X    if (hsEnable)   cfgr |=  (0x1 << 8);
N    else            cfgr &= ~(U32)HSMCI_HSMODE_ENABLE;
X    else            cfgr &= ~(U32)(0x1 << 8);
N	
N	rHSMCI_CFG(ch) = cfgr;
X	(*(volatile U32 *)(0xFFF80000+ch*50000+0x54)) = cfgr;
N}
N
N//------------------------------------------------------------------------------
N/// Configure the  MCI SDCBUS in the MCI_SDCR register. Only two modes available
N///
N/// \param pMci  Pointer to the low level MCI driver.
N/// \param busWidth  MCI bus width mode.
N//------------------------------------------------------------------------------
Nvoid MCI_SetBusWidth(Mci *pMci, U8 busWidth)
N{
N	U8 ch = pMci-> mciChan;
N    U32 mciSdcr;
N
N    mciSdcr = (rHSMCI_SDCR(ch) & ~((U32)HSMCI_SCDBUS));
X    mciSdcr = ((*(volatile U32 *)(0xFFF80000+ch*50000+0x0C)) & ~((U32)(0x3 << 6)));
N	rHSMCI_SDCR(ch) = (mciSdcr | busWidth);
X	(*(volatile U32 *)(0xFFF80000+ch*50000+0x0C)) = (mciSdcr | busWidth);
N}
N
N//------------------------------------------------------------------------------
N/// Close a MCI driver instance and the underlying peripheral.
N/// \param pMci  Pointer to a MCI driver instance.
N/// \param pMciHw  Pointer to a MCI peripheral.
N/// \param mciId  MCI peripheral identifier.
N//------------------------------------------------------------------------------
Nvoid MCI_Close(Mci *pMci)
N{
N	U8 ch = pMci-> mciChan;
N	
N	rHSMCI_IDR(ch) = 0xFFFFFFFF;
X	(*(volatile U32 *)(0xFFF80000+ch*50000+0x48)) = 0xFFFFFFFF;
N	rHSMCI_CR(ch) = HSMCI_MCIDIS;
X	(*(volatile U32 *)(0xFFF80000+ch*50000+0x00)) = (0x1 << 1);
N	
N	// Disable the MCI peripheral clock.
N	if(ch == 0) PMC_PeriDis(PERIF_ID_MCI0);
X	if(ch == 0) PMC_PeriDis((11));
N	else PMC_PeriDis(PERIF_ID_MCI1);
X	else PMC_PeriDis((29));
N
N    // Initialize the MCI driver structure
N    pMci->semaphore = 1;
N    pMci->pCommand = 0;
N}
N
N//------------------------------------------------------------------------------
N/// Processes pending events on the given MCI driver.
N/// \param pMci  Pointer to a MCI driver instance.
N//------------------------------------------------------------------------------
Nvoid MCI_Handler(Mci *pMci)
N{
N    U8 ch;
N    MciCmd *pCommand = pMci->pCommand;
N    volatile U32 status;
N    U32 status0, mask;
N    U8 i;
N
N	U32 transSize;
N	U8* p;
N
N	ch = pMci-> mciChan;
N
N    // Read the status register
N    status0 = rHSMCI_SR(ch);
X    status0 = (*(volatile U32 *)(0xFFF80000+ch*50000+0x40));
N    mask    = rHSMCI_IMR(ch);
X    mask    = (*(volatile U32 *)(0xFFF80000+ch*50000+0x4C));
N    status  = status0 & mask;
N	
N//	TRACE_WRN("iST 0x%08X", status0);
N//	TRACE_WRN("iMK 0x%08X", mask);
N//	TRACE_WRN("iSM 0x%08X", status);
N
N    // Check if an error has occured
N    if ((status & STATUS_ERRORS) != 0) {
X    if ((status & ((U32)((0x80000000) | (0x1 << 30) | (0x1 << 24) | (0x1 << 23) | (0x1 << 22) | (0x1 << 21) | (0x1 << 20) | (0x1 << 19) | (0x1 << 18) | (0x1 << 17) | (0x1 << 16)))) != 0) {
N        // Check error code
N        if ((status & STATUS_ERRORS) == HSMCI_RTOE) pCommand->status = MCI_STATUS_NORESPONSE;
X        if ((status & ((U32)((0x80000000) | (0x1 << 30) | (0x1 << 24) | (0x1 << 23) | (0x1 << 22) | (0x1 << 21) | (0x1 << 20) | (0x1 << 19) | (0x1 << 18) | (0x1 << 17) | (0x1 << 16)))) == (0x1 << 20)) pCommand->status = 3;
N        else pCommand->status = MCI_STATUS_ERROR;
X        else pCommand->status = 2;
N        TRACE_WRN("iErr 0x%x", (status & STATUS_ERRORS));
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("iErr 0x%x", (status & ((U32)((0x80000000) | (0x1 << 30) | (0x1 << 24) | (0x1 << 23) | (0x1 << 22) | (0x1 << 21) | (0x1 << 20) | (0x1 << 19) | (0x1 << 18) | (0x1 << 17) | (0x1 << 16))))); ShellPrintf("\n\r");};
N    }
N    mask &= ~STATUS_ERRORS;
X    mask &= ~((U32)((0x80000000) | (0x1 << 30) | (0x1 << 24) | (0x1 << 23) | (0x1 << 22) | (0x1 << 21) | (0x1 << 20) | (0x1 << 19) | (0x1 << 18) | (0x1 << 17) | (0x1 << 16)));
N
N//	TRACE_ERR("MCI_Handler Step 0");
N
N    // Check if a command has been completed
N    if (status & HSMCI_CMDRDY)
X    if (status & (0x1 << 0))
N	{
N		rHSMCI_IDR(ch) = HSMCI_CMDRDY;
X		(*(volatile U32 *)(0xFFF80000+ch*50000+0x48)) = (0x1 << 0);
N        if (pCommand->isRead == 0 && pCommand->tranType == MCI_STOP_TRANSFER)
X        if (pCommand->isRead == 0 && pCommand->tranType == 2)
N		{
N            if (status0 & HSMCI_XFRDONE) rHSMCI_CR(ch) = HSMCI_MCIDIS;
X            if (status0 & (0x1 << 27)) (*(volatile U32 *)(0xFFF80000+ch*50000+0x00)) = (0x1 << 1);
N            else rHSMCI_IER(ch) = HSMCI_XFRDONE;
X            else (*(volatile U32 *)(0xFFF80000+ch*50000+0x44)) = (0x1 << 27);
N        }
N        else
N		{
N            mask &= ~(U32)HSMCI_CMDRDY;
X            mask &= ~(U32)(0x1 << 0);
N            if (pCommand->dataTran == 0) rHSMCI_CR(ch) = HSMCI_MCIDIS;
X            if (pCommand->dataTran == 0) (*(volatile U32 *)(0xFFF80000+ch*50000+0x00)) = (0x1 << 1);
N        }
N    }
N
N//	TRACE_ERR("MCI_Handler Step 1");
N
N
N    // Check if transfer stopped
N    if (status & HSMCI_XFRDONE)
X    if (status & (0x1 << 27))
N	{
N        mask &= ~(U32)HSMCI_XFRDONE;
X        mask &= ~(U32)(0x1 << 27);
N        rHSMCI_CR(ch) = HSMCI_MCIDIS;
X        (*(volatile U32 *)(0xFFF80000+ch*50000+0x00)) = (0x1 << 1);
N    }
N
N//#if defined(MCI_DMA_ENABLE)
N
N    // Check FIFOEMPTY
N    if (status & HSMCI_FIFOEMPTY)
X    if (status & (0x1 << 26))
N	{
N        rHSMCI_IDR(ch) = HSMCI_FIFOEMPTY;
X        (*(volatile U32 *)(0xFFF80000+ch*50000+0x48)) = (0x1 << 26);
N        if ( pCommand->isRead == 0 && (status0 & HSMCI_BLKE) == 0 ) rHSMCI_IER(ch) = HSMCI_BLKE;
X        if ( pCommand->isRead == 0 && (status0 & (0x1 << 3)) == 0 ) (*(volatile U32 *)(0xFFF80000+ch*50000+0x44)) = (0x1 << 3);
N        else
N		{
N            mask &= ~(U32)HSMCI_FIFOEMPTY;
X            mask &= ~(U32)(0x1 << 26);
N            rHSMCI_CR(ch) = HSMCI_MCIDIS;
X            (*(volatile U32 *)(0xFFF80000+ch*50000+0x00)) = (0x1 << 1);
N        }
N    }
N	
N//	TRACE_ERR("MCI_Handler Step 2");
N	
N    if (status & HSMCI_BLKE) {
X    if (status & (0x1 << 3)) {
N        mask &= ~(U32)HSMCI_BLKE;
X        mask &= ~(U32)(0x1 << 3);
N        rHSMCI_CR(ch) = HSMCI_MCIDIS;
X        (*(volatile U32 *)(0xFFF80000+ch*50000+0x00)) = (0x1 << 1);
N    }
N
N//	TRACE_ERR("MCI_Handler Step 3");
N
N    // Check if a DMA transfer has been completed
N    if ((status & HSMCI_DMADONE) && (LLI_MCI[dmaLastLliNdx].controlA & AT91C_HDMA_DONE))
X    if ((status & (0x1 << 25)) && (LLI_MCI[dmaLastLliNdx].controlA & (0x80000000)))
N	{
N
N        U32 intFlag;
N        intFlag = DMA_GetInterruptMask();
N        intFlag = ~intFlag;
N        intFlag |= (AT91C_HDMA_BTC0 << SDMMC_DMA_CHANNEL);
X        intFlag |= ((0x1 << 0) << 0);
N        DMA_DisableIt(intFlag);
N
N//		TRACE_ERR("MCI_Handler Step 4");
N
N        // All data transferred
N        if (xfredBlocks >= pCommand->nbBlock)
N		{
N			rHSMCI_IDR(ch) = HSMCI_DMADONE;
X			(*(volatile U32 *)(0xFFF80000+ch*50000+0x48)) = (0x1 << 25);
N            if ( pCommand->isRead == 0 && (status0 & HSMCI_FIFOEMPTY) == 0 ) rHSMCI_IER(ch) = HSMCI_FIFOEMPTY;
X            if ( pCommand->isRead == 0 && (status0 & (0x1 << 26)) == 0 ) (*(volatile U32 *)(0xFFF80000+ch*50000+0x44)) = (0x1 << 26);
N            else
N			{
N                rHSMCI_CR(ch) = HSMCI_MCIDIS;
X                (*(volatile U32 *)(0xFFF80000+ch*50000+0x00)) = (0x1 << 1);
N                mask &= ~(U32)HSMCI_DMADONE;
X                mask &= ~(U32)(0x1 << 25);
N            }
N        }
N        // Start later part of DMA
N        else
N		{
N            p = &pCommand->pData[xfredBlocks*pCommand->blockSize];
N            transSize = ((pCommand->nbBlock - xfredBlocks)*pCommand->blockSize);
N            if (transSize > MCI_FIFO_SIZE)
X            if (transSize > (0x4000-0x400))
N			{
N                transSize = MCI_FIFO_SIZE;
X                transSize = (0x4000-0x400);
N                xfredBlocks += MCI_FIFO_SIZE/pCommand->blockSize;
X                xfredBlocks += (0x4000-0x400)/pCommand->blockSize;
N            }
N            else
N			{
N                xfredBlocks  = pCommand->nbBlock;
N            }
N            #if 0
S            WRITE_MCI(pMciHw, MCI_BLKR, (READ_MCI(pMciHw, MCI_BLKR)
S                                         & (~(U32)HSMCI_BCNT))
S                                           | (transSize/pCommand->blockSize));
N            #endif
N            if ((pCommand->blockSize & 0x3) == 0) {
N                transSize = toWCOUNT(transSize);
X                transSize = (((transSize)&0x3) ? (((transSize)/4)+1) : ((transSize)/4));
N            }
N            DMACH_MCI_P2M(SDMMC_DMA_CHANNEL, HSMCI_FIFO(ch), (U8*) p, transSize, 0, (pCommand->blockSize & 0x3) > 0);
X            DMACH_MCI_P2M(0, (0xFFF80000+ch*50000+0x200), (U8*) p, transSize, 0, (pCommand->blockSize & 0x3) > 0);
N            DMA_EnableChannel(SDMMC_DMA_CHANNEL);
X            DMA_EnableChannel(0);
N			
N//			TRACE_ERR("MCI_Handler Step 5");
N        }
N    }
N//#endif
N	
N//	TRACE_ERR("MCI_Handler Step 6");
N	
N    // All non-error mask done, complete the command
N    if (!mask || pCommand->status != MCI_STATUS_PENDING)
X    if (!mask || pCommand->status != 1)
N	{
N        // Store the card response in the provided buffer
N        if (pCommand->pResp)
N		{
N            U8 resSize;
N            switch (pCommand->resType)
N			{
N	            case 1: case 3: case 4: case 5: case 6: case 7:
N	                     resSize = 1;           break;
N	            case 2:  resSize = 4;           break;
N	            default: resSize = 0;           break;
N            }
N            for (i=0; i < resSize; i++) pCommand->pResp[i] = rHSMCI_RSPR0(ch);
X            for (i=0; i < resSize; i++) pCommand->pResp[i] = (*(volatile U32 *)(0xFFF80000+ch*50000+0x20));
N        }
N
N        // If no error occured, the transfer is successful
N        if (pCommand->status == MCI_STATUS_PENDING) pCommand->status = 0;
X        if (pCommand->status == 1) pCommand->status = 0;
N        // Any error, reset registers
N        else MCI_Reset(ch, 1);
N
N        // Disable interrupts
N		rHSMCI_IDR(ch) = rHSMCI_IMR(ch);
X		(*(volatile U32 *)(0xFFF80000+ch*50000+0x48)) = (*(volatile U32 *)(0xFFF80000+ch*50000+0x4C));
N		
N//      #if defined(MCI_DMA_ENABLE)
N        DMA_DisableChannel(SDMMC_DMA_CHANNEL);
X        DMA_DisableChannel(0);
N//      #endif
N
N//		TRACE_ERR("MCI_Handler Step 7");
N
N		// Disable the MCI peripheral clock.
N		if(ch == 0) PMC_PeriDis(PERIF_ID_MCI0);
X		if(ch == 0) PMC_PeriDis((11));
N		else PMC_PeriDis(PERIF_ID_MCI1);
X		else PMC_PeriDis((29));
N        
N        // Release the semaphore
N        pMci->semaphore++;
N
N//		TRACE_ERR("MCI_Handler Step 8");
N
N        // Invoke the callback associated with the current command (if any)
N		if (pCommand->callback)
N		{
N			(pCommand->callback)(pCommand->status, (void*)pCommand);
N		}
N    }
N	
N//	TRACE_ERR("MCI_Handler Step 9");
N}
N
Nvoid MCI_Reset(U8 ch, U32 keepSettings)
N{
N    if (keepSettings) {
N
N        U32 mciMr, mciSdcr, mciDtor, mciCstor;
N        U32 mciDma, mciCfg;
N
N        mciMr    = rHSMCI_MR(ch);
X        mciMr    = (*(volatile U32 *)(0xFFF80000+ch*50000+0x04));
N        mciSdcr  = rHSMCI_SDCR(ch);
X        mciSdcr  = (*(volatile U32 *)(0xFFF80000+ch*50000+0x0C));
N        mciDtor  = rHSMCI_DTOR(ch);
X        mciDtor  = (*(volatile U32 *)(0xFFF80000+ch*50000+0x08));
N        mciCstor = rHSMCI_CSTOR(ch);
X        mciCstor = (*(volatile U32 *)(0xFFF80000+ch*50000+0x1C));
N
N        mciDma = rHSMCI_DMA(ch);
X        mciDma = (*(volatile U32 *)(0xFFF80000+ch*50000+0x50));
N        mciCfg = rHSMCI_CFG(ch);
X        mciCfg = (*(volatile U32 *)(0xFFF80000+ch*50000+0x54));
N		
N		rHSMCI_CR(ch)		= HSMCI_SWRST;
X		(*(volatile U32 *)(0xFFF80000+ch*50000+0x00))		= (0x1 << 7);
N		rHSMCI_CR(ch)		= HSMCI_MCIDIS | HSMCI_PWSDIS;
X		(*(volatile U32 *)(0xFFF80000+ch*50000+0x00))		= (0x1 << 1) | (0x1 << 3);
N		rHSMCI_MR(ch)		= mciMr;
X		(*(volatile U32 *)(0xFFF80000+ch*50000+0x04))		= mciMr;
N		rHSMCI_SDCR(ch)		= mciSdcr;
X		(*(volatile U32 *)(0xFFF80000+ch*50000+0x0C))		= mciSdcr;
N		rHSMCI_DTOR(ch)		= mciDtor;
X		(*(volatile U32 *)(0xFFF80000+ch*50000+0x08))		= mciDtor;
N		rHSMCI_CSTOR(ch)	= mciCstor;
X		(*(volatile U32 *)(0xFFF80000+ch*50000+0x1C))	= mciCstor;
N		
N		rHSMCI_DMA(ch)		= mciDma;
X		(*(volatile U32 *)(0xFFF80000+ch*50000+0x50))		= mciDma;
N		rHSMCI_CFG(ch)		= mciCfg;
X		(*(volatile U32 *)(0xFFF80000+ch*50000+0x54))		= mciCfg;
N    }
N    else
N	{
N		rHSMCI_CR(ch)		= HSMCI_SWRST;
X		(*(volatile U32 *)(0xFFF80000+ch*50000+0x00))		= (0x1 << 7);
N		rHSMCI_CR(ch)		= HSMCI_MCIDIS | HSMCI_PWSDIS;
X		(*(volatile U32 *)(0xFFF80000+ch*50000+0x00))		= (0x1 << 1) | (0x1 << 3);
N    }
N}
N
N
N
Nstatic void AT91F_Prepare_Multiple_Transfer(U32 Channel, U32 LLI_rownumber, U32 LLI_Last_Row, U32 From_add, U32 To_add, U32 Ctrla, U32 Ctrlb)
N{
N    LLI_MCI[LLI_rownumber].sourceAddress =  From_add;
N    LLI_MCI[LLI_rownumber].destAddress =  To_add;
N    LLI_MCI[LLI_rownumber].controlA =  Ctrla;
N    LLI_MCI[LLI_rownumber].controlB =  Ctrlb;
N    if (LLI_Last_Row != LAST_ROW)
X    if (LLI_Last_Row != 0x100)
N        LLI_MCI[LLI_rownumber].descriptor =
N             (U32)&LLI_MCI[LLI_rownumber + 1] + 0;
N    else {
N        dmaLastLliNdx = LLI_rownumber;
N        LLI_MCI[LLI_rownumber].descriptor = 0;
N    }
N}
N
N// trans_size: number of transfers in SRC side
N// forceByte: 1 - byte count, 0 - word count
N
N
Nstatic U32
NDMACH_MCI_P2M(U32 channel_index, U32 src_addr, U8* dest_addr, U32 trans_size, U8  addrIncMode, U8 forceByte)
N{
N    U32 srcAddress;
N    U32 destAddress;
N    U32 buffSize;
N    U32 LLI_rownumber = 0;
N    U32 srcAddressMode = addrIncMode ? (AT91C_HDMA_SRC_ADDRESS_MODE_INCR) : (AT91C_HDMA_SRC_ADDRESS_MODE_FIXED);
X    U32 srcAddressMode = addrIncMode ? ((0x0 << 24)) : ((0x2 << 24));
N    U32 scSize, dcSize, mWidth, perWidth, addrInc;
N
N    // Disable dma channel
N    DMA_DisableChannel(channel_index);
N
N    // DMA channel configuration
N    srcAddress  = (U32)src_addr;    // Set the data start address
N    destAddress = (U32)dest_addr; //(U32)SSC_THR_ADD; 
N    buffSize    = trans_size;
N
N    // Memory width can be WORD if address is aligned
N    mWidth = ((destAddress & 0x3) == 0) ? AT91C_HDMA_DST_WIDTH_WORD : AT91C_HDMA_DST_WIDTH_BYTE;
X    mWidth = ((destAddress & 0x3) == 0) ? (0x2 << 28) : (0x0 << 28);
N    // Peripheral width is byte if FBYTE mode
N    perWidth = forceByte ? AT91C_HDMA_SRC_WIDTH_BYTE : AT91C_HDMA_SRC_WIDTH_WORD;
X    perWidth = forceByte ? (0x0 << 24) : (0x2 << 24);
N    addrInc  = forceByte ? 1 : 4;
N
N    if(buffSize >= DMA_TOTAL){
X    if(buffSize >= ((0xF00)*(5))){
N        TRACE_WRN("SD DMA, size too big %d\n\r", buffSize);
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SD DMA, size too big %d\n\r", buffSize); ShellPrintf("\n\r");};
N        buffSize = DMA_TOTAL;
X        buffSize = ((0xF00)*(5));
N    }
N
N    // Set DMA channel source address
N    DMA_SetSourceAddr(channel_index, srcAddress);
N
N    // Set DMA channel destination address
N    DMA_SetDestinationAddr(channel_index,destAddress);
N
N    // Set DMA channel DSCR
N    DMA_SetDescriptorAddr(channel_index, (U32)&LLI_MCI[0]);
N
N    // Set DMA channel control A 
N    DMA_SetSourceBufferSize(channel_index, buffSize, (perWidth >> 24), (mWidth >> 28), 0);
N
N	//Set DMA channel control B
N    DMA_SetSourceBufferMode(channel_index, DMA_TRANSFER_LLI, srcAddressMode >> 24);
X    DMA_SetSourceBufferMode(channel_index, 1, srcAddressMode >> 24);
N    DMA_SetDestBufferMode(channel_index, DMA_TRANSFER_LLI, (AT91C_HDMA_DST_ADDRESS_MODE_INCR >> 28));
X    DMA_SetDestBufferMode(channel_index, 1, ((0x0 << 28) >> 28));
N
N    // Set DMA channel config
N    DMA_SetConfiguration(channel_index, AT91C_HDMA_SRC_PER_0 \
N                                        | AT91C_HDMA_DST_PER_0 \
N                                        | AT91C_HDMA_SRC_H2SEL_HW \
N                                        | AT91C_HDMA_DST_H2SEL_HW \
N                                        | AT91C_HDMA_SOD_DISABLE \
N                                        | AT91C_HDMA_FIFOCFG_ENOUGHSPACE);
X    DMA_SetConfiguration(channel_index, (0x0)                                         | (0x0 << 4)                                         | (0x1 << 9)                                         | (0x1 << 13)                                         | (0x0 << 16)                                         | (0x2 << 28));
N
N    //scSize = (perChunkSize == 4) ? AT91C_HDMA_SCSIZE_4 : AT91C_HDMA_SCSIZE_1;
N    //dcSize = (memChunkSize == 4) ? AT91C_HDMA_DCSIZE_4 : AT91C_HDMA_DCSIZE_1;
N    scSize = AT91C_HDMA_SCSIZE_1; dcSize = AT91C_HDMA_DCSIZE_4;
X    scSize = (0x0 << 16); dcSize = (0x1 << 20);
N
N    // Set link list
N    buffSize *= addrInc;    // convert size to byte count
N    while(destAddress < ((U32)(dest_addr + buffSize))) {
N        if(((U32)(dest_addr + buffSize)) - destAddress <= (DMA_XFR_SIZE*addrInc) )
X        if(((U32)(dest_addr + buffSize)) - destAddress <= ((0xF00)*addrInc) )
N        {
N            AT91F_Prepare_Multiple_Transfer(channel_index, LLI_rownumber, LAST_ROW,
X            AT91F_Prepare_Multiple_Transfer(channel_index, LLI_rownumber, 0x100,
N                                        srcAddress,
N                                        destAddress,
N                                        (((((U32)(dest_addr + buffSize))
N                                               - destAddress)/addrInc)
N                                                | perWidth
N                                                | mWidth
N                                                | scSize
N                                                | dcSize
N                                                    ),
N                                        ( AT91C_HDMA_DST_DSCR_FETCH_FROM_MEM
X                                        ( (0x0 << 20)
N                                           | AT91C_HDMA_DST_ADDRESS_MODE_INCR
X                                           | (0x0 << 28)
N                                           | AT91C_HDMA_SRC_DSCR_FETCH_DISABLE
X                                           | (0x1 << 16)
N                                           | srcAddressMode
N                                           | AT91C_HDMA_FC_PER2MEM));
X                                           | (0x2 << 21)));
N        }
N        else
N        {
N            AT91F_Prepare_Multiple_Transfer(channel_index, LLI_rownumber, 0,
N                                        srcAddress,
N                                        destAddress,
N                                        ( (DMA_XFR_SIZE)
X                                        ( ((0xF00))
N                                            | perWidth
N                                            | mWidth
N                                            | scSize
N                                            | dcSize
N                                                ),
N                                        (  AT91C_HDMA_DST_DSCR_FETCH_FROM_MEM
X                                        (  (0x0 << 20)
N                                            | AT91C_HDMA_DST_ADDRESS_MODE_INCR
X                                            | (0x0 << 28)
N                                            | AT91C_HDMA_SRC_DSCR_FETCH_DISABLE
X                                            | (0x1 << 16)
N                                            | srcAddressMode
N                                            | AT91C_HDMA_FC_PER2MEM));
X                                            | (0x2 << 21)));
N
N        }
N
N        destAddress += DMA_XFR_SIZE*addrInc;
X        destAddress += (0xF00)*addrInc;
N
N        LLI_rownumber++;
N    }
N
N	TRACE_WRN("DMACH_MCI_P2M()");
X	{ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("DMACH_MCI_P2M()"); ShellPrintf("\n\r");};
N
N    return 0;
N}
N
N// trans_size: number of transfers in SRC side
N// forceByte: 1 - byte count, 0 - word count
Nstatic U32 DMACH_MCI_M2P(U32 channel_index, U8* src_addr, U32 dest_addr, U32 trans_size, U8 addrIncMode, U8 forceByte)
N{
N    U32 srcAddress;
N    U32 destAddress;
N    U32 buffSize;
N    U32 LLI_rownumber = 0;
N    U32 dstAddressMode = addrIncMode ?
N                                  (AT91C_HDMA_DST_ADDRESS_MODE_INCR)
X                                  ((0x0 << 28))
N                                : (AT91C_HDMA_DST_ADDRESS_MODE_FIXED);
X                                : ((0x2 << 28));
N    U32 dcSize, scSize, mWidth, perWidth, addrInc;
N
N    // Disable dma channel
N    DMA_DisableChannel(channel_index);
N
N    buffSize = trans_size;
N    if(buffSize >= DMA_TOTAL){
X    if(buffSize >= ((0xF00)*(5))){
N        TRACE_WRN("SD DMA, size too big %d\n\r", buffSize);
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SD DMA, size too big %d\n\r", buffSize); ShellPrintf("\n\r");};
N        buffSize = DMA_TOTAL;
X        buffSize = ((0xF00)*(5));
N    }
N
N    // DMA channel configuration
N    srcAddress  = (U32)src_addr;    // Set the data start address
N    destAddress = (U32)dest_addr;
N
N    // Memory width
N    mWidth = ((srcAddress & 0x3) == 0) ? AT91C_HDMA_SRC_WIDTH_WORD
X    mWidth = ((srcAddress & 0x3) == 0) ? (0x2 << 24)
N                                       : AT91C_HDMA_SRC_WIDTH_BYTE;
X                                       : (0x0 << 24);
N    // One Transfer size (1 or 4)
N    perWidth = forceByte ? AT91C_HDMA_DST_WIDTH_BYTE
X    perWidth = forceByte ? (0x0 << 28)
N                         : AT91C_HDMA_DST_WIDTH_WORD;
X                         : (0x2 << 28);
N    //addrInc = forceByte ? 1 : 4;
N    if (mWidth == AT91C_HDMA_SRC_WIDTH_BYTE) {
X    if (mWidth == (0x0 << 24)) {
N        addrInc = 1;
N        if (!forceByte) buffSize *= 4;
N    }
N    else
N        addrInc = 4;
N
N    // Set DMA channel source address
N    DMA_SetSourceAddr(channel_index, srcAddress);
N
N    // Set DMA channel destination address
N    DMA_SetDestinationAddr(channel_index,destAddress);
N
N    // Set DMA channel DSCR
N    DMA_SetDescriptorAddr(channel_index, (U32)&LLI_MCI[0]);
N
N    // Set DMA channel control A 
N    DMA_SetSourceBufferSize(channel_index, buffSize,
N                            (mWidth   >> 24),
N                            (perWidth >> 28), 0);
N
N    //Set DMA channel control B
N    DMA_SetSourceBufferMode(channel_index,
N                            DMA_TRANSFER_LLI,
X                            1,
N                            (AT91C_HDMA_SRC_ADDRESS_MODE_INCR >> 24));
X                            ((0x0 << 24) >> 24));
N    DMA_SetDestBufferMode(channel_index,
N                          DMA_TRANSFER_LLI,
X                          1,
N                          dstAddressMode >> 28);
N
N    // Set DMA channel config
N    DMA_SetConfiguration(channel_index, AT91C_HDMA_SRC_PER_0 \
N                                        | AT91C_HDMA_DST_PER_0 \
N                                        | AT91C_HDMA_SRC_H2SEL_SW \
N                                        | AT91C_HDMA_DST_H2SEL_HW \
N                                        | AT91C_HDMA_SOD_DISABLE \
N                                        | AT91C_HDMA_FIFOCFG_LARGESTBURST);
X    DMA_SetConfiguration(channel_index, (0x0)                                         | (0x0 << 4)                                         | (0x0 << 9)                                         | (0x1 << 13)                                         | (0x0 << 16)                                         | (0x0 << 28));
N    //dcSize = (perChunkSize == 4) ? AT91C_HDMA_DCSIZE_4 : AT91C_HDMA_DCSIZE_1;
N    //scSize = (memChunkSize == 4) ? AT91C_HDMA_SCSIZE_4 : AT91C_HDMA_SCSIZE_1;
N    dcSize = AT91C_HDMA_DCSIZE_1;    scSize = AT91C_HDMA_SCSIZE_4;
X    dcSize = (0x0 << 20);    scSize = (0x1 << 16);
N
N    // Set link list
N    buffSize *= addrInc; // convert to byte address
N    while(srcAddress < ((U32)(src_addr + buffSize)))
N    {
N        if(((U32)(src_addr + buffSize)) - srcAddress <= (DMA_XFR_SIZE*addrInc) )
X        if(((U32)(src_addr + buffSize)) - srcAddress <= ((0xF00)*addrInc) )
N        {
N            AT91F_Prepare_Multiple_Transfer(channel_index, LLI_rownumber, LAST_ROW,
X            AT91F_Prepare_Multiple_Transfer(channel_index, LLI_rownumber, 0x100,
N                                        srcAddress,
N                                        destAddress,
N                                        (((((U32)(src_addr + buffSize))
N                                                - srcAddress)/addrInc)
N                                                  | mWidth
N                                                  | perWidth
N                                                  | scSize
N                                                  | dcSize
N                                                      ),
N                                        ( AT91C_HDMA_DST_DSCR_FETCH_DISABLE
X                                        ( (0x1 << 20)
N                                        | dstAddressMode
N                                        | AT91C_HDMA_SRC_DSCR_FETCH_FROM_MEM
X                                        | (0x0 << 16)
N                                        | AT91C_HDMA_SRC_ADDRESS_MODE_INCR
X                                        | (0x0 << 24)
N                                        | AT91C_HDMA_FC_MEM2PER));
X                                        | (0x1 << 21)));
N        }
N        else
N        {
N            AT91F_Prepare_Multiple_Transfer(channel_index, LLI_rownumber, 0,
N                                        srcAddress,
N                                        destAddress,
N                                        ( (DMA_XFR_SIZE)
X                                        ( ((0xF00))
N                                            | mWidth
N                                            | perWidth
N                                            | scSize
N                                            | dcSize
N                                                ),
N                                        ( AT91C_HDMA_DST_DSCR_FETCH_DISABLE
X                                        ( (0x1 << 20)
N                                        | dstAddressMode
N                                        | AT91C_HDMA_SRC_DSCR_FETCH_FROM_MEM
X                                        | (0x0 << 16)
N                                        | AT91C_HDMA_SRC_ADDRESS_MODE_INCR
X                                        | (0x0 << 24)
N                                        | AT91C_HDMA_FC_MEM2PER));
X                                        | (0x1 << 21)));
N
N        }
N
N        srcAddress += DMA_XFR_SIZE*addrInc;
X        srcAddress += (0xF00)*addrInc;
N
N        
N        LLI_rownumber++;
N    }
N    	TRACE_WRN("DMACH_MCI_M2P()");
X    	{ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("DMACH_MCI_M2P()"); ShellPrintf("\n\r");};
N    return 0;
N}
N
Nstatic void DMACH_EnableIt(U8 ch, U32 channel)
N{
N    U32 intFlag;
N
N    intFlag = DMA_GetInterruptMask();
N    intFlag |= (AT91C_HDMA_BTC0 << channel);
X    intFlag |= ((0x1 << 0) << channel);
N    DMA_EnableIt(intFlag);
N}
