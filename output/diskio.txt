; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--thumb --list --debug -c --asm --interleave --gnu -o.\output\diskio.o --asm_dir=.\output\ --list_dir=.\output\ --depend=.\output\diskio.d --cpu=ARM926EJ-S --apcs=interwork -O1 -I.\atmel -I.\ -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\Atmel\SAM9M10 -Dat91sam9m10 -Dddram -DNOFPUT -DTRACE_LEVEL=4 --omf_browse=.\output\diskio.crf atmel\diskio.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  disk_initialize PROC
;;;30     
;;;31     DSTATUS disk_initialize (
000000  0001              MOVS     r1,r0
;;;32         BYTE drv                /* Physical drive number (0..) */
;;;33     )
;;;34     {
;;;35         DSTATUS stat = STA_NOINIT;
000002  2001              MOVS     r0,#1
;;;36     
;;;37         switch (drv) {
000004  2900              CMP      r1,#0
000006  d005              BEQ      |L1.20|
000008  2901              CMP      r1,#1
00000a  d005              BEQ      |L1.24|
00000c  2902              CMP      r1,#2
00000e  d100              BNE      |L1.18|
;;;38             case DRV_SDRAM :
;;;39                 stat = 0;
000010  2000              MOVS     r0,#0
                  |L1.18|
;;;40                 break;
;;;41     
;;;42             case DRV_MMC :
;;;43                 stat = 0;
;;;44                 break;
;;;45      
;;;46             case DRV_NAND:
;;;47                 stat = 0;
;;;48                 break;
;;;49         }
;;;50     
;;;51         return stat;
;;;52     }
000012  4770              BX       lr
                  |L1.20|
000014  2000              MOVS     r0,#0                 ;43
000016  4770              BX       lr
                  |L1.24|
000018  2000              MOVS     r0,#0                 ;47
00001a  4770              BX       lr
;;;53     
                          ENDP

                  disk_status PROC
;;;57     
;;;58     DSTATUS disk_status (
00001c  0001              MOVS     r1,r0
;;;59         BYTE drv        /* Physical drive number (0..) */
;;;60     )
;;;61     {
;;;62         DSTATUS stat=STA_NOINIT;
00001e  2001              MOVS     r0,#1
;;;63     
;;;64         switch (drv) {
000020  2900              CMP      r1,#0
000022  d005              BEQ      |L1.48|
000024  2901              CMP      r1,#1
000026  d005              BEQ      |L1.52|
000028  2902              CMP      r1,#2
00002a  d100              BNE      |L1.46|
;;;65             case DRV_SDRAM :
;;;66                 stat = 0;  // ok
00002c  2000              MOVS     r0,#0
                  |L1.46|
;;;67                 break;
;;;68     
;;;69             case DRV_MMC :
;;;70                 stat = 0;  // ok
;;;71                 break;  
;;;72             case DRV_NAND:
;;;73                 stat = 0;
;;;74                 break;
;;;75         }
;;;76     
;;;77         return stat;
;;;78     }
00002e  4770              BX       lr
                  |L1.48|
000030  2000              MOVS     r0,#0                 ;70
000032  4770              BX       lr
                  |L1.52|
000034  2000              MOVS     r0,#0                 ;73
000036  4770              BX       lr
;;;79     
                          ENDP

                  disk_read PROC
;;;83     
;;;84     DRESULT disk_read (
000038  b5ff              PUSH     {r0-r7,lr}
;;;85         BYTE drv,        /* Physical drive number (0..) */
;;;86         BYTE *buff,        /* Data buffer to store read data */
;;;87         DWORD sector,    /* Sector number (LBA) */
;;;88         BYTE count        /* Sector count (1..255) */
;;;89     )
;;;90     {
00003a  0017              MOVS     r7,r2
00003c  001e              MOVS     r6,r3
00003e  b083              SUB      sp,sp,#0xc
;;;91         unsigned char result;
;;;92         DRESULT res = RES_ERROR;
000040  2501              MOVS     r5,#1
;;;93     
;;;94         unsigned int addr, len;
;;;95         if (medias[drv].blockSize < SECTOR_SIZE_DEFAULT) {
000042  2144              MOVS     r1,#0x44
000044  4348              MULS     r0,r1,r0
000046  4979              LDR      r1,|L1.556|
000048  1844              ADDS     r4,r0,r1
00004a  69e1              LDR      r1,[r4,#0x1c]
00004c  0268              LSLS     r0,r5,#9
00004e  4281              CMP      r1,r0
000050  d205              BCS      |L1.94|
;;;96             addr = sector * (SECTOR_SIZE_DEFAULT / medias[drv].blockSize);
000052  f7fffffe          BL       __aeabi_uidivmod
000056  0001              MOVS     r1,r0
000058  4379              MULS     r1,r7,r1
;;;97             len  = count * (SECTOR_SIZE_DEFAULT / medias[drv].blockSize);
00005a  4370              MULS     r0,r6,r0
00005c  e001              B        |L1.98|
                  |L1.94|
;;;98         }
;;;99         else {
;;;100            addr = sector;
00005e  0039              MOVS     r1,r7
;;;101            len  = count;
000060  0030              MOVS     r0,r6
                  |L1.98|
;;;102        }
;;;103        
;;;104        result = MED_Read(&medias[drv],
000062  0003              MOVS     r3,r0
000064  9a04              LDR      r2,[sp,#0x10]
000066  2000              MOVS     r0,#0
000068  0006              MOVS     r6,r0
00006a  9601              STR      r6,[sp,#4]
00006c  9000              STR      r0,[sp,#0]
00006e  6866              LDR      r6,[r4,#4]
000070  0020              MOVS     r0,r4
000072  47b0              BLX      r6
000074  0004              MOVS     r4,r0
;;;105                          addr,               // address
;;;106                          (void*)buff,          // data                                            
;;;107                          len,                // data size
;;;108                          NULL,
;;;109                          NULL);
;;;110    
;;;111        if( result == MED_STATUS_SUCCESS ) {
000076  2c00              CMP      r4,#0
000078  d015              BEQ      |L1.166|
;;;112            res = RES_OK;
;;;113        }
;;;114        else {
;;;115            TRACE_ERROR("MED_Read pb: 0x%X\n\r", result);
00007a  201b              MOVS     r0,#0x1b
00007c  f7fffffe          BL       ShellPutByte
000080  a06b              ADR      r0,|L1.560|
000082  f7fffffe          BL       ShellPrintf
000086  201b              MOVS     r0,#0x1b
000088  f7fffffe          BL       ShellPutByte
00008c  a06b              ADR      r0,|L1.572|
00008e  f7fffffe          BL       ShellPrintf
000092  0021              MOVS     r1,r4
000094  a06a              ADR      r0,|L1.576|
000096  f7fffffe          BL       ShellPrintf
00009a  a06e              ADR      r0,|L1.596|
00009c  f7fffffe          BL       ShellPrintf
                  |L1.160|
;;;116            res = RES_ERROR;
;;;117        }
;;;118    
;;;119        return res;
0000a0  0028              MOVS     r0,r5
;;;120    }
0000a2  b007              ADD      sp,sp,#0x1c
0000a4  bdf0              POP      {r4-r7,pc}
                  |L1.166|
0000a6  2500              MOVS     r5,#0                 ;112
0000a8  e7fa              B        |L1.160|
;;;121    
                          ENDP

                  disk_write PROC
;;;127    
;;;128    DRESULT disk_write (
0000aa  b5fe              PUSH     {r1-r7,lr}
;;;129        BYTE drv,            /* Physical drive number (0..) */
;;;130        const BYTE *buff,    /* Data to be written */
;;;131        DWORD sector,        /* Sector number (LBA) */
;;;132        BYTE count            /* Sector count (1..255) */
;;;133    )
;;;134    {
0000ac  000c              MOVS     r4,r1
0000ae  0017              MOVS     r7,r2
0000b0  001e              MOVS     r6,r3
;;;135        DRESULT res=RES_PARERR;
;;;136        unsigned int result;
;;;137        void * tmp;
;;;138        tmp = (void *) buff;
;;;139    
;;;140        unsigned int addr, len;
;;;141        if (medias[drv].blockSize < SECTOR_SIZE_DEFAULT) {
0000b2  2144              MOVS     r1,#0x44
0000b4  4348              MULS     r0,r1,r0
0000b6  495d              LDR      r1,|L1.556|
0000b8  1845              ADDS     r5,r0,r1
0000ba  69e9              LDR      r1,[r5,#0x1c]
0000bc  2001              MOVS     r0,#1
0000be  0240              LSLS     r0,r0,#9
0000c0  4281              CMP      r1,r0
0000c2  d206              BCS      |L1.210|
;;;142            addr = sector * (SECTOR_SIZE_DEFAULT / medias[drv].blockSize);
0000c4  f7fffffe          BL       __aeabi_uidivmod
0000c8  0001              MOVS     r1,r0
0000ca  4379              MULS     r1,r7,r1
;;;143            len  = count * (SECTOR_SIZE_DEFAULT / medias[drv].blockSize);
0000cc  4370              MULS     r0,r6,r0
0000ce  0003              MOVS     r3,r0
0000d0  e001              B        |L1.214|
                  |L1.210|
;;;144        }
;;;145        else {
;;;146            addr = sector;
0000d2  0039              MOVS     r1,r7
;;;147            len  = count;
0000d4  0033              MOVS     r3,r6
                  |L1.214|
;;;148        }
;;;149        
;;;150        result = MED_Write(&medias[drv],
0000d6  0022              MOVS     r2,r4
0000d8  0028              MOVS     r0,r5
0000da  2400              MOVS     r4,#0
0000dc  0025              MOVS     r5,r4
0000de  9501              STR      r5,[sp,#4]
0000e0  9400              STR      r4,[sp,#0]
0000e2  6805              LDR      r5,[r0,#0]
0000e4  47a8              BLX      r5
0000e6  0004              MOVS     r4,r0
;;;151                           addr,              // address
;;;152                           (void*)tmp,         // data
;;;153                           len,               // data size
;;;154                           NULL,
;;;155                           NULL);
;;;156    
;;;157        if( result == MED_STATUS_SUCCESS ) {
0000e8  2c00              CMP      r4,#0
0000ea  d014              BEQ      |L1.278|
;;;158          
;;;159            res = RES_OK;
;;;160        }
;;;161        else {
;;;162          
;;;163            TRACE_ERROR("MED_Write pb: 0x%X\n\r", result);
0000ec  201b              MOVS     r0,#0x1b
0000ee  f7fffffe          BL       ShellPutByte
0000f2  a04f              ADR      r0,|L1.560|
0000f4  f7fffffe          BL       ShellPrintf
0000f8  201b              MOVS     r0,#0x1b
0000fa  f7fffffe          BL       ShellPutByte
0000fe  a04f              ADR      r0,|L1.572|
000100  f7fffffe          BL       ShellPrintf
000104  0021              MOVS     r1,r4
000106  a054              ADR      r0,|L1.600|
000108  f7fffffe          BL       ShellPrintf
00010c  a051              ADR      r0,|L1.596|
00010e  f7fffffe          BL       ShellPrintf
;;;164            res = RES_ERROR;
000112  2001              MOVS     r0,#1
;;;165        }
;;;166    
;;;167        return res;
;;;168    }
000114  bdfe              POP      {r1-r7,pc}
                  |L1.278|
000116  2000              MOVS     r0,#0                 ;159
000118  bdfe              POP      {r1-r7,pc}
;;;169    #endif /* _READONLY */
                          ENDP

                  disk_ioctl PROC
;;;187    
;;;188    DRESULT disk_ioctl (
00011a  b570              PUSH     {r4-r6,lr}
;;;189        BYTE drv,        /* Physical drive number (0..) */
;;;190        BYTE ctrl,        /* Control code */
;;;191        void *buff        /* Buffer to send/receive control data */
;;;192    )
;;;193    { 
00011c  0006              MOVS     r6,r0
00011e  000b              MOVS     r3,r1
000120  0014              MOVS     r4,r2
;;;194        DRESULT res=RES_PARERR;
000122  2004              MOVS     r0,#4
000124  2501              MOVS     r5,#1                 ;193
;;;195       
;;;196        switch (drv) {
;;;197            case DRV_SDRAM :
;;;198            switch (ctrl) { 
;;;199    
;;;200                case GET_BLOCK_SIZE:
;;;201                    *(WORD*)buff = 1;
;;;202                    res = RES_OK;
;;;203                    break;
;;;204                
;;;205                case GET_SECTOR_COUNT :   /* Get number of sectors on the disk (DWORD) */
;;;206                    //*(DWORD*)buff = (DWORD)(medias[DRV_SDRAM].size);
;;;207                    if (medias[DRV_SDRAM].blockSize < SECTOR_SIZE_DEFAULT)
000126  01c2              LSLS     r2,r0,#7
000128  2e00              CMP      r6,#0                 ;196
00012a  d02b              BEQ      |L1.388|
00012c  2e01              CMP      r6,#1                 ;196
00012e  d04f              BEQ      |L1.464|
000130  2e02              CMP      r6,#2                 ;196
000132  d10c              BNE      |L1.334|
000134  2b00              CMP      r3,#0                 ;198
000136  d023              BEQ      |L1.384|
000138  493c              LDR      r1,|L1.556|
00013a  3180              ADDS     r1,r1,#0x80
00013c  6a49              LDR      r1,[r1,#0x24]
00013e  2b01              CMP      r3,#1                 ;198
000140  d006              BEQ      |L1.336|
000142  2b02              CMP      r3,#2                 ;198
000144  d015              BEQ      |L1.370|
000146  2b03              CMP      r3,#3                 ;198
000148  d101              BNE      |L1.334|
00014a  8025              STRH     r5,[r4,#0]            ;201
00014c  2000              MOVS     r0,#0                 ;202
                  |L1.334|
;;;208                        *(DWORD*)buff = (DWORD)(medias[DRV_SDRAM].size /
;;;209                                                (SECTOR_SIZE_DEFAULT /
;;;210                                                medias[DRV_SDRAM].blockSize));
;;;211                    else
;;;212                        *(DWORD*)buff = (DWORD)(medias[DRV_SDRAM].size);
;;;213    
;;;214                    res = RES_OK;
;;;215                    break; 
;;;216    
;;;217                case GET_SECTOR_SIZE :   /* Get sectors on the disk (WORD) */
;;;218                    //*(WORD*)buff = medias[DRV_SDRAM].blockSize;
;;;219                    if (medias[DRV_SDRAM].blockSize < SECTOR_SIZE_DEFAULT)
;;;220                        *(WORD*)buff = SECTOR_SIZE_DEFAULT;
;;;221                    else
;;;222                        *(WORD*)buff = medias[DRV_SDRAM].blockSize;
;;;223                    res = RES_OK;
;;;224                    break; 
;;;225    
;;;226                case CTRL_SYNC :   /* Make sure that data has been written */ 
;;;227                    res = RES_OK; 
;;;228                    break; 
;;;229    
;;;230                default: 
;;;231                    res = RES_PARERR; 
;;;232            }
;;;233            break;
;;;234    
;;;235            case DRV_MMC :
;;;236            switch (ctrl) { 
;;;237    
;;;238                case GET_BLOCK_SIZE:
;;;239                    *(WORD*)buff = 1; 
;;;240                    res = RES_OK; 
;;;241                    break; 
;;;242                
;;;243                case GET_SECTOR_COUNT :   /* Get number of sectors on the disk (DWORD) */ 
;;;244                    //*(DWORD*)buff = (DWORD)(medias[DRV_MMC].size);
;;;245                    if (medias[DRV_MMC].blockSize < SECTOR_SIZE_DEFAULT)
;;;246                            *(DWORD*)buff = (DWORD)(medias[DRV_MMC].size /
;;;247                                                    (SECTOR_SIZE_DEFAULT /
;;;248                                                    medias[DRV_MMC].blockSize));
;;;249                    else
;;;250                        *(DWORD*)buff = (DWORD)(medias[DRV_MMC].size);
;;;251                    res = RES_OK; 
;;;252                    break; 
;;;253    
;;;254                case GET_SECTOR_SIZE :   /* Get sectors on the disk (WORD) */ 
;;;255                    //*(WORD*)buff = medias[DRV_MMC].blockSize;
;;;256                    if (medias[DRV_MMC].blockSize < SECTOR_SIZE_DEFAULT)
;;;257                        *(WORD*)buff = SECTOR_SIZE_DEFAULT;
;;;258                    else
;;;259                        *(WORD*)buff = medias[DRV_MMC].blockSize;
;;;260                    res = RES_OK;
;;;261                    break;
;;;262    
;;;263                case CTRL_SYNC :   /* Make sure that data has been written */ 
;;;264                    res = RES_OK; 
;;;265                    break; 
;;;266    
;;;267                default: 
;;;268                    res = RES_PARERR; 
;;;269            }
;;;270            break;
;;;271    
;;;272            case DRV_NAND :
;;;273                switch (ctrl) { 
;;;274    
;;;275                    case GET_BLOCK_SIZE:
;;;276                        *(WORD*)buff = 1; 
;;;277                        res = RES_OK; 
;;;278                        break; 
;;;279    
;;;280                    case GET_SECTOR_COUNT :   /* Get number of sectors on the disk (DWORD) */ 
;;;281                        if (medias[DRV_NAND].blockSize < SECTOR_SIZE_DEFAULT)
;;;282                            *(DWORD*)buff = (DWORD)(medias[DRV_NAND].size /
;;;283                                                    (SECTOR_SIZE_DEFAULT /
;;;284                                                    medias[DRV_NAND].blockSize));
;;;285                        else
;;;286                            *(DWORD*)buff = (DWORD)(medias[DRV_NAND].size);
;;;287                        res = RES_OK;
;;;288                        break; 
;;;289    
;;;290                    case GET_SECTOR_SIZE :	 /* Get sectors on the disk (WORD) */ 
;;;291                        //*(WORD*)buff = medias[DRV_MMC].blockSize;
;;;292                        if (medias[DRV_NAND].blockSize < SECTOR_SIZE_DEFAULT)
;;;293                            *(WORD*)buff = SECTOR_SIZE_DEFAULT;
;;;294                        else
;;;295                            *(WORD*)buff = medias[DRV_NAND].blockSize;
;;;296                        res = RES_OK;
;;;297                        break;
;;;298    
;;;299                    case CTRL_SYNC :   /* Make sure that data has been written */ 
;;;300                        MED_Flush(&medias[DRV_NAND]);
;;;301                        res = RES_OK; 
;;;302                        break; 
;;;303    
;;;304                    default: 
;;;305                        res = RES_PARERR; 
;;;306            }
;;;307    
;;;308        } 
;;;309    
;;;310       return res; 
;;;311    }
00014e  bd70              POP      {r4-r6,pc}
                  |L1.336|
000150  4b36              LDR      r3,|L1.556|
000152  0010              MOVS     r0,r2                 ;207
000154  3380              ADDS     r3,r3,#0x80           ;207
000156  6add              LDR      r5,[r3,#0x2c]         ;207
000158  4281              CMP      r1,r0                 ;207
00015a  d207              BCS      |L1.364|
00015c  f7fffffe          BL       __aeabi_uidivmod
000160  0001              MOVS     r1,r0                 ;208
000162  0028              MOVS     r0,r5                 ;208
000164  f7fffffe          BL       __aeabi_uidivmod
000168  6020              STR      r0,[r4,#0]            ;208
00016a  e000              B        |L1.366|
                  |L1.364|
00016c  6025              STR      r5,[r4,#0]            ;212
                  |L1.366|
00016e  2000              MOVS     r0,#0                 ;214
000170  bd70              POP      {r4-r6,pc}
                  |L1.370|
000172  4291              CMP      r1,r2                 ;219
000174  d201              BCS      |L1.378|
000176  8022              STRH     r2,[r4,#0]            ;220
000178  e000              B        |L1.380|
                  |L1.378|
00017a  8021              STRH     r1,[r4,#0]            ;222
                  |L1.380|
00017c  2000              MOVS     r0,#0                 ;223
00017e  bd70              POP      {r4-r6,pc}
                  |L1.384|
000180  2000              MOVS     r0,#0                 ;227
                  |L1.386|
000182  bd70              POP      {r4-r6,pc}
                  |L1.388|
000184  2b00              CMP      r3,#0                 ;236
000186  d021              BEQ      |L1.460|
000188  4928              LDR      r1,|L1.556|
00018a  2b01              CMP      r3,#1                 ;236
00018c  69c9              LDR      r1,[r1,#0x1c]         ;245
00018e  d006              BEQ      |L1.414|
000190  2b02              CMP      r3,#2                 ;236
000192  d014              BEQ      |L1.446|
000194  2b03              CMP      r3,#3                 ;236
000196  d1f4              BNE      |L1.386|
000198  8025              STRH     r5,[r4,#0]            ;239
00019a  2000              MOVS     r0,#0                 ;240
00019c  bd70              POP      {r4-r6,pc}
                  |L1.414|
00019e  4b23              LDR      r3,|L1.556|
0001a0  0010              MOVS     r0,r2                 ;245
0001a2  6a5d              LDR      r5,[r3,#0x24]         ;245
0001a4  4281              CMP      r1,r0                 ;245
0001a6  d207              BCS      |L1.440|
0001a8  f7fffffe          BL       __aeabi_uidivmod
0001ac  0001              MOVS     r1,r0                 ;246
0001ae  0028              MOVS     r0,r5                 ;246
0001b0  f7fffffe          BL       __aeabi_uidivmod
0001b4  6020              STR      r0,[r4,#0]            ;246
0001b6  e000              B        |L1.442|
                  |L1.440|
0001b8  6025              STR      r5,[r4,#0]            ;250
                  |L1.442|
0001ba  2000              MOVS     r0,#0                 ;251
0001bc  bd70              POP      {r4-r6,pc}
                  |L1.446|
0001be  4291              CMP      r1,r2                 ;256
0001c0  d201              BCS      |L1.454|
0001c2  8022              STRH     r2,[r4,#0]            ;257
0001c4  e000              B        |L1.456|
                  |L1.454|
0001c6  8021              STRH     r1,[r4,#0]            ;259
                  |L1.456|
0001c8  2000              MOVS     r0,#0                 ;260
0001ca  bd70              POP      {r4-r6,pc}
                  |L1.460|
0001cc  2000              MOVS     r0,#0                 ;264
                  |L1.462|
0001ce  bd70              POP      {r4-r6,pc}
                  |L1.464|
0001d0  2b00              CMP      r3,#0                 ;273
0001d2  d021              BEQ      |L1.536|
0001d4  4915              LDR      r1,|L1.556|
0001d6  2b01              CMP      r3,#1                 ;273
0001d8  6e09              LDR      r1,[r1,#0x60]         ;281
0001da  d006              BEQ      |L1.490|
0001dc  2b02              CMP      r3,#2                 ;273
0001de  d014              BEQ      |L1.522|
0001e0  2b03              CMP      r3,#3                 ;273
0001e2  d1f4              BNE      |L1.462|
0001e4  8025              STRH     r5,[r4,#0]            ;276
0001e6  2000              MOVS     r0,#0                 ;277
0001e8  bd70              POP      {r4-r6,pc}
                  |L1.490|
0001ea  4b10              LDR      r3,|L1.556|
0001ec  0010              MOVS     r0,r2                 ;281
0001ee  6e9d              LDR      r5,[r3,#0x68]         ;281
0001f0  4281              CMP      r1,r0                 ;281
0001f2  d207              BCS      |L1.516|
0001f4  f7fffffe          BL       __aeabi_uidivmod
0001f8  0001              MOVS     r1,r0                 ;282
0001fa  0028              MOVS     r0,r5                 ;282
0001fc  f7fffffe          BL       __aeabi_uidivmod
000200  6020              STR      r0,[r4,#0]            ;282
000202  e000              B        |L1.518|
                  |L1.516|
000204  6025              STR      r5,[r4,#0]            ;286
                  |L1.518|
000206  2000              MOVS     r0,#0                 ;287
000208  bd70              POP      {r4-r6,pc}
                  |L1.522|
00020a  4291              CMP      r1,r2                 ;292
00020c  d201              BCS      |L1.530|
00020e  8022              STRH     r2,[r4,#0]            ;293
000210  e000              B        |L1.532|
                  |L1.530|
000212  8021              STRH     r1,[r4,#0]            ;295
                  |L1.532|
000214  2000              MOVS     r0,#0                 ;296
000216  bd70              POP      {r4-r6,pc}
                  |L1.536|
000218  4804              LDR      r0,|L1.556|
00021a  3044              ADDS     r0,r0,#0x44           ;300
00021c  6941              LDR      r1,[r0,#0x14]         ;300
00021e  2900              CMP      r1,#0                 ;300
000220  d000              BEQ      |L1.548|
000222  4788              BLX      r1                    ;300
                  |L1.548|
000224  2000              MOVS     r0,#0                 ;301
000226  bd70              POP      {r4-r6,pc}
;;;312    
                          ENDP

                  get_fattime PROC
;;;322    //------------------------------------------------------------------------------
;;;323    DWORD get_fattime (void)
000228  4811              LDR      r0,|L1.624|
;;;324    {
;;;325        unsigned int time;
;;;326    
;;;327        time =  ((2009-1980)<<25)
;;;328              | ( 9<<21)
;;;329              | (15<<16)
;;;330              | (17<<11)
;;;331              | (45<<5)
;;;332              | ((59/2)<<0);
;;;333    
;;;334        return time;
;;;335    }
00022a  4770              BX       lr
;;;336    
                          ENDP

                  |L1.556|
                          DCD      medias
                  |L1.560|
000230  5b313b31          DCB      "[1;1;31mE: ",0
000234  3b33316d
000238  453a2000
                  |L1.572|
00023c  5b6d00            DCB      "[m",0
00023f  00                DCB      0
                  |L1.576|
000240  4d45445f          DCB      "MED_Read pb: 0x%X\n\r",0
000244  52656164
000248  2070623a
00024c  20307825
000250  580a0d00
                  |L1.596|
000254  0a0d00            DCB      "\n\r",0
000257  00                DCB      0
                  |L1.600|
000258  4d45445f          DCB      "MED_Write pb: 0x%X\n\r",0
00025c  57726974
000260  65207062
000264  3a203078
000268  25580a0d
00026c  00      
00026d  00                DCB      0
00026e  00                DCB      0
00026f  00                DCB      0
                  |L1.624|
                          DCD      0x3b2f8dbd
