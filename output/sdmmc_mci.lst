L 1 "atmel\sdmmc_mci.c"
N/* ----------------------------------------------------------------------------
N *         ATMEL Microcontroller Software Support
N * ----------------------------------------------------------------------------
N * Copyright (c) 2008, Atmel Corporation
N
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N * - Redistributions of source code must retain the above copyright notice,
N * this list of conditions and the disclaimer below.
N *
N * Atmel's name may not be used to endorse or promote products derived from
N * this software without specific prior written permission.
N *
N * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
N * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
N * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
N * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
N * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
N * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
N * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
N * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * ----------------------------------------------------------------------------
N */
N
N//------------------------------------------------------------------------------
N//         Headers
N//------------------------------------------------------------------------------
N
N#include "sdmmc_mci.h"
L 1 "atmel\sdmmc_mci.h" 1
N/* ----------------------------------------------------------------------------
N *         ATMEL Microcontroller Software Support
N * ----------------------------------------------------------------------------
N * Copyright (c) 2008, Atmel Corporation
N
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N * - Redistributions of source code must retain the above copyright notice,
N * this list of conditions and the disclaimer below.
N *
N * Atmel's name may not be used to endorse or promote products derived from
N * this software without specific prior written permission.
N *
N * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
N * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
N * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
N * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
N * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
N * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
N * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
N * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * ----------------------------------------------------------------------------
N */
N
N//------------------------------------------------------------------------------
N/// \page "sdcard sd mode initialization and identification"
N///
N/// !Purpose
N/// 
N/// sdcard sd mode initialization and identification sequence
N///
N/// !Description
N/// - Host sends Cmd0 to do card reset, card is in "idle state".
N/// - Host sends Cmd8 and checks the response of the card, only sdcard supports physical
N///    layer version 2.00 will response correctly to Cmd8, and this command is mandatory to be
N///    sent before ACmd41 for sdcard which support physical layer version 2.00, to enable new
N///    functions or to validate a dual-voltage card.
N///       - refer to "If Cmd8 response ok" branch for the initialize of sdcard 2.0.
N///       - refer to "If Cmd8 response fail" branch for the initialize of sdcard 1.x, mmc card, sdcard2.0
N///          with invalid voltage.
N/// - If Cmd8 response ok
N///       - Host sends ACmd41* with argument "HCS" equal to "1". 
N///       - If the response to ACmd41 failed, it means the card does not match the voltage 
N///          desired by the host, the card will be put into inactive state, initialize ends.
N///       - If the response with "CCS" equal to "1", the card is a version 2.0 high capacity sdcard, 
N///          refer to "Card Initialize" for the succeeding initialize sequence.
N///       - If the response with "CCS" equal to "0", the card is a version 2.0 standard capacity sdcard.
N///          refer to "Card Initialize" for the succeeding initialize sequence.
N/// - If Cmd8 response fail
N///       - Host sends ACmd41* argument "HCS" equal to "0".
N///       - If the response to ACmd41 ok, the card is a version 1.x sdcard, refer to "Card Initialize" for 
N///          the succeeding initialize sequence.
N///       - If the response to ACmd41 fails
N///          - Host sends Cmd0 to reset card.
N///          - Host sends Cmd1 with argument "hdSupport" equal to "1" to card.
N///          - If card has response to Cmd1, the card is a MMC card, refer to "Card Initialize" for the 
N///             succeeding initialize sequence. Furthermore, if the response with bit[30:29] equal to 
N///             "00" or "11", the card is a High Density MMC, else the card is a standard MMC.
N///          - If card has no response to Cmd1, the card is either an unknown card or a card does 
N///             not match host's voltage, the initialize ends.
N/// - Card Initialize
N///       - Host sends Cmd2 to get the its unique card identification number (CID).
N///       - Host sends Cmd3 to ask the card to publish a new relative card address (RCA), once the 
N///          RCA is received the card state changes to the "stand-by state".
N///       - Host sends Cmd9 to get the Card Specific Data (CSD).
N///       - At this stage, the initialization and identification process is over, the following steps are done 
N///          for the sdcard's succeeding operation.
N///       - Host sends Cmd13 to obtain the card status, make sure the card is "ready-for-data".
N///       - Host sends Cmd7 to transit card in "transfer state".
N///       - If card is a sdcard*, hosts send ACmd6 to set bus to 4-wire mode.
N///       - If card is a mmc card, the bus is set as 1-wire mode.
N///
N///     \note Send Cmd55 before send ACmd41. \endnote
N///     \note sdcard include ver 1.x sdcard, ver2.0 standard capacity sdcard, ver2.0 high capacity sdcard \endnote
N//------------------------------------------------------------------------------
N
N//------------------------------------------------------------------------------
N/// \page "sdcard sd mode write"
N///
N/// !Purpose
N/// 
N/// sdcard sd mode write process
N///
N/// !Description
N/// - Make sure sdcard is under "transfer state", if the sdcard is under other state, host will send
N///    Cmd12 to stop the current operation and to transit sdcard to "stand-by state".
N/// - Host sends Cmd13 to check sdcard's status, to make sure sdcard is "ready-for-data".
N/// - Host sends Cmd25 to do multiple blocks write, the address here is different between high capacity
N///    sdcard and normal sdcard, the address of SDHC is equal to the block number, while normal sdcard's
N///    address is equal to  block number times 512.
N///
N/// !Write Optimization
N/// - To optimize the write multiple blocks, try to keep the sdcard in the "rcv state" as long as possible.
N///    after send WRITE_MULTIPLE_BLOCK command, set the block number in the MCI_BLKR as 0, each time a 
N///    new write start, do not re-send the WRITE_MULTIPLE_BLOCK command, just re-configure the PDC. In 
N///    this case, host does not have to send STOP_TRANSMISSION to transfer the sdcard's state and the
N///    performance is optimized.
N/// - MoveToTransferState will check the state of the sdcard, and send STOP_TRANSMISSION if need
N///   to transfer state. Normally this function is called between the state tranfer.
N/// - ContinuousWrite will be called if WRITE_MULTIPLE_BLOCK already been sent and this function
N///    will not re-send the write command, but will re-configure PDC accordingly.
N//------------------------------------------------------------------------------
N
N//------------------------------------------------------------------------------
N/// \page "sdcard sd mode read"
N///
N/// !Purpose
N/// 
N/// sdcard sd mode read process
N///
N/// !Description
N/// - Make sure sdcard is under "transfer state", if the sdcard is under other state, host will send
N///    Cmd12 to stop the current operation and to transit sdcard to "stand-by state".
N/// - Host sends Cmd13 to check sdcard's status, to make sure sdcard is "ready-for-data".
N/// - Host sends Cmd18 to do multiple blocks read, the address here is different between high capacity
N///    sdcard and normal sdcard, the address of SDHC is equal to the block number, while normal sdcard's
N///    address is equal to  block number times 512.
N/// 
N/// !Read Optimization
N/// - To optimize the read multiple blocks, try to keep the sdcard in the "data state" as long as possible.
N///    after send READ_MULTIPLE_BLOCK command, set the block number in the MCI_BLKR as 0, each time a 
N///    new read start, do not re-send the READ_MULTIPLE_BLOCK command, just re-configure the PDC. In this
N///    case, host does not have to send STOP_TRANSMISSION to transfer the sdcard's state and the
N///    performance is optimized.
N/// - MoveToTransferState will check the state of the sdcard, and send STOP_TRANSMISSION if need
N///   to transfer state. Normally this function is called between the state tranfer.
N/// - ContinuousRead will be called if READ_MULTIPLE_BLOCK already been sent and this function
N///    will not re-send the read command, but will re-configure PDC accordingly.
N//------------------------------------------------------------------------------
N
N//------------------------------------------------------------------------------
N/// \page "sdhc"
N///
N/// !Purpose
N/// 
N/// highlight of sdhc
N///
N/// !Sdhc initialization and identification
N///
N///   - Refer to page "sdcard sd mode initialization and identification" for the initialization and identification
N///       sequence of a sdhc.
N/// 
N/// !Functional difference between sdhc and standard capacity sdcard
N///
N/// - Command argument is different:
N///   - Sdhc uses block address format in memory access commands*, block length is fixed to 512 bytes.
N///   - Standard capacity sdcard uses byte address format in memory access commands, block length
N///       is defined in Cmd16.
N/// - Partial access and misalign access are disabled in sdhc as the block address is used.
N/// - Sdhc does not support write-protected commands (Cmd28, Cmd29, Cmd30).
N///
N/// \note Memory access commands means block read commands (CMD17, CMD18), block write commands 
N///   (CMD24, CMD25), and block erase commands (CMD32, CMD33).
N///
N//------------------------------------------------------------------------------
N
N//------------------------------------------------------------------------------
N/// \page "sdmmc_mci"
N///
N/// !Purpose
N/// 
N/// Implementation for sdcard sd mode physical layer driver. Supply a set of sdcard sd mode's
N/// interface.
N///
N/// !Usage
N///
N/// -# SD_Init: Run the SDcard initialization sequence
N/// -# SD_MCI_Init : Run the SDcard SD Mode initialization sequence
N/// -# SD_Stop: Stop the SDcard by sending Cmd12
N/// -# SD_ReadBlock : Read blocks of data
N/// -# SD_WriteBlock : Write blocks of data
N/// -# Cmd0 : Resets all cards to idle state
N/// -# Cmd1 : MMC send operation condition command
N/// -# Cmd2 : Asks any card to send the CID numbers on the CMD line
N/// -# Cmd3 : Ask the card to publish a new relative address
N/// -# Cmd7 : Command toggles a card between the stand-by and transfer states or between
N///                the programming and disconnect states
N/// -# Cmd8 : Sends SD Memory Card interface condition, which includes host supply voltage 
N///                information and asks the card whether card supports voltage
N/// -# Cmd9 : Addressed card sends its card-specific data (CSD) on the CMD line
N/// -# Cmd12 : Forces the card to stop transmission
N/// -# Cmd13 : Addressed card sends its status register
N/// -# Cmd16 : Set block length
N/// -# Cmd18 : Read multiple blocks
N/// -# Cmd25 : Write multiple blocks
N/// -# Cmd55 : App command, should be sent before application specific command
N/// -# Acmd6 : Defines the data bus width 
N/// -# Acmd41 : Asks to all cards to send their operations conditions
N/// -# CmdEMMC8 : Sends eMMC EXT_CSD command
N/// -# CmdEMMC6 : Switches the mode of operation of the selected card or modifies the
N///                        EXT_CSD registers
N//------------------------------------------------------------------------------
N
N#ifndef SDMMC_MCI_H
N#define SDMMC_MCI_H
N
N//------------------------------------------------------------------------------
N//         Header
N//------------------------------------------------------------------------------
N
N#include <board.h>
L 1 ".\atmel\board.h" 1
N/* ----------------------------------------------------------------------------
N *         ATMEL Microcontroller Software Support
N * ----------------------------------------------------------------------------
N * Copyright (c) 2008, Atmel Corporation
N *
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N * - Redistributions of source code must retain the above copyright notice,
N * this list of conditions and the disclaimer below.
N *
N * Atmel's name may not be used to endorse or promote products derived from
N * this software without specific prior written permission.
N *
N * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
N * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
N * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
N * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
N * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
N * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
N * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
N * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * ----------------------------------------------------------------------------
N */
N
N//------------------------------------------------------------------------------
N/// \dir
N/// !Purpose
N///
N/// Definition and functions for using AT91SAM9M10-related features, such
N/// has PIO pins, memories, etc.
N///
N/// !Usage
N/// -# The code for booting the board is provided by board_cstartup.S and
N///    board_lowlevel.c.
N/// -# For using board PIOs, board characteristics (clock, etc.) and external
N///    components, see board.h.
N/// -# For manipulating memories (remapping, SDRAM, etc.), see board_memories.h.
N//------------------------------------------------------------------------------
N
N//------------------------------------------------------------------------------
N/// \unit
N/// !Purpose
N///
N/// Definition of AT91SAM9M10-EK characteristics, AT91SAM9M10-dependant PIOs and
N/// external components interfacing.
N///
N/// !Usage
N/// -# For operating frequency information, see "SAM9M10-EK - Operating frequencies".
N/// -# For using portable PIO definitions, see "SAM9M10-EK - PIO definitions".
N/// -# Several USB definitions are included here (see "SAM9M10-EK - USB device").
N/// -# For external components definitions, see "SAM79260-EK - External components".
N/// -# For memory-related definitions, see "SAM79260-EK - Memories".
N//------------------------------------------------------------------------------
N
N#ifndef BOARD_H
N#define BOARD_H
N
N//------------------------------------------------------------------------------
N//         Headers
N//------------------------------------------------------------------------------
N
N
N    #include "chip.h"
L 1 ".\atmel\chip.h" 1
N/* ----------------------------------------------------------------------------
N *         ATMEL Microcontroller Software Support 
N * ----------------------------------------------------------------------------
N * Copyright (c) 2008, Atmel Corporation
N *
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N * - Redistributions of source code must retain the above copyright notice,
N * this list of conditions and the disclaimer below.
N *
N * Atmel's name may not be used to endorse or promote products derived from
N * this software without specific prior written permission.
N *
N * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
N * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
N * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
N * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
N * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
N * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
N * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
N * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * ----------------------------------------------------------------------------
N */
N 
N//------------------------------------------------------------------------------
N/// \unit
N/// !Purpose
N///
N/// Definition of AT91SAM9M10 characteristics and features
N///
N/// !Usage
N/// -# For ARM core feature, see "AT91SAM9M10 - ARM core features".
N/// -# For IP features, see "AT91SAM9M10 - IP features".
N/// -# For misc, see "AT91SAM9M10 - Misc".
N//------------------------------------------------------------------------------
N 
N#ifndef CHIP_H 
N#define CHIP_H
N
N//------------------------------------------------------------------------------
N//         Headers
N//------------------------------------------------------------------------------
N
N//------------------------------------------------------------------------------
N//         Definitions
N//------------------------------------------------------------------------------
N
N//------------------------------------------------------------------------------
N/// \page "AT91SAM9M10 - ARM core features"
N/// This page lists several characteristics related to the ARM core
N///
N
N//ARM core features
N
N/// ARM core definition.
N#define arm926ej_s
N
N/// family definition.
N//#define at91sam9m10 (already defined)
N
N/// temporary define, to be removed
N#define CP15_PRESENT
N
N//------------------------------------------------------------------------------
N/// \page "AT91SAM9M10 - IP features"
N/// This page lists several characteristics related to the embedded IP
N///
N
N//IP FEATURES
N
N// DMA channels number
N#define CHIP_DMA_CHANNEL_NUM   8
N
N// Indicate chip's MCI interface. 
N#define MCI2_INTERFACE
N
N/// Indicates chip has an UDP High Speed. 
N#define CHIP_USB_UDPHS 
N
N/// Indicates chip has an Host High Speed. 
N#define CHIP_USB_UHP_OHCI 
N#define CHIP_USB_UHP_EHCI 
N
N/// Indicates chip has an internal pull-up. 
N#define CHIP_USB_PULLUP_INTERNAL 
N
N/// Number of USB endpoints 
N#define CHIP_USB_NUMENDPOINTS 7 
N
N/// Endpoints max paxcket size 
N#define CHIP_USB_ENDPOINTS_MAXPACKETSIZE(i) \
N   ((i == 0) ? 64 : \
N   ((i == 1) ? 1024 : \
N   ((i == 2) ? 1024 : \
N   ((i == 3) ? 1024 : \
N   ((i == 4) ? 1024 : \
N   ((i == 5) ? 1024 : \
N   ((i == 6) ? 1024 : 0 )))))))
X#define CHIP_USB_ENDPOINTS_MAXPACKETSIZE(i)    ((i == 0) ? 64 :    ((i == 1) ? 1024 :    ((i == 2) ? 1024 :    ((i == 3) ? 1024 :    ((i == 4) ? 1024 :    ((i == 5) ? 1024 :    ((i == 6) ? 1024 : 0 )))))))
N
N/// Endpoints Number of Bank 
N#define CHIP_USB_ENDPOINTS_BANKS(i) \
N   ((i == 0) ? 1 : \
N   ((i == 1) ? 2 : \
N   ((i == 2) ? 2 : \
N   ((i == 3) ? 3 : \
N   ((i == 4) ? 3 : \
N   ((i == 5) ? 3 : \
N   ((i == 6) ? 3 : 0 )))))))
X#define CHIP_USB_ENDPOINTS_BANKS(i)    ((i == 0) ? 1 :    ((i == 1) ? 2 :    ((i == 2) ? 2 :    ((i == 3) ? 3 :    ((i == 4) ? 3 :    ((i == 5) ? 3 :    ((i == 6) ? 3 : 0 )))))))
N
N/// Endpoints max paxcket size 
N#define CHIP_USB_ENDPOINTS_DMA(i) \
N   ((i == 1) ? 1 : \
N   ((i == 2) ? 1 : \
N   ((i == 3) ? 1 : \
N   ((i == 4) ? 1 : \
N   ((i == 5) ? 1 : \
N   ((i == 6) ? 1 : 0 ))))))
X#define CHIP_USB_ENDPOINTS_DMA(i)    ((i == 1) ? 1 :    ((i == 2) ? 1 :    ((i == 3) ? 1 :    ((i == 4) ? 1 :    ((i == 5) ? 1 :    ((i == 6) ? 1 : 0 ))))))
N
N//------------------------------------------------------------------------------
N/// \page "AT91SAM9M10 - Misc "
N/// This page lists misc features
N///
N
N//Misc 
N
N#endif //#ifndef CHIP_H
N
L 69 ".\atmel\board.h" 2
N    #include "AT91SAM9M10.h"
L 1 ".\atmel\AT91SAM9M10.h" 1
N//  ----------------------------------------------------------------------------
N//          ATMEL Microcontroller Software Support  -  ROUSSET  -
N//  ----------------------------------------------------------------------------
N//  Copyright (c) 2009, Atmel Corporation
N// 
N//  All rights reserved.
N// 
N//  Redistribution and use in source and binary forms, with or without
N//  modification, are permitted provided that the following conditions are met:
N// 
N//  - Redistributions of source code must retain the above copyright notice,
N//  this list of conditions and the disclaimer below.
N// 
N//  Atmel's name may not be used to endorse or promote products derived from
N//  this software without specific prior written permission. 
N//  
N//  DISCLAIMER:  THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
N//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
N//  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
N//  DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
N//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
N//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
N//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
N//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N//  ----------------------------------------------------------------------------
N// File Name           : AT91SAM9M10.h
N// Object              : AT91SAM9M10 definitions
N// Generated           : AT91 SW Application Group  03/29/2010 (13:41:42)
N// 
N// CVS Reference       : /AT91SAM9M10.pl/1.3/Fri Mar 26 09:51:19 2010//
N// CVS Reference       : /SYS_SAM9264.pl/1.2/Tue Oct  2 12:19:30 2007//
N// CVS Reference       : /HMATRIX2_SAM9264.pl/1.5/Fri Aug 31 13:13:12 2007//
N// CVS Reference       : /CCR_SAM9264.pl/1.6/Fri Feb 29 14:02:52 2008//
N// CVS Reference       : /PMC_SAM9264.pl/1.9/Thu Nov 29 09:55:11 2007//
N// CVS Reference       : /HDDRSDRC2_6304B.pl/1.5/Fri Mar 12 10:40:41 2010//
N// CVS Reference       : /EBI_SAM9260.pl/1.1/Fri Sep 30 12:12:14 2005//
N// CVS Reference       : /HSMC3_SAM9264.pl/1.1/Wed Oct 10 09:39:31 2007//
N// CVS Reference       : /HECC_6143A.pl/1.1/Wed Feb  9 17:16:57 2005//
N// CVS Reference       : /SFR_SAM9264.pl/1.4/Fri Feb 29 14:02:55 2008//
N// CVS Reference       : /AIC_6075A.pl/1.1/Mon Jul 12 17:04:01 2004//
N// CVS Reference       : /PDC_6074C.pl/1.2/Thu Feb  3 09:02:11 2005//
N// CVS Reference       : /DBGU_6059D.pl/1.2/Mon Mar 29 11:07:19 2010//
N// CVS Reference       : /PIO_SAM9264.pl/1.1/Wed Oct 10 09:38:26 2007//
N// CVS Reference       : /RSTC_6098A.pl/1.4/Fri Oct 17 13:27:55 2008//
N// CVS Reference       : /SHDWC_6122A.pl/1.3/Wed Oct  6 14:16:58 2004//
N// CVS Reference       : /RTTC_6081A.pl/1.2/Thu Nov  4 13:57:22 2004//
N// CVS Reference       : /PITC_6079A.pl/1.2/Thu Nov  4 13:56:22 2004//
N// CVS Reference       : /WDTC_6080A.pl/1.3/Thu Nov  4 13:58:52 2004//
N// CVS Reference       : /TC_6082A.pl/1.8/Fri Oct 17 13:27:58 2008//
N// CVS Reference       : /MCI_6101F.pl/1.3/Fri Jan 23 09:15:32 2009//
N// CVS Reference       : /TWI_6061B.pl/1.3/Fri Oct 17 13:27:59 2008//
N// CVS Reference       : /US_6089S.pl/1.1/Mon Mar 29 11:03:23 2010//
N// CVS Reference       : /SSC_6078B.pl/1.3/Fri Oct 17 13:27:57 2008//
N// CVS Reference       : /SPI_6088D.pl/1.3/Fri May 20 14:23:02 2005//
N// CVS Reference       : /AC97C_XXXX.pl/1.3/Tue Feb 22 17:08:27 2005//
N// CVS Reference       : /PWM_6044D.pl/1.2/Tue May 10 12:39:09 2005//
N// CVS Reference       : /LCDC_6063A.pl/1.6/Tue Jan 20 16:29:59 2009//
N// CVS Reference       : /HDMA_SAM9264.pl/1.2/Thu Sep 13 11:48:30 2007//
N// CVS Reference       : /UDPHS_SAM9_7ept6dma4iso.pl/1.4/Tue Jun 24 13:05:14 2008//
N// CVS Reference       : /TSC_SAM9264.pl/1.2/Thu Jun 25 08:43:26 2009//
N// CVS Reference       : /RTC_1245D.pl/1.3/Fri Sep 17 14:01:31 2004//
N// CVS Reference       : /EMACB_SAM9264.pl/1.1/Tue Sep 25 12:07:23 2007//
N// CVS Reference       : /uhphs_ohci.pl/1.1/Fri Jun 22 14:20:34 2007//
N// CVS Reference       : /uhphs_ehci.pl/1.3/Tue Jul 17 07:50:29 2007//
N// CVS Reference       : /VDEC_7190.pl/1.2/Fri Aug 31 15:21:50 2007//
N// CVS Reference       : /ISI_SAM9264.pl/1.2/Wed Sep  3 08:30:55 2008//
N// CVS Reference       : /TRNG_xxxxx.pl/1.1/Wed Jul 18 12:02:58 2007//
N//  ----------------------------------------------------------------------------
N
N#ifndef AT91SAM9M10_H
N#define AT91SAM9M10_H
N
N#ifndef __ASSEMBLY__
Ntypedef volatile unsigned int AT91_REG;// Hardware register definition
N#define AT91_CAST(a) (a)
N#else
S#define AT91_CAST(a)
N#endif
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR SPECIAL FUNCTION REGISTER
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_SFR {
N	AT91_REG	 SFR_EMA; 	// memory Extra Margin Adjustment control
N	AT91_REG	 SFR_DDRCFG; 	// DDR2 SSTL18 control
N	AT91_REG	 SFR_DDRDELAY; 	// DDR2 controller clock delay
N	AT91_REG	 SFR_EBIDELAY; 	// EBI DDR controller clock delay
N	AT91_REG	 SFR_UTMICFG; 	// UTMI Software Reset, and OHCI suspend interrupt control
N	AT91_REG	 SFR_INT; 	// OHCI suspend Interrupt status
N} AT91S_SFR, *AT91PS_SFR;
N#else
S#define SFR_EMA         (AT91_CAST(AT91_REG *) 	0x00000000) // (SFR_EMA) memory Extra Margin Adjustment control
S#define SFR_DDRCFG      (AT91_CAST(AT91_REG *) 	0x00000004) // (SFR_DDRCFG) DDR2 SSTL18 control
S#define SFR_DDRDELAY    (AT91_CAST(AT91_REG *) 	0x00000008) // (SFR_DDRDELAY) DDR2 controller clock delay
S#define SFR_EBIDELAY    (AT91_CAST(AT91_REG *) 	0x0000000C) // (SFR_EBIDELAY) EBI DDR controller clock delay
S#define SFR_UTMICFG     (AT91_CAST(AT91_REG *) 	0x00000010) // (SFR_UTMICFG) UTMI Software Reset, and OHCI suspend interrupt control
S#define SFR_OHCI_SUSP_INT (AT91_CAST(AT91_REG *) 	0x00000014) // (SFR_OHCI_SUSP_INT) OHCI suspend Interrupt status
S
N#endif
N// -------- SFR_EMA : (SFR Offset: 0x0) memory Extra Margin Adjustment control register -------- 
N#define AT91C_SFR_RAM_EMA     (0x7 <<  0) // (SFR) SRAM EMA
N#define 	AT91C_SFR_RAM_EMA_0                    (0x0) // (SFR) Normal Mode
N#define 	AT91C_SFR_RAM_EMA_1                    (0x1) // (SFR) DEBUG MODE 1
N#define 	AT91C_SFR_RAM_EMA_2                    (0x2) // (SFR) DEBUG MODE 2
N#define 	AT91C_SFR_RAM_EMA_3                    (0x3) // (SFR) DEBUG MODE 3
N#define 	AT91C_SFR_RAM_EMA_4                    (0x4) // (SFR) DEBUG MODE 4
N#define 	AT91C_SFR_RAM_EMA_5                    (0x5) // (SFR) DEBUG MODE 5
N#define 	AT91C_SFR_RAM_EMA_6                    (0x6) // (SFR) DEBUG MODE 6
N#define 	AT91C_SFR_RAM_EMA_7                    (0x7) // (SFR) DEBUG MODE 7
N#define AT91C_SFR_DPRAM_EMA   (0x7 <<  4) // (SFR) SRAM EMA
N#define 	AT91C_SFR_DPRAM_EMA_0                    (0x0 <<  4) // (SFR) Normal Mode
N#define 	AT91C_SFR_DPRAM_EMA_1                    (0x1 <<  4) // (SFR) DEBUG MODE 1
N#define 	AT91C_SFR_DPRAM_EMA_2                    (0x2 <<  4) // (SFR) DEBUG MODE 2
N#define 	AT91C_SFR_DPRAM_EMA_3                    (0x3 <<  4) // (SFR) DEBUG MODE 3
N#define 	AT91C_SFR_DPRAM_EMA_4                    (0x4 <<  4) // (SFR) DEBUG MODE 4
N#define 	AT91C_SFR_DPRAM_EMA_5                    (0x5 <<  4) // (SFR) DEBUG MODE 5
N#define 	AT91C_SFR_DPRAM_EMA_6                    (0x6 <<  4) // (SFR) DEBUG MODE 6
N#define 	AT91C_SFR_DPRAM_EMA_7                    (0x7 <<  4) // (SFR) DEBUG MODE 7
N#define AT91C_SFR_RF_EMA      (0x7 <<  8) // (SFR) SRAM EMA
N#define 	AT91C_SFR_RF_EMA_0                    (0x0 <<  8) // (SFR) Normal Mode
N#define 	AT91C_SFR_RF_EMA_1                    (0x1 <<  8) // (SFR) DEBUG MODE 1
N#define 	AT91C_SFR_RF_EMA_2                    (0x2 <<  8) // (SFR) DEBUG MODE 2
N#define 	AT91C_SFR_RF_EMA_3                    (0x3 <<  8) // (SFR) DEBUG MODE 3
N#define 	AT91C_SFR_RF_EMA_4                    (0x4 <<  8) // (SFR) DEBUG MODE 4
N#define 	AT91C_SFR_RF_EMA_5                    (0x5 <<  8) // (SFR) DEBUG MODE 5
N#define 	AT91C_SFR_RF_EMA_6                    (0x6 <<  8) // (SFR) DEBUG MODE 6
N#define 	AT91C_SFR_RF_EMA_7                    (0x7 <<  8) // (SFR) DEBUG MODE 7
N#define AT91C_SFR_DPRF_EMA    (0x7 << 12) // (SFR) SRAM EMA
N#define 	AT91C_SFR_DPRF_EMA_0                    (0x0 << 12) // (SFR) Normal Mode
N#define 	AT91C_SFR_DPRF_EMA_1                    (0x1 << 12) // (SFR) DEBUG MODE 1
N#define 	AT91C_SFR_DPRF_EMA_2                    (0x2 << 12) // (SFR) DEBUG MODE 2
N#define 	AT91C_SFR_DPRF_EMA_3                    (0x3 << 12) // (SFR) DEBUG MODE 3
N#define 	AT91C_SFR_DPRF_EMA_4                    (0x4 << 12) // (SFR) DEBUG MODE 4
N#define 	AT91C_SFR_DPRF_EMA_5                    (0x5 << 12) // (SFR) DEBUG MODE 5
N#define 	AT91C_SFR_DPRF_EMA_6                    (0x6 << 12) // (SFR) DEBUG MODE 6
N#define 	AT91C_SFR_DPRF_EMA_7                    (0x7 << 12) // (SFR) DEBUG MODE 7
N#define AT91C_SFR_ROM_EMA     (0x7 << 16) // (SFR) SRAM EMA
N#define 	AT91C_SFR_ROM_EMA_0                    (0x0 << 16) // (SFR) Normal Mode
N#define 	AT91C_SFR_ROM_EMA_1                    (0x1 << 16) // (SFR) DEBUG MODE 1
N#define 	AT91C_SFR_ROM_EMA_2                    (0x2 << 16) // (SFR) DEBUG MODE 2
N#define 	AT91C_SFR_ROM_EMA_3                    (0x3 << 16) // (SFR) DEBUG MODE 3
N#define 	AT91C_SFR_ROM_EMA_4                    (0x4 << 16) // (SFR) DEBUG MODE 4
N#define 	AT91C_SFR_ROM_EMA_5                    (0x5 << 16) // (SFR) DEBUG MODE 5
N#define 	AT91C_SFR_ROM_EMA_6                    (0x6 << 16) // (SFR) DEBUG MODE 6
N#define 	AT91C_SFR_ROM_EMA_7                    (0x7 << 16) // (SFR) DEBUG MODE 7
N// -------- SFR_DDRCFG : (SFR Offset: 0x4) DDR2 SSTL18 control register -------- 
N#define AT91C_SFR_DDRCFG_SSTL (0x1 <<  0) // (SFR) Control DDR2 pads SSTL mode control
N#define 	AT91C_SFR_DDRCFG_SSTL_NORMAL               (0x0) // (SFR) Force pads in SSTL18 mode when DDR2 is connected
N#define 	AT91C_SFR_DDRCFG_SSTL_COMPATIBLE           (0x1) // (SFR) LVCMOS level (compatible SSTL18)
N#define AT91C_SFR_DDRCFG_CLKDELAY (0x1 <<  8) // (SFR) Control DDR2 pads clocks delay on clk, dqs0, dqs1
N#define 	AT91C_SFR_DDRCFG_CLKDELAY_HARD                 (0x0 <<  8) // (SFR) Fixed by hardware
N#define 	AT91C_SFR_DDRCFG_CLKDELAY_SOFT                 (0x1 <<  8) // (SFR) Software must write correct delay value
N// -------- SFR_DDRDELAY : (SFR Offset: 0x8) DDR2 controller clock delay -------- 
N#define AT91C_SFR_DDRDELAY_CLK (0xFF <<  0) // (SFR) Control CLK clock delay
N#define 	AT91C_SFR_DDRDELAY_CLK_0                    (0x0) // (SFR) minimum delay
N#define 	AT91C_SFR_DDRDELAY_CLK_1                    (0x1) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_CLK_2                    (0x2) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_CLK_3                    (0x3) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_CLK_4                    (0x4) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_CLK_5                    (0x5) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_CLK_6                    (0x6) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_CLK_7                    (0x7) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_CLK_8                    (0x8) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_CLK_9                    (0x9) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_CLK_10                   (0xA) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_CLK_11                   (0xB) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_CLK_12                   (0xC) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_CLK_13                   (0xD) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_CLK_14                   (0xE) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_CLK_15                   (0xF) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_CLK_16                   (0x10) // (SFR) 
N#define AT91C_SFR_DDRDELAY_DQS0 (0xFF <<  8) // (SFR) Control DQS0 clock delay
N#define 	AT91C_SFR_DDRDELAY_DQS0_0                    (0x0 <<  8) // (SFR) minimum delay
N#define 	AT91C_SFR_DDRDELAY_DQS0_1                    (0x1 <<  8) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS0_2                    (0x2 <<  8) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS0_3                    (0x3 <<  8) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS0_4                    (0x4 <<  8) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS0_5                    (0x5 <<  8) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS0_6                    (0x6 <<  8) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS0_7                    (0x7 <<  8) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS0_8                    (0x8 <<  8) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS0_9                    (0x9 <<  8) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS0_10                   (0xA <<  8) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS0_11                   (0xB <<  8) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS0_12                   (0xC <<  8) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS0_13                   (0xD <<  8) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS0_14                   (0xE <<  8) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS0_15                   (0xF <<  8) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS0_16                   (0x10 <<  8) // (SFR) 
N#define AT91C_SFR_DDRDELAY_DQS1 (0xFF << 16) // (SFR) Control DQS1 clock delay
N#define 	AT91C_SFR_DDRDELAY_DQS1_0                    (0x0 << 16) // (SFR) minimum delay
N#define 	AT91C_SFR_DDRDELAY_DQS1_1                    (0x1 << 16) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS1_2                    (0x2 << 16) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS1_3                    (0x3 << 16) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS1_4                    (0x4 << 16) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS1_5                    (0x5 << 16) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS1_6                    (0x6 << 16) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS1_7                    (0x7 << 16) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS1_8                    (0x8 << 16) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS1_9                    (0x9 << 16) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS1_10                   (0xA << 16) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS1_11                   (0xB << 16) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS1_12                   (0xC << 16) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS1_13                   (0xD << 16) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS1_14                   (0xE << 16) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS1_15                   (0xF << 16) // (SFR) 
N#define 	AT91C_SFR_DDRDELAY_DQS1_16                   (0x10 << 16) // (SFR) 
N// -------- SFR_EBIDELAY : (SFR Offset: 0xc) EBI DDR controller clock delay -------- 
N#define AT91C_SFR_EBIDELAY_CLK (0xFF <<  0) // (SFR) Control CLK clock delay
N#define 	AT91C_SFR_EBIDELAY_CLK_0                    (0x0) // (SFR) minimum delay
N#define 	AT91C_SFR_EBIDELAY_CLK_1                    (0x1) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_CLK_2                    (0x2) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_CLK_3                    (0x3) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_CLK_4                    (0x4) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_CLK_5                    (0x5) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_CLK_6                    (0x6) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_CLK_7                    (0x7) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_CLK_8                    (0x8) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_CLK_9                    (0x9) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_CLK_10                   (0xA) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_CLK_11                   (0xB) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_CLK_12                   (0xC) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_CLK_13                   (0xD) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_CLK_14                   (0xE) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_CLK_15                   (0xF) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_CLK_16                   (0x10) // (SFR) 
N#define AT91C_SFR_EBIDELAY_DQS0 (0xFF <<  8) // (SFR) Control DQS0 clock delay
N#define 	AT91C_SFR_EBIDELAY_DQS0_0                    (0x0 <<  8) // (SFR) minimum delay
N#define 	AT91C_SFR_EBIDELAY_DQS0_1                    (0x1 <<  8) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS0_2                    (0x2 <<  8) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS0_3                    (0x3 <<  8) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS0_4                    (0x4 <<  8) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS0_5                    (0x5 <<  8) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS0_6                    (0x6 <<  8) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS0_7                    (0x7 <<  8) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS0_8                    (0x8 <<  8) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS0_9                    (0x9 <<  8) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS0_10                   (0xA <<  8) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS0_11                   (0xB <<  8) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS0_12                   (0xC <<  8) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS0_13                   (0xD <<  8) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS0_14                   (0xE <<  8) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS0_15                   (0xF <<  8) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS0_16                   (0x10 <<  8) // (SFR) 
N#define AT91C_SFR_EBIDELAY_DQS1 (0xFF << 16) // (SFR) Control DQS1 clock delay
N#define 	AT91C_SFR_EBIDELAY_DQS1_0                    (0x0 << 16) // (SFR) minimum delay
N#define 	AT91C_SFR_EBIDELAY_DQS1_1                    (0x1 << 16) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS1_2                    (0x2 << 16) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS1_3                    (0x3 << 16) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS1_4                    (0x4 << 16) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS1_5                    (0x5 << 16) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS1_6                    (0x6 << 16) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS1_7                    (0x7 << 16) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS1_8                    (0x8 << 16) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS1_9                    (0x9 << 16) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS1_10                   (0xA << 16) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS1_11                   (0xB << 16) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS1_12                   (0xC << 16) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS1_13                   (0xD << 16) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS1_14                   (0xE << 16) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS1_15                   (0xF << 16) // (SFR) 
N#define 	AT91C_SFR_EBIDELAY_DQS1_16                   (0x10 << 16) // (SFR) 
N// -------- SFR_UTMICFG : (SFR Offset: 0x10) UTMI Software Reset -------- 
N#define AT91C_SFR_UTMICFG_PORT0 (0x1 <<  0) // (SFR) UTMI Software Reset port 0
N#define AT91C_SFR_UTMICFG_PORT1 (0x1 <<  1) // (SFR) UTMI Software Reset port 1
N#define AT91C_SFR_UTMICFG_OHCI_SUSP_INT_ENABLE (0x1 <<  2) // (SFR) OHCI Suspend Interrupt enable
N// -------- SFR_OHCI_SUSP_INT : (SFR Offset: 0x14) OHCI suspend Interrupt status -------- 
N#define AT91C_SFR_OHCI_SUSP_INT_STATUS (0x3 <<  0) // (SFR) OHCI suspend Interrupt status
N#define 	AT91C_SFR_OHCI_SUSP_INT_STATUS_PORT0                (0x1) // (SFR) OHCI suspend Interrupt status for port 0
N#define 	AT91C_SFR_OHCI_SUSP_INT_STATUS_PORT1                (0x2) // (SFR) OHCI suspend Interrupt status for port 1
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR System Peripherals
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_SYS {
N	AT91_REG	 Reserved0[3904]; 	// 
N	AT91_REG	 SYS_RSTC_RCR; 	// Reset Control Register
N	AT91_REG	 SYS_RSTC_RSR; 	// Reset Status Register
N	AT91_REG	 SYS_RSTC_RMR; 	// Reset Mode Register
N	AT91_REG	 Reserved1[1]; 	// 
N	AT91_REG	 SYS_SHDWC_SHCR; 	// Shut Down Control Register
N	AT91_REG	 SYS_SHDWC_SHMR; 	// Shut Down Mode Register
N	AT91_REG	 SYS_SHDWC_SHSR; 	// Shut Down Status Register
N	AT91_REG	 Reserved2[1]; 	// 
N	AT91_REG	 SYS_RTTC0_RTMR; 	// Real-time Mode Register
N	AT91_REG	 SYS_RTTC0_RTAR; 	// Real-time Alarm Register
N	AT91_REG	 SYS_RTTC0_RTVR; 	// Real-time Value Register
N	AT91_REG	 SYS_RTTC0_RTSR; 	// Real-time Status Register
N	AT91_REG	 SYS_PITC_PIMR; 	// Period Interval Mode Register
N	AT91_REG	 SYS_PITC_PISR; 	// Period Interval Status Register
N	AT91_REG	 SYS_PITC_PIVR; 	// Period Interval Value Register
N	AT91_REG	 SYS_PITC_PIIR; 	// Period Interval Image Register
N	AT91_REG	 SYS_WDTC_WDCR; 	// Watchdog Control Register
N	AT91_REG	 SYS_WDTC_WDMR; 	// Watchdog Mode Register
N	AT91_REG	 SYS_WDTC_WDSR; 	// Watchdog Status Register
N	AT91_REG	 Reserved3[1]; 	// 
N	AT91_REG	 SYS_SLCKSEL; 	// Slow Clock Selection Register
N	AT91_REG	 Reserved4[3]; 	// 
N	AT91_REG	 SYS_GPBR[4]; 	// General Purpose Register
N	AT91_REG	 Reserved5[16]; 	// 
N	AT91_REG	 RTC_CR; 	// Control Register
N	AT91_REG	 RTC_MR; 	// Mode Register
N	AT91_REG	 RTC_TIMR; 	// Time Register
N	AT91_REG	 RTC_CALR; 	// Calendar Register
N	AT91_REG	 RTC_TIMALR; 	// Time Alarm Register
N	AT91_REG	 RTC_CALALR; 	// Calendar Alarm Register
N	AT91_REG	 RTC_SR; 	// Status Register
N	AT91_REG	 RTC_SCCR; 	// Status Clear Command Register
N	AT91_REG	 RTC_IER; 	// Interrupt Enable Register
N	AT91_REG	 RTC_IDR; 	// Interrupt Disable Register
N	AT91_REG	 RTC_IMR; 	// Interrupt Mask Register
N	AT91_REG	 RTC_VER; 	// Valid Entry Register
N	AT91_REG	 Reserved6[7]; 	// 
N	AT91_REG	 SYS_RSTC_VER; 	// Version Register
N} AT91S_SYS, *AT91PS_SYS;
N#else
S#define SLCKSEL         (AT91_CAST(AT91_REG *) 	0x00003D50) // (SLCKSEL) Slow Clock Selection Register
S#define GPBR            (AT91_CAST(AT91_REG *) 	0x00003D60) // (GPBR) General Purpose Register
S
N#endif
N// -------- SLCKSEL : (SYS Offset: 0x3d50) Slow Clock Selection Register -------- 
N#define AT91C_SLCKSEL_RCEN    (0x1 <<  0) // (SYS) Enable Internal RC Oscillator
N#define AT91C_SLCKSEL_OSC32EN (0x1 <<  1) // (SYS) Enable External Oscillator
N#define AT91C_SLCKSEL_OSC32BYP (0x1 <<  2) // (SYS) Bypass External Oscillator
N#define AT91C_SLCKSEL_OSCSEL  (0x1 <<  3) // (SYS) OSC Selection
N// -------- GPBR : (SYS Offset: 0x3d60) GPBR General Purpose Register -------- 
N#define AT91C_GPBR_GPRV       (0x0 <<  0) // (SYS) General Purpose Register Value
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR External Bus Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_EBI {
N	AT91_REG	 EBI_DUMMY; 	// Dummy register - Do not use
N} AT91S_EBI, *AT91PS_EBI;
N#else
S#define EBI_DUMMY       (AT91_CAST(AT91_REG *) 	0x00000000) // (EBI_DUMMY) Dummy register - Do not use
S
N#endif
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR DDR2/SDRAM Controller
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_HDDRSDRC2 {
N	AT91_REG	 HDDRSDRC2_MR; 	// Mode Register
N	AT91_REG	 HDDRSDRC2_RTR; 	// Refresh Timer Register
N	AT91_REG	 HDDRSDRC2_CR; 	// Configuration Register
N	AT91_REG	 HDDRSDRC2_T0PR; 	// Timing0 Register
N	AT91_REG	 HDDRSDRC2_T1PR; 	// Timing1 Register
N	AT91_REG	 HDDRSDRC2_T2PR; 	// Timing2 Register
N	AT91_REG	 Reserved0[1]; 	// 
N	AT91_REG	 HDDRSDRC2_LPR; 	// Low-power Register
N	AT91_REG	 HDDRSDRC2_MDR; 	// Memory Device Register
N	AT91_REG	 HDDRSDRC2_DLL; 	// DLL Information Register
N	AT91_REG	 HDDRSDRC2_VER; 	// DLL Version Register
N	AT91_REG	 HDDRSDRC2_HS; 	// High Speed Register
N	AT91_REG	 HDDRSDRC2_DELAY1; 	// Pad delay1 Register
N	AT91_REG	 HDDRSDRC2_DELAY2; 	// Pad delay2 Register
N	AT91_REG	 HDDRSDRC2_DELAY3; 	// Pad delay3 Register
N	AT91_REG	 HDDRSDRC2_DELAY4; 	// Pad delay4 Register
N	AT91_REG	 HDDRSDRC2_DELAY5; 	// Pad delay5 Register
N	AT91_REG	 HDDRSDRC2_DELAY6; 	// Pad delay6 Register
N	AT91_REG	 HDDRSDRC2_DELAY7; 	// Pad delay7 Register
N	AT91_REG	 HDDRSDRC2_DELAY8; 	// Pad delay8 Register
N	AT91_REG	 Reserved1[37]; 	// 
N	AT91_REG	 HDDRSDRC2_WPMR; 	// Write Protect Mode Register
N	AT91_REG	 HDDRSDRC2_WPSR; 	// Write Protect Status Register
N	AT91_REG	 Reserved2[4]; 	// 
N	AT91_REG	 HDDRSDRC2_VERSION; 	// Version Register
N} AT91S_HDDRSDRC2, *AT91PS_HDDRSDRC2;
N#else
S#define HDDRSDRC2_MR    (AT91_CAST(AT91_REG *) 	0x00000000) // (HDDRSDRC2_MR) Mode Register
S#define HDDRSDRC2_RTR   (AT91_CAST(AT91_REG *) 	0x00000004) // (HDDRSDRC2_RTR) Refresh Timer Register
S#define HDDRSDRC2_CR    (AT91_CAST(AT91_REG *) 	0x00000008) // (HDDRSDRC2_CR) Configuration Register
S#define HDDRSDRC2_T0PR  (AT91_CAST(AT91_REG *) 	0x0000000C) // (HDDRSDRC2_T0PR) Timing0 Register
S#define HDDRSDRC2_T1PR  (AT91_CAST(AT91_REG *) 	0x00000010) // (HDDRSDRC2_T1PR) Timing1 Register
S#define HDDRSDRC2_T2PR  (AT91_CAST(AT91_REG *) 	0x00000014) // (HDDRSDRC2_T2PR) Timing2 Register
S#define HDDRSDRC2_LPR   (AT91_CAST(AT91_REG *) 	0x0000001C) // (HDDRSDRC2_LPR) Low-power Register
S#define HDDRSDRC2_MDR   (AT91_CAST(AT91_REG *) 	0x00000020) // (HDDRSDRC2_MDR) Memory Device Register
S#define HDDRSDRC2_DLL   (AT91_CAST(AT91_REG *) 	0x00000024) // (HDDRSDRC2_DLL) DLL Information Register
S#define HDDRSDRC2_DLL_VER (AT91_CAST(AT91_REG *) 	0x00000028) // (HDDRSDRC2_DLL_VER) DLL Version Register
S#define HDDRSDRC2_HS    (AT91_CAST(AT91_REG *) 	0x0000002C) // (HDDRSDRC2_HS) High Speed Register
S#define HDDRSDRC2_DELAY1 (AT91_CAST(AT91_REG *) 	0x00000030) // (HDDRSDRC2_DELAY1) Pad delay1 Register
S#define HDDRSDRC2_DELAY2 (AT91_CAST(AT91_REG *) 	0x00000034) // (HDDRSDRC2_DELAY2) Pad delay2 Register
S#define HDDRSDRC2_DELAY3 (AT91_CAST(AT91_REG *) 	0x00000038) // (HDDRSDRC2_DELAY3) Pad delay3 Register
S#define HDDRSDRC2_DELAY4 (AT91_CAST(AT91_REG *) 	0x0000003C) // (HDDRSDRC2_DELAY4) Pad delay4 Register
S#define HDDRSDRC2_DELAY5 (AT91_CAST(AT91_REG *) 	0x00000040) // (HDDRSDRC2_DELAY5) Pad delay5 Register
S#define HDDRSDRC2_DELAY6 (AT91_CAST(AT91_REG *) 	0x00000044) // (HDDRSDRC2_DELAY6) Pad delay6 Register
S#define HDDRSDRC2_DELAY7 (AT91_CAST(AT91_REG *) 	0x00000048) // (HDDRSDRC2_DELAY7) Pad delay7 Register
S#define HDDRSDRC2_DELAY8 (AT91_CAST(AT91_REG *) 	0x0000004C) // (HDDRSDRC2_DELAY8) Pad delay8 Register
S#define HDDRSDRC2_WPMR  (AT91_CAST(AT91_REG *) 	0x000000E4) // (HDDRSDRC2_WPMR) Write Protect Mode Register
S#define HDDRSDRC2_WPSR  (AT91_CAST(AT91_REG *) 	0x000000E8) // (HDDRSDRC2_WPSR) Write Protect Status Register
S#define HDDRSDRC2_VERSION (AT91_CAST(AT91_REG *) 	0x000000FC) // (HDDRSDRC2_VERSION) Version Register
S
N#endif
N// -------- HDDRSDRC2_MR : (HDDRSDRC2 Offset: 0x0) Mode Register -------- 
N#define AT91C_DDRC2_MODE      (0x7 <<  0) // (HDDRSDRC2) DDR/SDRAM Command Mode
N#define 	AT91C_DDRC2_MODE_NORMAL_CMD           (0x0) // (HDDRSDRC2) Normal Mode
N#define 	AT91C_DDRC2_MODE_NOP_CMD              (0x1) // (HDDRSDRC2) Issue a NOP Command at every access
N#define 	AT91C_DDRC2_MODE_PRCGALL_CMD          (0x2) // (HDDRSDRC2) Issue a All Banks Precharge Command at every access
N#define 	AT91C_DDRC2_MODE_LMR_CMD              (0x3) // (HDDRSDRC2) Issue a Load Mode Register at every access
N#define 	AT91C_DDRC2_MODE_RFSH_CMD             (0x4) // (HDDRSDRC2) Issue a Refresh
N#define 	AT91C_DDRC2_MODE_EXT_LMR_CMD          (0x5) // (HDDRSDRC2) Issue an Extended Load Mode Register
N#define 	AT91C_DDRC2_MODE_DEEP_CMD             (0x6) // (HDDRSDRC2) Enter Deep Power Mode
N#define 	AT91C_DDRC2_MODE_Reserved             (0x7) // (HDDRSDRC2) Reserved value
N// -------- HDDRSDRC2_RTR : (HDDRSDRC2 Offset: 0x4) Refresh Timer Register -------- 
N#define AT91C_DDRC2_COUNT     (0xFFF <<  0) // (HDDRSDRC2) Refresh Timer Count
N// -------- HDDRSDRC2_CR : (HDDRSDRC2 Offset: 0x8) Configuration Register -------- 
N#define AT91C_DDRC2_NC        (0x3 <<  0) // (HDDRSDRC2) Number of Column Bits
N#define 	AT91C_DDRC2_NC_DDR9_SDR8            (0x0) // (HDDRSDRC2) DDR 9 Bits | SDR 8 Bits
N#define 	AT91C_DDRC2_NC_DDR10_SDR9           (0x1) // (HDDRSDRC2) DDR 10 Bits | SDR 9 Bits
N#define 	AT91C_DDRC2_NC_DDR11_SDR10          (0x2) // (HDDRSDRC2) DDR 11 Bits | SDR 10 Bits
N#define 	AT91C_DDRC2_NC_DDR12_SDR11          (0x3) // (HDDRSDRC2) DDR 12 Bits | SDR 11 Bits
N#define AT91C_DDRC2_NR        (0x3 <<  2) // (HDDRSDRC2) Number of Row Bits
N#define 	AT91C_DDRC2_NR_11                   (0x0 <<  2) // (HDDRSDRC2) 11 Bits
N#define 	AT91C_DDRC2_NR_12                   (0x1 <<  2) // (HDDRSDRC2) 12 Bits
N#define 	AT91C_DDRC2_NR_13                   (0x2 <<  2) // (HDDRSDRC2) 13 Bits
N#define 	AT91C_DDRC2_NR_14                   (0x3 <<  2) // (HDDRSDRC2) 14 Bits
N#define AT91C_DDRC2_CAS       (0x7 <<  4) // (HDDRSDRC2) CAS Latency
N#define 	AT91C_DDRC2_CAS_2                    (0x2 <<  4) // (HDDRSDRC2) 2 cycles (SDR CAS Latency)
N#define 	AT91C_DDRC2_CAS_3                    (0x3 <<  4) // (HDDRSDRC2) 3 cycles (DDR2 CAS Latency), 3 cycles (SDR CAS Latency)
N#define AT91C_DDRC2_DLL       (0x1 <<  7) // (HDDRSDRC2) DLL Reset
N#define 	AT91C_DDRC2_DLL_RESET_DISABLED       (0x0 <<  7) // (HDDRSDRC2) DLL normal mode
N#define 	AT91C_DDRC2_DLL_RESET_ENABLED        (0x1 <<  7) // (HDDRSDRC2) Reset DLL
N#define AT91C_DDRC2_DIC_DS    (0x1 <<  8) // (HDDRSDRC2) Output driver impedance control
N#define 	AT91C_DDRC2_DIC_DS_NORMAL               (0x0 <<  8) // (HDDRSDRC2) Normal driver strength.
N#define 	AT91C_DDRC2_DIC_DS_WEEK                 (0x1 <<  8) // (HDDRSDRC2) Weak driver strength
N#define AT91C_DDRC2_DIS_DLL   (0x1 <<  9) // (HDDRSDRC2) Disable DLL
N#define 	AT91C_DDRC2_DIS_DLL_ENABLE               (0x0 <<  9) // (HDDRSDRC2) Enable DLL
N#define 	AT91C_DDRC2_DIS_DLL_DISABLE              (0x1 <<  9) // (HDDRSDRC2) Disable DLL
N#define AT91C_DDRC2_OCD       (0x7 << 12) // (HDDRSDRC2) Off chip driver
N#define 	AT91C_DDRC2_OCD_EXIT                 (0x0 << 12) // (HDDRSDRC2) Exit OCD calibration mode.
N#define 	AT91C_DDRC2_OCD_DEFAULT              (0x7 << 12) // (HDDRSDRC2) Program OCD calibration default value.
N#define AT91C_DDRC2_DQMS      (0x1 << 16) // (HDDRSDRC2) Data Mask share
N#define 	AT91C_DDRC2_DQMS_NOT_SHARED           (0x0 << 16) // (HDDRSDRC2) Used DQM bits are not shared
N#define 	AT91C_DDRC2_DQMS_SHARED               (0x1 << 16) // (HDDRSDRC2) Used DQM bits are shared
N#define AT91C_DDRC2_ACTBST    (0x1 << 18) // (HDDRSDRC2) ACTIVE Bank X to Burst Stop Read Access Bank Y
N#define 	AT91C_DDRC2_ACTBST_CAN_ACCESS           (0x0 << 18) // (HDDRSDRC2) After an ACTIVE command in Bank X, BURST STOP command can be issued to another bank to stop current read access.
N#define 	AT91C_DDRC2_ACTBST_NOT_ACCESS           (0x1 << 18) // (HDDRSDRC2) After an ACTIVE command in Bank X, BURST STOP command cannot be issued to another bank to stop current read access.
N// -------- HDDRSDRC2_T0PR : (HDDRSDRC2 Offset: 0xc) Timing0 Register -------- 
N#define AT91C_DDRC2_TRAS      (0xF <<  0) // (HDDRSDRC2) Active to precharge delay
N#define 	AT91C_DDRC2_TRAS_0                    (0x0) // (HDDRSDRC2) Value :  0
N#define 	AT91C_DDRC2_TRAS_1                    (0x1) // (HDDRSDRC2) Value :  1
N#define 	AT91C_DDRC2_TRAS_2                    (0x2) // (HDDRSDRC2) Value :  2
N#define 	AT91C_DDRC2_TRAS_3                    (0x3) // (HDDRSDRC2) Value :  3
N#define 	AT91C_DDRC2_TRAS_4                    (0x4) // (HDDRSDRC2) Value :  4
N#define 	AT91C_DDRC2_TRAS_5                    (0x5) // (HDDRSDRC2) Value :  5
N#define 	AT91C_DDRC2_TRAS_6                    (0x6) // (HDDRSDRC2) Value :  6
N#define 	AT91C_DDRC2_TRAS_7                    (0x7) // (HDDRSDRC2) Value :  7
N#define 	AT91C_DDRC2_TRAS_8                    (0x8) // (HDDRSDRC2) Value :  8
N#define 	AT91C_DDRC2_TRAS_9                    (0x9) // (HDDRSDRC2) Value :  9
N#define 	AT91C_DDRC2_TRAS_10                   (0xA) // (HDDRSDRC2) Value : 10
N#define 	AT91C_DDRC2_TRAS_11                   (0xB) // (HDDRSDRC2) Value : 11
N#define 	AT91C_DDRC2_TRAS_12                   (0xC) // (HDDRSDRC2) Value : 12
N#define 	AT91C_DDRC2_TRAS_13                   (0xD) // (HDDRSDRC2) Value : 13
N#define 	AT91C_DDRC2_TRAS_14                   (0xE) // (HDDRSDRC2) Value : 14
N#define 	AT91C_DDRC2_TRAS_15                   (0xF) // (HDDRSDRC2) Value : 15
N#define AT91C_DDRC2_TRCD      (0xF <<  4) // (HDDRSDRC2) Row to column delay
N#define 	AT91C_DDRC2_TRCD_0                    (0x0 <<  4) // (HDDRSDRC2) Value :  0
N#define 	AT91C_DDRC2_TRCD_1                    (0x1 <<  4) // (HDDRSDRC2) Value :  1
N#define 	AT91C_DDRC2_TRCD_2                    (0x2 <<  4) // (HDDRSDRC2) Value :  2
N#define 	AT91C_DDRC2_TRCD_3                    (0x3 <<  4) // (HDDRSDRC2) Value :  3
N#define 	AT91C_DDRC2_TRCD_4                    (0x4 <<  4) // (HDDRSDRC2) Value :  4
N#define 	AT91C_DDRC2_TRCD_5                    (0x5 <<  4) // (HDDRSDRC2) Value :  5
N#define 	AT91C_DDRC2_TRCD_6                    (0x6 <<  4) // (HDDRSDRC2) Value :  6
N#define 	AT91C_DDRC2_TRCD_7                    (0x7 <<  4) // (HDDRSDRC2) Value :  7
N#define 	AT91C_DDRC2_TRCD_8                    (0x8 <<  4) // (HDDRSDRC2) Value :  8
N#define 	AT91C_DDRC2_TRCD_9                    (0x9 <<  4) // (HDDRSDRC2) Value :  9
N#define 	AT91C_DDRC2_TRCD_10                   (0xA <<  4) // (HDDRSDRC2) Value : 10
N#define 	AT91C_DDRC2_TRCD_11                   (0xB <<  4) // (HDDRSDRC2) Value : 11
N#define 	AT91C_DDRC2_TRCD_12                   (0xC <<  4) // (HDDRSDRC2) Value : 12
N#define 	AT91C_DDRC2_TRCD_13                   (0xD <<  4) // (HDDRSDRC2) Value : 13
N#define 	AT91C_DDRC2_TRCD_14                   (0xE <<  4) // (HDDRSDRC2) Value : 14
N#define 	AT91C_DDRC2_TRCD_15                   (0xF <<  4) // (HDDRSDRC2) Value : 15
N#define AT91C_DDRC2_TWR       (0xF <<  8) // (HDDRSDRC2) Write recovery delay
N#define 	AT91C_DDRC2_TWR_0                    (0x0 <<  8) // (HDDRSDRC2) Value :  0
N#define 	AT91C_DDRC2_TWR_1                    (0x1 <<  8) // (HDDRSDRC2) Value :  1
N#define 	AT91C_DDRC2_TWR_2                    (0x2 <<  8) // (HDDRSDRC2) Value :  2
N#define 	AT91C_DDRC2_TWR_3                    (0x3 <<  8) // (HDDRSDRC2) Value :  3
N#define 	AT91C_DDRC2_TWR_4                    (0x4 <<  8) // (HDDRSDRC2) Value :  4
N#define 	AT91C_DDRC2_TWR_5                    (0x5 <<  8) // (HDDRSDRC2) Value :  5
N#define 	AT91C_DDRC2_TWR_6                    (0x6 <<  8) // (HDDRSDRC2) Value :  6
N#define 	AT91C_DDRC2_TWR_7                    (0x7 <<  8) // (HDDRSDRC2) Value :  7
N#define 	AT91C_DDRC2_TWR_8                    (0x8 <<  8) // (HDDRSDRC2) Value :  8
N#define 	AT91C_DDRC2_TWR_9                    (0x9 <<  8) // (HDDRSDRC2) Value :  9
N#define 	AT91C_DDRC2_TWR_10                   (0xA <<  8) // (HDDRSDRC2) Value : 10
N#define 	AT91C_DDRC2_TWR_11                   (0xB <<  8) // (HDDRSDRC2) Value : 11
N#define 	AT91C_DDRC2_TWR_12                   (0xC <<  8) // (HDDRSDRC2) Value : 12
N#define 	AT91C_DDRC2_TWR_13                   (0xD <<  8) // (HDDRSDRC2) Value : 13
N#define 	AT91C_DDRC2_TWR_14                   (0xE <<  8) // (HDDRSDRC2) Value : 14
N#define 	AT91C_DDRC2_TWR_15                   (0xF <<  8) // (HDDRSDRC2) Value : 15
N#define AT91C_DDRC2_TRC       (0xF << 12) // (HDDRSDRC2) Row cycle delay
N#define 	AT91C_DDRC2_TRC_0                    (0x0 << 12) // (HDDRSDRC2) Value :  0
N#define 	AT91C_DDRC2_TRC_1                    (0x1 << 12) // (HDDRSDRC2) Value :  1
N#define 	AT91C_DDRC2_TRC_2                    (0x2 << 12) // (HDDRSDRC2) Value :  2
N#define 	AT91C_DDRC2_TRC_3                    (0x3 << 12) // (HDDRSDRC2) Value :  3
N#define 	AT91C_DDRC2_TRC_4                    (0x4 << 12) // (HDDRSDRC2) Value :  4
N#define 	AT91C_DDRC2_TRC_5                    (0x5 << 12) // (HDDRSDRC2) Value :  5
N#define 	AT91C_DDRC2_TRC_6                    (0x6 << 12) // (HDDRSDRC2) Value :  6
N#define 	AT91C_DDRC2_TRC_7                    (0x7 << 12) // (HDDRSDRC2) Value :  7
N#define 	AT91C_DDRC2_TRC_8                    (0x8 << 12) // (HDDRSDRC2) Value :  8
N#define 	AT91C_DDRC2_TRC_9                    (0x9 << 12) // (HDDRSDRC2) Value :  9
N#define 	AT91C_DDRC2_TRC_10                   (0xA << 12) // (HDDRSDRC2) Value : 10
N#define 	AT91C_DDRC2_TRC_11                   (0xB << 12) // (HDDRSDRC2) Value : 11
N#define 	AT91C_DDRC2_TRC_12                   (0xC << 12) // (HDDRSDRC2) Value : 12
N#define 	AT91C_DDRC2_TRC_13                   (0xD << 12) // (HDDRSDRC2) Value : 13
N#define 	AT91C_DDRC2_TRC_14                   (0xE << 12) // (HDDRSDRC2) Value : 14
N#define 	AT91C_DDRC2_TRC_15                   (0xF << 12) // (HDDRSDRC2) Value : 15
N#define AT91C_DDRC2_TRP       (0xF << 16) // (HDDRSDRC2) Row precharge delay
N#define 	AT91C_DDRC2_TRP_0                    (0x0 << 16) // (HDDRSDRC2) Value :  0
N#define 	AT91C_DDRC2_TRP_1                    (0x1 << 16) // (HDDRSDRC2) Value :  1
N#define 	AT91C_DDRC2_TRP_2                    (0x2 << 16) // (HDDRSDRC2) Value :  2
N#define 	AT91C_DDRC2_TRP_3                    (0x3 << 16) // (HDDRSDRC2) Value :  3
N#define 	AT91C_DDRC2_TRP_4                    (0x4 << 16) // (HDDRSDRC2) Value :  4
N#define 	AT91C_DDRC2_TRP_5                    (0x5 << 16) // (HDDRSDRC2) Value :  5
N#define 	AT91C_DDRC2_TRP_6                    (0x6 << 16) // (HDDRSDRC2) Value :  6
N#define 	AT91C_DDRC2_TRP_7                    (0x7 << 16) // (HDDRSDRC2) Value :  7
N#define 	AT91C_DDRC2_TRP_8                    (0x8 << 16) // (HDDRSDRC2) Value :  8
N#define 	AT91C_DDRC2_TRP_9                    (0x9 << 16) // (HDDRSDRC2) Value :  9
N#define 	AT91C_DDRC2_TRP_10                   (0xA << 16) // (HDDRSDRC2) Value : 10
N#define 	AT91C_DDRC2_TRP_11                   (0xB << 16) // (HDDRSDRC2) Value : 11
N#define 	AT91C_DDRC2_TRP_12                   (0xC << 16) // (HDDRSDRC2) Value : 12
N#define 	AT91C_DDRC2_TRP_13                   (0xD << 16) // (HDDRSDRC2) Value : 13
N#define 	AT91C_DDRC2_TRP_14                   (0xE << 16) // (HDDRSDRC2) Value : 14
N#define 	AT91C_DDRC2_TRP_15                   (0xF << 16) // (HDDRSDRC2) Value : 15
N#define AT91C_DDRC2_TRRD      (0xF << 20) // (HDDRSDRC2) Active bankA to Active bankB
N#define 	AT91C_DDRC2_TRRD_0                    (0x0 << 20) // (HDDRSDRC2) Value :  0
N#define 	AT91C_DDRC2_TRRD_1                    (0x1 << 20) // (HDDRSDRC2) Value :  1
N#define 	AT91C_DDRC2_TRRD_2                    (0x2 << 20) // (HDDRSDRC2) Value :  2
N#define 	AT91C_DDRC2_TRRD_3                    (0x3 << 20) // (HDDRSDRC2) Value :  3
N#define 	AT91C_DDRC2_TRRD_4                    (0x4 << 20) // (HDDRSDRC2) Value :  4
N#define 	AT91C_DDRC2_TRRD_5                    (0x5 << 20) // (HDDRSDRC2) Value :  5
N#define 	AT91C_DDRC2_TRRD_6                    (0x6 << 20) // (HDDRSDRC2) Value :  6
N#define 	AT91C_DDRC2_TRRD_7                    (0x7 << 20) // (HDDRSDRC2) Value :  7
N#define 	AT91C_DDRC2_TRRD_8                    (0x8 << 20) // (HDDRSDRC2) Value :  8
N#define 	AT91C_DDRC2_TRRD_9                    (0x9 << 20) // (HDDRSDRC2) Value :  9
N#define 	AT91C_DDRC2_TRRD_10                   (0xA << 20) // (HDDRSDRC2) Value : 10
N#define 	AT91C_DDRC2_TRRD_11                   (0xB << 20) // (HDDRSDRC2) Value : 11
N#define 	AT91C_DDRC2_TRRD_12                   (0xC << 20) // (HDDRSDRC2) Value : 12
N#define 	AT91C_DDRC2_TRRD_13                   (0xD << 20) // (HDDRSDRC2) Value : 13
N#define 	AT91C_DDRC2_TRRD_14                   (0xE << 20) // (HDDRSDRC2) Value : 14
N#define 	AT91C_DDRC2_TRRD_15                   (0xF << 20) // (HDDRSDRC2) Value : 15
N#define AT91C_DDRC2_TWTR      (0x7 << 24) // (HDDRSDRC2) Internal write to read delay
N#define 	AT91C_DDRC2_TWTR_0                    (0x0 << 24) // (HDDRSDRC2) Value : 1
N#define 	AT91C_DDRC2_TWTR_1                    (0x1 << 24) // (HDDRSDRC2) Value : 2
N#define AT91C_REDUCE_WRRD     (0x1 << 27) // (HDDRSDRC2) Reduce Write to Read Delay
N#define AT91C_DDRC2_TMRD      (0xF << 28) // (HDDRSDRC2) Load mode register command to active or refresh command
N#define 	AT91C_DDRC2_TMRD_0                    (0x0 << 28) // (HDDRSDRC2) Value :  0
N#define 	AT91C_DDRC2_TMRD_1                    (0x1 << 28) // (HDDRSDRC2) Value :  1
N#define 	AT91C_DDRC2_TMRD_2                    (0x2 << 28) // (HDDRSDRC2) Value :  2
N#define 	AT91C_DDRC2_TMRD_3                    (0x3 << 28) // (HDDRSDRC2) Value :  3
N#define 	AT91C_DDRC2_TMRD_4                    (0x4 << 28) // (HDDRSDRC2) Value :  4
N#define 	AT91C_DDRC2_TMRD_5                    (0x5 << 28) // (HDDRSDRC2) Value :  5
N#define 	AT91C_DDRC2_TMRD_6                    (0x6 << 28) // (HDDRSDRC2) Value :  6
N#define 	AT91C_DDRC2_TMRD_7                    (0x7 << 28) // (HDDRSDRC2) Value :  7
N#define 	AT91C_DDRC2_TMRD_8                    (0x8 << 28) // (HDDRSDRC2) Value :  8
N#define 	AT91C_DDRC2_TMRD_9                    (0x9 << 28) // (HDDRSDRC2) Value :  9
N#define 	AT91C_DDRC2_TMRD_10                   (0xA << 28) // (HDDRSDRC2) Value : 10
N#define 	AT91C_DDRC2_TMRD_11                   (0xB << 28) // (HDDRSDRC2) Value : 11
N#define 	AT91C_DDRC2_TMRD_12                   (0xC << 28) // (HDDRSDRC2) Value : 12
N#define 	AT91C_DDRC2_TMRD_13                   (0xD << 28) // (HDDRSDRC2) Value : 13
N#define 	AT91C_DDRC2_TMRD_14                   (0xE << 28) // (HDDRSDRC2) Value : 14
N#define 	AT91C_DDRC2_TMRD_15                   (0xF << 28) // (HDDRSDRC2) Value : 15
N// -------- HDDRSDRC2_T1PR : (HDDRSDRC2 Offset: 0x10) Timing1 Register -------- 
N#define AT91C_DDRC2_TRFC      (0x1F <<  0) // (HDDRSDRC2) row cycle delay
N#define 	AT91C_DDRC2_TRFC_0                    (0x0) // (HDDRSDRC2) Value :  0
N#define 	AT91C_DDRC2_TRFC_1                    (0x1) // (HDDRSDRC2) Value :  1
N#define 	AT91C_DDRC2_TRFC_2                    (0x2) // (HDDRSDRC2) Value :  2
N#define 	AT91C_DDRC2_TRFC_3                    (0x3) // (HDDRSDRC2) Value :  3
N#define 	AT91C_DDRC2_TRFC_4                    (0x4) // (HDDRSDRC2) Value :  4
N#define 	AT91C_DDRC2_TRFC_5                    (0x5) // (HDDRSDRC2) Value :  5
N#define 	AT91C_DDRC2_TRFC_6                    (0x6) // (HDDRSDRC2) Value :  6
N#define 	AT91C_DDRC2_TRFC_7                    (0x7) // (HDDRSDRC2) Value :  7
N#define 	AT91C_DDRC2_TRFC_8                    (0x8) // (HDDRSDRC2) Value :  8
N#define 	AT91C_DDRC2_TRFC_9                    (0x9) // (HDDRSDRC2) Value :  9
N#define 	AT91C_DDRC2_TRFC_10                   (0xA) // (HDDRSDRC2) Value : 10
N#define 	AT91C_DDRC2_TRFC_11                   (0xB) // (HDDRSDRC2) Value : 11
N#define 	AT91C_DDRC2_TRFC_12                   (0xC) // (HDDRSDRC2) Value : 12
N#define 	AT91C_DDRC2_TRFC_13                   (0xD) // (HDDRSDRC2) Value : 13
N#define 	AT91C_DDRC2_TRFC_14                   (0xE) // (HDDRSDRC2) Value : 14
N#define 	AT91C_DDRC2_TRFC_15                   (0xF) // (HDDRSDRC2) Value : 15
N#define 	AT91C_DDRC2_TRFC_16                   (0x10) // (HDDRSDRC2) Value : 16
N#define 	AT91C_DDRC2_TRFC_17                   (0x11) // (HDDRSDRC2) Value : 17
N#define 	AT91C_DDRC2_TRFC_18                   (0x12) // (HDDRSDRC2) Value : 18
N#define 	AT91C_DDRC2_TRFC_19                   (0x13) // (HDDRSDRC2) Value : 19
N#define 	AT91C_DDRC2_TRFC_20                   (0x14) // (HDDRSDRC2) Value : 20
N#define 	AT91C_DDRC2_TRFC_21                   (0x15) // (HDDRSDRC2) Value : 21
N#define 	AT91C_DDRC2_TRFC_22                   (0x16) // (HDDRSDRC2) Value : 22
N#define 	AT91C_DDRC2_TRFC_23                   (0x17) // (HDDRSDRC2) Value : 23
N#define 	AT91C_DDRC2_TRFC_24                   (0x18) // (HDDRSDRC2) Value : 24
N#define 	AT91C_DDRC2_TRFC_25                   (0x19) // (HDDRSDRC2) Value : 25
N#define 	AT91C_DDRC2_TRFC_26                   (0x1A) // (HDDRSDRC2) Value : 26
N#define 	AT91C_DDRC2_TRFC_27                   (0x1B) // (HDDRSDRC2) Value : 27
N#define 	AT91C_DDRC2_TRFC_28                   (0x1C) // (HDDRSDRC2) Value : 28
N#define 	AT91C_DDRC2_TRFC_29                   (0x1D) // (HDDRSDRC2) Value : 29
N#define 	AT91C_DDRC2_TRFC_30                   (0x1E) // (HDDRSDRC2) Value : 30
N#define 	AT91C_DDRC2_TRFC_31                   (0x1F) // (HDDRSDRC2) Value : 31
N#define AT91C_DDRC2_TXSNR     (0xFF <<  8) // (HDDRSDRC2) Exit self refresh delay to Read command
N#define 	AT91C_DDRC2_TXSNR_0                    (0x0 <<  8) // (HDDRSDRC2) Value :   0
N#define 	AT91C_DDRC2_TXSNR_8                    (0x8 <<  8) // (HDDRSDRC2) Value :   8
N#define 	AT91C_DDRC2_TXSNR_16                   (0x10 <<  8) // (HDDRSDRC2) Value :  16
N#define 	AT91C_DDRC2_TXSNR_32                   (0x20 <<  8) // (HDDRSDRC2) Value :  32
N#define 	AT91C_DDRC2_TXSNR_48                   (0x30 <<  8) // (HDDRSDRC2) Value :  48
N#define 	AT91C_DDRC2_TXSNR_64                   (0x40 <<  8) // (HDDRSDRC2) Value :  64
N#define 	AT91C_DDRC2_TXSNR_80                   (0x50 <<  8) // (HDDRSDRC2) Value :  80
N#define 	AT91C_DDRC2_TXSNR_96                   (0x60 <<  8) // (HDDRSDRC2) Value :  96
N#define 	AT91C_DDRC2_TXSNR_112                  (0x70 <<  8) // (HDDRSDRC2) Value : 112
N#define 	AT91C_DDRC2_TXSNR_128                  (0x80 <<  8) // (HDDRSDRC2) Value : 128
N#define 	AT91C_DDRC2_TXSNR_144                  (0x90 <<  8) // (HDDRSDRC2) Value : 144
N#define 	AT91C_DDRC2_TXSNR_160                  (0xA0 <<  8) // (HDDRSDRC2) Value : 160
N#define 	AT91C_DDRC2_TXSNR_176                  (0xB0 <<  8) // (HDDRSDRC2) Value : 176
N#define 	AT91C_DDRC2_TXSNR_192                  (0xC0 <<  8) // (HDDRSDRC2) Value : 192
N#define 	AT91C_DDRC2_TXSNR_208                  (0xD0 <<  8) // (HDDRSDRC2) Value : 208
N#define 	AT91C_DDRC2_TXSNR_224                  (0xE0 <<  8) // (HDDRSDRC2) Value : 224
N#define 	AT91C_DDRC2_TXSNR_240                  (0xF0 <<  8) // (HDDRSDRC2) Value : 240
N#define 	AT91C_DDRC2_TXSNR_255                  (0xFF <<  8) // (HDDRSDRC2) Value : 255
N#define AT91C_DDRC2_TXSRD     (0xFF << 16) // (HDDRSDRC2) Exit self refresh delay to Read command
N#define 	AT91C_DDRC2_TXSRD_0                    (0x0 << 16) // (HDDRSDRC2) Value :   0
N#define 	AT91C_DDRC2_TXSRD_8                    (0x8 << 16) // (HDDRSDRC2) Value :   8
N#define 	AT91C_DDRC2_TXSRD_16                   (0x10 << 16) // (HDDRSDRC2) Value :  16
N#define 	AT91C_DDRC2_TXSRD_32                   (0x20 << 16) // (HDDRSDRC2) Value :  32
N#define 	AT91C_DDRC2_TXSRD_48                   (0x30 << 16) // (HDDRSDRC2) Value :  48
N#define 	AT91C_DDRC2_TXSRD_64                   (0x40 << 16) // (HDDRSDRC2) Value :  64
N#define 	AT91C_DDRC2_TXSRD_80                   (0x50 << 16) // (HDDRSDRC2) Value :  80
N#define 	AT91C_DDRC2_TXSRD_96                   (0x60 << 16) // (HDDRSDRC2) Value :  96
N#define 	AT91C_DDRC2_TXSRD_112                  (0x70 << 16) // (HDDRSDRC2) Value : 112
N#define 	AT91C_DDRC2_TXSRD_128                  (0x80 << 16) // (HDDRSDRC2) Value : 128
N#define 	AT91C_DDRC2_TXSRD_144                  (0x90 << 16) // (HDDRSDRC2) Value : 144
N#define 	AT91C_DDRC2_TXSRD_160                  (0xA0 << 16) // (HDDRSDRC2) Value : 160
N#define 	AT91C_DDRC2_TXSRD_176                  (0xB0 << 16) // (HDDRSDRC2) Value : 176
N#define 	AT91C_DDRC2_TXSRD_192                  (0xC0 << 16) // (HDDRSDRC2) Value : 192
N#define 	AT91C_DDRC2_TXSRD_208                  (0xD0 << 16) // (HDDRSDRC2) Value : 208
N#define 	AT91C_DDRC2_TXSRD_224                  (0xE0 << 16) // (HDDRSDRC2) Value : 224
N#define 	AT91C_DDRC2_TXSRD_240                  (0xF0 << 16) // (HDDRSDRC2) Value : 240
N#define 	AT91C_DDRC2_TXSRD_255                  (0xFF << 16) // (HDDRSDRC2) Value : 255
N#define AT91C_DDRC2_TXP       (0xF << 24) // (HDDRSDRC2) Exit Power-down delay to first command
N#define 	AT91C_DDRC2_TXP_0                    (0x0 << 24) // (HDDRSDRC2) Value :  0
N#define 	AT91C_DDRC2_TXP_1                    (0x1 << 24) // (HDDRSDRC2) Value :  1
N#define 	AT91C_DDRC2_TXP_2                    (0x2 << 24) // (HDDRSDRC2) Value :  2
N#define 	AT91C_DDRC2_TXP_3                    (0x3 << 24) // (HDDRSDRC2) Value :  3
N#define 	AT91C_DDRC2_TXP_4                    (0x4 << 24) // (HDDRSDRC2) Value :  4
N#define 	AT91C_DDRC2_TXP_5                    (0x5 << 24) // (HDDRSDRC2) Value :  5
N#define 	AT91C_DDRC2_TXP_6                    (0x6 << 24) // (HDDRSDRC2) Value :  6
N#define 	AT91C_DDRC2_TXP_7                    (0x7 << 24) // (HDDRSDRC2) Value :  7
N#define 	AT91C_DDRC2_TXP_8                    (0x8 << 24) // (HDDRSDRC2) Value :  8
N#define 	AT91C_DDRC2_TXP_9                    (0x9 << 24) // (HDDRSDRC2) Value :  9
N#define 	AT91C_DDRC2_TXP_10                   (0xA << 24) // (HDDRSDRC2) Value : 10
N#define 	AT91C_DDRC2_TXP_11                   (0xB << 24) // (HDDRSDRC2) Value : 11
N#define 	AT91C_DDRC2_TXP_12                   (0xC << 24) // (HDDRSDRC2) Value : 12
N#define 	AT91C_DDRC2_TXP_13                   (0xD << 24) // (HDDRSDRC2) Value : 13
N#define 	AT91C_DDRC2_TXP_14                   (0xE << 24) // (HDDRSDRC2) Value : 14
N#define 	AT91C_DDRC2_TXP_15                   (0xF << 24) // (HDDRSDRC2) Value : 15
N// -------- HDDRSDRC2_T2PR : (HDDRSDRC2 Offset: 0x14) Timing2 Register -------- 
N#define AT91C_DDRC2_TXARD     (0xF <<  0) // (HDDRSDRC2) Exit active power down delay to read command in 'Fast Exit' mode.
N#define 	AT91C_DDRC2_TXARD_0                    (0x0) // (HDDRSDRC2) Value :  0
N#define 	AT91C_DDRC2_TXARD_1                    (0x1) // (HDDRSDRC2) Value :  1
N#define 	AT91C_DDRC2_TXARD_2                    (0x2) // (HDDRSDRC2) Value :  2
N#define 	AT91C_DDRC2_TXARD_3                    (0x3) // (HDDRSDRC2) Value :  3
N#define 	AT91C_DDRC2_TXARD_4                    (0x4) // (HDDRSDRC2) Value :  4
N#define 	AT91C_DDRC2_TXARD_5                    (0x5) // (HDDRSDRC2) Value :  5
N#define 	AT91C_DDRC2_TXARD_6                    (0x6) // (HDDRSDRC2) Value :  6
N#define 	AT91C_DDRC2_TXARD_7                    (0x7) // (HDDRSDRC2) Value :  7
N#define 	AT91C_DDRC2_TXARD_8                    (0x8) // (HDDRSDRC2) Value :  8
N#define 	AT91C_DDRC2_TXARD_9                    (0x9) // (HDDRSDRC2) Value :  9
N#define 	AT91C_DDRC2_TXARD_10                   (0xA) // (HDDRSDRC2) Value : 10
N#define 	AT91C_DDRC2_TXARD_11                   (0xB) // (HDDRSDRC2) Value : 11
N#define 	AT91C_DDRC2_TXARD_12                   (0xC) // (HDDRSDRC2) Value : 12
N#define 	AT91C_DDRC2_TXARD_13                   (0xD) // (HDDRSDRC2) Value : 13
N#define 	AT91C_DDRC2_TXARD_14                   (0xE) // (HDDRSDRC2) Value : 14
N#define 	AT91C_DDRC2_TXARD_15                   (0xF) // (HDDRSDRC2) Value : 15
N#define AT91C_DDRC2_TXARDS    (0xF <<  4) // (HDDRSDRC2) Exit active power down delay to read command in 'Slow Exit' mode.
N#define 	AT91C_DDRC2_TXARDS_0                    (0x0 <<  4) // (HDDRSDRC2) Value :  0
N#define 	AT91C_DDRC2_TXARDS_1                    (0x1 <<  4) // (HDDRSDRC2) Value :  1
N#define 	AT91C_DDRC2_TXARDS_2                    (0x2 <<  4) // (HDDRSDRC2) Value :  2
N#define 	AT91C_DDRC2_TXARDS_3                    (0x3 <<  4) // (HDDRSDRC2) Value :  3
N#define 	AT91C_DDRC2_TXARDS_4                    (0x4 <<  4) // (HDDRSDRC2) Value :  4
N#define 	AT91C_DDRC2_TXARDS_5                    (0x5 <<  4) // (HDDRSDRC2) Value :  5
N#define 	AT91C_DDRC2_TXARDS_6                    (0x6 <<  4) // (HDDRSDRC2) Value :  6
N#define 	AT91C_DDRC2_TXARDS_7                    (0x7 <<  4) // (HDDRSDRC2) Value :  7
N#define 	AT91C_DDRC2_TXARDS_8                    (0x8 <<  4) // (HDDRSDRC2) Value :  8
N#define 	AT91C_DDRC2_TXARDS_9                    (0x9 <<  4) // (HDDRSDRC2) Value :  9
N#define 	AT91C_DDRC2_TXARDS_10                   (0xA <<  4) // (HDDRSDRC2) Value : 10
N#define 	AT91C_DDRC2_TXARDS_11                   (0xB <<  4) // (HDDRSDRC2) Value : 11
N#define 	AT91C_DDRC2_TXARDS_12                   (0xC <<  4) // (HDDRSDRC2) Value : 12
N#define 	AT91C_DDRC2_TXARDS_13                   (0xD <<  4) // (HDDRSDRC2) Value : 13
N#define 	AT91C_DDRC2_TXARDS_14                   (0xE <<  4) // (HDDRSDRC2) Value : 14
N#define 	AT91C_DDRC2_TXARDS_15                   (0xF <<  4) // (HDDRSDRC2) Value : 15
N#define AT91C_DDRC2_TRPA      (0xF <<  8) // (HDDRSDRC2) Row precharge all delay
N#define 	AT91C_DDRC2_TRPA_0                    (0x0 <<  8) // (HDDRSDRC2) Value :  0
N#define 	AT91C_DDRC2_TRPA_1                    (0x1 <<  8) // (HDDRSDRC2) Value :  1
N#define 	AT91C_DDRC2_TRPA_2                    (0x2 <<  8) // (HDDRSDRC2) Value :  2
N#define 	AT91C_DDRC2_TRPA_3                    (0x3 <<  8) // (HDDRSDRC2) Value :  3
N#define 	AT91C_DDRC2_TRPA_4                    (0x4 <<  8) // (HDDRSDRC2) Value :  4
N#define 	AT91C_DDRC2_TRPA_5                    (0x5 <<  8) // (HDDRSDRC2) Value :  5
N#define 	AT91C_DDRC2_TRPA_6                    (0x6 <<  8) // (HDDRSDRC2) Value :  6
N#define 	AT91C_DDRC2_TRPA_7                    (0x7 <<  8) // (HDDRSDRC2) Value :  7
N#define 	AT91C_DDRC2_TRPA_8                    (0x8 <<  8) // (HDDRSDRC2) Value :  8
N#define 	AT91C_DDRC2_TRPA_9                    (0x9 <<  8) // (HDDRSDRC2) Value :  9
N#define 	AT91C_DDRC2_TRPA_10                   (0xA <<  8) // (HDDRSDRC2) Value : 10
N#define 	AT91C_DDRC2_TRPA_11                   (0xB <<  8) // (HDDRSDRC2) Value : 11
N#define 	AT91C_DDRC2_TRPA_12                   (0xC <<  8) // (HDDRSDRC2) Value : 12
N#define 	AT91C_DDRC2_TRPA_13                   (0xD <<  8) // (HDDRSDRC2) Value : 13
N#define 	AT91C_DDRC2_TRPA_14                   (0xE <<  8) // (HDDRSDRC2) Value : 14
N#define 	AT91C_DDRC2_TRPA_15                   (0xF <<  8) // (HDDRSDRC2) Value : 15
N#define AT91C_DDRC2_TRTP      (0x7 << 12) // (HDDRSDRC2) Read to Precharge delay
N#define 	AT91C_DDRC2_TRTP_0                    (0x0 << 12) // (HDDRSDRC2) Value :  0
N#define 	AT91C_DDRC2_TRTP_1                    (0x1 << 12) // (HDDRSDRC2) Value :  1
N#define 	AT91C_DDRC2_TRTP_2                    (0x2 << 12) // (HDDRSDRC2) Value :  2
N#define 	AT91C_DDRC2_TRTP_3                    (0x3 << 12) // (HDDRSDRC2) Value :  3
N#define 	AT91C_DDRC2_TRTP_4                    (0x4 << 12) // (HDDRSDRC2) Value :  4
N#define 	AT91C_DDRC2_TRTP_5                    (0x5 << 12) // (HDDRSDRC2) Value :  5
N#define 	AT91C_DDRC2_TRTP_6                    (0x6 << 12) // (HDDRSDRC2) Value :  6
N#define 	AT91C_DDRC2_TRTP_7                    (0x7 << 12) // (HDDRSDRC2) Value :  7
N// -------- HDDRSDRC2_LPR : (HDDRSDRC2 Offset: 0x1c)  -------- 
N#define AT91C_DDRC2_LPCB      (0x3 <<  0) // (HDDRSDRC2) Low-power Command Bit
N#define 	AT91C_DDRC2_LPCB_DISABLED             (0x0) // (HDDRSDRC2) Low-power Feature is inhibited: no power-down, self refresh and Deep power mode are issued to the SDRAM device.
N#define 	AT91C_DDRC2_LPCB_SELFREFRESH          (0x1) // (HDDRSDRC2) The DDRSDRAMC Controller issues a Self Refresh Command to the SDRAM device, the clock(s) is/are de-activated and the CKE signal is set low. The SDRAM device leaves the self refresh mode when accessed and enters it after the access.
N#define 	AT91C_DDRC2_LPCB_POWERDOWN            (0x2) // (HDDRSDRC2) The HDDRSDRC2 Controller issues a Power-down Command to the SDRAM device after each access, the CKE signal is set low. The SDRAM device leaves the power-down mode when accessed and enters it after the access.
N#define 	AT91C_DDRC2_LPCB_DEEP_PWD             (0x3) // (HDDRSDRC2) The HDDRSDRC2 Controller issues a Deep Power-down Command to the Mobile SDRAM device. This mode is unique to Mobile SDRAM devices
N#define AT91C_DDRC2_CLK_FR    (0x1 <<  2) // (HDDRSDRC2) Clock frozen Command Bit
N#define 	AT91C_DDRC2_CLK_FR_DISABLED             (0x0 <<  2) // (HDDRSDRC2) Low-power Feature is inhibited: no power-down, self refresh and Deep power mode are issued to the SDRAM device.
N#define 	AT91C_DDRC2_CLK_FR_SELFREFRESH          (0x1 <<  2) // (HDDRSDRC2) The DDRSDRAMC Controller issues a Self Refresh Command to the SDRAM device, the clock(s) is/are de-activated and the CKE signal is set low. The SDRAM device leaves the self refresh mode when accessed and enters it after the access.
N#define 	AT91C_DDRC2_CLK_FR_POWERDOWN            (0x2 <<  2) // (HDDRSDRC2) The HDDRSDRC2 Controller issues a Power-down Command to the SDRAM device after each access, the CKE signal is set low. The SDRAM device leaves the power-down mode when accessed and enters it after the access.
N#define 	AT91C_DDRC2_CLK_FR_DEEP_PWD             (0x3 <<  2) // (HDDRSDRC2) The HDDRSDRC2 Controller issues a Deep Power-down Command to the Mobile SDRAM device. This mode is unique to Mobile SDRAM devices
N#define AT91C_DDRC2_PASR      (0x7 <<  4) // (HDDRSDRC2) Partial Array Self Refresh
N#define AT91C_DDRC2_TCR       (0x3 <<  8) // (HDDRSDRC2) Temperature compensated self refresh
N#define AT91C_DDRC2_DS        (0x3 << 10) // (HDDRSDRC2) Drive strength
N#define AT91C_DDRC2_TIMEOUT   (0x3 << 12) // (HDDRSDRC2) low-power mode delay
N#define 	AT91C_DDRC2_TIMEOUT_0                    (0x0 << 12) // (HDDRSDRC2) The SDRAM controller activates the SDRAM low-power mode immediately after the end of the last transfer.
N#define 	AT91C_DDRC2_TIMEOUT_64                   (0x1 << 12) // (HDDRSDRC2) The SDRAM controller activates the SDRAM low-power mode 64 clock cycles after the end of the last transfer.
N#define 	AT91C_DDRC2_TIMEOUT_128                  (0x2 << 12) // (HDDRSDRC2) The SDRAM controller activates the SDRAM low-power mode 128 clock cycles after the end of the last transfer.
N#define 	AT91C_DDRC2_TIMEOUT_Reserved             (0x3 << 12) // (HDDRSDRC2) Reserved
N#define AT91C_DDRC2_ADPE      (0x1 << 16) // (HDDRSDRC2) Active Power Down Exit time
N#define 	AT91C_DDRC2_ADPE_FAST                 (0x0 << 16) // (HDDRSDRC2) Fast Exit
N#define 	AT91C_DDRC2_ADPE_SLOW                 (0x1 << 16) // (HDDRSDRC2) Slow Exit
N// -------- HDDRSDRC2_MDR : (HDDRSDRC2 Offset: 0x20) Memory Device Register -------- 
N#define AT91C_DDRC2_MD        (0x7 <<  0) // (HDDRSDRC2) memory device
N#define 	AT91C_DDRC2_MD_SDR_SDRAM            (0x0) // (HDDRSDRC2) SDR SDRAM
N#define 	AT91C_DDRC2_MD_LP_SDR_SDRAM         (0x1) // (HDDRSDRC2) Low Power SDR SDRAM
N#define 	AT91C_DDRC2_MD_DDR_SDRAM            (0x2) // (HDDRSDRC2) DDR SDRAM
N#define 	AT91C_DDRC2_MD_LP_DDR_SDRAM         (0x3) // (HDDRSDRC2) Low Power DDR SDRAM
N#define 	AT91C_DDRC2_MD_DDR2_SDRAM           (0x6) // (HDDRSDRC2) DDR2 SDRAM
N#define AT91C_DDRC2_DBW       (0x1 <<  4) // (HDDRSDRC2) Data Bus Width
N#define 	AT91C_DDRC2_DBW_32_BITS              (0x0 <<  4) // (HDDRSDRC2) 32 Bits datas bus
N#define 	AT91C_DDRC2_DBW_16_BITS              (0x1 <<  4) // (HDDRSDRC2) 16 Bits datas bus
N// -------- HDDRSDRC2_DLL : (HDDRSDRC2 Offset: 0x24) DLL Information Register -------- 
N#define AT91C_DDRC2_MDINC     (0x1 <<  0) // (HDDRSDRC2) DLL Master Delay Increment
N#define AT91C_DDRC2_MDDEC     (0x1 <<  1) // (HDDRSDRC2) DLL Master Delay Decrement
N#define AT91C_DDRC2_MDOVF     (0x1 <<  2) // (HDDRSDRC2) DLL Master Delay Overflow Flag
N#define AT91C_DDRC2_MDVAL     (0xFF <<  8) // (HDDRSDRC2) DLL Master Delay Value
N// -------- HDDRSDRC2_HS : (HDDRSDRC2 Offset: 0x2c) High Speed Register -------- 
N#define AT91C_DDRC2_NO_OPT    (0x1 <<  1) // (HDDRSDRC2) Disable optimization
N#define AT91C_DDRC2_NO_ANT    (0x1 <<  2) // (HDDRSDRC2) Disable Anticipated read
N// -------- HDDRSDRC2_DELAY1 : (HDDRSDRC2 Offset: 0x30) Pad delay1 Register -------- 
N#define AT91C_DDRC2_DELAY     (0xF <<  0) // (HDDRSDRC2) Pad delay value
N// -------- HDDRSDRC2_DELAY2 : (HDDRSDRC2 Offset: 0x34) Pad delay2 Register -------- 
N// -------- HDDRSDRC2_DELAY3 : (HDDRSDRC2 Offset: 0x38) Pad delay3 Register -------- 
N// -------- HDDRSDRC2_DELAY4 : (HDDRSDRC2 Offset: 0x3c) Pad delay4 Register -------- 
N// -------- HDDRSDRC2_DELAY5 : (HDDRSDRC2 Offset: 0x40) Pad delay5 Register -------- 
N// -------- HDDRSDRC2_DELAY6 : (HDDRSDRC2 Offset: 0x44) Pad delay6 Register -------- 
N// -------- HDDRSDRC2_DELAY7 : (HDDRSDRC2 Offset: 0x48) Pad delay7 Register -------- 
N// -------- HDDRSDRC2_DELAY8 : (HDDRSDRC2 Offset: 0x4c) Pad delay8 Register -------- 
N// -------- HDDRSDRC2_WPMR : (HDDRSDRC2 Offset: 0xe4) Write Protect Mode Register -------- 
N#define AT91C_DDRC2_WPEN      (0x1 <<  0) // (HDDRSDRC2) write protect enable
N#define 	AT91C_DDRC2_WPEN_DISABLE              (0x0) // (HDDRSDRC2) 0 = Disables the Write Protect if WPKEY corresponds to 0x444452 (DDR in ASCII).
N#define 	AT91C_DDRC2_WPEN_ENABLE               (0x1) // (HDDRSDRC2) 1 = Enables the Write Protect if WPKEY corresponds to 0x444452 (DDR in ASCII).
N#define AT91C_DDRC2_WPKEY     (0xFFFFFF <<  8) // (HDDRSDRC2) write protect key
N// -------- HDDRSDRC2_WPSR : (HDDRSDRC2 Offset: 0xe8) Write Protect Status Register -------- 
N#define AT91C_DDRC2_WPVS      (0x1 <<  0) // (HDDRSDRC2) write protect violation status
N#define 	AT91C_DDRC2_WPVS_NO                   (0x0) // (HDDRSDRC2) 0 = No Write Protect Violation has occurred since the last read of the DDRSDRC_WPSR register.
N#define 	AT91C_DDRC2_WPVS_YES                  (0x1) // (HDDRSDRC2) A Write Protect Violation has occurred since the last read of the DDRSDRC_WPSR register.
N#define AT91C_DDRC2_WPVSRC    (0xFFFF <<  8) // (HDDRSDRC2) Write Protect Violation Source
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Static Memory Controller Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_SMC {
N	AT91_REG	 SMC_SETUP0; 	//  Setup Register for CS 0
N	AT91_REG	 SMC_PULSE0; 	//  Pulse Register for CS 0
N	AT91_REG	 SMC_CYCLE0; 	//  Cycle Register for CS 0
N	AT91_REG	 SMC_CTRL0; 	//  Control Register for CS 0
N	AT91_REG	 SMC_SETUP1; 	//  Setup Register for CS 1
N	AT91_REG	 SMC_PULSE1; 	//  Pulse Register for CS 1
N	AT91_REG	 SMC_CYCLE1; 	//  Cycle Register for CS 1
N	AT91_REG	 SMC_CTRL1; 	//  Control Register for CS 1
N	AT91_REG	 SMC_SETUP2; 	//  Setup Register for CS 2
N	AT91_REG	 SMC_PULSE2; 	//  Pulse Register for CS 2
N	AT91_REG	 SMC_CYCLE2; 	//  Cycle Register for CS 2
N	AT91_REG	 SMC_CTRL2; 	//  Control Register for CS 2
N	AT91_REG	 SMC_SETUP3; 	//  Setup Register for CS 3
N	AT91_REG	 SMC_PULSE3; 	//  Pulse Register for CS 3
N	AT91_REG	 SMC_CYCLE3; 	//  Cycle Register for CS 3
N	AT91_REG	 SMC_CTRL3; 	//  Control Register for CS 3
N	AT91_REG	 SMC_SETUP4; 	//  Setup Register for CS 4
N	AT91_REG	 SMC_PULSE4; 	//  Pulse Register for CS 4
N	AT91_REG	 SMC_CYCLE4; 	//  Cycle Register for CS 4
N	AT91_REG	 SMC_CTRL4; 	//  Control Register for CS 4
N	AT91_REG	 SMC_SETUP5; 	//  Setup Register for CS 5
N	AT91_REG	 SMC_PULSE5; 	//  Pulse Register for CS 5
N	AT91_REG	 SMC_CYCLE5; 	//  Cycle Register for CS 5
N	AT91_REG	 SMC_CTRL5; 	//  Control Register for CS 5
N	AT91_REG	 SMC_SETUP6; 	//  Setup Register for CS 6
N	AT91_REG	 SMC_PULSE6; 	//  Pulse Register for CS 6
N	AT91_REG	 SMC_CYCLE6; 	//  Cycle Register for CS 6
N	AT91_REG	 SMC_CTRL6; 	//  Control Register for CS 6
N	AT91_REG	 SMC_SETUP7; 	//  Setup Register for CS 7
N	AT91_REG	 SMC_PULSE7; 	//  Pulse Register for CS 7
N	AT91_REG	 SMC_CYCLE7; 	//  Cycle Register for CS 7
N	AT91_REG	 SMC_CTRL7; 	//  Control Register for CS 7
N	AT91_REG	 Reserved0[16]; 	// 
N	AT91_REG	 SMC_DELAY1; 	// SMC Delay Control Register
N	AT91_REG	 SMC_DELAY2; 	// SMC Delay Control Register
N	AT91_REG	 SMC_DELAY3; 	// SMC Delay Control Register
N	AT91_REG	 SMC_DELAY4; 	// SMC Delay Control Register
N	AT91_REG	 SMC_DELAY5; 	// SMC Delay Control Register
N	AT91_REG	 SMC_DELAY6; 	// SMC Delay Control Register
N	AT91_REG	 SMC_DELAY7; 	// SMC Delay Control Register
N	AT91_REG	 SMC_DELAY8; 	// SMC Delay Control Register
N} AT91S_SMC, *AT91PS_SMC;
N#else
S#define SETUP0          (AT91_CAST(AT91_REG *) 	0x00000000) // (SETUP0)  Setup Register for CS 0
S#define PULSE0          (AT91_CAST(AT91_REG *) 	0x00000004) // (PULSE0)  Pulse Register for CS 0
S#define CYCLE0          (AT91_CAST(AT91_REG *) 	0x00000008) // (CYCLE0)  Cycle Register for CS 0
S#define CTRL0           (AT91_CAST(AT91_REG *) 	0x0000000C) // (CTRL0)  Control Register for CS 0
S#define SETUP1          (AT91_CAST(AT91_REG *) 	0x00000010) // (SETUP1)  Setup Register for CS 1
S#define PULSE1          (AT91_CAST(AT91_REG *) 	0x00000014) // (PULSE1)  Pulse Register for CS 1
S#define CYCLE1          (AT91_CAST(AT91_REG *) 	0x00000018) // (CYCLE1)  Cycle Register for CS 1
S#define CTRL1           (AT91_CAST(AT91_REG *) 	0x0000001C) // (CTRL1)  Control Register for CS 1
S#define SETUP2          (AT91_CAST(AT91_REG *) 	0x00000020) // (SETUP2)  Setup Register for CS 2
S#define PULSE2          (AT91_CAST(AT91_REG *) 	0x00000024) // (PULSE2)  Pulse Register for CS 2
S#define CYCLE2          (AT91_CAST(AT91_REG *) 	0x00000028) // (CYCLE2)  Cycle Register for CS 2
S#define CTRL2           (AT91_CAST(AT91_REG *) 	0x0000002C) // (CTRL2)  Control Register for CS 2
S#define SETUP3          (AT91_CAST(AT91_REG *) 	0x00000030) // (SETUP3)  Setup Register for CS 3
S#define PULSE3          (AT91_CAST(AT91_REG *) 	0x00000034) // (PULSE3)  Pulse Register for CS 3
S#define CYCLE3          (AT91_CAST(AT91_REG *) 	0x00000038) // (CYCLE3)  Cycle Register for CS 3
S#define CTRL3           (AT91_CAST(AT91_REG *) 	0x0000003C) // (CTRL3)  Control Register for CS 3
S#define SETUP4          (AT91_CAST(AT91_REG *) 	0x00000040) // (SETUP4)  Setup Register for CS 4
S#define PULSE4          (AT91_CAST(AT91_REG *) 	0x00000044) // (PULSE4)  Pulse Register for CS 4
S#define CYCLE4          (AT91_CAST(AT91_REG *) 	0x00000048) // (CYCLE4)  Cycle Register for CS 4
S#define CTRL4           (AT91_CAST(AT91_REG *) 	0x0000004C) // (CTRL4)  Control Register for CS 4
S#define SETUP5          (AT91_CAST(AT91_REG *) 	0x00000050) // (SETUP5)  Setup Register for CS 5
S#define PULSE5          (AT91_CAST(AT91_REG *) 	0x00000054) // (PULSE5)  Pulse Register for CS 5
S#define CYCLE5          (AT91_CAST(AT91_REG *) 	0x00000058) // (CYCLE5)  Cycle Register for CS 5
S#define CTRL5           (AT91_CAST(AT91_REG *) 	0x0000005C) // (CTRL5)  Control Register for CS 5
S#define SETUP6          (AT91_CAST(AT91_REG *) 	0x00000060) // (SETUP6)  Setup Register for CS 6
S#define PULSE6          (AT91_CAST(AT91_REG *) 	0x00000064) // (PULSE6)  Pulse Register for CS 6
S#define CYCLE6          (AT91_CAST(AT91_REG *) 	0x00000068) // (CYCLE6)  Cycle Register for CS 6
S#define CTRL6           (AT91_CAST(AT91_REG *) 	0x0000006C) // (CTRL6)  Control Register for CS 6
S#define SETUP7          (AT91_CAST(AT91_REG *) 	0x00000070) // (SETUP7)  Setup Register for CS 7
S#define PULSE7          (AT91_CAST(AT91_REG *) 	0x00000074) // (PULSE7)  Pulse Register for CS 7
S#define CYCLE7          (AT91_CAST(AT91_REG *) 	0x00000078) // (CYCLE7)  Cycle Register for CS 7
S#define CTRL7           (AT91_CAST(AT91_REG *) 	0x0000007C) // (CTRL7)  Control Register for CS 7
S#define DELAY1          (AT91_CAST(AT91_REG *) 	0x000000C0) // (DELAY1) SMC Delay Control Register
S#define DELAY2          (AT91_CAST(AT91_REG *) 	0x000000C4) // (DELAY2) SMC Delay Control Register
S#define DELAY3          (AT91_CAST(AT91_REG *) 	0x000000C8) // (DELAY3) SMC Delay Control Register
S#define DELAY4          (AT91_CAST(AT91_REG *) 	0x000000CC) // (DELAY4) SMC Delay Control Register
S#define DELAY5          (AT91_CAST(AT91_REG *) 	0x000000D0) // (DELAY5) SMC Delay Control Register
S#define DELAY6          (AT91_CAST(AT91_REG *) 	0x000000D4) // (DELAY6) SMC Delay Control Register
S#define DELAY7          (AT91_CAST(AT91_REG *) 	0x000000D8) // (DELAY7) SMC Delay Control Register
S#define DELAY8          (AT91_CAST(AT91_REG *) 	0x000000DC) // (DELAY8) SMC Delay Control Register
S
N#endif
N// -------- SMC_SETUP : (SMC Offset: 0x0) Setup Register for CS x -------- 
N#define AT91C_SMC_NWESETUP    (0x3F <<  0) // (SMC) NWE Setup Length
N#define AT91C_SMC_NCSSETUPWR  (0x3F <<  8) // (SMC) NCS Setup Length in WRite Access
N#define AT91C_SMC_NRDSETUP    (0x3F << 16) // (SMC) NRD Setup Length
N#define AT91C_SMC_NCSSETUPRD  (0x3F << 24) // (SMC) NCS Setup Length in ReaD Access
N// -------- SMC_PULSE : (SMC Offset: 0x4) Pulse Register for CS x -------- 
N#define AT91C_SMC_NWEPULSE    (0x7F <<  0) // (SMC) NWE Pulse Length
N#define AT91C_SMC_NCSPULSEWR  (0x7F <<  8) // (SMC) NCS Pulse Length in WRite Access
N#define AT91C_SMC_NRDPULSE    (0x7F << 16) // (SMC) NRD Pulse Length
N#define AT91C_SMC_NCSPULSERD  (0x7F << 24) // (SMC) NCS Pulse Length in ReaD Access
N// -------- SMC_CYC : (SMC Offset: 0x8) Cycle Register for CS x -------- 
N#define AT91C_SMC_NWECYCLE    (0x1FF <<  0) // (SMC) Total Write Cycle Length
N#define AT91C_SMC_NRDCYCLE    (0x1FF << 16) // (SMC) Total Read Cycle Length
N// -------- SMC_CTRL : (SMC Offset: 0xc) Control Register for CS x -------- 
N#define AT91C_SMC_READMODE    (0x1 <<  0) // (SMC) Read Mode
N#define AT91C_SMC_WRITEMODE   (0x1 <<  1) // (SMC) Write Mode
N#define AT91C_SMC_NWAITM      (0x3 <<  5) // (SMC) NWAIT Mode
N#define 	AT91C_SMC_NWAITM_NWAIT_DISABLE        (0x0 <<  5) // (SMC) External NWAIT disabled.
N#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_FROZEN  (0x2 <<  5) // (SMC) External NWAIT enabled in frozen mode.
N#define 	AT91C_SMC_NWAITM_NWAIT_ENABLE_READY   (0x3 <<  5) // (SMC) External NWAIT enabled in ready mode.
N#define AT91C_SMC_BAT         (0x1 <<  8) // (SMC) Byte Access Type
N#define 	AT91C_SMC_BAT_BYTE_SELECT          (0x0 <<  8) // (SMC) Write controled by ncs, nbs0, nbs1, nbs2, nbs3. Read controled by ncs, nrd, nbs0, nbs1, nbs2, nbs3.
N#define 	AT91C_SMC_BAT_BYTE_WRITE           (0x1 <<  8) // (SMC) Write controled by ncs, nwe0, nwe1, nwe2, nwe3. Read controled by ncs and nrd.
N#define AT91C_SMC_DBW         (0x3 << 12) // (SMC) Data Bus Width
N#define 	AT91C_SMC_DBW_WIDTH_EIGTH_BITS     (0x0 << 12) // (SMC) 8 bits.
N#define 	AT91C_SMC_DBW_WIDTH_SIXTEEN_BITS   (0x1 << 12) // (SMC) 16 bits.
N#define 	AT91C_SMC_DBW_WIDTH_THIRTY_TWO_BITS (0x2 << 12) // (SMC) 32 bits.
N#define AT91C_SMC_TDF         (0xF << 16) // (SMC) Data Float Time.
N#define AT91C_SMC_TDFEN       (0x1 << 20) // (SMC) TDF Enabled.
N#define AT91C_SMC_PMEN        (0x1 << 24) // (SMC) Page Mode Enabled.
N#define AT91C_SMC_PS          (0x3 << 28) // (SMC) Page Size
N#define 	AT91C_SMC_PS_SIZE_FOUR_BYTES      (0x0 << 28) // (SMC) 4 bytes.
N#define 	AT91C_SMC_PS_SIZE_EIGHT_BYTES     (0x1 << 28) // (SMC) 8 bytes.
N#define 	AT91C_SMC_PS_SIZE_SIXTEEN_BYTES   (0x2 << 28) // (SMC) 16 bytes.
N#define 	AT91C_SMC_PS_SIZE_THIRTY_TWO_BYTES (0x3 << 28) // (SMC) 32 bytes.
N// -------- SMC_SETUP : (SMC Offset: 0x10) Setup Register for CS x -------- 
N// -------- SMC_PULSE : (SMC Offset: 0x14) Pulse Register for CS x -------- 
N// -------- SMC_CYC : (SMC Offset: 0x18) Cycle Register for CS x -------- 
N// -------- SMC_CTRL : (SMC Offset: 0x1c) Control Register for CS x -------- 
N// -------- SMC_SETUP : (SMC Offset: 0x20) Setup Register for CS x -------- 
N// -------- SMC_PULSE : (SMC Offset: 0x24) Pulse Register for CS x -------- 
N// -------- SMC_CYC : (SMC Offset: 0x28) Cycle Register for CS x -------- 
N// -------- SMC_CTRL : (SMC Offset: 0x2c) Control Register for CS x -------- 
N// -------- SMC_SETUP : (SMC Offset: 0x30) Setup Register for CS x -------- 
N// -------- SMC_PULSE : (SMC Offset: 0x34) Pulse Register for CS x -------- 
N// -------- SMC_CYC : (SMC Offset: 0x38) Cycle Register for CS x -------- 
N// -------- SMC_CTRL : (SMC Offset: 0x3c) Control Register for CS x -------- 
N// -------- SMC_SETUP : (SMC Offset: 0x40) Setup Register for CS x -------- 
N// -------- SMC_PULSE : (SMC Offset: 0x44) Pulse Register for CS x -------- 
N// -------- SMC_CYC : (SMC Offset: 0x48) Cycle Register for CS x -------- 
N// -------- SMC_CTRL : (SMC Offset: 0x4c) Control Register for CS x -------- 
N// -------- SMC_SETUP : (SMC Offset: 0x50) Setup Register for CS x -------- 
N// -------- SMC_PULSE : (SMC Offset: 0x54) Pulse Register for CS x -------- 
N// -------- SMC_CYC : (SMC Offset: 0x58) Cycle Register for CS x -------- 
N// -------- SMC_CTRL : (SMC Offset: 0x5c) Control Register for CS x -------- 
N// -------- SMC_SETUP : (SMC Offset: 0x60) Setup Register for CS x -------- 
N// -------- SMC_PULSE : (SMC Offset: 0x64) Pulse Register for CS x -------- 
N// -------- SMC_CYC : (SMC Offset: 0x68) Cycle Register for CS x -------- 
N// -------- SMC_CTRL : (SMC Offset: 0x6c) Control Register for CS x -------- 
N// -------- SMC_SETUP : (SMC Offset: 0x70) Setup Register for CS x -------- 
N// -------- SMC_PULSE : (SMC Offset: 0x74) Pulse Register for CS x -------- 
N// -------- SMC_CYC : (SMC Offset: 0x78) Cycle Register for CS x -------- 
N// -------- SMC_CTRL : (SMC Offset: 0x7c) Control Register for CS x -------- 
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR AHB Matrix Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_MATRIX {
N	AT91_REG	 MATRIX_MCFG0; 	//  Master Configuration Register 0 : ARM-I
N	AT91_REG	 MATRIX_MCFG1; 	//  Master Configuration Register 1 ; ARM-D
N	AT91_REG	 MATRIX_MCFG2; 	//  Master Configuration Register 2 : pdc
N	AT91_REG	 MATRIX_MCFG3; 	//  Master Configuration Register 3 : USB Host OHCI
N	AT91_REG	 MATRIX_MCFG4; 	//  Master Configuration Register 4 : DMA0
N	AT91_REG	 MATRIX_MCFG5; 	//  Master Configuration Register 5 : DMA1
N	AT91_REG	 MATRIX_MCFG6; 	//  Master Configuration Register 6 : hisi
N	AT91_REG	 MATRIX_MCFG7; 	//  Master Configuration Register 7 : lcdc
N	AT91_REG	 MATRIX_MCFG8; 	//  Master Configuration Register 8 : eMAC
N	AT91_REG	 MATRIX_MCFG9; 	//  Master Configuration Register 9 : USB Device
N	AT91_REG	 MATRIX_MCFG10; 	//  Master Configuration Register 10 : USB Host EHCI
N	AT91_REG	 MATRIX_MCFG11; 	//  Master Configuration Register 11 : Video Decoder
N	AT91_REG	 Reserved0[4]; 	// 
N	AT91_REG	 MATRIX_SCFG0; 	//  Slave Configuration Register 0 : SRAM S0
N	AT91_REG	 MATRIX_SCFG1; 	//  Slave Configuration Register 1 : SRAM S1
N	AT91_REG	 MATRIX_SCFG2; 	//  Slave Configuration Register 2 : SRAM S2
N	AT91_REG	 MATRIX_SCFG3; 	//  Slave Configuration Register 3 : SRAM S3
N	AT91_REG	 MATRIX_SCFG4; 	//  Slave Configuration Register 4 ; ROM + USB Dev + USB EHCI + USB OHCI + LCD + Video Decoder
N	AT91_REG	 MATRIX_SCFG5; 	//  Slave Configuration Register 5 : DDR2 S0
N	AT91_REG	 MATRIX_SCFG6; 	//  Slave Configuration Register 6 : DDR2 S1
N	AT91_REG	 MATRIX_SCFG7; 	//  Slave Configuration Register 7 : DDR2 S2
N	AT91_REG	 Reserved1[8]; 	// 
N	AT91_REG	 MATRIX_PRAS0; 	//  PRAS0 : SRAM S0
N	AT91_REG	 MATRIX_PRBS0; 	//  PRBS0 : SRAM S0
N	AT91_REG	 MATRIX_PRAS1; 	//  PRAS1 : SRAM S1
N	AT91_REG	 MATRIX_PRBS1; 	//  PRBS1 : SRAM S1
N	AT91_REG	 MATRIX_PRAS2; 	//  PRAS2 : SRAM S2
N	AT91_REG	 MATRIX_PRBS2; 	//  PRBS2 : SRAM S2
N	AT91_REG	 MATRIX_PRAS3; 	//  PRAS3 : SRAM S3
N	AT91_REG	 MATRIX_PRBS3; 	//  PRBS3 : SRAM S3
N	AT91_REG	 MATRIX_PRAS4; 	//  PRAS4 : ROM + USB Dev + USB EHCI + USB OHCI + LCD + Video Decoder
N	AT91_REG	 MATRIX_PRBS4; 	//  PRBS4 : ROM + USB Dev + USB EHCI + USB OHCI + LCD + Video Decoder
N	AT91_REG	 MATRIX_PRAS5; 	//  PRAS5 : DDR2 S0
N	AT91_REG	 MATRIX_PRBS5; 	//  PRBS5 : DDR2 S0
N	AT91_REG	 MATRIX_PRAS6; 	//  PRAS6 : DDR2 S1
N	AT91_REG	 MATRIX_PRBS6; 	//  PRBS6 : DDR2 S1
N	AT91_REG	 MATRIX_PRAS7; 	//  PRAS7 : DDR2 S2
N	AT91_REG	 MATRIX_PRBS7; 	//  PRBS7 : DDR2 S2
N	AT91_REG	 Reserved2[16]; 	// 
N	AT91_REG	 MATRIX_MRCR; 	//  Master Remap Control Register 
N	AT91_REG	 Reserved3[56]; 	// 
N	AT91_REG	 MATRIX_WRPROTEN; 	//  Write Protection Control Register 
N	AT91_REG	 MATRIX_WRPROTST; 	//  Write Protection Status Register 
N} AT91S_MATRIX, *AT91PS_MATRIX;
N#else
S#define MATRIX_MCFG0    (AT91_CAST(AT91_REG *) 	0x00000000) // (MATRIX_MCFG0)  Master Configuration Register 0 : ARM-I
S#define MATRIX_MCFG1    (AT91_CAST(AT91_REG *) 	0x00000004) // (MATRIX_MCFG1)  Master Configuration Register 1 ; ARM-D
S#define MATRIX_MCFG2    (AT91_CAST(AT91_REG *) 	0x00000008) // (MATRIX_MCFG2)  Master Configuration Register 2 : pdc
S#define MATRIX_MCFG3    (AT91_CAST(AT91_REG *) 	0x0000000C) // (MATRIX_MCFG3)  Master Configuration Register 3 : USB Host OHCI
S#define MATRIX_MCFG4    (AT91_CAST(AT91_REG *) 	0x00000010) // (MATRIX_MCFG4)  Master Configuration Register 4 : DMA0
S#define MATRIX_MCFG5    (AT91_CAST(AT91_REG *) 	0x00000014) // (MATRIX_MCFG5)  Master Configuration Register 5 : DMA1
S#define MATRIX_MCFG6    (AT91_CAST(AT91_REG *) 	0x00000018) // (MATRIX_MCFG6)  Master Configuration Register 6 : hisi
S#define MATRIX_MCFG7    (AT91_CAST(AT91_REG *) 	0x0000001C) // (MATRIX_MCFG7)  Master Configuration Register 7 : lcdc
S#define MATRIX_MCFG8    (AT91_CAST(AT91_REG *) 	0x00000020) // (MATRIX_MCFG8)  Master Configuration Register 8 : eMAC
S#define MATRIX_MCFG9    (AT91_CAST(AT91_REG *) 	0x00000024) // (MATRIX_MCFG9)  Master Configuration Register 9 : USB Device
S#define MATRIX_MCFG10   (AT91_CAST(AT91_REG *) 	0x00000028) // (MATRIX_MCFG10)  Master Configuration Register 10 : USB Host EHCI
S#define MATRIX_MCFG11   (AT91_CAST(AT91_REG *) 	0x0000002C) // (MATRIX_MCFG11)  Master Configuration Register 11 : Video Decoder
S#define MATRIX_SCFG0    (AT91_CAST(AT91_REG *) 	0x00000040) // (MATRIX_SCFG0)  Slave Configuration Register 0 : SRAM S0
S#define MATRIX_SCFG1    (AT91_CAST(AT91_REG *) 	0x00000044) // (MATRIX_SCFG1)  Slave Configuration Register 1 : SRAM S1
S#define MATRIX_SCFG2    (AT91_CAST(AT91_REG *) 	0x00000048) // (MATRIX_SCFG2)  Slave Configuration Register 2 : SRAM S2
S#define MATRIX_SCFG3    (AT91_CAST(AT91_REG *) 	0x0000004C) // (MATRIX_SCFG3)  Slave Configuration Register 3 : SRAM S3
S#define MATRIX_SCFG4    (AT91_CAST(AT91_REG *) 	0x00000050) // (MATRIX_SCFG4)  Slave Configuration Register 4 ; ROM + USB Dev + USB EHCI + USB OHCI + LCD + Video Decoder
S#define MATRIX_SCFG5    (AT91_CAST(AT91_REG *) 	0x00000054) // (MATRIX_SCFG5)  Slave Configuration Register 5 : DDR2 S0
S#define MATRIX_SCFG6    (AT91_CAST(AT91_REG *) 	0x00000058) // (MATRIX_SCFG6)  Slave Configuration Register 6 : DDR2 S1
S#define MATRIX_SCFG7    (AT91_CAST(AT91_REG *) 	0x0000005C) // (MATRIX_SCFG7)  Slave Configuration Register 7 : DDR2 S2
S#define MATRIX_PRAS0    (AT91_CAST(AT91_REG *) 	0x00000080) // (MATRIX_PRAS0)  PRAS0 : SRAM S0
S#define MATRIX_PRBS0    (AT91_CAST(AT91_REG *) 	0x00000084) // (MATRIX_PRBS0)  PRBS0 : SRAM S0
S#define MATRIX_PRAS1    (AT91_CAST(AT91_REG *) 	0x00000088) // (MATRIX_PRAS1)  PRAS1 : SRAM S1
S#define MATRIX_PRBS1    (AT91_CAST(AT91_REG *) 	0x0000008C) // (MATRIX_PRBS1)  PRBS1 : SRAM S1
S#define MATRIX_PRAS2    (AT91_CAST(AT91_REG *) 	0x00000090) // (MATRIX_PRAS2)  PRAS2 : SRAM S2
S#define MATRIX_PRBS2    (AT91_CAST(AT91_REG *) 	0x00000094) // (MATRIX_PRBS2)  PRBS2 : SRAM S2
S#define MATRIX_PRAS3    (AT91_CAST(AT91_REG *) 	0x00000098) // (MATRIX_PRAS3)  PRAS3 : SRAM S3
S#define MATRIX_PRBS3    (AT91_CAST(AT91_REG *) 	0x0000009C) // (MATRIX_PRBS3)  PRBS3 : SRAM S3
S#define MATRIX_PRAS4    (AT91_CAST(AT91_REG *) 	0x000000A0) // (MATRIX_PRAS4)  PRAS4 : ROM + USB Dev + USB EHCI + USB OHCI + LCD + Video Decoder
S#define MATRIX_PRBS4    (AT91_CAST(AT91_REG *) 	0x000000A4) // (MATRIX_PRBS4)  PRBS4 : ROM + USB Dev + USB EHCI + USB OHCI + LCD + Video Decoder
S#define MATRIX_PRAS5    (AT91_CAST(AT91_REG *) 	0x000000A8) // (MATRIX_PRAS5)  PRAS5 : DDR2 S0
S#define MATRIX_PRBS5    (AT91_CAST(AT91_REG *) 	0x000000AC) // (MATRIX_PRBS5)  PRBS5 : DDR2 S0
S#define MATRIX_PRAS6    (AT91_CAST(AT91_REG *) 	0x000000B0) // (MATRIX_PRAS6)  PRAS6 : DDR2 S1
S#define MATRIX_PRBS6    (AT91_CAST(AT91_REG *) 	0x000000B4) // (MATRIX_PRBS6)  PRBS6 : DDR2 S1
S#define MATRIX_PRAS7    (AT91_CAST(AT91_REG *) 	0x000000B8) // (MATRIX_PRAS7)  PRAS7 : DDR2 S2
S#define MATRIX_PRBS7    (AT91_CAST(AT91_REG *) 	0x000000BC) // (MATRIX_PRBS7)  PRBS7 : DDR2 S2
S#define MATRIX_MRCR     (AT91_CAST(AT91_REG *) 	0x00000100) // (MATRIX_MRCR)  Master Remap Control Register 
S#define MATRIX_WRPROTEN (AT91_CAST(AT91_REG *) 	0x000001E4) // (MATRIX_WRPROTEN)  Write Protection Control Register 
S#define MATRIX_WRPROTST (AT91_CAST(AT91_REG *) 	0x000001E8) // (MATRIX_WRPROTST)  Write Protection Status Register 
S
N#endif
N// -------- MATRIX_MCFG0 : (MATRIX Offset: 0x0) Master Configuration Register ARM-I -------- 
N#define AT91C_MATRIX_ULBT     (0x7 <<  0) // (MATRIX) Undefined Length Burst Type
N// -------- MATRIX_MCFG1 : (MATRIX Offset: 0x4) Master Configuration Register ARM-D -------- 
N// -------- MATRIX_MCFG2 : (MATRIX Offset: 0x8) Master Configuration Register PDC -------- 
N// -------- MATRIX_MCFG3 : (MATRIX Offset: 0xc) Master Configuration Register USB Host OHCI -------- 
N// -------- MATRIX_MCFG4 : (MATRIX Offset: 0x10) Master Configuration Register DMA0 -------- 
N// -------- MATRIX_MCFG5 : (MATRIX Offset: 0x14) Master Configuration Register DMA1 -------- 
N// -------- MATRIX_MCFG6 : (MATRIX Offset: 0x18) Master Configuration Register HISI -------- 
N// -------- MATRIX_MCFG7 : (MATRIX Offset: 0x1c) Master Configuration Register LCD -------- 
N// -------- MATRIX_MCFG8 : (MATRIX Offset: 0x20) Master Configuration Register EMAC -------- 
N// -------- MATRIX_MCFG9 : (MATRIX Offset: 0x24) Master Configuration Register USB Device -------- 
N// -------- MATRIX_MCFG10 : (MATRIX Offset: 0x28) Master Configuration Register USB Host EHCI -------- 
N// -------- MATRIX_MCFG11 : (MATRIX Offset: 0x2c) Master Configuration Register Video Decoder -------- 
N// -------- MATRIX_SCFG0 : (MATRIX Offset: 0x40) Slave Configuration Register 0 -------- 
N#define AT91C_MATRIX_SLOT_CYCLE (0xFF <<  0) // (MATRIX) Maximum Number of Allowed Cycles for a Burst
N#define AT91C_MATRIX_DEFMSTR_TYPE (0x3 << 16) // (MATRIX) Default Master Type
N#define 	AT91C_MATRIX_DEFMSTR_TYPE_NO_DEFMSTR           (0x0 << 16) // (MATRIX) No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This results in having a one cycle latency for the first transfer of a burst.
N#define 	AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR         (0x1 << 16) // (MATRIX) Last Default Master. At the end of current slave access, if no other master request is pending, the slave stay connected with the last master having accessed it. This results in not having the one cycle latency when the last master re-trying access on the slave.
N#define 	AT91C_MATRIX_DEFMSTR_TYPE_FIXED_DEFMSTR        (0x2 << 16) // (MATRIX) Fixed Default Master. At the end of current slave access, if no other master request is pending, the slave connects with fixed which number is in FIXED_DEFMSTR field. This results in not having the one cycle latency when the fixed master re-trying access on the slave.
N#define AT91C_MATRIX_FIXED_DEFMSTR0 (0xF << 18) // (MATRIX) Fixed Index of Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR0_ARM926I              (0x0 << 18) // (MATRIX) ARM926EJ-S Instruction Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR0_ARM926D              (0x1 << 18) // (MATRIX) ARM926EJ-S Data Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR0_PDC                  (0x2 << 18) // (MATRIX) PDC Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR0_UHPHS_OHCI           (0x3 << 18) // (MATRIX) USB Host OHCI Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR0_DMA0                 (0x4 << 18) // (MATRIX) DMA0 Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR0_DMA1                 (0x5 << 18) // (MATRIX) DMA1 Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR0_ISI                  (0x6 << 18) // (MATRIX) ISI Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR0_EMAC                 (0x8 << 18) // (MATRIX) EMAC Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR0_UDPHS                (0x9 << 18) // (MATRIX) USB Device Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR0_UHPHS_EHCI           (0xA << 18) // (MATRIX) USB Host EHCI Master is Default Master
N#define AT91C_MATRIX_ARBT     (0x3 << 24) // (MATRIX) Arbitration Type
N// -------- MATRIX_SCFG1 : (MATRIX Offset: 0x44) Slave Configuration Register 1 -------- 
N#define AT91C_MATRIX_FIXED_DEFMSTR1 (0xF << 18) // (MATRIX) Fixed Index of Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR1_ARM926I              (0x0 << 18) // (MATRIX) ARM926EJ-S Instruction Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR1_ARM926D              (0x1 << 18) // (MATRIX) ARM926EJ-S Data Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR1_PDC                  (0x2 << 18) // (MATRIX) PDC Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR1_ISI                  (0x6 << 18) // (MATRIX) ISI Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR1_UDPHS                (0x9 << 18) // (MATRIX) USB Device Master is Default Master
N// -------- MATRIX_SCFG2 : (MATRIX Offset: 0x48) Slave Configuration Register 2 -------- 
N#define AT91C_MATRIX_FIXED_DEFMSTR2 (0xF << 18) // (MATRIX) Fixed Index of Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR2_ARM926I              (0x0 << 18) // (MATRIX) ARM926EJ-S Instruction Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR2_VDEC                 (0xB << 18) // (MATRIX) Video Decoder Master is Default Master
N// -------- MATRIX_SCFG3 : (MATRIX Offset: 0x4c) Slave Configuration Register 3 -------- 
N#define AT91C_MATRIX_FIXED_DEFMSTR3 (0xF << 18) // (MATRIX) Fixed Index of Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR3_ARM926D              (0x1 << 18) // (MATRIX) ARM926EJ-S Data Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR3_LCD                  (0x7 << 18) // (MATRIX) LCD Master is Default Master
N// -------- MATRIX_SCFG4 : (MATRIX Offset: 0x50) Slave Configuration Register 4 -------- 
N#define AT91C_MATRIX_FIXED_DEFMSTR4 (0xF << 18) // (MATRIX) Fixed Index of Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR4_ARM926I              (0x0 << 18) // (MATRIX) ARM926EJ-S Instruction Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR4_PDC                  (0x2 << 18) // (MATRIX) PDC Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR4_UHPHS_OHCI           (0x3 << 18) // (MATRIX) USB Host OHCI Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR4_DMA0                 (0x4 << 18) // (MATRIX) DMA0 Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR4_DMA1                 (0x5 << 18) // (MATRIX) DMA1 Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR4_ISI                  (0x6 << 18) // (MATRIX) ISI Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR4_EMAC                 (0x8 << 18) // (MATRIX) EMAC Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR4_UDPHS                (0x9 << 18) // (MATRIX) USB Device Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR4_UHPHS_EHCI           (0xA << 18) // (MATRIX) USB Host EHCI Master is Default Master
N// -------- MATRIX_SCFG5 : (MATRIX Offset: 0x54) Slave Configuration Register 5 -------- 
N#define AT91C_MATRIX_FIXED_DEFMSTR5 (0xF << 18) // (MATRIX) Fixed Index of Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR5_ARM926D              (0x1 << 18) // (MATRIX) ARM926EJ-S Data Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR5_PDC                  (0x2 << 18) // (MATRIX) PDC Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR5_UHPHS_OHCI           (0x3 << 18) // (MATRIX) USB Host OHCI Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR5_DMA0                 (0x4 << 18) // (MATRIX) DMA0 Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR5_DMA1                 (0x5 << 18) // (MATRIX) DMA1 Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR5_ISI                  (0x6 << 18) // (MATRIX) ISI Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR5_EMAC                 (0x8 << 18) // (MATRIX) EMAC Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR5_UDPHS                (0x9 << 18) // (MATRIX) USB Device Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR5_UHPHS_EHCI           (0xA << 18) // (MATRIX) USB Host EHCI Master is Default Master
N// -------- MATRIX_SCFG6 : (MATRIX Offset: 0x58) Slave Configuration Register 6 -------- 
N#define AT91C_MATRIX_FIXED_DEFMSTR6 (0xF << 18) // (MATRIX) Fixed Index of Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR6_ARM926I              (0x0 << 18) // (MATRIX) ARM926EJ-S Instruction Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR6_ARM926D              (0x1 << 18) // (MATRIX) ARM926EJ-S Data Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR6_PDC                  (0x2 << 18) // (MATRIX) PDC Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR6_UHPHS_OHCI           (0x3 << 18) // (MATRIX) USB Host OHCI Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR6_DMA0                 (0x4 << 18) // (MATRIX) DMA0 Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR6_DMA1                 (0x5 << 18) // (MATRIX) DMA1 Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR6_ISI                  (0x6 << 18) // (MATRIX) ISI Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR6_LCD                  (0x7 << 18) // (MATRIX) LCD Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR6_EMAC                 (0x8 << 18) // (MATRIX) EMAC Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR6_UDPHS                (0x9 << 18) // (MATRIX) USB Device Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR6_UHPHS_EHCI           (0xA << 18) // (MATRIX) USB Host EHCI Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR6_VDEC                 (0xB << 18) // (MATRIX) Video Decoder Master is Default Master
N// -------- MATRIX_SCFG7 : (MATRIX Offset: 0x5c) Slave Configuration Register 7 -------- 
N#define AT91C_MATRIX_FIXED_DEFMSTR7 (0xF << 18) // (MATRIX) Fixed Index of Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR7_ARM926I              (0x0 << 18) // (MATRIX) ARM926EJ-S Instruction Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR7_ARM926D              (0x1 << 18) // (MATRIX) ARM926EJ-S Data Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR7_PDC                  (0x2 << 18) // (MATRIX) PDC Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR7_DMA0                 (0x4 << 18) // (MATRIX) DMA0 Master is Default Master
N#define 	AT91C_MATRIX_FIXED_DEFMSTR7_DMA1                 (0x5 << 18) // (MATRIX) DMA1 Master is Default Master
N// -------- MATRIX_PRAS0 : (MATRIX Offset: 0x80) PRAS0 Register -------- 
N#define AT91C_MATRIX_M0PR     (0x3 <<  0) // (MATRIX) ARM926EJ-S Instruction priority
N#define AT91C_MATRIX_M1PR     (0x3 <<  4) // (MATRIX) ARM926EJ-S Data priority
N#define AT91C_MATRIX_M2PR     (0x3 <<  8) // (MATRIX) PDC priority
N#define AT91C_MATRIX_M3PR     (0x3 << 12) // (MATRIX) USB Host OHCI priority
N#define AT91C_MATRIX_M4PR     (0x3 << 16) // (MATRIX) DMA0 priority
N#define AT91C_MATRIX_M5PR     (0x3 << 20) // (MATRIX) DMA1 priority
N#define AT91C_MATRIX_M6PR     (0x3 << 24) // (MATRIX) ISI priority
N#define AT91C_MATRIX_M7PR     (0x3 << 28) // (MATRIX) LCD priority
N// -------- MATRIX_PRBS0 : (MATRIX Offset: 0x84) PRBS0 Register -------- 
N#define AT91C_MATRIX_M8PR     (0x3 <<  0) // (MATRIX) EMAC priority
N#define AT91C_MATRIX_M9PR     (0x3 <<  4) // (MATRIX) USB Device priority
N#define AT91C_MATRIX_M10PR    (0x3 <<  8) // (MATRIX) USB Host EHCI priority
N#define AT91C_MATRIX_M11PR    (0x3 << 12) // (MATRIX) Video Decoder priority
N// -------- MATRIX_PRAS1 : (MATRIX Offset: 0x88) PRAS1 Register -------- 
N// -------- MATRIX_PRBS1 : (MATRIX Offset: 0x8c) PRBS1 Register -------- 
N// -------- MATRIX_PRAS2 : (MATRIX Offset: 0x90) PRAS2 Register -------- 
N// -------- MATRIX_PRBS2 : (MATRIX Offset: 0x94) PRBS2 Register -------- 
N// -------- MATRIX_PRAS3 : (MATRIX Offset: 0x98) PRAS3 Register -------- 
N// -------- MATRIX_PRBS3 : (MATRIX Offset: 0x9c) PRBS3 Register -------- 
N// -------- MATRIX_PRAS4 : (MATRIX Offset: 0xa0) PRAS4 Register -------- 
N// -------- MATRIX_PRBS4 : (MATRIX Offset: 0xa4) PRBS4 Register -------- 
N// -------- MATRIX_PRAS5 : (MATRIX Offset: 0xa8) PRAS5 Register -------- 
N// -------- MATRIX_PRBS5 : (MATRIX Offset: 0xac) PRBS5 Register -------- 
N// -------- MATRIX_PRAS6 : (MATRIX Offset: 0xb0) PRAS6 Register -------- 
N// -------- MATRIX_PRBS6 : (MATRIX Offset: 0xb4) PRBS6 Register -------- 
N// -------- MATRIX_PRAS7 : (MATRIX Offset: 0xb8) PRAS7 Register -------- 
N// -------- MATRIX_PRBS7 : (MATRIX Offset: 0xbc) PRBS7 Register -------- 
N// -------- MATRIX_MRCR : (MATRIX Offset: 0x100) MRCR Register -------- 
N#define AT91C_MATRIX_RCA926I  (0x1 <<  0) // (MATRIX) Remap Command Bit for ARM926EJ-S Instruction
N#define AT91C_MATRIX_RCA926D  (0x1 <<  1) // (MATRIX) Remap Command Bit for ARM926EJ-S Data
N#define AT91C_MATRIX_RCB2     (0x1 <<  2) // (MATRIX) Remap Command Bit for PDC
N#define AT91C_MATRIX_RCB3     (0x1 <<  3) // (MATRIX) Remap Command Bit for USB Host OHCI
N#define AT91C_MATRIX_RCB4     (0x1 <<  4) // (MATRIX) Remap Command Bit for DMA0
N#define AT91C_MATRIX_RCB5     (0x1 <<  5) // (MATRIX) Remap Command Bit for DMA1
N#define AT91C_MATRIX_RCB6     (0x1 <<  6) // (MATRIX) Remap Command Bit for ISI
N#define AT91C_MATRIX_RCB7     (0x1 <<  7) // (MATRIX) Remap Command Bit for LCD
N#define AT91C_MATRIX_RCB8     (0x1 <<  8) // (MATRIX) Remap Command Bit for EMAC
N#define AT91C_MATRIX_RCB9     (0x1 <<  9) // (MATRIX) Remap Command Bit for USB Device
N#define AT91C_MATRIX_RCB10    (0x1 << 10) // (MATRIX) Remap Command Bit for USB Host EHCI
N#define AT91C_MATRIX_RCB11    (0x1 << 11) // (MATRIX) Remap Command Bit for Video Decoder
N// -------- MATRIX_WRPROTEN : (MATRIX Offset: 0x1e4) Write Protection Control Register -------- 
N#define AT91C_MATRIX_WRPROT   (0x1 <<  0) // (MATRIX) Enable/Disable Write Protection of HMATRIX2 configuration registers (requires key)
N#define 	AT91C_MATRIX_WRPROT_DISABLE              (0x0) // (MATRIX) Disable Write Protection of HMATRIX2 configuration registers
N#define 	AT91C_MATRIX_WRPROT_ENABLE               (0x1) // (MATRIX) Enable  Write Protection of HMATRIX2 configuration registers
N// -------- MATRIX_WRPROTST : (MATRIX Offset: 0x1e8) Write Protection Status Register -------- 
N#define AT91C_MATRIX_WRPROT_VIOLATION (0x1 <<  0) // (MATRIX) Violation of Write Protection of HMATRIX2 configuration registers
N#define 	AT91C_MATRIX_WRPROT_VIOLATION_UNDETECTED           (0x0) // (MATRIX) No violation of Write Protection of HMATRIX2 configuration registers
N#define 	AT91C_MATRIX_WRPROT_VIOLATION_DETECTED             (0x1) // (MATRIX) Violation of  Write Protection of HMATRIX2 configuration registers
N#define AT91C_MATRIX_WRPROT_VIOLATION_OFFSET (0x1FF <<  8) // (MATRIX) Offset where violation of Write Protection of HMATRIX2 configuration registers is detected
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR AHB CCFG Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_CCFG {
N	AT91_REG	 CCFG_TCMR; 	//  TCM configuration
N	AT91_REG	 CCFG_UDPHS; 	//  USB HS configuration
N	AT91_REG	 CCFG_VIDEO; 	//  Video Mode configuration
N	AT91_REG	 Reserved0[3]; 	// 
N	AT91_REG	 CCFG_EBICSA; 	//  EBI Chip Select Assignement Register
N	AT91_REG	 Reserved1[52]; 	// 
N	AT91_REG	 CCFG_MATRIXVERSION; 	//  Version Register
N} AT91S_CCFG, *AT91PS_CCFG;
N#else
S#define CCFG_TCMR       (AT91_CAST(AT91_REG *) 	0x00000000) // (CCFG_TCMR)  TCM configuration
S#define CCFG_UDPHS      (AT91_CAST(AT91_REG *) 	0x00000004) // (CCFG_UDPHS)  USB HS configuration
S#define CCFG_VIDEO      (AT91_CAST(AT91_REG *) 	0x00000008) // (CCFG_VIDEO)  Video Mode configuration
S#define CCFG_EBICSA     (AT91_CAST(AT91_REG *) 	0x00000018) // (CCFG_EBICSA)  EBI Chip Select Assignement Register
S#define CCFG_MATRIXVERSION (AT91_CAST(AT91_REG *) 	0x000000EC) // (CCFG_MATRIXVERSION)  Version Register
S
N#endif
N// -------- CCFG_TCMR : (CCFG Offset: 0x0) TCM Configuration -------- 
N#define AT91C_CCFG_ITCM_SIZE  (0xF <<  0) // (CCFG) Size of ITCM enabled memory block
N#define 	AT91C_CCFG_ITCM_SIZE_0KB                  (0x0) // (CCFG) 0 KB (No ITCM Memory)
N#define 	AT91C_CCFG_ITCM_SIZE_32KB                 (0x6) // (CCFG) 32 KB
N#define AT91C_CCFG_DTCM_SIZE  (0xF <<  4) // (CCFG) Size of DTCM enabled memory block
N#define 	AT91C_CCFG_DTCM_SIZE_0KB                  (0x0 <<  4) // (CCFG) 0 KB (No DTCM Memory)
N#define 	AT91C_CCFG_DTCM_SIZE_32KB                 (0x6 <<  4) // (CCFG) 32 KB
N#define 	AT91C_CCFG_DTCM_SIZE_64KB                 (0x7 <<  4) // (CCFG) 64 KB
N#define AT91C_CCFG_WAIT_STATE_TCM (0x1 << 11) // (CCFG) Wait state TCM register
N#define 	AT91C_CCFG_WAIT_STATE_TCM_NO_WS                (0x0 << 11) // (CCFG) NO WAIT STATE : 0 WS
N#define 	AT91C_CCFG_WAIT_STATE_TCM_ONE_WS               (0x1 << 11) // (CCFG) 1 WS activated (only for RATIO 3:1 or 4:1
N// -------- CCFG_UDPHS : (CCFG Offset: 0x4) USB HS configuration -------- 
N#define AT91C_CCFG_DONT_USE_UTMI_LOCK (0x1 <<  0) // (CCFG) 
N#define 	AT91C_CCFG_DONT_USE_UTMI_LOCK_DONT_USE_LOCK        (0x0) // (CCFG) 
N// -------- CCFG_VIDEO : (CCFG Offset: 0x8) Video Mode configuration -------- 
N#define AT91C_VDEC_SEL        (0x1 <<  0) // (CCFG) 
N#define 	AT91C_VDEC_SEL_OFF                  (0x0) // (CCFG) 0: Video Mode OFF
N#define 	AT91C_VDEC_SEL_ON                   (0x1) // (CCFG) 1: Video Mode ON
N// -------- CCFG_EBICSA : (CCFG Offset: 0x18) EBI Chip Select Assignement Register -------- 
N#define AT91C_EBI_CS1A        (0x1 <<  1) // (CCFG) Chip Select 1 Assignment
N#define 	AT91C_EBI_CS1A_SMC                  (0x0 <<  1) // (CCFG) Chip Select 1 is assigned to the Static Memory Controller.
N#define 	AT91C_EBI_CS1A_SDRAMC               (0x1 <<  1) // (CCFG) Chip Select 1 is assigned to the SDRAM Controller.
N#define AT91C_EBI_CS3A        (0x1 <<  3) // (CCFG) Chip Select 3 Assignment
N#define 	AT91C_EBI_CS3A_SMC                  (0x0 <<  3) // (CCFG) Chip Select 3 is only assigned to the Static Memory Controller and NCS3 behaves as defined by the SMC.
N#define 	AT91C_EBI_CS3A_SM                   (0x1 <<  3) // (CCFG) Chip Select 3 is assigned to the Static Memory Controller and the SmartMedia Logic is activated.
N#define AT91C_EBI_CS4A        (0x1 <<  4) // (CCFG) Chip Select 4 Assignment
N#define 	AT91C_EBI_CS4A_SMC                  (0x0 <<  4) // (CCFG) Chip Select 4 is only assigned to the Static Memory Controller and NCS4 behaves as defined by the SMC.
N#define 	AT91C_EBI_CS4A_CF                   (0x1 <<  4) // (CCFG) Chip Select 4 is assigned to the Static Memory Controller and the CompactFlash Logic (first slot) is activated.
N#define AT91C_EBI_CS5A        (0x1 <<  5) // (CCFG) Chip Select 5 Assignment
N#define 	AT91C_EBI_CS5A_SMC                  (0x0 <<  5) // (CCFG) Chip Select 5 is only assigned to the Static Memory Controller and NCS5 behaves as defined by the SMC
N#define 	AT91C_EBI_CS5A_CF                   (0x1 <<  5) // (CCFG) Chip Select 5 is assigned to the Static Memory Controller and the CompactFlash Logic (second slot) is activated.
N#define AT91C_EBI_DBPUC       (0x1 <<  8) // (CCFG) Data Bus Pull-up Configuration
N#define AT91C_EBI_SUPPLY      (0x1 << 16) // (CCFG) EBI supply set to 1.8
N#define AT91C_EBI_DRV         (0x1 << 17) // (CCFG) Drive type for EBI pads
N#define AT91C_CCFG_DDR_DRV    (0x1 << 18) // (CCFG) Drive type for DDR2 dedicated port
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Advanced Interrupt Controller
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_AIC {
N	AT91_REG	 AIC_SMR[32]; 	// Source Mode Register
N	AT91_REG	 AIC_SVR[32]; 	// Source Vector Register
N	AT91_REG	 AIC_IVR; 	// IRQ Vector Register
N	AT91_REG	 AIC_FVR; 	// FIQ Vector Register
N	AT91_REG	 AIC_ISR; 	// Interrupt Status Register
N	AT91_REG	 AIC_IPR; 	// Interrupt Pending Register
N	AT91_REG	 AIC_IMR; 	// Interrupt Mask Register
N	AT91_REG	 AIC_CISR; 	// Core Interrupt Status Register
N	AT91_REG	 Reserved0[2]; 	// 
N	AT91_REG	 AIC_IECR; 	// Interrupt Enable Command Register
N	AT91_REG	 AIC_IDCR; 	// Interrupt Disable Command Register
N	AT91_REG	 AIC_ICCR; 	// Interrupt Clear Command Register
N	AT91_REG	 AIC_ISCR; 	// Interrupt Set Command Register
N	AT91_REG	 AIC_EOICR; 	// End of Interrupt Command Register
N	AT91_REG	 AIC_SPU; 	// Spurious Vector Register
N	AT91_REG	 AIC_DCR; 	// Debug Control Register (Protect)
N	AT91_REG	 Reserved1[1]; 	// 
N	AT91_REG	 AIC_FFER; 	// Fast Forcing Enable Register
N	AT91_REG	 AIC_FFDR; 	// Fast Forcing Disable Register
N	AT91_REG	 AIC_FFSR; 	// Fast Forcing Status Register
N} AT91S_AIC, *AT91PS_AIC;
N#else
S#define AIC_SMR         (AT91_CAST(AT91_REG *) 	0x00000000) // (AIC_SMR) Source Mode Register
S#define AIC_SVR         (AT91_CAST(AT91_REG *) 	0x00000080) // (AIC_SVR) Source Vector Register
S#define AIC_IVR         (AT91_CAST(AT91_REG *) 	0x00000100) // (AIC_IVR) IRQ Vector Register
S#define AIC_FVR         (AT91_CAST(AT91_REG *) 	0x00000104) // (AIC_FVR) FIQ Vector Register
S#define AIC_ISR         (AT91_CAST(AT91_REG *) 	0x00000108) // (AIC_ISR) Interrupt Status Register
S#define AIC_IPR         (AT91_CAST(AT91_REG *) 	0x0000010C) // (AIC_IPR) Interrupt Pending Register
S#define AIC_IMR         (AT91_CAST(AT91_REG *) 	0x00000110) // (AIC_IMR) Interrupt Mask Register
S#define AIC_CISR        (AT91_CAST(AT91_REG *) 	0x00000114) // (AIC_CISR) Core Interrupt Status Register
S#define AIC_IECR        (AT91_CAST(AT91_REG *) 	0x00000120) // (AIC_IECR) Interrupt Enable Command Register
S#define AIC_IDCR        (AT91_CAST(AT91_REG *) 	0x00000124) // (AIC_IDCR) Interrupt Disable Command Register
S#define AIC_ICCR        (AT91_CAST(AT91_REG *) 	0x00000128) // (AIC_ICCR) Interrupt Clear Command Register
S#define AIC_ISCR        (AT91_CAST(AT91_REG *) 	0x0000012C) // (AIC_ISCR) Interrupt Set Command Register
S#define AIC_EOICR       (AT91_CAST(AT91_REG *) 	0x00000130) // (AIC_EOICR) End of Interrupt Command Register
S#define AIC_SPU         (AT91_CAST(AT91_REG *) 	0x00000134) // (AIC_SPU) Spurious Vector Register
S#define AIC_DCR         (AT91_CAST(AT91_REG *) 	0x00000138) // (AIC_DCR) Debug Control Register (Protect)
S#define AIC_FFER        (AT91_CAST(AT91_REG *) 	0x00000140) // (AIC_FFER) Fast Forcing Enable Register
S#define AIC_FFDR        (AT91_CAST(AT91_REG *) 	0x00000144) // (AIC_FFDR) Fast Forcing Disable Register
S#define AIC_FFSR        (AT91_CAST(AT91_REG *) 	0x00000148) // (AIC_FFSR) Fast Forcing Status Register
S
N#endif
N// -------- AIC_SMR : (AIC Offset: 0x0) Control Register -------- 
N#define AT91C_AIC_PRIOR       (0x7 <<  0) // (AIC) Priority Level
N#define 	AT91C_AIC_PRIOR_LOWEST               (0x0) // (AIC) Lowest priority level
N#define 	AT91C_AIC_PRIOR_HIGHEST              (0x7) // (AIC) Highest priority level
N#define AT91C_AIC_SRCTYPE     (0x3 <<  5) // (AIC) Interrupt Source Type
N#define 	AT91C_AIC_SRCTYPE_INT_LEVEL_SENSITIVE  (0x0 <<  5) // (AIC) Internal Sources Code Label Level Sensitive
N#define 	AT91C_AIC_SRCTYPE_INT_EDGE_TRIGGERED   (0x1 <<  5) // (AIC) Internal Sources Code Label Edge triggered
N#define 	AT91C_AIC_SRCTYPE_EXT_HIGH_LEVEL       (0x2 <<  5) // (AIC) External Sources Code Label High-level Sensitive
N#define 	AT91C_AIC_SRCTYPE_EXT_POSITIVE_EDGE    (0x3 <<  5) // (AIC) External Sources Code Label Positive Edge triggered
N// -------- AIC_CISR : (AIC Offset: 0x114) AIC Core Interrupt Status Register -------- 
N#define AT91C_AIC_NFIQ        (0x1 <<  0) // (AIC) NFIQ Status
N#define AT91C_AIC_NIRQ        (0x1 <<  1) // (AIC) NIRQ Status
N// -------- AIC_DCR : (AIC Offset: 0x138) AIC Debug Control Register (Protect) -------- 
N#define AT91C_AIC_DCR_PROT    (0x1 <<  0) // (AIC) Protection Mode
N#define AT91C_AIC_DCR_GMSK    (0x1 <<  1) // (AIC) General Mask
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Peripheral DMA Controller
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_PDC {
N	AT91_REG	 PDC_RPR; 	// Receive Pointer Register
N	AT91_REG	 PDC_RCR; 	// Receive Counter Register
N	AT91_REG	 PDC_TPR; 	// Transmit Pointer Register
N	AT91_REG	 PDC_TCR; 	// Transmit Counter Register
N	AT91_REG	 PDC_RNPR; 	// Receive Next Pointer Register
N	AT91_REG	 PDC_RNCR; 	// Receive Next Counter Register
N	AT91_REG	 PDC_TNPR; 	// Transmit Next Pointer Register
N	AT91_REG	 PDC_TNCR; 	// Transmit Next Counter Register
N	AT91_REG	 PDC_PTCR; 	// PDC Transfer Control Register
N	AT91_REG	 PDC_PTSR; 	// PDC Transfer Status Register
N} AT91S_PDC, *AT91PS_PDC;
N#else
S#define PDC_RPR         (AT91_CAST(AT91_REG *) 	0x00000000) // (PDC_RPR) Receive Pointer Register
S#define PDC_RCR         (AT91_CAST(AT91_REG *) 	0x00000004) // (PDC_RCR) Receive Counter Register
S#define PDC_TPR         (AT91_CAST(AT91_REG *) 	0x00000008) // (PDC_TPR) Transmit Pointer Register
S#define PDC_TCR         (AT91_CAST(AT91_REG *) 	0x0000000C) // (PDC_TCR) Transmit Counter Register
S#define PDC_RNPR        (AT91_CAST(AT91_REG *) 	0x00000010) // (PDC_RNPR) Receive Next Pointer Register
S#define PDC_RNCR        (AT91_CAST(AT91_REG *) 	0x00000014) // (PDC_RNCR) Receive Next Counter Register
S#define PDC_TNPR        (AT91_CAST(AT91_REG *) 	0x00000018) // (PDC_TNPR) Transmit Next Pointer Register
S#define PDC_TNCR        (AT91_CAST(AT91_REG *) 	0x0000001C) // (PDC_TNCR) Transmit Next Counter Register
S#define PDC_PTCR        (AT91_CAST(AT91_REG *) 	0x00000020) // (PDC_PTCR) PDC Transfer Control Register
S#define PDC_PTSR        (AT91_CAST(AT91_REG *) 	0x00000024) // (PDC_PTSR) PDC Transfer Status Register
S
N#endif
N// -------- PDC_PTCR : (PDC Offset: 0x20) PDC Transfer Control Register -------- 
N#define AT91C_PDC_RXTEN       (0x1 <<  0) // (PDC) Receiver Transfer Enable
N#define AT91C_PDC_RXTDIS      (0x1 <<  1) // (PDC) Receiver Transfer Disable
N#define AT91C_PDC_TXTEN       (0x1 <<  8) // (PDC) Transmitter Transfer Enable
N#define AT91C_PDC_TXTDIS      (0x1 <<  9) // (PDC) Transmitter Transfer Disable
N// -------- PDC_PTSR : (PDC Offset: 0x24) PDC Transfer Status Register -------- 
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Debug Unit
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_DBGU {
N	AT91_REG	 DBGU_CR; 	// Control Register
N	AT91_REG	 DBGU_MR; 	// Mode Register
N	AT91_REG	 DBGU_IER; 	// Interrupt Enable Register
N	AT91_REG	 DBGU_IDR; 	// Interrupt Disable Register
N	AT91_REG	 DBGU_IMR; 	// Interrupt Mask Register
N	AT91_REG	 DBGU_CSR; 	// Channel Status Register
N	AT91_REG	 DBGU_RHR; 	// Receiver Holding Register
N	AT91_REG	 DBGU_THR; 	// Transmitter Holding Register
N	AT91_REG	 DBGU_BRGR; 	// Baud Rate Generator Register
N	AT91_REG	 Reserved0[7]; 	// 
N	AT91_REG	 DBGU_CIDR; 	// Chip ID Register
N	AT91_REG	 DBGU_EXID; 	// Chip ID Extension Register
N	AT91_REG	 DBGU_FNTR; 	// Force NTRST Register
N	AT91_REG	 Reserved1[45]; 	// 
N	AT91_REG	 DBGU_RPR; 	// Receive Pointer Register
N	AT91_REG	 DBGU_RCR; 	// Receive Counter Register
N	AT91_REG	 DBGU_TPR; 	// Transmit Pointer Register
N	AT91_REG	 DBGU_TCR; 	// Transmit Counter Register
N	AT91_REG	 DBGU_RNPR; 	// Receive Next Pointer Register
N	AT91_REG	 DBGU_RNCR; 	// Receive Next Counter Register
N	AT91_REG	 DBGU_TNPR; 	// Transmit Next Pointer Register
N	AT91_REG	 DBGU_TNCR; 	// Transmit Next Counter Register
N	AT91_REG	 DBGU_PTCR; 	// PDC Transfer Control Register
N	AT91_REG	 DBGU_PTSR; 	// PDC Transfer Status Register
N} AT91S_DBGU, *AT91PS_DBGU;
N#else
S#define DBGU_CR         (AT91_CAST(AT91_REG *) 	0x00000000) // (DBGU_CR) Control Register
S#define DBGU_MR         (AT91_CAST(AT91_REG *) 	0x00000004) // (DBGU_MR) Mode Register
S#define DBGU_IER        (AT91_CAST(AT91_REG *) 	0x00000008) // (DBGU_IER) Interrupt Enable Register
S#define DBGU_IDR        (AT91_CAST(AT91_REG *) 	0x0000000C) // (DBGU_IDR) Interrupt Disable Register
S#define DBGU_IMR        (AT91_CAST(AT91_REG *) 	0x00000010) // (DBGU_IMR) Interrupt Mask Register
S#define DBGU_CSR        (AT91_CAST(AT91_REG *) 	0x00000014) // (DBGU_CSR) Channel Status Register
S#define DBGU_RHR        (AT91_CAST(AT91_REG *) 	0x00000018) // (DBGU_RHR) Receiver Holding Register
S#define DBGU_THR        (AT91_CAST(AT91_REG *) 	0x0000001C) // (DBGU_THR) Transmitter Holding Register
S#define DBGU_BRGR       (AT91_CAST(AT91_REG *) 	0x00000020) // (DBGU_BRGR) Baud Rate Generator Register
S#define DBGU_CIDR       (AT91_CAST(AT91_REG *) 	0x00000040) // (DBGU_CIDR) Chip ID Register
S#define DBGU_EXID       (AT91_CAST(AT91_REG *) 	0x00000044) // (DBGU_EXID) Chip ID Extension Register
S#define DBGU_FNTR       (AT91_CAST(AT91_REG *) 	0x00000048) // (DBGU_FNTR) Force NTRST Register
S
N#endif
N// -------- DBGU_CR : (DBGU Offset: 0x0) Debug Unit Control Register -------- 
N#define AT91C_DBGU_RSTRX      (0x1 <<  2) // (DBGU) Reset Receiver
N#define AT91C_DBGU_RSTTX      (0x1 <<  3) // (DBGU) Reset Transmitter
N#define AT91C_DBGU_RXEN       (0x1 <<  4) // (DBGU) Receiver Enable
N#define AT91C_DBGU_RXDIS      (0x1 <<  5) // (DBGU) Receiver Disable
N#define AT91C_DBGU_TXEN       (0x1 <<  6) // (DBGU) Transmitter Enable
N#define AT91C_DBGU_TXDIS      (0x1 <<  7) // (DBGU) Transmitter Disable
N#define AT91C_DBGU_RSTSTA     (0x1 <<  8) // (DBGU) Reset Status Bits
N// -------- DBGU_MR : (DBGU Offset: 0x4) Debug Unit Mode Register -------- 
N#define AT91C_DBGU_PAR        (0x7 <<  9) // (DBGU) Parity type
N#define 	AT91C_DBGU_PAR_EVEN                 (0x0 <<  9) // (DBGU) Even Parity
N#define 	AT91C_DBGU_PAR_ODD                  (0x1 <<  9) // (DBGU) Odd Parity
N#define 	AT91C_DBGU_PAR_SPACE                (0x2 <<  9) // (DBGU) Parity forced to 0 (Space)
N#define 	AT91C_DBGU_PAR_MARK                 (0x3 <<  9) // (DBGU) Parity forced to 1 (Mark)
N#define 	AT91C_DBGU_PAR_NONE                 (0x4 <<  9) // (DBGU) No Parity
N#define AT91C_DBGU_CHMODE     (0x3 << 14) // (DBGU) Channel Mode
N#define 	AT91C_DBGU_CHMODE_NORMAL               (0x0 << 14) // (DBGU) Normal Mode: The debug unit channel operates as an RX/TX debug unit.
N#define 	AT91C_DBGU_CHMODE_AUTO                 (0x1 << 14) // (DBGU) Automatic Echo: Receiver Data Input is connected to the TXD pin.
N#define 	AT91C_DBGU_CHMODE_LOCAL                (0x2 << 14) // (DBGU) Local Loopback: Transmitter Output Signal is connected to Receiver Input Signal.
N#define 	AT91C_DBGU_CHMODE_REMOTE               (0x3 << 14) // (DBGU) Remote Loopback: RXD pin is internally connected to TXD pin.
N// -------- DBGU_IER : (DBGU Offset: 0x8) Debug Unit Interrupt Enable Register -------- 
N#define AT91C_DBGU_RXRDY      (0x1 <<  0) // (DBGU) RXRDY Interrupt
N#define AT91C_DBGU_TXRDY      (0x1 <<  1) // (DBGU) TXRDY Interrupt
N#define AT91C_DBGU_ENDRX      (0x1 <<  3) // (DBGU) End of Receive Transfer Interrupt
N#define AT91C_DBGU_ENDTX      (0x1 <<  4) // (DBGU) End of Transmit Interrupt
N#define AT91C_DBGU_OVRE       (0x1 <<  5) // (DBGU) Overrun Interrupt
N#define AT91C_DBGU_FRAME      (0x1 <<  6) // (DBGU) Framing Error Interrupt
N#define AT91C_DBGU_PARE       (0x1 <<  7) // (DBGU) Parity Error Interrupt
N#define AT91C_DBGU_TXEMPTY    (0x1 <<  9) // (DBGU) TXEMPTY Interrupt
N#define AT91C_DBGU_TXBUFE     (0x1 << 11) // (DBGU) TXBUFE Interrupt
N#define AT91C_DBGU_RXBUFF     (0x1 << 12) // (DBGU) RXBUFF Interrupt
N#define AT91C_DBGU_COMM_TX    (0x1 << 30) // (DBGU) COMM_TX Interrupt
N#define AT91C_DBGU_COMM_RX    (0x1 << 31) // (DBGU) COMM_RX Interrupt
N// -------- DBGU_IDR : (DBGU Offset: 0xc) Debug Unit Interrupt Disable Register -------- 
N// -------- DBGU_IMR : (DBGU Offset: 0x10) Debug Unit Interrupt Mask Register -------- 
N// -------- DBGU_CSR : (DBGU Offset: 0x14) Debug Unit Channel Status Register -------- 
N// -------- DBGU_FNTR : (DBGU Offset: 0x48) Debug Unit FORCE_NTRST Register -------- 
N#define AT91C_DBGU_FORCE_NTRST (0x1 <<  0) // (DBGU) Force NTRST in JTAG
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Parallel Input Output Controler
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_PIO {
N	AT91_REG	 PIO_PER; 	// PIO Enable Register
N	AT91_REG	 PIO_PDR; 	// PIO Disable Register
N	AT91_REG	 PIO_PSR; 	// PIO Status Register
N	AT91_REG	 Reserved0[1]; 	// 
N	AT91_REG	 PIO_OER; 	// Output Enable Register
N	AT91_REG	 PIO_ODR; 	// Output Disable Registerr
N	AT91_REG	 PIO_OSR; 	// Output Status Register
N	AT91_REG	 Reserved1[1]; 	// 
N	AT91_REG	 PIO_IFER; 	// Input Filter Enable Register
N	AT91_REG	 PIO_IFDR; 	// Input Filter Disable Register
N	AT91_REG	 PIO_IFSR; 	// Input Filter Status Register
N	AT91_REG	 Reserved2[1]; 	// 
N	AT91_REG	 PIO_SODR; 	// Set Output Data Register
N	AT91_REG	 PIO_CODR; 	// Clear Output Data Register
N	AT91_REG	 PIO_ODSR; 	// Output Data Status Register
N	AT91_REG	 PIO_PDSR; 	// Pin Data Status Register
N	AT91_REG	 PIO_IER; 	// Interrupt Enable Register
N	AT91_REG	 PIO_IDR; 	// Interrupt Disable Register
N	AT91_REG	 PIO_IMR; 	// Interrupt Mask Register
N	AT91_REG	 PIO_ISR; 	// Interrupt Status Register
N	AT91_REG	 PIO_MDER; 	// Multi-driver Enable Register
N	AT91_REG	 PIO_MDDR; 	// Multi-driver Disable Register
N	AT91_REG	 PIO_MDSR; 	// Multi-driver Status Register
N	AT91_REG	 Reserved3[1]; 	// 
N	AT91_REG	 PIO_PPUDR; 	// Pull-up Disable Register
N	AT91_REG	 PIO_PPUER; 	// Pull-up Enable Register
N	AT91_REG	 PIO_PPUSR; 	// Pull-up Status Register
N	AT91_REG	 Reserved4[1]; 	// 
N	AT91_REG	 PIO_ASR; 	// Select A Register
N	AT91_REG	 PIO_BSR; 	// Select B Register
N	AT91_REG	 PIO_ABSR; 	// AB Select Status Register
N	AT91_REG	 Reserved5[9]; 	// 
N	AT91_REG	 PIO_OWER; 	// Output Write Enable Register
N	AT91_REG	 PIO_OWDR; 	// Output Write Disable Register
N	AT91_REG	 PIO_OWSR; 	// Output Write Status Register
N	AT91_REG	 Reserved6[1]; 	// 
N	AT91_REG	 PIO_SLEWRATE1; 	// PIO Slewrate Control Register
N	AT91_REG	 Reserved7[3]; 	// 
N	AT91_REG	 PIO_DELAY1; 	// PIO Delay Control Register
N	AT91_REG	 PIO_DELAY2; 	// PIO Delay Control Register
N	AT91_REG	 PIO_DELAY3; 	// PIO Delay Control Register
N	AT91_REG	 PIO_DELAY4; 	// PIO Delay Control Register
N	AT91_REG	 Reserved8[11]; 	// 
N	AT91_REG	 PIO_VERSION; 	// PIO Version Register
N} AT91S_PIO, *AT91PS_PIO;
N#else
S#define PIO_PER         (AT91_CAST(AT91_REG *) 	0x00000000) // (PIO_PER) PIO Enable Register
S#define PIO_PDR         (AT91_CAST(AT91_REG *) 	0x00000004) // (PIO_PDR) PIO Disable Register
S#define PIO_PSR         (AT91_CAST(AT91_REG *) 	0x00000008) // (PIO_PSR) PIO Status Register
S#define PIO_OER         (AT91_CAST(AT91_REG *) 	0x00000010) // (PIO_OER) Output Enable Register
S#define PIO_ODR         (AT91_CAST(AT91_REG *) 	0x00000014) // (PIO_ODR) Output Disable Registerr
S#define PIO_OSR         (AT91_CAST(AT91_REG *) 	0x00000018) // (PIO_OSR) Output Status Register
S#define PIO_IFER        (AT91_CAST(AT91_REG *) 	0x00000020) // (PIO_IFER) Input Filter Enable Register
S#define PIO_IFDR        (AT91_CAST(AT91_REG *) 	0x00000024) // (PIO_IFDR) Input Filter Disable Register
S#define PIO_IFSR        (AT91_CAST(AT91_REG *) 	0x00000028) // (PIO_IFSR) Input Filter Status Register
S#define PIO_SODR        (AT91_CAST(AT91_REG *) 	0x00000030) // (PIO_SODR) Set Output Data Register
S#define PIO_CODR        (AT91_CAST(AT91_REG *) 	0x00000034) // (PIO_CODR) Clear Output Data Register
S#define PIO_ODSR        (AT91_CAST(AT91_REG *) 	0x00000038) // (PIO_ODSR) Output Data Status Register
S#define PIO_PDSR        (AT91_CAST(AT91_REG *) 	0x0000003C) // (PIO_PDSR) Pin Data Status Register
S#define PIO_IER         (AT91_CAST(AT91_REG *) 	0x00000040) // (PIO_IER) Interrupt Enable Register
S#define PIO_IDR         (AT91_CAST(AT91_REG *) 	0x00000044) // (PIO_IDR) Interrupt Disable Register
S#define PIO_IMR         (AT91_CAST(AT91_REG *) 	0x00000048) // (PIO_IMR) Interrupt Mask Register
S#define PIO_ISR         (AT91_CAST(AT91_REG *) 	0x0000004C) // (PIO_ISR) Interrupt Status Register
S#define PIO_MDER        (AT91_CAST(AT91_REG *) 	0x00000050) // (PIO_MDER) Multi-driver Enable Register
S#define PIO_MDDR        (AT91_CAST(AT91_REG *) 	0x00000054) // (PIO_MDDR) Multi-driver Disable Register
S#define PIO_MDSR        (AT91_CAST(AT91_REG *) 	0x00000058) // (PIO_MDSR) Multi-driver Status Register
S#define PIO_PPUDR       (AT91_CAST(AT91_REG *) 	0x00000060) // (PIO_PPUDR) Pull-up Disable Register
S#define PIO_PPUER       (AT91_CAST(AT91_REG *) 	0x00000064) // (PIO_PPUER) Pull-up Enable Register
S#define PIO_PPUSR       (AT91_CAST(AT91_REG *) 	0x00000068) // (PIO_PPUSR) Pull-up Status Register
S#define PIO_ASR         (AT91_CAST(AT91_REG *) 	0x00000070) // (PIO_ASR) Select A Register
S#define PIO_BSR         (AT91_CAST(AT91_REG *) 	0x00000074) // (PIO_BSR) Select B Register
S#define PIO_ABSR        (AT91_CAST(AT91_REG *) 	0x00000078) // (PIO_ABSR) AB Select Status Register
S#define PIO_OWER        (AT91_CAST(AT91_REG *) 	0x000000A0) // (PIO_OWER) Output Write Enable Register
S#define PIO_OWDR        (AT91_CAST(AT91_REG *) 	0x000000A4) // (PIO_OWDR) Output Write Disable Register
S#define PIO_OWSR        (AT91_CAST(AT91_REG *) 	0x000000A8) // (PIO_OWSR) Output Write Status Register
S#define SLEWRATE1       (AT91_CAST(AT91_REG *) 	0x000000B0) // (SLEWRATE1) PIO Slewrate Control Register
S#define PIO_VERSION     (AT91_CAST(AT91_REG *) 	0x000000FC) // (PIO_VERSION) PIO Version Register
S
N#endif
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Power Management Controller V610
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_PMC {
N	AT91_REG	 PMC_SCER; 	// System Clock Enable Register
N	AT91_REG	 PMC_SCDR; 	// System Clock Disable Register
N	AT91_REG	 PMC_SCSR; 	// System Clock Status Register
N	AT91_REG	 Reserved0[1]; 	// 
N	AT91_REG	 PMC_PCER; 	// Peripheral Clock Enable Register
N	AT91_REG	 PMC_PCDR; 	// Peripheral Clock Disable Register
N	AT91_REG	 PMC_PCSR; 	// Peripheral Clock Status Register
N	AT91_REG	 PMC_UCKR; 	// UTMI Clock Configuration Register
N	AT91_REG	 PMC_MOR; 	// Main Oscillator Register
N	AT91_REG	 PMC_MCFR; 	// Main Clock  Frequency Register
N	AT91_REG	 PMC_PLLAR; 	// PLL A Register
N	AT91_REG	 Reserved1[1]; 	// 
N	AT91_REG	 PMC_MCKR; 	// Master Clock Register
N	AT91_REG	 Reserved2[1]; 	// 
N	AT91_REG	 PMC_USB; 	// USB clock register
N	AT91_REG	 Reserved3[1]; 	// 
N	AT91_REG	 PMC_PCKR[2]; 	// Programmable Clock 0 Register
N	AT91_REG	 Reserved4[6]; 	// 
N	AT91_REG	 PMC_IER; 	// Interrupt Enable Register
N	AT91_REG	 PMC_IDR; 	// Interrupt Disable Register
N	AT91_REG	 PMC_SR; 	// Status Register
N	AT91_REG	 PMC_IMR; 	// Interrupt Mask Register
N	AT91_REG	 Reserved5[4]; 	// 
N	AT91_REG	 PMC_PLLICPR; 	// PLL Charge Pump Current Register
N	AT91_REG	 Reserved6[26]; 	// 
N	AT91_REG	 PMC_ADDRSIZE; 	// 
N	AT91_REG	 PMC_NAME1; 	// 
N	AT91_REG	 PMC_NAME2; 	// 
N	AT91_REG	 PMC_FEATURES; 	// 
N	AT91_REG	 PMC_VERSION; 	// 
N} AT91S_PMC, *AT91PS_PMC;
N#else
S#define PMC_SCER        (AT91_CAST(AT91_REG *) 	0x00000000) // (PMC_SCER) System Clock Enable Register
S#define PMC_SCDR        (AT91_CAST(AT91_REG *) 	0x00000004) // (PMC_SCDR) System Clock Disable Register
S#define PMC_SCSR        (AT91_CAST(AT91_REG *) 	0x00000008) // (PMC_SCSR) System Clock Status Register
S#define PMC_PCER        (AT91_CAST(AT91_REG *) 	0x00000010) // (PMC_PCER) Peripheral Clock Enable Register
S#define PMC_PCDR        (AT91_CAST(AT91_REG *) 	0x00000014) // (PMC_PCDR) Peripheral Clock Disable Register
S#define PMC_PCSR        (AT91_CAST(AT91_REG *) 	0x00000018) // (PMC_PCSR) Peripheral Clock Status Register
S#define CKGR_UCKR       (AT91_CAST(AT91_REG *) 	0x0000001C) // (CKGR_UCKR) UTMI Clock Configuration Register
S#define CKGR_MOR        (AT91_CAST(AT91_REG *) 	0x00000020) // (CKGR_MOR) Main Oscillator Register
S#define CKGR_MCFR       (AT91_CAST(AT91_REG *) 	0x00000024) // (CKGR_MCFR) Main Clock  Frequency Register
S#define CKGR_PLLAR      (AT91_CAST(AT91_REG *) 	0x00000028) // (CKGR_PLLAR) PLL A Register
S#define PMC_MCKR        (AT91_CAST(AT91_REG *) 	0x00000030) // (PMC_MCKR) Master Clock Register
S#define PMC_USB         (AT91_CAST(AT91_REG *) 	0x00000038) // (PMC_USB) USB clock register
S#define PMC_PCKR        (AT91_CAST(AT91_REG *) 	0x00000040) // (PMC_PCKR) Programmable Clock 0 Register
S#define PMC_IER         (AT91_CAST(AT91_REG *) 	0x00000060) // (PMC_IER) Interrupt Enable Register
S#define PMC_IDR         (AT91_CAST(AT91_REG *) 	0x00000064) // (PMC_IDR) Interrupt Disable Register
S#define PMC_SR          (AT91_CAST(AT91_REG *) 	0x00000068) // (PMC_SR) Status Register
S#define PMC_IMR         (AT91_CAST(AT91_REG *) 	0x0000006C) // (PMC_IMR) Interrupt Mask Register
S#define PMC_PLLICPR     (AT91_CAST(AT91_REG *) 	0x00000080) // (PMC_PLLICPR) PLL Charge Pump Current Register
S#define PMC_ADDRSIZE    (AT91_CAST(AT91_REG *) 	0x000000EC) // (PMC_ADDRSIZE) 
S#define PMC_NAME1       (AT91_CAST(AT91_REG *) 	0x000000F0) // (PMC_NAME1) 
S#define PMC_NAME2       (AT91_CAST(AT91_REG *) 	0x000000F4) // (PMC_NAME2) 
S#define PMC_FEATURES    (AT91_CAST(AT91_REG *) 	0x000000F8) // (PMC_FEATURES) 
S#define PMC_VERSION     (AT91_CAST(AT91_REG *) 	0x000000FC) // (PMC_VERSION) 
S
N#endif
N// -------- PMC_SCER : (PMC Offset: 0x0) System Clock Enable Register -------- 
N#define AT91C_PMC_DDR         (0x1 <<  2) // (PMC) DDR controller Clock2x
N#define AT91C_PMC_UHP         (0x1 <<  6) // (PMC) USB Host Port Clock
N#define AT91C_PMC_UDP         (0x1 <<  7) // (PMC) USB Device Port Clock
N#define AT91C_PMC_PCK0        (0x1 <<  8) // (PMC) Programmable Clock Output
N#define AT91C_PMC_PCK1        (0x1 <<  9) // (PMC) Programmable Clock Output
N// -------- PMC_SCDR : (PMC Offset: 0x4) System Clock Disable Register -------- 
N#define AT91C_PMC_PCK         (0x1 <<  0) // (PMC) Processor Clock
N// -------- PMC_SCSR : (PMC Offset: 0x8) System Clock Status Register -------- 
N// -------- CKGR_UCKR : (PMC Offset: 0x1c) UTMI Clock Configuration Register -------- 
N#define AT91C_CKGR_UPLLEN     (0x1 << 16) // (PMC) UTMI PLL Enable
N#define 	AT91C_CKGR_UPLLEN_DISABLED             (0x0 << 16) // (PMC) The UTMI PLL is disabled
N#define 	AT91C_CKGR_UPLLEN_ENABLED              (0x1 << 16) // (PMC) The UTMI PLL is enabled
N#define AT91C_CKGR_PLLCOUNT   (0xF << 20) // (PMC) UTMI Oscillator Start-up Time
N#define AT91C_CKGR_BIASEN     (0x1 << 24) // (PMC) UTMI BIAS Enable
N#define 	AT91C_CKGR_BIASEN_DISABLED             (0x0 << 24) // (PMC) The UTMI BIAS is disabled
N#define 	AT91C_CKGR_BIASEN_ENABLED              (0x1 << 24) // (PMC) The UTMI BIAS is enabled
N#define AT91C_CKGR_BIASCOUNT  (0xF << 28) // (PMC) UTMI BIAS Start-up Time
N// -------- CKGR_MOR : (PMC Offset: 0x20) Main Oscillator Register -------- 
N#define AT91C_CKGR_MOSCEN     (0x1 <<  0) // (PMC) Main Oscillator Enable
N#define AT91C_CKGR_OSCBYPASS  (0x1 <<  1) // (PMC) Main Oscillator Bypass
N#define AT91C_CKGR_OSCOUNT    (0xFF <<  8) // (PMC) Main Oscillator Start-up Time
N// -------- CKGR_MCFR : (PMC Offset: 0x24) Main Clock Frequency Register -------- 
N#define AT91C_CKGR_MAINF      (0xFFFF <<  0) // (PMC) Main Clock Frequency
N#define AT91C_CKGR_MAINRDY    (0x1 << 16) // (PMC) Main Clock Ready
N// -------- CKGR_PLLAR : (PMC Offset: 0x28) PLL A Register -------- 
N#define AT91C_CKGR_DIVA       (0xFF <<  0) // (PMC) Divider A Selected
N#define 	AT91C_CKGR_DIVA_0                    (0x0) // (PMC) Divider A output is 0
N#define 	AT91C_CKGR_DIVA_BYPASS               (0x1) // (PMC) Divider A is bypassed
N#define AT91C_CKGR_PLLACOUNT  (0x3F <<  8) // (PMC) PLL A Counter
N#define AT91C_CKGR_OUTA       (0x3 << 14) // (PMC) PLL A Output Frequency Range
N#define 	AT91C_CKGR_OUTA_0                    (0x0 << 14) // (PMC) Please refer to the PLLA datasheet
N#define 	AT91C_CKGR_OUTA_1                    (0x1 << 14) // (PMC) Please refer to the PLLA datasheet
N#define 	AT91C_CKGR_OUTA_2                    (0x2 << 14) // (PMC) Please refer to the PLLA datasheet
N#define 	AT91C_CKGR_OUTA_3                    (0x3 << 14) // (PMC) Please refer to the PLLA datasheet
N#define AT91C_CKGR_MULA       (0xFF << 16) // (PMC) PLL A Multiplier
N#define AT91C_CKGR_SRCA       (0x1 << 29) // (PMC) 
N// -------- PMC_MCKR : (PMC Offset: 0x30) Master Clock Register -------- 
N#define AT91C_PMC_CSS         (0x3 <<  0) // (PMC) Programmable Clock Selection
N#define 	AT91C_PMC_CSS_SLOW_CLK             (0x0) // (PMC) Slow Clock is selected
N#define 	AT91C_PMC_CSS_MAIN_CLK             (0x1) // (PMC) Main Clock is selected
N#define 	AT91C_PMC_CSS_PLLA_CLK             (0x2) // (PMC) Clock from PLL A is selected
N#define 	AT91C_PMC_CSS_UPLL_CLK             (0x3) // (PMC) Clock from UTMI PLL is selected
N#define AT91C_PMC_PRES        (0x7 <<  2) // (PMC) Programmable Clock Prescaler
N#define 	AT91C_PMC_PRES_CLK                  (0x0 <<  2) // (PMC) Selected clock
N#define 	AT91C_PMC_PRES_CLK_2                (0x1 <<  2) // (PMC) Selected clock divided by 2
N#define 	AT91C_PMC_PRES_CLK_4                (0x2 <<  2) // (PMC) Selected clock divided by 4
N#define 	AT91C_PMC_PRES_CLK_8                (0x3 <<  2) // (PMC) Selected clock divided by 8
N#define 	AT91C_PMC_PRES_CLK_16               (0x4 <<  2) // (PMC) Selected clock divided by 16
N#define 	AT91C_PMC_PRES_CLK_32               (0x5 <<  2) // (PMC) Selected clock divided by 32
N#define 	AT91C_PMC_PRES_CLK_64               (0x6 <<  2) // (PMC) Selected clock divided by 64
N#define AT91C_PMC_MDIV        (0x3 <<  8) // (PMC) Master Clock Division
N#define 	AT91C_PMC_MDIV_1                    (0x0 <<  8) // (PMC) Processor clock = Master Clock ; DDR Clock = Master Clock
N#define 	AT91C_PMC_MDIV_2                    (0x1 <<  8) // (PMC) Processor clock = 2 * Master Clock ; DDR Clock = 2 * Master Clock
N#define 	AT91C_PMC_MDIV_4                    (0x2 <<  8) // (PMC) Processor clock = 4 * Master Clock ; DDR Clock = 2 * Master Clock
N#define 	AT91C_PMC_MDIV_3                    (0x3 <<  8) // (PMC) Processor clock = 3 * Master Clock ; DDR Clock = 2 * Master Clock
N#define AT91C_PMC_PLLADIV2    (0x1 << 12) // (PMC) PLLA divisor by 2
N#define 	AT91C_PMC_PLLADIV2_1                    (0x0 << 12) // (PMC) PLLA clock frequency is divided by 1
N#define 	AT91C_PMC_PLLADIV2_2                    (0x1 << 12) // (PMC) PLLA clock frequency is divided by 2
N// -------- PMC_USB : (PMC Offset: 0x38) USB Clock Register -------- 
N#define AT91C_PMC_USBS        (0x1 <<  0) // (PMC) USBS
N#define 	AT91C_PMC_USBS_USB_PLLA             (0x0) // (PMC) USB Clock Input is PLLA
N#define 	AT91C_PMC_USBS_USB_UPLL             (0x1) // (PMC) USB Clock Input is UPLL
N#define AT91C_PMC_USBDIV      (0xF <<  8) // (PMC) USBDIV
N#define 	AT91C_PMC_USBDIV_1                    (0x0 <<  8) // (PMC) USB Clock divided by 1
N#define 	AT91C_PMC_USBDIV_2                    (0x1 <<  8) // (PMC) USB Clock divided by 2
N#define 	AT91C_PMC_USBDIV_3                    (0x2 <<  8) // (PMC) USB Clock divided by 3
N#define 	AT91C_PMC_USBDIV_4                    (0x3 <<  8) // (PMC) USB Clock divided by 4
N#define 	AT91C_PMC_USBDIV_5                    (0x4 <<  8) // (PMC) USB Clock divided by 5
N#define 	AT91C_PMC_USBDIV_6                    (0x5 <<  8) // (PMC) USB Clock divided by 6
N#define 	AT91C_PMC_USBDIV_7                    (0x6 <<  8) // (PMC) USB Clock divided by 7
N#define 	AT91C_PMC_USBDIV_8                    (0x7 <<  8) // (PMC) USB Clock divided by 8
N#define 	AT91C_PMC_USBDIV_9                    (0x8 <<  8) // (PMC) USB Clock divided by 9
N#define 	AT91C_PMC_USBDIV_10                   (0x9 <<  8) // (PMC) USB Clock divided by 10
N#define 	AT91C_PMC_USBDIV_11                   (0xA <<  8) // (PMC) USB Clock divided by 11
N#define 	AT91C_PMC_USBDIV_12                   (0xB <<  8) // (PMC) USB Clock divided by 12
N#define 	AT91C_PMC_USBDIV_13                   (0xC <<  8) // (PMC) USB Clock divided by 13
N#define 	AT91C_PMC_USBDIV_14                   (0xD <<  8) // (PMC) USB Clock divided by 14
N#define 	AT91C_PMC_USBDIV_15                   (0xE <<  8) // (PMC) USB Clock divided by 15
N#define 	AT91C_PMC_USBDIV_16                   (0xF <<  8) // (PMC) USB Clock divided by 16
N// -------- PMC_PCKR : (PMC Offset: 0x40) Programmable Clock 0 Register -------- 
N#define AT91C_PMC_SLCKMCK     (0x1 <<  8) // (PMC) Programmable Clock Prescaler
N#define 	AT91C_PMC_SLCKMCK_SLCK                 (0x0 <<  8) // (PMC) Slow Clock selected
N#define 	AT91C_PMC_SLCKMCK_MCK                  (0x1 <<  8) // (PMC) Master Clock selected
N// -------- PMC_IER : (PMC Offset: 0x60) PMC Interrupt Enable Register -------- 
N#define AT91C_PMC_MOSCS       (0x1 <<  0) // (PMC) MOSC Status/Enable/Disable/Mask
N#define AT91C_PMC_LOCKA       (0x1 <<  1) // (PMC) PLL A Status/Enable/Disable/Mask
N#define AT91C_PMC_MCKRDY      (0x1 <<  3) // (PMC) Master Clock Status/Enable/Disable/Mask
N#define AT91C_PMC_LOCKU       (0x1 <<  6) // (PMC) PLL UTMI Status/Enable/Disable/Mask
N#define AT91C_PMC_PCK0RDY     (0x1 <<  8) // (PMC) PCK0_RDY Status/Enable/Disable/Mask
N#define AT91C_PMC_PCK1RDY     (0x1 <<  9) // (PMC) PCK1_RDY Status/Enable/Disable/Mask
N// -------- PMC_IDR : (PMC Offset: 0x64) PMC Interrupt Disable Register -------- 
N// -------- PMC_SR : (PMC Offset: 0x68) PMC Status Register -------- 
N// -------- PMC_IMR : (PMC Offset: 0x6c) PMC Interrupt Mask Register -------- 
N// -------- PMC_PLLICPR : (PMC Offset: 0x80) PLL Charge Pump Current Register -------- 
N#define AT91C_PMC_ICPPLLA     (0xF <<  0) // (PMC) PLLA charge pump current setting
N#define 	AT91C_PMC_ICPPLLA_0                    (0x0) // (PMC) 595-800 MHz
N#define 	AT91C_PMC_ICPPLLA_1                    (0x1) // (PMC) 395-600 MHz
N#define AT91C_PMC_REALLOCK    (0x1 <<  7) // (PMC) PLLs use real lock signals when 1
N#define AT91C_PMC_IPLLA       (0xF <<  8) // (PMC) PLLA special setting
N#define 	AT91C_PMC_IPLLA_0                    (0x0 <<  8) // (PMC) Internal LFT
N#define 	AT91C_PMC_IPLLA_1                    (0x1 <<  8) // (PMC) External LFT
N// -------- PMC_FEATURES : (PMC Offset: 0xf8)   -------- 
N#define AT91C_PMC_CFGAHBCLK   (0x1 <<  0) // (PMC) 
N#define 	AT91C_PMC_CFGAHBCLK_0                    (0x0) // (PMC) 
N#define 	AT91C_PMC_CFGAHBCLK_1                    (0x1) // (PMC) 
N#define AT91C_PMC_HCLKEN      (0x1 <<  1) // (PMC) 
N#define 	AT91C_PMC_HCLKEN_0                    (0x0 <<  1) // (PMC) 
N#define 	AT91C_PMC_HCLKEN_1                    (0x1 <<  1) // (PMC) 
N#define AT91C_PMC_PERMCLK     (0x1 <<  2) // (PMC) 
N#define 	AT91C_PMC_PERMCLK_0                    (0x0 <<  2) // (PMC) 
N#define 	AT91C_PMC_PERMCLK_1                    (0x1 <<  2) // (PMC) 
N#define AT91C_PMC_CORE2       (0x1 <<  3) // (PMC) 
N#define 	AT91C_PMC_CORE2_0                    (0x0 <<  3) // (PMC) 
N#define 	AT91C_PMC_CORE2_1                    (0x1 <<  3) // (PMC) 
N#define AT91C_PMC_USBDEVCK    (0x1 <<  4) // (PMC) 
N#define 	AT91C_PMC_USBDEVCK_0                    (0x0 <<  4) // (PMC) 
N#define 	AT91C_PMC_USBDEVCK_1                    (0x1 <<  4) // (PMC) 
N#define AT91C_PMC_USBHOSTCK   (0x1 <<  5) // (PMC) 
N#define 	AT91C_PMC_USBHOSTCK_0                    (0x0 <<  5) // (PMC) 
N#define 	AT91C_PMC_USBHOSTCK_1                    (0x1 <<  5) // (PMC) 
N#define AT91C_PMC_USBOTGCK    (0x1 <<  6) // (PMC) 
N#define 	AT91C_PMC_USBOTGCK_0                    (0x0 <<  6) // (PMC) 
N#define 	AT91C_PMC_USBOTGCK_1                    (0x1 <<  6) // (PMC) 
N#define AT91C_PMC_UHSYNRST    (0x1 <<  7) // (PMC) 
N#define 	AT91C_PMC_UHSYNRST_0                    (0x0 <<  7) // (PMC) 
N#define 	AT91C_PMC_UHSYNRST_1                    (0x1 <<  7) // (PMC) 
N#define AT91C_PMC_UOSYNRST    (0x1 <<  8) // (PMC) 
N#define 	AT91C_PMC_UOSYNRST_0                    (0x0 <<  8) // (PMC) 
N#define 	AT91C_PMC_UOSYNRST_1                    (0x1 <<  8) // (PMC) 
N#define AT91C_PMC_PLLENPOL    (0x1 <<  9) // (PMC) 
N#define 	AT91C_PMC_PLLENPOL_0                    (0x0 <<  9) // (PMC) 
N#define 	AT91C_PMC_PLLENPOL_1                    (0x1 <<  9) // (PMC) 
N#define AT91C_PMC_BIASREG     (0x1 << 10) // (PMC) 
N#define 	AT91C_PMC_BIASREG_0                    (0x0 << 10) // (PMC) 
N#define 	AT91C_PMC_BIASREG_1                    (0x1 << 10) // (PMC) 
N#define AT91C_PMC_OUTPLL      (0x1 << 11) // (PMC) 
N#define 	AT91C_PMC_OUTPLL_0                    (0x0 << 11) // (PMC) 
N#define 	AT91C_PMC_OUTPLL_1                    (0x1 << 11) // (PMC) 
N#define AT91C_PMC_OUTCURR     (0x1 << 12) // (PMC) 
N#define 	AT91C_PMC_OUTCURR_0                    (0x0 << 12) // (PMC) 
N#define 	AT91C_PMC_OUTCURR_1                    (0x1 << 12) // (PMC) 
N#define AT91C_PMC_FWUP        (0x1 << 13) // (PMC) 
N#define 	AT91C_PMC_FWUP_0                    (0x0 << 13) // (PMC) 
N#define 	AT91C_PMC_FWUP_1                    (0x1 << 13) // (PMC) 
N#define AT91C_PMC_SELMAINCLK  (0x1 << 14) // (PMC) 
N#define 	AT91C_PMC_SELMAINCLK_0                    (0x0 << 14) // (PMC) 
N#define 	AT91C_PMC_SELMAINCLK_1                    (0x1 << 14) // (PMC) 
N#define AT91C_PMC_RSTCLKM     (0x1 << 15) // (PMC) 
N#define 	AT91C_PMC_RSTCLKM_0                    (0x0 << 15) // (PMC) 
N#define 	AT91C_PMC_RSTCLKM_1                    (0x1 << 15) // (PMC) 
N#define AT91C_PMC_NB_PERIPH_CLOCK (0xFF << 16) // (PMC) 
N// -------- PMC_VERSION : (PMC Offset: 0xfc)   -------- 
N#define AT91C_PMC_Version     (0xFFFF <<  0) // (PMC) 
N#define 	AT91C_PMC_Version_0                    (0x0) // (PMC) 
N#define 	AT91C_PMC_Version_1                    (0x1) // (PMC) 
N#define AT91C_PMC_MFN         (0x7 << 16) // (PMC) 
N#define 	AT91C_PMC_MFN_0                    (0x0 << 16) // (PMC) 
N#define 	AT91C_PMC_MFN_1                    (0x1 << 16) // (PMC) 
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Clock Generator Controler
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_CKGR {
N	AT91_REG	 CKGR_UCKR; 	// UTMI Clock Configuration Register
N	AT91_REG	 CKGR_MOR; 	// Main Oscillator Register
N	AT91_REG	 CKGR_MCFR; 	// Main Clock  Frequency Register
N	AT91_REG	 CKGR_PLLAR; 	// PLL A Register
N} AT91S_CKGR, *AT91PS_CKGR;
N#else
S
N#endif
N// -------- CKGR_UCKR : (CKGR Offset: 0x0) UTMI Clock Configuration Register -------- 
N// -------- CKGR_MOR : (CKGR Offset: 0x4) Main Oscillator Register -------- 
N// -------- CKGR_MCFR : (CKGR Offset: 0x8) Main Clock Frequency Register -------- 
N// -------- CKGR_PLLAR : (CKGR Offset: 0xc) PLL A Register -------- 
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Reset Controller Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_RSTC {
N	AT91_REG	 RSTC_RCR; 	// Reset Control Register
N	AT91_REG	 RSTC_RSR; 	// Reset Status Register
N	AT91_REG	 RSTC_RMR; 	// Reset Mode Register
N	AT91_REG	 Reserved0[60]; 	// 
N	AT91_REG	 RSTC_VER; 	// Version Register
N} AT91S_RSTC, *AT91PS_RSTC;
N#else
S#define RSTC_RCR        (AT91_CAST(AT91_REG *) 	0x00000000) // (RSTC_RCR) Reset Control Register
S#define RSTC_RSR        (AT91_CAST(AT91_REG *) 	0x00000004) // (RSTC_RSR) Reset Status Register
S#define RSTC_RMR        (AT91_CAST(AT91_REG *) 	0x00000008) // (RSTC_RMR) Reset Mode Register
S#define RSTC_VER        (AT91_CAST(AT91_REG *) 	0x000000FC) // (RSTC_VER) Version Register
S
N#endif
N// -------- RSTC_RCR : (RSTC Offset: 0x0) Reset Control Register -------- 
N#define AT91C_RSTC_PROCRST    (0x1 <<  0) // (RSTC) Processor Reset
N#define AT91C_RSTC_ICERST     (0x1 <<  1) // (RSTC) ICE Interface Reset
N#define AT91C_RSTC_PERRST     (0x1 <<  2) // (RSTC) Peripheral Reset
N#define AT91C_RSTC_EXTRST     (0x1 <<  3) // (RSTC) External Reset
N#define AT91C_RSTC_KEY        (0xFF << 24) // (RSTC) Password
N// -------- RSTC_RSR : (RSTC Offset: 0x4) Reset Status Register -------- 
N#define AT91C_RSTC_URSTS      (0x1 <<  0) // (RSTC) User Reset Status
N#define AT91C_RSTC_RSTTYP     (0x7 <<  8) // (RSTC) Reset Type
N#define 	AT91C_RSTC_RSTTYP_GENERAL              (0x0 <<  8) // (RSTC) General reset. Both VDDCORE and VDDBU rising.
N#define 	AT91C_RSTC_RSTTYP_WAKEUP               (0x1 <<  8) // (RSTC) WakeUp Reset. VDDCORE rising.
N#define 	AT91C_RSTC_RSTTYP_WATCHDOG             (0x2 <<  8) // (RSTC) Watchdog Reset. Watchdog overflow occured.
N#define 	AT91C_RSTC_RSTTYP_SOFTWARE             (0x3 <<  8) // (RSTC) Software Reset. Processor reset required by the software.
N#define 	AT91C_RSTC_RSTTYP_USER                 (0x4 <<  8) // (RSTC) User Reset. NRST pin detected low.
N#define AT91C_RSTC_NRSTL      (0x1 << 16) // (RSTC) NRST pin level
N#define AT91C_RSTC_SRCMP      (0x1 << 17) // (RSTC) Software Reset Command in Progress.
N// -------- RSTC_RMR : (RSTC Offset: 0x8) Reset Mode Register -------- 
N#define AT91C_RSTC_URSTEN     (0x1 <<  0) // (RSTC) User Reset Enable
N#define AT91C_RSTC_URSTIEN    (0x1 <<  4) // (RSTC) User Reset Interrupt Enable
N#define AT91C_RSTC_ERSTL      (0xF <<  8) // (RSTC) User Reset Enable
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Shut Down Controller Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_SHDWC {
N	AT91_REG	 SHDWC_SHCR; 	// Shut Down Control Register
N	AT91_REG	 SHDWC_SHMR; 	// Shut Down Mode Register
N	AT91_REG	 SHDWC_SHSR; 	// Shut Down Status Register
N} AT91S_SHDWC, *AT91PS_SHDWC;
N#else
S#define SHDWC_SHCR      (AT91_CAST(AT91_REG *) 	0x00000000) // (SHDWC_SHCR) Shut Down Control Register
S#define SHDWC_SHMR      (AT91_CAST(AT91_REG *) 	0x00000004) // (SHDWC_SHMR) Shut Down Mode Register
S#define SHDWC_SHSR      (AT91_CAST(AT91_REG *) 	0x00000008) // (SHDWC_SHSR) Shut Down Status Register
S
N#endif
N// -------- SHDWC_SHCR : (SHDWC Offset: 0x0) Shut Down Control Register -------- 
N#define AT91C_SHDWC_SHDW      (0x1 <<  0) // (SHDWC) Processor Reset
N#define AT91C_SHDWC_KEY       (0xFF << 24) // (SHDWC) Shut down KEY Password
N// -------- SHDWC_SHMR : (SHDWC Offset: 0x4) Shut Down Mode Register -------- 
N#define AT91C_SHDWC_WKMODE0   (0x3 <<  0) // (SHDWC) Wake Up 0 Mode Selection
N#define 	AT91C_SHDWC_WKMODE0_NONE                 (0x0) // (SHDWC) None. No detection is performed on the wake up input.
N#define 	AT91C_SHDWC_WKMODE0_HIGH                 (0x1) // (SHDWC) High Level.
N#define 	AT91C_SHDWC_WKMODE0_LOW                  (0x2) // (SHDWC) Low Level.
N#define 	AT91C_SHDWC_WKMODE0_ANYLEVEL             (0x3) // (SHDWC) Any level change.
N#define AT91C_SHDWC_CPTWK0    (0xF <<  4) // (SHDWC) Counter On Wake Up 0
N#define AT91C_SHDWC_WKMODE1   (0x3 <<  8) // (SHDWC) Wake Up 1 Mode Selection
N#define 	AT91C_SHDWC_WKMODE1_NONE                 (0x0 <<  8) // (SHDWC) None. No detection is performed on the wake up input.
N#define 	AT91C_SHDWC_WKMODE1_HIGH                 (0x1 <<  8) // (SHDWC) High Level.
N#define 	AT91C_SHDWC_WKMODE1_LOW                  (0x2 <<  8) // (SHDWC) Low Level.
N#define 	AT91C_SHDWC_WKMODE1_ANYLEVEL             (0x3 <<  8) // (SHDWC) Any level change.
N#define AT91C_SHDWC_CPTWK1    (0xF << 12) // (SHDWC) Counter On Wake Up 1
N#define AT91C_SHDWC_RTTWKEN   (0x1 << 16) // (SHDWC) Real Time Timer Wake Up Enable
N#define AT91C_SHDWC_RTCWKEN   (0x1 << 17) // (SHDWC) Real Time Clock Wake Up Enable
N// -------- SHDWC_SHSR : (SHDWC Offset: 0x8) Shut Down Status Register -------- 
N#define AT91C_SHDWC_WAKEUP0   (0x1 <<  0) // (SHDWC) Wake Up 0 Status
N#define AT91C_SHDWC_WAKEUP1   (0x1 <<  1) // (SHDWC) Wake Up 1 Status
N#define AT91C_SHDWC_FWKUP     (0x1 <<  2) // (SHDWC) Force Wake Up Status
N#define AT91C_SHDWC_RTTWK     (0x1 << 16) // (SHDWC) Real Time Timer wake Up
N#define AT91C_SHDWC_RTCWK     (0x1 << 17) // (SHDWC) Real Time Clock wake Up
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Real Time Timer Controller Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_RTTC {
N	AT91_REG	 RTTC_RTMR; 	// Real-time Mode Register
N	AT91_REG	 RTTC_RTAR; 	// Real-time Alarm Register
N	AT91_REG	 RTTC_RTVR; 	// Real-time Value Register
N	AT91_REG	 RTTC_RTSR; 	// Real-time Status Register
N} AT91S_RTTC, *AT91PS_RTTC;
N#else
S#define RTTC_RTMR       (AT91_CAST(AT91_REG *) 	0x00000000) // (RTTC_RTMR) Real-time Mode Register
S#define RTTC_RTAR       (AT91_CAST(AT91_REG *) 	0x00000004) // (RTTC_RTAR) Real-time Alarm Register
S#define RTTC_RTVR       (AT91_CAST(AT91_REG *) 	0x00000008) // (RTTC_RTVR) Real-time Value Register
S#define RTTC_RTSR       (AT91_CAST(AT91_REG *) 	0x0000000C) // (RTTC_RTSR) Real-time Status Register
S
N#endif
N// -------- RTTC_RTMR : (RTTC Offset: 0x0) Real-time Mode Register -------- 
N#define AT91C_RTTC_RTPRES     (0xFFFF <<  0) // (RTTC) Real-time Timer Prescaler Value
N#define AT91C_RTTC_ALMIEN     (0x1 << 16) // (RTTC) Alarm Interrupt Enable
N#define AT91C_RTTC_RTTINCIEN  (0x1 << 17) // (RTTC) Real Time Timer Increment Interrupt Enable
N#define AT91C_RTTC_RTTRST     (0x1 << 18) // (RTTC) Real Time Timer Restart
N// -------- RTTC_RTAR : (RTTC Offset: 0x4) Real-time Alarm Register -------- 
N#define AT91C_RTTC_ALMV       (0x0 <<  0) // (RTTC) Alarm Value
N// -------- RTTC_RTVR : (RTTC Offset: 0x8) Current Real-time Value Register -------- 
N#define AT91C_RTTC_CRTV       (0x0 <<  0) // (RTTC) Current Real-time Value
N// -------- RTTC_RTSR : (RTTC Offset: 0xc) Real-time Status Register -------- 
N#define AT91C_RTTC_ALMS       (0x1 <<  0) // (RTTC) Real-time Alarm Status
N#define AT91C_RTTC_RTTINC     (0x1 <<  1) // (RTTC) Real-time Timer Increment
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Periodic Interval Timer Controller Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_PITC {
N	AT91_REG	 PITC_PIMR; 	// Period Interval Mode Register
N	AT91_REG	 PITC_PISR; 	// Period Interval Status Register
N	AT91_REG	 PITC_PIVR; 	// Period Interval Value Register
N	AT91_REG	 PITC_PIIR; 	// Period Interval Image Register
N} AT91S_PITC, *AT91PS_PITC;
N#else
S#define PITC_PIMR       (AT91_CAST(AT91_REG *) 	0x00000000) // (PITC_PIMR) Period Interval Mode Register
S#define PITC_PISR       (AT91_CAST(AT91_REG *) 	0x00000004) // (PITC_PISR) Period Interval Status Register
S#define PITC_PIVR       (AT91_CAST(AT91_REG *) 	0x00000008) // (PITC_PIVR) Period Interval Value Register
S#define PITC_PIIR       (AT91_CAST(AT91_REG *) 	0x0000000C) // (PITC_PIIR) Period Interval Image Register
S
N#endif
N// -------- PITC_PIMR : (PITC Offset: 0x0) Periodic Interval Mode Register -------- 
N#define AT91C_PITC_PIV        (0xFFFFF <<  0) // (PITC) Periodic Interval Value
N#define AT91C_PITC_PITEN      (0x1 << 24) // (PITC) Periodic Interval Timer Enabled
N#define AT91C_PITC_PITIEN     (0x1 << 25) // (PITC) Periodic Interval Timer Interrupt Enable
N// -------- PITC_PISR : (PITC Offset: 0x4) Periodic Interval Status Register -------- 
N#define AT91C_PITC_PITS       (0x1 <<  0) // (PITC) Periodic Interval Timer Status
N// -------- PITC_PIVR : (PITC Offset: 0x8) Periodic Interval Value Register -------- 
N#define AT91C_PITC_CPIV       (0xFFFFF <<  0) // (PITC) Current Periodic Interval Value
N#define AT91C_PITC_PICNT      (0xFFF << 20) // (PITC) Periodic Interval Counter
N// -------- PITC_PIIR : (PITC Offset: 0xc) Periodic Interval Image Register -------- 
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Watchdog Timer Controller Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_WDTC {
N	AT91_REG	 WDTC_WDCR; 	// Watchdog Control Register
N	AT91_REG	 WDTC_WDMR; 	// Watchdog Mode Register
N	AT91_REG	 WDTC_WDSR; 	// Watchdog Status Register
N} AT91S_WDTC, *AT91PS_WDTC;
N#else
S#define WDTC_WDCR       (AT91_CAST(AT91_REG *) 	0x00000000) // (WDTC_WDCR) Watchdog Control Register
S#define WDTC_WDMR       (AT91_CAST(AT91_REG *) 	0x00000004) // (WDTC_WDMR) Watchdog Mode Register
S#define WDTC_WDSR       (AT91_CAST(AT91_REG *) 	0x00000008) // (WDTC_WDSR) Watchdog Status Register
S
N#endif
N// -------- WDTC_WDCR : (WDTC Offset: 0x0) Periodic Interval Image Register -------- 
N#define AT91C_WDTC_WDRSTT     (0x1 <<  0) // (WDTC) Watchdog Restart
N#define AT91C_WDTC_KEY        (0xFF << 24) // (WDTC) Watchdog KEY Password
N// -------- WDTC_WDMR : (WDTC Offset: 0x4) Watchdog Mode Register -------- 
N#define AT91C_WDTC_WDV        (0xFFF <<  0) // (WDTC) Watchdog Timer Restart
N#define AT91C_WDTC_WDFIEN     (0x1 << 12) // (WDTC) Watchdog Fault Interrupt Enable
N#define AT91C_WDTC_WDRSTEN    (0x1 << 13) // (WDTC) Watchdog Reset Enable
N#define AT91C_WDTC_WDRPROC    (0x1 << 14) // (WDTC) Watchdog Timer Restart
N#define AT91C_WDTC_WDDIS      (0x1 << 15) // (WDTC) Watchdog Disable
N#define AT91C_WDTC_WDD        (0xFFF << 16) // (WDTC) Watchdog Delta Value
N#define AT91C_WDTC_WDDBGHLT   (0x1 << 28) // (WDTC) Watchdog Debug Halt
N#define AT91C_WDTC_WDIDLEHLT  (0x1 << 29) // (WDTC) Watchdog Idle Halt
N// -------- WDTC_WDSR : (WDTC Offset: 0x8) Watchdog Status Register -------- 
N#define AT91C_WDTC_WDUNF      (0x1 <<  0) // (WDTC) Watchdog Underflow
N#define AT91C_WDTC_WDERR      (0x1 <<  1) // (WDTC) Watchdog Error
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Real-time Clock Alarm and Parallel Load Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_RTC {
N	AT91_REG	 RTC_CR; 	// Control Register
N	AT91_REG	 RTC_MR; 	// Mode Register
N	AT91_REG	 RTC_TIMR; 	// Time Register
N	AT91_REG	 RTC_CALR; 	// Calendar Register
N	AT91_REG	 RTC_TIMALR; 	// Time Alarm Register
N	AT91_REG	 RTC_CALALR; 	// Calendar Alarm Register
N	AT91_REG	 RTC_SR; 	// Status Register
N	AT91_REG	 RTC_SCCR; 	// Status Clear Command Register
N	AT91_REG	 RTC_IER; 	// Interrupt Enable Register
N	AT91_REG	 RTC_IDR; 	// Interrupt Disable Register
N	AT91_REG	 RTC_IMR; 	// Interrupt Mask Register
N	AT91_REG	 RTC_VER; 	// Valid Entry Register
N} AT91S_RTC, *AT91PS_RTC;
N#else
S#define RTC_CR          (AT91_CAST(AT91_REG *) 	0x00000000) // (RTC_CR) Control Register
S#define RTC_MR          (AT91_CAST(AT91_REG *) 	0x00000004) // (RTC_MR) Mode Register
S#define RTC_TIMR        (AT91_CAST(AT91_REG *) 	0x00000008) // (RTC_TIMR) Time Register
S#define RTC_CALR        (AT91_CAST(AT91_REG *) 	0x0000000C) // (RTC_CALR) Calendar Register
S#define RTC_TIMALR      (AT91_CAST(AT91_REG *) 	0x00000010) // (RTC_TIMALR) Time Alarm Register
S#define RTC_CALALR      (AT91_CAST(AT91_REG *) 	0x00000014) // (RTC_CALALR) Calendar Alarm Register
S#define RTC_SR          (AT91_CAST(AT91_REG *) 	0x00000018) // (RTC_SR) Status Register
S#define RTC_SCCR        (AT91_CAST(AT91_REG *) 	0x0000001C) // (RTC_SCCR) Status Clear Command Register
S#define RTC_IER         (AT91_CAST(AT91_REG *) 	0x00000020) // (RTC_IER) Interrupt Enable Register
S#define RTC_IDR         (AT91_CAST(AT91_REG *) 	0x00000024) // (RTC_IDR) Interrupt Disable Register
S#define RTC_IMR         (AT91_CAST(AT91_REG *) 	0x00000028) // (RTC_IMR) Interrupt Mask Register
S#define RTC_VER         (AT91_CAST(AT91_REG *) 	0x0000002C) // (RTC_VER) Valid Entry Register
S
N#endif
N// -------- RTC_CR : (RTC Offset: 0x0) RTC Control Register -------- 
N#define AT91C_RTC_UPDTIM      (0x1 <<  0) // (RTC) Update Request Time Register
N#define AT91C_RTC_UPDCAL      (0x1 <<  1) // (RTC) Update Request Calendar Register
N#define AT91C_RTC_TIMEVSEL    (0x3 <<  8) // (RTC) Time Event Selection
N#define 	AT91C_RTC_TIMEVSEL_MINUTE               (0x0 <<  8) // (RTC) Minute change.
N#define 	AT91C_RTC_TIMEVSEL_HOUR                 (0x1 <<  8) // (RTC) Hour change.
N#define 	AT91C_RTC_TIMEVSEL_DAY24                (0x2 <<  8) // (RTC) Every day at midnight.
N#define 	AT91C_RTC_TIMEVSEL_DAY12                (0x3 <<  8) // (RTC) Every day at noon.
N#define AT91C_RTC_CALEVSEL    (0x3 << 16) // (RTC) Calendar Event Selection
N#define 	AT91C_RTC_CALEVSEL_WEEK                 (0x0 << 16) // (RTC) Week change (every Monday at time 00:00:00).
N#define 	AT91C_RTC_CALEVSEL_MONTH                (0x1 << 16) // (RTC) Month change (every 01 of each month at time 00:00:00).
N#define 	AT91C_RTC_CALEVSEL_YEAR                 (0x2 << 16) // (RTC) Year change (every January 1 at time 00:00:00).
N// -------- RTC_MR : (RTC Offset: 0x4) RTC Mode Register -------- 
N#define AT91C_RTC_HRMOD       (0x1 <<  0) // (RTC) 12-24 hour Mode
N// -------- RTC_TIMR : (RTC Offset: 0x8) RTC Time Register -------- 
N#define AT91C_RTC_SEC         (0x7F <<  0) // (RTC) Current Second
N#define AT91C_RTC_MIN         (0x7F <<  8) // (RTC) Current Minute
N#define AT91C_RTC_HOUR        (0x3F << 16) // (RTC) Current Hour
N#define AT91C_RTC_AMPM        (0x1 << 22) // (RTC) Ante Meridiem, Post Meridiem Indicator
N// -------- RTC_CALR : (RTC Offset: 0xc) RTC Calendar Register -------- 
N#define AT91C_RTC_CENT        (0x3F <<  0) // (RTC) Current Century
N#define AT91C_RTC_YEAR        (0xFF <<  8) // (RTC) Current Year
N#define AT91C_RTC_MONTH       (0x1F << 16) // (RTC) Current Month
N#define AT91C_RTC_DAY         (0x7 << 21) // (RTC) Current Day
N#define AT91C_RTC_DATE        (0x3F << 24) // (RTC) Current Date
N// -------- RTC_TIMALR : (RTC Offset: 0x10) RTC Time Alarm Register -------- 
N#define AT91C_RTC_SECEN       (0x1 <<  7) // (RTC) Second Alarm Enable
N#define AT91C_RTC_MINEN       (0x1 << 15) // (RTC) Minute Alarm
N#define AT91C_RTC_HOUREN      (0x1 << 23) // (RTC) Current Hour
N// -------- RTC_CALALR : (RTC Offset: 0x14) RTC Calendar Alarm Register -------- 
N#define AT91C_RTC_MONTHEN     (0x1 << 23) // (RTC) Month Alarm Enable
N#define AT91C_RTC_DATEEN      (0x1 << 31) // (RTC) Date Alarm Enable
N// -------- RTC_SR : (RTC Offset: 0x18) RTC Status Register -------- 
N#define AT91C_RTC_ACKUPD      (0x1 <<  0) // (RTC) Acknowledge for Update
N#define AT91C_RTC_ALARM       (0x1 <<  1) // (RTC) Alarm Flag
N#define AT91C_RTC_SECEV       (0x1 <<  2) // (RTC) Second Event
N#define AT91C_RTC_TIMEV       (0x1 <<  3) // (RTC) Time Event
N#define AT91C_RTC_CALEV       (0x1 <<  4) // (RTC) Calendar event
N// -------- RTC_SCCR : (RTC Offset: 0x1c) RTC Status Clear Command Register -------- 
N// -------- RTC_IER : (RTC Offset: 0x20) RTC Interrupt Enable Register -------- 
N// -------- RTC_IDR : (RTC Offset: 0x24) RTC Interrupt Disable Register -------- 
N// -------- RTC_IMR : (RTC Offset: 0x28) RTC Interrupt Mask Register -------- 
N// -------- RTC_VER : (RTC Offset: 0x2c) RTC Valid Entry Register -------- 
N#define AT91C_RTC_NVTIM       (0x1 <<  0) // (RTC) Non valid Time
N#define AT91C_RTC_NVCAL       (0x1 <<  1) // (RTC) Non valid Calendar
N#define AT91C_RTC_NVTIMALR    (0x1 <<  2) // (RTC) Non valid time Alarm
N#define AT91C_RTC_NVCALALR    (0x1 <<  3) // (RTC) Nonvalid Calendar Alarm
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Timer Counter Channel Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_TC {
N	AT91_REG	 TC_CCR; 	// Channel Control Register
N	AT91_REG	 TC_CMR; 	// Channel Mode Register (Capture Mode / Waveform Mode)
N	AT91_REG	 Reserved0[2]; 	// 
N	AT91_REG	 TC_CV; 	// Counter Value
N	AT91_REG	 TC_RA; 	// Register A
N	AT91_REG	 TC_RB; 	// Register B
N	AT91_REG	 TC_RC; 	// Register C
N	AT91_REG	 TC_SR; 	// Status Register
N	AT91_REG	 TC_IER; 	// Interrupt Enable Register
N	AT91_REG	 TC_IDR; 	// Interrupt Disable Register
N	AT91_REG	 TC_IMR; 	// Interrupt Mask Register
N} AT91S_TC, *AT91PS_TC;
N#else
S#define TC_CCR          (AT91_CAST(AT91_REG *) 	0x00000000) // (TC_CCR) Channel Control Register
S#define TC_CMR          (AT91_CAST(AT91_REG *) 	0x00000004) // (TC_CMR) Channel Mode Register (Capture Mode / Waveform Mode)
S#define TC_CV           (AT91_CAST(AT91_REG *) 	0x00000010) // (TC_CV) Counter Value
S#define TC_RA           (AT91_CAST(AT91_REG *) 	0x00000014) // (TC_RA) Register A
S#define TC_RB           (AT91_CAST(AT91_REG *) 	0x00000018) // (TC_RB) Register B
S#define TC_RC           (AT91_CAST(AT91_REG *) 	0x0000001C) // (TC_RC) Register C
S#define TC_SR           (AT91_CAST(AT91_REG *) 	0x00000020) // (TC_SR) Status Register
S#define TC_IER          (AT91_CAST(AT91_REG *) 	0x00000024) // (TC_IER) Interrupt Enable Register
S#define TC_IDR          (AT91_CAST(AT91_REG *) 	0x00000028) // (TC_IDR) Interrupt Disable Register
S#define TC_IMR          (AT91_CAST(AT91_REG *) 	0x0000002C) // (TC_IMR) Interrupt Mask Register
S
N#endif
N// -------- TC_CCR : (TC Offset: 0x0) TC Channel Control Register -------- 
N#define AT91C_TC_CLKEN        (0x1 <<  0) // (TC) Counter Clock Enable Command
N#define AT91C_TC_CLKDIS       (0x1 <<  1) // (TC) Counter Clock Disable Command
N#define AT91C_TC_SWTRG        (0x1 <<  2) // (TC) Software Trigger Command
N// -------- TC_CMR : (TC Offset: 0x4) TC Channel Mode Register: Capture Mode / Waveform Mode -------- 
N#define AT91C_TC_CLKS         (0x7 <<  0) // (TC) Clock Selection
N#define 	AT91C_TC_CLKS_TIMER_DIV1_CLOCK     (0x0) // (TC) Clock selected: TIMER_DIV1_CLOCK
N#define 	AT91C_TC_CLKS_TIMER_DIV2_CLOCK     (0x1) // (TC) Clock selected: TIMER_DIV2_CLOCK
N#define 	AT91C_TC_CLKS_TIMER_DIV3_CLOCK     (0x2) // (TC) Clock selected: TIMER_DIV3_CLOCK
N#define 	AT91C_TC_CLKS_TIMER_DIV4_CLOCK     (0x3) // (TC) Clock selected: TIMER_DIV4_CLOCK
N#define 	AT91C_TC_CLKS_TIMER_DIV5_CLOCK     (0x4) // (TC) Clock selected: TIMER_DIV5_CLOCK
N#define 	AT91C_TC_CLKS_XC0                  (0x5) // (TC) Clock selected: XC0
N#define 	AT91C_TC_CLKS_XC1                  (0x6) // (TC) Clock selected: XC1
N#define 	AT91C_TC_CLKS_XC2                  (0x7) // (TC) Clock selected: XC2
N#define AT91C_TC_CLKI         (0x1 <<  3) // (TC) Clock Invert
N#define AT91C_TC_BURST        (0x3 <<  4) // (TC) Burst Signal Selection
N#define 	AT91C_TC_BURST_NONE                 (0x0 <<  4) // (TC) The clock is not gated by an external signal
N#define 	AT91C_TC_BURST_XC0                  (0x1 <<  4) // (TC) XC0 is ANDed with the selected clock
N#define 	AT91C_TC_BURST_XC1                  (0x2 <<  4) // (TC) XC1 is ANDed with the selected clock
N#define 	AT91C_TC_BURST_XC2                  (0x3 <<  4) // (TC) XC2 is ANDed with the selected clock
N#define AT91C_TC_CPCSTOP      (0x1 <<  6) // (TC) Counter Clock Stopped with RC Compare
N#define AT91C_TC_LDBSTOP      (0x1 <<  6) // (TC) Counter Clock Stopped with RB Loading
N#define AT91C_TC_CPCDIS       (0x1 <<  7) // (TC) Counter Clock Disable with RC Compare
N#define AT91C_TC_LDBDIS       (0x1 <<  7) // (TC) Counter Clock Disabled with RB Loading
N#define AT91C_TC_ETRGEDG      (0x3 <<  8) // (TC) External Trigger Edge Selection
N#define 	AT91C_TC_ETRGEDG_NONE                 (0x0 <<  8) // (TC) Edge: None
N#define 	AT91C_TC_ETRGEDG_RISING               (0x1 <<  8) // (TC) Edge: rising edge
N#define 	AT91C_TC_ETRGEDG_FALLING              (0x2 <<  8) // (TC) Edge: falling edge
N#define 	AT91C_TC_ETRGEDG_BOTH                 (0x3 <<  8) // (TC) Edge: each edge
N#define AT91C_TC_EEVTEDG      (0x3 <<  8) // (TC) External Event Edge Selection
N#define 	AT91C_TC_EEVTEDG_NONE                 (0x0 <<  8) // (TC) Edge: None
N#define 	AT91C_TC_EEVTEDG_RISING               (0x1 <<  8) // (TC) Edge: rising edge
N#define 	AT91C_TC_EEVTEDG_FALLING              (0x2 <<  8) // (TC) Edge: falling edge
N#define 	AT91C_TC_EEVTEDG_BOTH                 (0x3 <<  8) // (TC) Edge: each edge
N#define AT91C_TC_EEVT         (0x3 << 10) // (TC) External Event  Selection
N#define 	AT91C_TC_EEVT_TIOB                 (0x0 << 10) // (TC) Signal selected as external event: TIOB TIOB direction: input
N#define 	AT91C_TC_EEVT_XC0                  (0x1 << 10) // (TC) Signal selected as external event: XC0 TIOB direction: output
N#define 	AT91C_TC_EEVT_XC1                  (0x2 << 10) // (TC) Signal selected as external event: XC1 TIOB direction: output
N#define 	AT91C_TC_EEVT_XC2                  (0x3 << 10) // (TC) Signal selected as external event: XC2 TIOB direction: output
N#define AT91C_TC_ABETRG       (0x1 << 10) // (TC) TIOA or TIOB External Trigger Selection
N#define AT91C_TC_ENETRG       (0x1 << 12) // (TC) External Event Trigger enable
N#define AT91C_TC_WAVESEL      (0x3 << 13) // (TC) Waveform  Selection
N#define 	AT91C_TC_WAVESEL_UP                   (0x0 << 13) // (TC) UP mode without atomatic trigger on RC Compare
N#define 	AT91C_TC_WAVESEL_UPDOWN               (0x1 << 13) // (TC) UPDOWN mode without automatic trigger on RC Compare
N#define 	AT91C_TC_WAVESEL_UP_AUTO              (0x2 << 13) // (TC) UP mode with automatic trigger on RC Compare
N#define 	AT91C_TC_WAVESEL_UPDOWN_AUTO          (0x3 << 13) // (TC) UPDOWN mode with automatic trigger on RC Compare
N#define AT91C_TC_CPCTRG       (0x1 << 14) // (TC) RC Compare Trigger Enable
N#define AT91C_TC_WAVE         (0x1 << 15) // (TC) 
N#define AT91C_TC_ACPA         (0x3 << 16) // (TC) RA Compare Effect on TIOA
N#define 	AT91C_TC_ACPA_NONE                 (0x0 << 16) // (TC) Effect: none
N#define 	AT91C_TC_ACPA_SET                  (0x1 << 16) // (TC) Effect: set
N#define 	AT91C_TC_ACPA_CLEAR                (0x2 << 16) // (TC) Effect: clear
N#define 	AT91C_TC_ACPA_TOGGLE               (0x3 << 16) // (TC) Effect: toggle
N#define AT91C_TC_LDRA         (0x3 << 16) // (TC) RA Loading Selection
N#define 	AT91C_TC_LDRA_NONE                 (0x0 << 16) // (TC) Edge: None
N#define 	AT91C_TC_LDRA_RISING               (0x1 << 16) // (TC) Edge: rising edge of TIOA
N#define 	AT91C_TC_LDRA_FALLING              (0x2 << 16) // (TC) Edge: falling edge of TIOA
N#define 	AT91C_TC_LDRA_BOTH                 (0x3 << 16) // (TC) Edge: each edge of TIOA
N#define AT91C_TC_ACPC         (0x3 << 18) // (TC) RC Compare Effect on TIOA
N#define 	AT91C_TC_ACPC_NONE                 (0x0 << 18) // (TC) Effect: none
N#define 	AT91C_TC_ACPC_SET                  (0x1 << 18) // (TC) Effect: set
N#define 	AT91C_TC_ACPC_CLEAR                (0x2 << 18) // (TC) Effect: clear
N#define 	AT91C_TC_ACPC_TOGGLE               (0x3 << 18) // (TC) Effect: toggle
N#define AT91C_TC_LDRB         (0x3 << 18) // (TC) RB Loading Selection
N#define 	AT91C_TC_LDRB_NONE                 (0x0 << 18) // (TC) Edge: None
N#define 	AT91C_TC_LDRB_RISING               (0x1 << 18) // (TC) Edge: rising edge of TIOA
N#define 	AT91C_TC_LDRB_FALLING              (0x2 << 18) // (TC) Edge: falling edge of TIOA
N#define 	AT91C_TC_LDRB_BOTH                 (0x3 << 18) // (TC) Edge: each edge of TIOA
N#define AT91C_TC_AEEVT        (0x3 << 20) // (TC) External Event Effect on TIOA
N#define 	AT91C_TC_AEEVT_NONE                 (0x0 << 20) // (TC) Effect: none
N#define 	AT91C_TC_AEEVT_SET                  (0x1 << 20) // (TC) Effect: set
N#define 	AT91C_TC_AEEVT_CLEAR                (0x2 << 20) // (TC) Effect: clear
N#define 	AT91C_TC_AEEVT_TOGGLE               (0x3 << 20) // (TC) Effect: toggle
N#define AT91C_TC_ASWTRG       (0x3 << 22) // (TC) Software Trigger Effect on TIOA
N#define 	AT91C_TC_ASWTRG_NONE                 (0x0 << 22) // (TC) Effect: none
N#define 	AT91C_TC_ASWTRG_SET                  (0x1 << 22) // (TC) Effect: set
N#define 	AT91C_TC_ASWTRG_CLEAR                (0x2 << 22) // (TC) Effect: clear
N#define 	AT91C_TC_ASWTRG_TOGGLE               (0x3 << 22) // (TC) Effect: toggle
N#define AT91C_TC_BCPB         (0x3 << 24) // (TC) RB Compare Effect on TIOB
N#define 	AT91C_TC_BCPB_NONE                 (0x0 << 24) // (TC) Effect: none
N#define 	AT91C_TC_BCPB_SET                  (0x1 << 24) // (TC) Effect: set
N#define 	AT91C_TC_BCPB_CLEAR                (0x2 << 24) // (TC) Effect: clear
N#define 	AT91C_TC_BCPB_TOGGLE               (0x3 << 24) // (TC) Effect: toggle
N#define AT91C_TC_BCPC         (0x3 << 26) // (TC) RC Compare Effect on TIOB
N#define 	AT91C_TC_BCPC_NONE                 (0x0 << 26) // (TC) Effect: none
N#define 	AT91C_TC_BCPC_SET                  (0x1 << 26) // (TC) Effect: set
N#define 	AT91C_TC_BCPC_CLEAR                (0x2 << 26) // (TC) Effect: clear
N#define 	AT91C_TC_BCPC_TOGGLE               (0x3 << 26) // (TC) Effect: toggle
N#define AT91C_TC_BEEVT        (0x3 << 28) // (TC) External Event Effect on TIOB
N#define 	AT91C_TC_BEEVT_NONE                 (0x0 << 28) // (TC) Effect: none
N#define 	AT91C_TC_BEEVT_SET                  (0x1 << 28) // (TC) Effect: set
N#define 	AT91C_TC_BEEVT_CLEAR                (0x2 << 28) // (TC) Effect: clear
N#define 	AT91C_TC_BEEVT_TOGGLE               (0x3 << 28) // (TC) Effect: toggle
N#define AT91C_TC_BSWTRG       (0x3 << 30) // (TC) Software Trigger Effect on TIOB
N#define 	AT91C_TC_BSWTRG_NONE                 (0x0 << 30) // (TC) Effect: none
N#define 	AT91C_TC_BSWTRG_SET                  (0x1 << 30) // (TC) Effect: set
N#define 	AT91C_TC_BSWTRG_CLEAR                (0x2 << 30) // (TC) Effect: clear
N#define 	AT91C_TC_BSWTRG_TOGGLE               (0x3 << 30) // (TC) Effect: toggle
N// -------- TC_SR : (TC Offset: 0x20) TC Channel Status Register -------- 
N#define AT91C_TC_COVFS        (0x1 <<  0) // (TC) Counter Overflow
N#define AT91C_TC_LOVRS        (0x1 <<  1) // (TC) Load Overrun
N#define AT91C_TC_CPAS         (0x1 <<  2) // (TC) RA Compare
N#define AT91C_TC_CPBS         (0x1 <<  3) // (TC) RB Compare
N#define AT91C_TC_CPCS         (0x1 <<  4) // (TC) RC Compare
N#define AT91C_TC_LDRAS        (0x1 <<  5) // (TC) RA Loading
N#define AT91C_TC_LDRBS        (0x1 <<  6) // (TC) RB Loading
N#define AT91C_TC_ETRGS        (0x1 <<  7) // (TC) External Trigger
N#define AT91C_TC_CLKSTA       (0x1 << 16) // (TC) Clock Enabling
N#define AT91C_TC_MTIOA        (0x1 << 17) // (TC) TIOA Mirror
N#define AT91C_TC_MTIOB        (0x1 << 18) // (TC) TIOA Mirror
N// -------- TC_IER : (TC Offset: 0x24) TC Channel Interrupt Enable Register -------- 
N// -------- TC_IDR : (TC Offset: 0x28) TC Channel Interrupt Disable Register -------- 
N// -------- TC_IMR : (TC Offset: 0x2c) TC Channel Interrupt Mask Register -------- 
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Timer Counter Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_TCB {
N	AT91S_TC	 TCB_TC0; 	// TC Channel 0
N	AT91_REG	 Reserved0[4]; 	// 
N	AT91S_TC	 TCB_TC1; 	// TC Channel 1
N	AT91_REG	 Reserved1[4]; 	// 
N	AT91S_TC	 TCB_TC2; 	// TC Channel 2
N	AT91_REG	 Reserved2[4]; 	// 
N	AT91_REG	 TCB_BCR; 	// TC Block Control Register
N	AT91_REG	 TCB_BMR; 	// TC Block Mode Register
N	AT91_REG	 Reserved3[9]; 	// 
N	AT91_REG	 TCB_ADDRSIZE; 	// TC ADDRSIZE REGISTER 
N	AT91_REG	 TCB_IPNAME1; 	// TC IPNAME1 REGISTER 
N	AT91_REG	 TCB_IPNAME2; 	// TC IPNAME2 REGISTER 
N	AT91_REG	 TCB_FEATURES; 	// TC FEATURES REGISTER 
N	AT91_REG	 TCB_VER; 	//  Version Register
N} AT91S_TCB, *AT91PS_TCB;
N#else
S#define TCB_BCR         (AT91_CAST(AT91_REG *) 	0x000000C0) // (TCB_BCR) TC Block Control Register
S#define TCB_BMR         (AT91_CAST(AT91_REG *) 	0x000000C4) // (TCB_BMR) TC Block Mode Register
S#define TC_ADDRSIZE     (AT91_CAST(AT91_REG *) 	0x000000EC) // (TC_ADDRSIZE) TC ADDRSIZE REGISTER 
S#define TC_IPNAME1      (AT91_CAST(AT91_REG *) 	0x000000F0) // (TC_IPNAME1) TC IPNAME1 REGISTER 
S#define TC_IPNAME2      (AT91_CAST(AT91_REG *) 	0x000000F4) // (TC_IPNAME2) TC IPNAME2 REGISTER 
S#define TC_FEATURES     (AT91_CAST(AT91_REG *) 	0x000000F8) // (TC_FEATURES) TC FEATURES REGISTER 
S#define TC_VER          (AT91_CAST(AT91_REG *) 	0x000000FC) // (TC_VER)  Version Register
S
N#endif
N// -------- TCB_BCR : (TCB Offset: 0xc0) TC Block Control Register -------- 
N#define AT91C_TCB_SYNC        (0x1 <<  0) // (TCB) Synchro Command
N// -------- TCB_BMR : (TCB Offset: 0xc4) TC Block Mode Register -------- 
N#define AT91C_TCB_TC0XC0S     (0x3 <<  0) // (TCB) External Clock Signal 0 Selection
N#define 	AT91C_TCB_TC0XC0S_TCLK0                (0x0) // (TCB) TCLK0 connected to XC0
N#define 	AT91C_TCB_TC0XC0S_NONE                 (0x1) // (TCB) None signal connected to XC0
N#define 	AT91C_TCB_TC0XC0S_TIOA1                (0x2) // (TCB) TIOA1 connected to XC0
N#define 	AT91C_TCB_TC0XC0S_TIOA2                (0x3) // (TCB) TIOA2 connected to XC0
N#define AT91C_TCB_TC1XC1S     (0x3 <<  2) // (TCB) External Clock Signal 1 Selection
N#define 	AT91C_TCB_TC1XC1S_TCLK1                (0x0 <<  2) // (TCB) TCLK1 connected to XC1
N#define 	AT91C_TCB_TC1XC1S_NONE                 (0x1 <<  2) // (TCB) None signal connected to XC1
N#define 	AT91C_TCB_TC1XC1S_TIOA0                (0x2 <<  2) // (TCB) TIOA0 connected to XC1
N#define 	AT91C_TCB_TC1XC1S_TIOA2                (0x3 <<  2) // (TCB) TIOA2 connected to XC1
N#define AT91C_TCB_TC2XC2S     (0x3 <<  4) // (TCB) External Clock Signal 2 Selection
N#define 	AT91C_TCB_TC2XC2S_TCLK2                (0x0 <<  4) // (TCB) TCLK2 connected to XC2
N#define 	AT91C_TCB_TC2XC2S_NONE                 (0x1 <<  4) // (TCB) None signal connected to XC2
N#define 	AT91C_TCB_TC2XC2S_TIOA0                (0x2 <<  4) // (TCB) TIOA0 connected to XC2
N#define 	AT91C_TCB_TC2XC2S_TIOA1                (0x3 <<  4) // (TCB) TIOA2 connected to XC2
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Multimedia Card Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_MCI {
N	AT91_REG	 MCI_CR; 	// MCI Control Register
N	AT91_REG	 MCI_MR; 	// MCI Mode Register
N	AT91_REG	 MCI_DTOR; 	// MCI Data Timeout Register
N	AT91_REG	 MCI_SDCR; 	// MCI SD/SDIO Card Register
N	AT91_REG	 MCI_ARGR; 	// MCI Argument Register
N	AT91_REG	 MCI_CMDR; 	// MCI Command Register
N	AT91_REG	 MCI_BLKR; 	// MCI Block Register
N	AT91_REG	 MCI_CSTOR; 	// MCI Completion Signal Timeout Register
N	AT91_REG	 MCI_RSPR[4]; 	// MCI Response Register
N	AT91_REG	 MCI_RDR; 	// MCI Receive Data Register
N	AT91_REG	 MCI_TDR; 	// MCI Transmit Data Register
N	AT91_REG	 Reserved0[2]; 	// 
N	AT91_REG	 MCI_SR; 	// MCI Status Register
N	AT91_REG	 MCI_IER; 	// MCI Interrupt Enable Register
N	AT91_REG	 MCI_IDR; 	// MCI Interrupt Disable Register
N	AT91_REG	 MCI_IMR; 	// MCI Interrupt Mask Register
N	AT91_REG	 MCI_DMA; 	// MCI DMA Configuration Register
N	AT91_REG	 MCI_CFG; 	// MCI Configuration Register
N	AT91_REG	 Reserved1[35]; 	// 
N	AT91_REG	 MCI_WPCR; 	// MCI Write Protection Control Register
N	AT91_REG	 MCI_WPSR; 	// MCI Write Protection Status Register
N	AT91_REG	 MCI_ADDRSIZE; 	// MCI ADDRSIZE REGISTER 
N	AT91_REG	 MCI_IPNAME1; 	// MCI IPNAME1 REGISTER 
N	AT91_REG	 MCI_IPNAME2; 	// MCI IPNAME2 REGISTER 
N	AT91_REG	 MCI_FEATURES; 	// MCI FEATURES REGISTER 
N	AT91_REG	 MCI_VER; 	// MCI VERSION REGISTER 
N	AT91_REG	 MCI_RPR; 	// Receive Pointer Register
N	AT91_REG	 MCI_RCR; 	// Receive Counter Register
N	AT91_REG	 MCI_TPR; 	// Transmit Pointer Register
N	AT91_REG	 MCI_TCR; 	// Transmit Counter Register
N	AT91_REG	 MCI_RNPR; 	// Receive Next Pointer Register
N	AT91_REG	 MCI_RNCR; 	// Receive Next Counter Register
N	AT91_REG	 MCI_TNPR; 	// Transmit Next Pointer Register
N	AT91_REG	 MCI_TNCR; 	// Transmit Next Counter Register
N	AT91_REG	 MCI_PTCR; 	// PDC Transfer Control Register
N	AT91_REG	 MCI_PTSR; 	// PDC Transfer Status Register
N	AT91_REG	 Reserved2[54]; 	// 
N	AT91_REG	 MCI_FIFO; 	// MCI FIFO Aperture Register
N} AT91S_MCI, *AT91PS_MCI;
N#else
S#define MCI_CR          (AT91_CAST(AT91_REG *) 	0x00000000) // (MCI_CR) MCI Control Register
S#define MCI_MR          (AT91_CAST(AT91_REG *) 	0x00000004) // (MCI_MR) MCI Mode Register
S#define MCI_DTOR        (AT91_CAST(AT91_REG *) 	0x00000008) // (MCI_DTOR) MCI Data Timeout Register
S#define MCI_SDCR        (AT91_CAST(AT91_REG *) 	0x0000000C) // (MCI_SDCR) MCI SD/SDIO Card Register
S#define MCI_ARGR        (AT91_CAST(AT91_REG *) 	0x00000010) // (MCI_ARGR) MCI Argument Register
S#define MCI_CMDR        (AT91_CAST(AT91_REG *) 	0x00000014) // (MCI_CMDR) MCI Command Register
S#define MCI_BLKR        (AT91_CAST(AT91_REG *) 	0x00000018) // (MCI_BLKR) MCI Block Register
S#define MCI_CSTOR       (AT91_CAST(AT91_REG *) 	0x0000001C) // (MCI_CSTOR) MCI Completion Signal Timeout Register
S#define MCI_RSPR        (AT91_CAST(AT91_REG *) 	0x00000020) // (MCI_RSPR) MCI Response Register
S#define MCI_RDR         (AT91_CAST(AT91_REG *) 	0x00000030) // (MCI_RDR) MCI Receive Data Register
S#define MCI_TDR         (AT91_CAST(AT91_REG *) 	0x00000034) // (MCI_TDR) MCI Transmit Data Register
S#define MCI_SR          (AT91_CAST(AT91_REG *) 	0x00000040) // (MCI_SR) MCI Status Register
S#define MCI_IER         (AT91_CAST(AT91_REG *) 	0x00000044) // (MCI_IER) MCI Interrupt Enable Register
S#define MCI_IDR         (AT91_CAST(AT91_REG *) 	0x00000048) // (MCI_IDR) MCI Interrupt Disable Register
S#define MCI_IMR         (AT91_CAST(AT91_REG *) 	0x0000004C) // (MCI_IMR) MCI Interrupt Mask Register
S#define MCI_DMA         (AT91_CAST(AT91_REG *) 	0x00000050) // (MCI_DMA) MCI DMA Configuration Register
S#define MCI_CFG         (AT91_CAST(AT91_REG *) 	0x00000054) // (MCI_CFG) MCI Configuration Register
S#define MCI_WPCR        (AT91_CAST(AT91_REG *) 	0x000000E4) // (MCI_WPCR) MCI Write Protection Control Register
S#define MCI_WPSR        (AT91_CAST(AT91_REG *) 	0x000000E8) // (MCI_WPSR) MCI Write Protection Status Register
S#define MCI_ADDRSIZE    (AT91_CAST(AT91_REG *) 	0x000000EC) // (MCI_ADDRSIZE) MCI ADDRSIZE REGISTER 
S#define MCI_IPNAME1     (AT91_CAST(AT91_REG *) 	0x000000F0) // (MCI_IPNAME1) MCI IPNAME1 REGISTER 
S#define MCI_IPNAME2     (AT91_CAST(AT91_REG *) 	0x000000F4) // (MCI_IPNAME2) MCI IPNAME2 REGISTER 
S#define MCI_FEATURES    (AT91_CAST(AT91_REG *) 	0x000000F8) // (MCI_FEATURES) MCI FEATURES REGISTER 
S#define MCI_VER         (AT91_CAST(AT91_REG *) 	0x000000FC) // (MCI_VER) MCI VERSION REGISTER 
S#define MCI_FIFO        (AT91_CAST(AT91_REG *) 	0x00000200) // (MCI_FIFO) MCI FIFO Aperture Register
S
N#endif
N// -------- MCI_CR : (MCI Offset: 0x0) MCI Control Register -------- 
N#define AT91C_MCI_MCIEN       (0x1 <<  0) // (MCI) Multimedia Interface Enable
N#define 	AT91C_MCI_MCIEN_0                    (0x0) // (MCI) No effect
N#define 	AT91C_MCI_MCIEN_1                    (0x1) // (MCI) Enable the MultiMedia Interface if MCIDIS is 0
N#define AT91C_MCI_MCIDIS      (0x1 <<  1) // (MCI) Multimedia Interface Disable
N#define 	AT91C_MCI_MCIDIS_0                    (0x0 <<  1) // (MCI) No effect
N#define 	AT91C_MCI_MCIDIS_1                    (0x1 <<  1) // (MCI) Disable the MultiMedia Interface
N#define AT91C_MCI_PWSEN       (0x1 <<  2) // (MCI) Power Save Mode Enable
N#define 	AT91C_MCI_PWSEN_0                    (0x0 <<  2) // (MCI) No effect
N#define 	AT91C_MCI_PWSEN_1                    (0x1 <<  2) // (MCI) Enable the Power-saving mode if PWSDIS is 0.
N#define AT91C_MCI_PWSDIS      (0x1 <<  3) // (MCI) Power Save Mode Disable
N#define 	AT91C_MCI_PWSDIS_0                    (0x0 <<  3) // (MCI) No effect
N#define 	AT91C_MCI_PWSDIS_1                    (0x1 <<  3) // (MCI) Disable the Power-saving mode.
N#define AT91C_MCI_IOWAITEN    (0x1 <<  4) // (MCI) SDIO Read Wait Enable
N#define 	AT91C_MCI_IOWAITEN_0                    (0x0 <<  4) // (MCI) No effect
N#define 	AT91C_MCI_IOWAITEN_1                    (0x1 <<  4) // (MCI) Enables the SDIO Read Wait Operation.
N#define AT91C_MCI_IOWAITDIS   (0x1 <<  5) // (MCI) SDIO Read Wait Disable
N#define 	AT91C_MCI_IOWAITDIS_0                    (0x0 <<  5) // (MCI) No effect
N#define 	AT91C_MCI_IOWAITDIS_1                    (0x1 <<  5) // (MCI) Disables the SDIO Read Wait Operation.
N#define AT91C_MCI_SWRST       (0x1 <<  7) // (MCI) MCI Software reset
N#define 	AT91C_MCI_SWRST_0                    (0x0 <<  7) // (MCI) No effect
N#define 	AT91C_MCI_SWRST_1                    (0x1 <<  7) // (MCI) Resets the MCI
N// -------- MCI_MR : (MCI Offset: 0x4) MCI Mode Register -------- 
N#define AT91C_MCI_CLKDIV      (0xFF <<  0) // (MCI) Clock Divider
N#define AT91C_MCI_PWSDIV      (0x7 <<  8) // (MCI) Power Saving Divider
N#define AT91C_MCI_RDPROOF     (0x1 << 11) // (MCI) Read Proof Enable
N#define 	AT91C_MCI_RDPROOF_DISABLE              (0x0 << 11) // (MCI) Disables Read Proof
N#define 	AT91C_MCI_RDPROOF_ENABLE               (0x1 << 11) // (MCI) Enables Read Proof
N#define AT91C_MCI_WRPROOF     (0x1 << 12) // (MCI) Write Proof Enable
N#define 	AT91C_MCI_WRPROOF_DISABLE              (0x0 << 12) // (MCI) Disables Write Proof
N#define 	AT91C_MCI_WRPROOF_ENABLE               (0x1 << 12) // (MCI) Enables Write Proof
N#define AT91C_MCI_PDCFBYTE    (0x1 << 13) // (MCI) PDC Force Byte Transfer
N#define 	AT91C_MCI_PDCFBYTE_DISABLE              (0x0 << 13) // (MCI) Disables PDC Force Byte Transfer
N#define 	AT91C_MCI_PDCFBYTE_ENABLE               (0x1 << 13) // (MCI) Enables PDC Force Byte Transfer
N#define AT91C_MCI_PDCPADV     (0x1 << 14) // (MCI) PDC Padding Value
N#define AT91C_MCI_PDCMODE     (0x1 << 15) // (MCI) PDC Oriented Mode
N#define 	AT91C_MCI_PDCMODE_DISABLE              (0x0 << 15) // (MCI) Disables PDC Transfer
N#define 	AT91C_MCI_PDCMODE_ENABLE               (0x1 << 15) // (MCI) Enables PDC Transfer
N#define AT91C_MCI_BLKLEN      (0xFFFF0000) //(0xFFFF << 16) // (MCI) Data Block Length
N// -------- MCI_DTOR : (MCI Offset: 0x8) MCI Data Timeout Register -------- 
N#define AT91C_MCI_DTOCYC      (0xF <<  0) // (MCI) Data Timeout Cycle Number
N#define AT91C_MCI_DTOMUL      (0x7 <<  4) // (MCI) Data Timeout Multiplier
N#define 	AT91C_MCI_DTOMUL_1                    (0x0 <<  4) // (MCI) DTOCYC x 1
N#define 	AT91C_MCI_DTOMUL_16                   (0x1 <<  4) // (MCI) DTOCYC x 16
N#define 	AT91C_MCI_DTOMUL_128                  (0x2 <<  4) // (MCI) DTOCYC x 128
N#define 	AT91C_MCI_DTOMUL_256                  (0x3 <<  4) // (MCI) DTOCYC x 256
N#define 	AT91C_MCI_DTOMUL_1024                 (0x4 <<  4) // (MCI) DTOCYC x 1024
N#define 	AT91C_MCI_DTOMUL_4096                 (0x5 <<  4) // (MCI) DTOCYC x 4096
N#define 	AT91C_MCI_DTOMUL_65536                (0x6 <<  4) // (MCI) DTOCYC x 65536
N#define 	AT91C_MCI_DTOMUL_1048576              (0x7 <<  4) // (MCI) DTOCYC x 1048576
N// -------- MCI_SDCR : (MCI Offset: 0xc) MCI SD Card Register -------- 
N#define AT91C_MCI_SCDSEL      (0x3 <<  0) // (MCI) SD Card/SDIO Selector
N#define 	AT91C_MCI_SCDSEL_SLOTA                (0x0) // (MCI) Slot A selected
N#define 	AT91C_MCI_SCDSEL_SLOTB                (0x1) // (MCI) Slot B selected
N#define 	AT91C_MCI_SCDSEL_SLOTC                (0x2) // (MCI) Slot C selected
N#define 	AT91C_MCI_SCDSEL_SLOTD                (0x3) // (MCI) Slot D selected
N#define AT91C_MCI_SCDBUS      (0x3 <<  6) // (MCI) SDCard/SDIO Bus Width
N#define 	AT91C_MCI_SCDBUS_1BIT                 (0x0 <<  6) // (MCI) 1-bit data bus
N#define 	AT91C_MCI_SCDBUS_4BITS                (0x2 <<  6) // (MCI) 4-bits data bus
N#define 	AT91C_MCI_SCDBUS_8BITS                (0x3 <<  6) // (MCI) 8-bits data bus
N// -------- MCI_CMDR : (MCI Offset: 0x14) MCI Command Register -------- 
N#define AT91C_MCI_CMDNB       (0x3F <<  0) // (MCI) Command Number
N#define AT91C_MCI_RSPTYP      (0x3 <<  6) // (MCI) Response Type
N#define 	AT91C_MCI_RSPTYP_NO                   (0x0 <<  6) // (MCI) No response
N#define 	AT91C_MCI_RSPTYP_48                   (0x1 <<  6) // (MCI) 48-bit response
N#define 	AT91C_MCI_RSPTYP_136                  (0x2 <<  6) // (MCI) 136-bit response
N#define 	AT91C_MCI_RSPTYP_R1B                  (0x3 <<  6) // (MCI) R1b response
N#define AT91C_MCI_SPCMD       (0x7 <<  8) // (MCI) Special CMD
N#define 	AT91C_MCI_SPCMD_NONE                 (0x0 <<  8) // (MCI) Not a special CMD
N#define 	AT91C_MCI_SPCMD_INIT                 (0x1 <<  8) // (MCI) Initialization CMD
N#define 	AT91C_MCI_SPCMD_SYNC                 (0x2 <<  8) // (MCI) Synchronized CMD
N#define 	AT91C_MCI_SPCMD_CE_ATA               (0x3 <<  8) // (MCI) CE-ATA Completion Signal disable CMD
N#define 	AT91C_MCI_SPCMD_IT_CMD               (0x4 <<  8) // (MCI) Interrupt command
N#define 	AT91C_MCI_SPCMD_IT_REP               (0x5 <<  8) // (MCI) Interrupt response
N#define AT91C_MCI_OPDCMD      (0x1 << 11) // (MCI) Open Drain Command
N#define 	AT91C_MCI_OPDCMD_PUSHPULL             (0x0 << 11) // (MCI) Push/pull command
N#define 	AT91C_MCI_OPDCMD_OPENDRAIN            (0x1 << 11) // (MCI) Open drain command
N#define AT91C_MCI_MAXLAT      (0x1 << 12) // (MCI) Maximum Latency for Command to respond
N#define 	AT91C_MCI_MAXLAT_5                    (0x0 << 12) // (MCI) 5 cycles maximum latency
N#define 	AT91C_MCI_MAXLAT_64                   (0x1 << 12) // (MCI) 64 cycles maximum latency
N#define AT91C_MCI_TRCMD       (0x3 << 16) // (MCI) Transfer CMD
N#define 	AT91C_MCI_TRCMD_NO                   (0x0 << 16) // (MCI) No transfer
N#define 	AT91C_MCI_TRCMD_START                (0x1 << 16) // (MCI) Start transfer
N#define 	AT91C_MCI_TRCMD_STOP                 (0x2 << 16) // (MCI) Stop transfer
N#define AT91C_MCI_TRDIR       (0x1 << 18) // (MCI) Transfer Direction
N#define 	AT91C_MCI_TRDIR_WRITE                (0x0 << 18) // (MCI) Write
N#define 	AT91C_MCI_TRDIR_READ                 (0x1 << 18) // (MCI) Read
N#define AT91C_MCI_TRTYP       (0x7 << 19) // (MCI) Transfer Type
N#define 	AT91C_MCI_TRTYP_BLOCK                (0x0 << 19) // (MCI) MMC/SDCard Single Block Transfer type
N#define 	AT91C_MCI_TRTYP_MULTIPLE             (0x1 << 19) // (MCI) MMC/SDCard Multiple Block transfer type
N#define 	AT91C_MCI_TRTYP_STREAM               (0x2 << 19) // (MCI) MMC Stream transfer type
N#define 	AT91C_MCI_TRTYP_SDIO_BYTE            (0x4 << 19) // (MCI) SDIO Byte transfer type
N#define 	AT91C_MCI_TRTYP_SDIO_BLOCK           (0x5 << 19) // (MCI) SDIO Block transfer type
N#define AT91C_MCI_IOSPCMD     (0x3 << 24) // (MCI) SDIO Special Command
N#define 	AT91C_MCI_IOSPCMD_NONE                 (0x0 << 24) // (MCI) NOT a special command
N#define 	AT91C_MCI_IOSPCMD_SUSPEND              (0x1 << 24) // (MCI) SDIO Suspend Command
N#define 	AT91C_MCI_IOSPCMD_RESUME               (0x2 << 24) // (MCI) SDIO Resume Command
N#define AT91C_MCI_ATACS       (0x1 << 26) // (MCI) ATA with command completion signal
N#define 	AT91C_MCI_ATACS_NORMAL               (0x0 << 26) // (MCI) normal operation mode
N#define 	AT91C_MCI_ATACS_COMPLETION           (0x1 << 26) // (MCI) completion signal is expected within MCI_CSTOR
N// -------- MCI_BLKR : (MCI Offset: 0x18) MCI Block Register -------- 
N#define AT91C_MCI_BCNT        (0xFFFF <<  0) // (MCI) MMC/SDIO Block Count / SDIO Byte Count
N// -------- MCI_CSTOR : (MCI Offset: 0x1c) MCI Completion Signal Timeout Register -------- 
N#define AT91C_MCI_CSTOCYC     (0xF <<  0) // (MCI) Completion Signal Timeout Cycle Number
N#define AT91C_MCI_CSTOMUL     (0x7 <<  4) // (MCI) Completion Signal Timeout Multiplier
N#define 	AT91C_MCI_CSTOMUL_1                    (0x0 <<  4) // (MCI) CSTOCYC x 1
N#define 	AT91C_MCI_CSTOMUL_16                   (0x1 <<  4) // (MCI) CSTOCYC x  16
N#define 	AT91C_MCI_CSTOMUL_128                  (0x2 <<  4) // (MCI) CSTOCYC x  128
N#define 	AT91C_MCI_CSTOMUL_256                  (0x3 <<  4) // (MCI) CSTOCYC x  256
N#define 	AT91C_MCI_CSTOMUL_1024                 (0x4 <<  4) // (MCI) CSTOCYC x  1024
N#define 	AT91C_MCI_CSTOMUL_4096                 (0x5 <<  4) // (MCI) CSTOCYC x  4096
N#define 	AT91C_MCI_CSTOMUL_65536                (0x6 <<  4) // (MCI) CSTOCYC x  65536
N#define 	AT91C_MCI_CSTOMUL_1048576              (0x7 <<  4) // (MCI) CSTOCYC x  1048576
N// -------- MCI_SR : (MCI Offset: 0x40) MCI Status Register -------- 
N#define AT91C_MCI_CMDRDY      (0x1 <<  0) // (MCI) Command Ready flag
N#define AT91C_MCI_RXRDY       (0x1 <<  1) // (MCI) RX Ready flag
N#define AT91C_MCI_TXRDY       (0x1 <<  2) // (MCI) TX Ready flag
N#define AT91C_MCI_BLKE        (0x1 <<  3) // (MCI) Data Block Transfer Ended flag
N#define AT91C_MCI_DTIP        (0x1 <<  4) // (MCI) Data Transfer in Progress flag
N#define AT91C_MCI_NOTBUSY     (0x1 <<  5) // (MCI) Data Line Not Busy flag
N#define AT91C_MCI_ENDRX       (0x1 <<  6) // (MCI) End of RX Buffer flag
N#define AT91C_MCI_ENDTX       (0x1 <<  7) // (MCI) End of TX Buffer flag
N#define AT91C_MCI_SDIOIRQA    (0x1 <<  8) // (MCI) SDIO Interrupt for Slot A
N#define AT91C_MCI_SDIOIRQB    (0x1 <<  9) // (MCI) SDIO Interrupt for Slot B
N#define AT91C_MCI_SDIOIRQC    (0x1 << 10) // (MCI) SDIO Interrupt for Slot C
N#define AT91C_MCI_SDIOIRQD    (0x1 << 11) // (MCI) SDIO Interrupt for Slot D
N#define AT91C_MCI_SDIOWAIT    (0x1 << 12) // (MCI) SDIO Read Wait operation flag
N#define AT91C_MCI_CSRCV       (0x1 << 13) // (MCI) CE-ATA Completion Signal flag
N#define AT91C_MCI_RXBUFF      (0x1 << 14) // (MCI) RX Buffer Full flag
N#define AT91C_MCI_TXBUFE      (0x1 << 15) // (MCI) TX Buffer Empty flag
N#define AT91C_MCI_RINDE       (0x1 << 16) // (MCI) Response Index Error flag
N#define AT91C_MCI_RDIRE       (0x1 << 17) // (MCI) Response Direction Error flag
N#define AT91C_MCI_RCRCE       (0x1 << 18) // (MCI) Response CRC Error flag
N#define AT91C_MCI_RENDE       (0x1 << 19) // (MCI) Response End Bit Error flag
N#define AT91C_MCI_RTOE        (0x1 << 20) // (MCI) Response Time-out Error flag
N#define AT91C_MCI_DCRCE       (0x1 << 21) // (MCI) data CRC Error flag
N#define AT91C_MCI_DTOE        (0x1 << 22) // (MCI) Data timeout Error flag
N#define AT91C_MCI_CSTOE       (0x1 << 23) // (MCI) Completion Signal timeout Error flag
N#define AT91C_MCI_BLKOVRE     (0x1 << 24) // (MCI) DMA Block Overrun Error flag
N#define AT91C_MCI_DMADONE     (0x1 << 25) // (MCI) DMA Transfer Done flag
N#define AT91C_MCI_FIFOEMPTY   (0x1 << 26) // (MCI) FIFO Empty flag
N#define AT91C_MCI_XFRDONE     (0x1 << 27) // (MCI) Transfer Done flag
N#define AT91C_MCI_OVRE        (0x1 << 30) // (MCI) Overrun flag
N#define AT91C_MCI_UNRE        (0x80000000) // (0x1 << 31) // (MCI) Underrun flag
N// -------- MCI_IER : (MCI Offset: 0x44) MCI Interrupt Enable Register -------- 
N// -------- MCI_IDR : (MCI Offset: 0x48) MCI Interrupt Disable Register -------- 
N// -------- MCI_IMR : (MCI Offset: 0x4c) MCI Interrupt Mask Register -------- 
N// -------- MCI_DMA : (MCI Offset: 0x50) MCI DMA Configuration Register -------- 
N#define AT91C_MCI_OFFSET      (0x3 <<  0) // (MCI) DMA Write Buffer Offset
N#define AT91C_MCI_CHKSIZE     (0x7 <<  4) // (MCI) DMA Channel Read/Write Chunk Size
N#define 	AT91C_MCI_CHKSIZE_1                    (0x0 <<  4) // (MCI) Number of data transferred is 1
N#define 	AT91C_MCI_CHKSIZE_4                    (0x1 <<  4) // (MCI) Number of data transferred is 4
N#define 	AT91C_MCI_CHKSIZE_8                    (0x2 <<  4) // (MCI) Number of data transferred is 8
N#define 	AT91C_MCI_CHKSIZE_16                   (0x3 <<  4) // (MCI) Number of data transferred is 16
N#define 	AT91C_MCI_CHKSIZE_32                   (0x4 <<  4) // (MCI) Number of data transferred is 32
N#define AT91C_MCI_DMAEN       (0x1 <<  8) // (MCI) DMA Hardware Handshaking Enable
N#define 	AT91C_MCI_DMAEN_DISABLE              (0x0 <<  8) // (MCI) DMA interface is disabled
N#define 	AT91C_MCI_DMAEN_ENABLE               (0x1 <<  8) // (MCI) DMA interface is enabled
N// -------- MCI_CFG : (MCI Offset: 0x54) MCI Configuration Register -------- 
N#define AT91C_MCI_FIFOMODE    (0x1 <<  0) // (MCI) MCI Internal FIFO Control Mode
N#define 	AT91C_MCI_FIFOMODE_AMOUNTDATA           (0x0) // (MCI) A write transfer starts when a sufficient amount of datas is written into the FIFO
N#define 	AT91C_MCI_FIFOMODE_ONEDATA              (0x1) // (MCI) A write transfer starts as soon as one data is written into the FIFO
N#define AT91C_MCI_FERRCTRL    (0x1 <<  4) // (MCI) Flow Error Flag Reset Control Mode
N#define 	AT91C_MCI_FERRCTRL_RWCMD                (0x0 <<  4) // (MCI) When an underflow/overflow condition flag is set, a new Write/Read command is needed to reset the flag
N#define 	AT91C_MCI_FERRCTRL_READSR               (0x1 <<  4) // (MCI) When an underflow/overflow condition flag is set, a read status resets the flag
N#define AT91C_MCI_HSMODE      (0x1 <<  8) // (MCI) High Speed Mode
N#define 	AT91C_MCI_HSMODE_DISABLE              (0x0 <<  8) // (MCI) Default Bus Timing Mode
N#define 	AT91C_MCI_HSMODE_ENABLE               (0x1 <<  8) // (MCI) High Speed Mode
N#define AT91C_MCI_LSYNC       (0x1 << 12) // (MCI) Synchronize on last block
N#define 	AT91C_MCI_LSYNC_CURRENT              (0x0 << 12) // (MCI) Pending command sent at end of current data block
N#define 	AT91C_MCI_LSYNC_INFINITE             (0x1 << 12) // (MCI) Pending command sent at end of block transfer when transfer length is not infinite
N// -------- MCI_WPCR : (MCI Offset: 0xe4) Write Protection Control Register -------- 
N#define AT91C_MCI_WP_EN       (0x1 <<  0) // (MCI) Write Protection Enable
N#define 	AT91C_MCI_WP_EN_DISABLE              (0x0) // (MCI) Write Operation is disabled (if WP_KEY corresponds)
N#define 	AT91C_MCI_WP_EN_ENABLE               (0x1) // (MCI) Write Operation is enabled (if WP_KEY corresponds)
N#define AT91C_MCI_WP_KEY      (0xFFFFFF <<  8) // (MCI) Write Protection Key
N// -------- MCI_WPSR : (MCI Offset: 0xe8) Write Protection Status Register -------- 
N#define AT91C_MCI_WP_VS       (0xF <<  0) // (MCI) Write Protection Violation Status
N#define 	AT91C_MCI_WP_VS_NO_VIOLATION         (0x0) // (MCI) No Write Protection Violation detected since last read
N#define 	AT91C_MCI_WP_VS_ON_WRITE             (0x1) // (MCI) Write Protection Violation detected since last read
N#define 	AT91C_MCI_WP_VS_ON_RESET             (0x2) // (MCI) Software Reset Violation detected since last read
N#define 	AT91C_MCI_WP_VS_ON_BOTH              (0x3) // (MCI) Write Protection and Software Reset Violation detected since last read
N#define AT91C_MCI_WP_VSRC     (0xF <<  8) // (MCI) Write Protection Violation Source
N#define 	AT91C_MCI_WP_VSRC_NO_VIOLATION         (0x0 <<  8) // (MCI) No Write Protection Violation detected since last read
N#define 	AT91C_MCI_WP_VSRC_MCI_MR               (0x1 <<  8) // (MCI) Write Protection Violation detected on MCI_MR since last read
N#define 	AT91C_MCI_WP_VSRC_MCI_DTOR             (0x2 <<  8) // (MCI) Write Protection Violation detected on MCI_DTOR since last read
N#define 	AT91C_MCI_WP_VSRC_MCI_SDCR             (0x3 <<  8) // (MCI) Write Protection Violation detected on MCI_SDCR since last read
N#define 	AT91C_MCI_WP_VSRC_MCI_CSTOR            (0x4 <<  8) // (MCI) Write Protection Violation detected on MCI_CSTOR since last read
N#define 	AT91C_MCI_WP_VSRC_MCI_DMA              (0x5 <<  8) // (MCI) Write Protection Violation detected on MCI_DMA since last read
N#define 	AT91C_MCI_WP_VSRC_MCI_CFG              (0x6 <<  8) // (MCI) Write Protection Violation detected on MCI_CFG since last read
N#define 	AT91C_MCI_WP_VSRC_MCI_DEL              (0x7 <<  8) // (MCI) Write Protection Violation detected on MCI_DEL since last read
N// -------- MCI_VER : (MCI Offset: 0xfc)  VERSION  Register -------- 
N#define AT91C_MCI_VER         (0xF <<  0) // (MCI)  VERSION  Register
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Two-wire Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_TWI {
N	AT91_REG	 TWI_CR; 	// Control Register
N	AT91_REG	 TWI_MMR; 	// Master Mode Register
N	AT91_REG	 TWI_SMR; 	// Slave Mode Register
N	AT91_REG	 TWI_IADR; 	// Internal Address Register
N	AT91_REG	 TWI_CWGR; 	// Clock Waveform Generator Register
N	AT91_REG	 Reserved0[3]; 	// 
N	AT91_REG	 TWI_SR; 	// Status Register
N	AT91_REG	 TWI_IER; 	// Interrupt Enable Register
N	AT91_REG	 TWI_IDR; 	// Interrupt Disable Register
N	AT91_REG	 TWI_IMR; 	// Interrupt Mask Register
N	AT91_REG	 TWI_RHR; 	// Receive Holding Register
N	AT91_REG	 TWI_THR; 	// Transmit Holding Register
N	AT91_REG	 Reserved1[45]; 	// 
N	AT91_REG	 TWI_ADDRSIZE; 	// TWI ADDRSIZE REGISTER 
N	AT91_REG	 TWI_IPNAME1; 	// TWI IPNAME1 REGISTER 
N	AT91_REG	 TWI_IPNAME2; 	// TWI IPNAME2 REGISTER 
N	AT91_REG	 TWI_FEATURES; 	// TWI FEATURES REGISTER 
N	AT91_REG	 TWI_VER; 	// Version Register
N	AT91_REG	 TWI_RPR; 	// Receive Pointer Register
N	AT91_REG	 TWI_RCR; 	// Receive Counter Register
N	AT91_REG	 TWI_TPR; 	// Transmit Pointer Register
N	AT91_REG	 TWI_TCR; 	// Transmit Counter Register
N	AT91_REG	 TWI_RNPR; 	// Receive Next Pointer Register
N	AT91_REG	 TWI_RNCR; 	// Receive Next Counter Register
N	AT91_REG	 TWI_TNPR; 	// Transmit Next Pointer Register
N	AT91_REG	 TWI_TNCR; 	// Transmit Next Counter Register
N	AT91_REG	 TWI_PTCR; 	// PDC Transfer Control Register
N	AT91_REG	 TWI_PTSR; 	// PDC Transfer Status Register
N} AT91S_TWI, *AT91PS_TWI;
N#else
S#define TWI_CR          (AT91_CAST(AT91_REG *) 	0x00000000) // (TWI_CR) Control Register
S#define TWI_MMR         (AT91_CAST(AT91_REG *) 	0x00000004) // (TWI_MMR) Master Mode Register
S#define TWI_SMR         (AT91_CAST(AT91_REG *) 	0x00000008) // (TWI_SMR) Slave Mode Register
S#define TWI_IADR        (AT91_CAST(AT91_REG *) 	0x0000000C) // (TWI_IADR) Internal Address Register
S#define TWI_CWGR        (AT91_CAST(AT91_REG *) 	0x00000010) // (TWI_CWGR) Clock Waveform Generator Register
S#define TWI_SR          (AT91_CAST(AT91_REG *) 	0x00000020) // (TWI_SR) Status Register
S#define TWI_IER         (AT91_CAST(AT91_REG *) 	0x00000024) // (TWI_IER) Interrupt Enable Register
S#define TWI_IDR         (AT91_CAST(AT91_REG *) 	0x00000028) // (TWI_IDR) Interrupt Disable Register
S#define TWI_IMR         (AT91_CAST(AT91_REG *) 	0x0000002C) // (TWI_IMR) Interrupt Mask Register
S#define TWI_RHR         (AT91_CAST(AT91_REG *) 	0x00000030) // (TWI_RHR) Receive Holding Register
S#define TWI_THR         (AT91_CAST(AT91_REG *) 	0x00000034) // (TWI_THR) Transmit Holding Register
S#define TWI_ADDRSIZE    (AT91_CAST(AT91_REG *) 	0x000000EC) // (TWI_ADDRSIZE) TWI ADDRSIZE REGISTER 
S#define TWI_IPNAME1     (AT91_CAST(AT91_REG *) 	0x000000F0) // (TWI_IPNAME1) TWI IPNAME1 REGISTER 
S#define TWI_IPNAME2     (AT91_CAST(AT91_REG *) 	0x000000F4) // (TWI_IPNAME2) TWI IPNAME2 REGISTER 
S#define TWI_FEATURES    (AT91_CAST(AT91_REG *) 	0x000000F8) // (TWI_FEATURES) TWI FEATURES REGISTER 
S#define TWI_VER         (AT91_CAST(AT91_REG *) 	0x000000FC) // (TWI_VER) Version Register
S
N#endif
N// -------- TWI_CR : (TWI Offset: 0x0) TWI Control Register -------- 
N#define AT91C_TWI_START       (0x1 <<  0) // (TWI) Send a START Condition
N#define AT91C_TWI_STOP        (0x1 <<  1) // (TWI) Send a STOP Condition
N#define AT91C_TWI_MSEN        (0x1 <<  2) // (TWI) TWI Master Transfer Enabled
N#define AT91C_TWI_MSDIS       (0x1 <<  3) // (TWI) TWI Master Transfer Disabled
N#define AT91C_TWI_SVEN        (0x1 <<  4) // (TWI) TWI Slave mode Enabled
N#define AT91C_TWI_SVDIS       (0x1 <<  5) // (TWI) TWI Slave mode Disabled
N#define AT91C_TWI_SWRST       (0x1 <<  7) // (TWI) Software Reset
N// -------- TWI_MMR : (TWI Offset: 0x4) TWI Master Mode Register -------- 
N#define AT91C_TWI_IADRSZ      (0x3 <<  8) // (TWI) Internal Device Address Size
N#define 	AT91C_TWI_IADRSZ_NO                   (0x0 <<  8) // (TWI) No internal device address
N#define 	AT91C_TWI_IADRSZ_1_BYTE               (0x1 <<  8) // (TWI) One-byte internal device address
N#define 	AT91C_TWI_IADRSZ_2_BYTE               (0x2 <<  8) // (TWI) Two-byte internal device address
N#define 	AT91C_TWI_IADRSZ_3_BYTE               (0x3 <<  8) // (TWI) Three-byte internal device address
N#define AT91C_TWI_MREAD       (0x1 << 12) // (TWI) Master Read Direction
N#define AT91C_TWI_DADR        (0x7F << 16) // (TWI) Device Address
N// -------- TWI_SMR : (TWI Offset: 0x8) TWI Slave Mode Register -------- 
N#define AT91C_TWI_SADR        (0x7F << 16) // (TWI) Slave Address
N// -------- TWI_CWGR : (TWI Offset: 0x10) TWI Clock Waveform Generator Register -------- 
N#define AT91C_TWI_CLDIV       (0xFF <<  0) // (TWI) Clock Low Divider
N#define AT91C_TWI_CHDIV       (0xFF <<  8) // (TWI) Clock High Divider
N#define AT91C_TWI_CKDIV       (0x7 << 16) // (TWI) Clock Divider
N// -------- TWI_SR : (TWI Offset: 0x20) TWI Status Register -------- 
N#define AT91C_TWI_TXCOMP_SLAVE (0x1 <<  0) // (TWI) Transmission Completed
N#define AT91C_TWI_TXCOMP_MASTER (0x1 <<  0) // (TWI) Transmission Completed
N#define AT91C_TWI_RXRDY       (0x1 <<  1) // (TWI) Receive holding register ReaDY
N#define AT91C_TWI_TXRDY_MASTER (0x1 <<  2) // (TWI) Transmit holding register ReaDY
N#define AT91C_TWI_TXRDY_SLAVE (0x1 <<  2) // (TWI) Transmit holding register ReaDY
N#define AT91C_TWI_SVREAD      (0x1 <<  3) // (TWI) Slave READ (used only in Slave mode)
N#define AT91C_TWI_SVACC       (0x1 <<  4) // (TWI) Slave ACCess (used only in Slave mode)
N#define AT91C_TWI_GACC        (0x1 <<  5) // (TWI) General Call ACcess (used only in Slave mode)
N#define AT91C_TWI_OVRE        (0x1 <<  6) // (TWI) Overrun Error (used only in Master and Multi-master mode)
N#define AT91C_TWI_NACK_SLAVE  (0x1 <<  8) // (TWI) Not Acknowledged
N#define AT91C_TWI_NACK_MASTER (0x1 <<  8) // (TWI) Not Acknowledged
N#define AT91C_TWI_ARBLST_MULTI_MASTER (0x1 <<  9) // (TWI) Arbitration Lost (used only in Multimaster mode)
N#define AT91C_TWI_SCLWS       (0x1 << 10) // (TWI) Clock Wait State (used only in Slave mode)
N#define AT91C_TWI_EOSACC      (0x1 << 11) // (TWI) End Of Slave ACCess (used only in Slave mode)
N#define AT91C_TWI_ENDRX       (0x1 << 12) // (TWI) End of Receiver Transfer
N#define AT91C_TWI_ENDTX       (0x1 << 13) // (TWI) End of Receiver Transfer
N#define AT91C_TWI_RXBUFF      (0x1 << 14) // (TWI) RXBUFF Interrupt
N#define AT91C_TWI_TXBUFE      (0x1 << 15) // (TWI) TXBUFE Interrupt
N// -------- TWI_IER : (TWI Offset: 0x24) TWI Interrupt Enable Register -------- 
N// -------- TWI_IDR : (TWI Offset: 0x28) TWI Interrupt Disable Register -------- 
N// -------- TWI_IMR : (TWI Offset: 0x2c) TWI Interrupt Mask Register -------- 
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Usart
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_USART {
N	AT91_REG	 US_CR; 	// Control Register
N	AT91_REG	 US_MR; 	// Mode Register
N	AT91_REG	 US_IER; 	// Interrupt Enable Register
N	AT91_REG	 US_IDR; 	// Interrupt Disable Register
N	AT91_REG	 US_IMR; 	// Interrupt Mask Register
N	AT91_REG	 US_CSR; 	// Channel Status Register
N	AT91_REG	 US_RHR; 	// Receiver Holding Register
N	AT91_REG	 US_THR; 	// Transmitter Holding Register
N	AT91_REG	 US_BRGR; 	// Baud Rate Generator Register
N	AT91_REG	 US_RTOR; 	// Receiver Time-out Register
N	AT91_REG	 US_TTGR; 	// Transmitter Time-guard Register
N	AT91_REG	 Reserved0[5]; 	// 
N	AT91_REG	 US_FIDI; 	// FI_DI_Ratio Register
N	AT91_REG	 US_NER; 	// Nb Errors Register
N	AT91_REG	 Reserved1[1]; 	// 
N	AT91_REG	 US_IF; 	// IRDA_FILTER Register
N	AT91_REG	 US_MAN; 	// Manchester Encoder Decoder Register
N	AT91_REG	 Reserved2[38]; 	// 
N	AT91_REG	 US_ADDRSIZE; 	// US ADDRSIZE REGISTER 
N	AT91_REG	 US_IPNAME1; 	// US IPNAME1 REGISTER 
N	AT91_REG	 US_IPNAME2; 	// US IPNAME2 REGISTER 
N	AT91_REG	 US_FEATURES; 	// US FEATURES REGISTER 
N	AT91_REG	 US_VER; 	// VERSION Register
N	AT91_REG	 US_RPR; 	// Receive Pointer Register
N	AT91_REG	 US_RCR; 	// Receive Counter Register
N	AT91_REG	 US_TPR; 	// Transmit Pointer Register
N	AT91_REG	 US_TCR; 	// Transmit Counter Register
N	AT91_REG	 US_RNPR; 	// Receive Next Pointer Register
N	AT91_REG	 US_RNCR; 	// Receive Next Counter Register
N	AT91_REG	 US_TNPR; 	// Transmit Next Pointer Register
N	AT91_REG	 US_TNCR; 	// Transmit Next Counter Register
N	AT91_REG	 US_PTCR; 	// PDC Transfer Control Register
N	AT91_REG	 US_PTSR; 	// PDC Transfer Status Register
N} AT91S_USART, *AT91PS_USART;
N#else
S#define US_CR           (AT91_CAST(AT91_REG *) 	0x00000000) // (US_CR) Control Register
S#define US_MR           (AT91_CAST(AT91_REG *) 	0x00000004) // (US_MR) Mode Register
S#define US_IER          (AT91_CAST(AT91_REG *) 	0x00000008) // (US_IER) Interrupt Enable Register
S#define US_IDR          (AT91_CAST(AT91_REG *) 	0x0000000C) // (US_IDR) Interrupt Disable Register
S#define US_IMR          (AT91_CAST(AT91_REG *) 	0x00000010) // (US_IMR) Interrupt Mask Register
S#define US_CSR          (AT91_CAST(AT91_REG *) 	0x00000014) // (US_CSR) Channel Status Register
S#define US_RHR          (AT91_CAST(AT91_REG *) 	0x00000018) // (US_RHR) Receiver Holding Register
S#define US_THR          (AT91_CAST(AT91_REG *) 	0x0000001C) // (US_THR) Transmitter Holding Register
S#define US_BRGR         (AT91_CAST(AT91_REG *) 	0x00000020) // (US_BRGR) Baud Rate Generator Register
S#define US_RTOR         (AT91_CAST(AT91_REG *) 	0x00000024) // (US_RTOR) Receiver Time-out Register
S#define US_TTGR         (AT91_CAST(AT91_REG *) 	0x00000028) // (US_TTGR) Transmitter Time-guard Register
S#define US_FIDI         (AT91_CAST(AT91_REG *) 	0x00000040) // (US_FIDI) FI_DI_Ratio Register
S#define US_NER          (AT91_CAST(AT91_REG *) 	0x00000044) // (US_NER) Nb Errors Register
S#define US_IF           (AT91_CAST(AT91_REG *) 	0x0000004C) // (US_IF) IRDA_FILTER Register
S#define US_MAN          (AT91_CAST(AT91_REG *) 	0x00000050) // (US_MAN) Manchester Encoder Decoder Register
S#define US_ADDRSIZE     (AT91_CAST(AT91_REG *) 	0x000000EC) // (US_ADDRSIZE) US ADDRSIZE REGISTER 
S#define US_IPNAME1      (AT91_CAST(AT91_REG *) 	0x000000F0) // (US_IPNAME1) US IPNAME1 REGISTER 
S#define US_IPNAME2      (AT91_CAST(AT91_REG *) 	0x000000F4) // (US_IPNAME2) US IPNAME2 REGISTER 
S#define US_FEATURES     (AT91_CAST(AT91_REG *) 	0x000000F8) // (US_FEATURES) US FEATURES REGISTER 
S#define US_VER          (AT91_CAST(AT91_REG *) 	0x000000FC) // (US_VER) VERSION Register
S
N#endif
N// -------- US_CR : (USART Offset: 0x0)  Control Register -------- 
N#define AT91C_US_RSTRX        (0x1 <<  2) // (USART) Reset Receiver
N#define AT91C_US_RSTTX        (0x1 <<  3) // (USART) Reset Transmitter
N#define AT91C_US_RXEN         (0x1 <<  4) // (USART) Receiver Enable
N#define AT91C_US_RXDIS        (0x1 <<  5) // (USART) Receiver Disable
N#define AT91C_US_TXEN         (0x1 <<  6) // (USART) Transmitter Enable
N#define AT91C_US_TXDIS        (0x1 <<  7) // (USART) Transmitter Disable
N#define AT91C_US_RSTSTA       (0x1 <<  8) // (USART) Reset Status Bits
N#define AT91C_US_STTBRK       (0x1 <<  9) // (USART) Start Break
N#define AT91C_US_STPBRK       (0x1 << 10) // (USART) Stop Break
N#define AT91C_US_STTTO        (0x1 << 11) // (USART) Start Time-out
N#define AT91C_US_SENDA        (0x1 << 12) // (USART) Send Address
N#define AT91C_US_RSTIT        (0x1 << 13) // (USART) Reset Iterations
N#define AT91C_US_RSTNACK      (0x1 << 14) // (USART) Reset Non Acknowledge
N#define AT91C_US_RETTO        (0x1 << 15) // (USART) Rearm Time-out
N#define AT91C_US_DTREN        (0x1 << 16) // (USART) Data Terminal ready Enable
N#define AT91C_US_DTRDIS       (0x1 << 17) // (USART) Data Terminal ready Disable
N#define AT91C_US_RTSEN        (0x1 << 18) // (USART) Request to Send enable
N#define AT91C_US_RTSDIS       (0x1 << 19) // (USART) Request to Send Disable
N// -------- US_MR : (USART Offset: 0x4)  Mode Register -------- 
N#define AT91C_US_USMODE       (0xF <<  0) // (USART) Usart mode
N#define 	AT91C_US_USMODE_NORMAL               (0x0) // (USART) Normal
N#define 	AT91C_US_USMODE_RS485                (0x1) // (USART) RS485
N#define 	AT91C_US_USMODE_HWHSH                (0x2) // (USART) Hardware Handshaking
N#define 	AT91C_US_USMODE_ISO7816_0            (0x4) // (USART) ISO7816 protocol: T = 0
N#define 	AT91C_US_USMODE_ISO7816_1            (0x6) // (USART) ISO7816 protocol: T = 1
N#define 	AT91C_US_USMODE_IRDA                 (0x8) // (USART) IrDA
N#define 	AT91C_US_USMODE_SPI_MASTER           (0xE) // (USART) SPI Master
N#define 	AT91C_US_USMODE_SPI_SLAVE            (0xF) // (USART) SPI Slave
N#define AT91C_US_CLKS         (0x3 <<  4) // (USART) Clock Selection (Baud Rate generator Input Clock
N#define 	AT91C_US_CLKS_CLOCK                (0x0 <<  4) // (USART) Clock
N#define 	AT91C_US_CLKS_FDIV1                (0x1 <<  4) // (USART) fdiv1
N#define 	AT91C_US_CLKS_SLOW                 (0x2 <<  4) // (USART) slow_clock (ARM)
N#define 	AT91C_US_CLKS_EXT                  (0x3 <<  4) // (USART) External (SCK)
N#define AT91C_US_CHRL         (0x3 <<  6) // (USART) Clock Selection (Baud Rate generator Input Clock
N#define 	AT91C_US_CHRL_5_BITS               (0x0 <<  6) // (USART) Character Length: 5 bits
N#define 	AT91C_US_CHRL_6_BITS               (0x1 <<  6) // (USART) Character Length: 6 bits
N#define 	AT91C_US_CHRL_7_BITS               (0x2 <<  6) // (USART) Character Length: 7 bits
N#define 	AT91C_US_CHRL_8_BITS               (0x3 <<  6) // (USART) Character Length: 8 bits
N#define AT91C_US_SYNC         (0x1 <<  8) // (USART) Synchronous Mode Select
N#define AT91C_US_PAR          (0x7 <<  9) // (USART) Parity type
N#define 	AT91C_US_PAR_EVEN                 (0x0 <<  9) // (USART) Even Parity
N#define 	AT91C_US_PAR_ODD                  (0x1 <<  9) // (USART) Odd Parity
N#define 	AT91C_US_PAR_SPACE                (0x2 <<  9) // (USART) Parity forced to 0 (Space)
N#define 	AT91C_US_PAR_MARK                 (0x3 <<  9) // (USART) Parity forced to 1 (Mark)
N#define 	AT91C_US_PAR_NONE                 (0x4 <<  9) // (USART) No Parity
N#define 	AT91C_US_PAR_MULTI_DROP           (0x6 <<  9) // (USART) Multi-drop mode
N#define AT91C_US_NBSTOP       (0x3 << 12) // (USART) Number of Stop bits
N#define 	AT91C_US_NBSTOP_1_BIT                (0x0 << 12) // (USART) 1 stop bit
N#define 	AT91C_US_NBSTOP_15_BIT               (0x1 << 12) // (USART) Asynchronous (SYNC=0) 2 stop bits Synchronous (SYNC=1) 2 stop bits
N#define 	AT91C_US_NBSTOP_2_BIT                (0x2 << 12) // (USART) 2 stop bits
N#define AT91C_US_CHMODE       (0x3 << 14) // (USART) Channel Mode
N#define 	AT91C_US_CHMODE_NORMAL               (0x0 << 14) // (USART) Normal Mode: The USART channel operates as an RX/TX USART.
N#define 	AT91C_US_CHMODE_AUTO                 (0x1 << 14) // (USART) Automatic Echo: Receiver Data Input is connected to the TXD pin.
N#define 	AT91C_US_CHMODE_LOCAL                (0x2 << 14) // (USART) Local Loopback: Transmitter Output Signal is connected to Receiver Input Signal.
N#define 	AT91C_US_CHMODE_REMOTE               (0x3 << 14) // (USART) Remote Loopback: RXD pin is internally connected to TXD pin.
N#define AT91C_US_MSBF         (0x1 << 16) // (USART) Bit Order
N#define AT91C_US_MODE9        (0x1 << 17) // (USART) 9-bit Character length
N#define AT91C_US_CKLO         (0x1 << 18) // (USART) Clock Output Select
N#define AT91C_US_OVER         (0x1 << 19) // (USART) Over Sampling Mode
N#define AT91C_US_INACK        (0x1 << 20) // (USART) Inhibit Non Acknowledge
N#define AT91C_US_DSNACK       (0x1 << 21) // (USART) Disable Successive NACK
N#define AT91C_US_VAR_SYNC     (0x1 << 22) // (USART) Variable synchronization of command/data sync Start Frame Delimiter
N#define AT91C_US_MAX_ITER     (0x1 << 24) // (USART) Number of Repetitions
N#define AT91C_US_FILTER       (0x1 << 28) // (USART) Receive Line Filter
N#define AT91C_US_MANMODE      (0x1 << 29) // (USART) Manchester Encoder/Decoder Enable
N#define AT91C_US_MODSYNC      (0x1 << 30) // (USART) Manchester Synchronization mode
N#define AT91C_US_ONEBIT       (0x1 << 31) // (USART) Start Frame Delimiter selector
N// -------- US_IER : (USART Offset: 0x8)  Interrupt Enable Register -------- 
N#define AT91C_US_RXRDY        (0x1 <<  0) // (USART) RXRDY Interrupt
N#define AT91C_US_TXRDY        (0x1 <<  1) // (USART) TXRDY Interrupt
N#define AT91C_US_RXBRK        (0x1 <<  2) // (USART) Break Received/End of Break
N#define AT91C_US_ENDRX        (0x1 <<  3) // (USART) End of Receive Transfer Interrupt
N#define AT91C_US_ENDTX        (0x1 <<  4) // (USART) End of Transmit Interrupt
N#define AT91C_US_OVRE         (0x1 <<  5) // (USART) Overrun Interrupt
N#define AT91C_US_FRAME        (0x1 <<  6) // (USART) Framing Error Interrupt
N#define AT91C_US_PARE         (0x1 <<  7) // (USART) Parity Error Interrupt
N#define AT91C_US_TIMEOUT      (0x1 <<  8) // (USART) Receiver Time-out
N#define AT91C_US_TXEMPTY      (0x1 <<  9) // (USART) TXEMPTY Interrupt
N#define AT91C_US_ITERATION    (0x1 << 10) // (USART) Max number of Repetitions Reached
N#define AT91C_US_TXBUFE       (0x1 << 11) // (USART) TXBUFE Interrupt
N#define AT91C_US_RXBUFF       (0x1 << 12) // (USART) RXBUFF Interrupt
N#define AT91C_US_NACK         (0x1 << 13) // (USART) Non Acknowledge
N#define AT91C_US_RIIC         (0x1 << 16) // (USART) Ring INdicator Input Change Flag
N#define AT91C_US_DSRIC        (0x1 << 17) // (USART) Data Set Ready Input Change Flag
N#define AT91C_US_DCDIC        (0x1 << 18) // (USART) Data Carrier Flag
N#define AT91C_US_CTSIC        (0x1 << 19) // (USART) Clear To Send Input Change Flag
N#define AT91C_US_MANE         (0x1 << 20) // (USART) Manchester Error Interrupt
N// -------- US_IDR : (USART Offset: 0xc)  Interrupt Disable Register -------- 
N// -------- US_IMR : (USART Offset: 0x10)  Interrupt Mask Register -------- 
N// -------- US_CSR : (USART Offset: 0x14)  Channel Status Register -------- 
N#define AT91C_US_RI           (0x1 << 20) // (USART) Image of RI Input
N#define AT91C_US_DSR          (0x1 << 21) // (USART) Image of DSR Input
N#define AT91C_US_DCD          (0x1 << 22) // (USART) Image of DCD Input
N#define AT91C_US_CTS          (0x1 << 23) // (USART) Image of CTS Input
N#define AT91C_US_MANERR       (0x1 << 24) // (USART) Manchester Error
N// -------- US_MAN : (USART Offset: 0x50) Manchester Encoder Decoder Register -------- 
N#define AT91C_US_TX_PL        (0xF <<  0) // (USART) Transmitter Preamble Length
N#define AT91C_US_TX_PP        (0x3 <<  8) // (USART) Transmitter Preamble Pattern
N#define 	AT91C_US_TX_PP_ALL_ONE              (0x0 <<  8) // (USART) ALL_ONE
N#define 	AT91C_US_TX_PP_ALL_ZERO             (0x1 <<  8) // (USART) ALL_ZERO
N#define 	AT91C_US_TX_PP_ZERO_ONE             (0x2 <<  8) // (USART) ZERO_ONE
N#define 	AT91C_US_TX_PP_ONE_ZERO             (0x3 <<  8) // (USART) ONE_ZERO
N#define AT91C_US_TX_MPOL      (0x1 << 12) // (USART) Transmitter Manchester Polarity
N#define AT91C_US_RX_PL        (0xF << 16) // (USART) Receiver Preamble Length
N#define AT91C_US_RX_PP        (0x3 << 24) // (USART) Receiver Preamble Pattern detected
N#define 	AT91C_US_RX_PP_ALL_ONE              (0x0 << 24) // (USART) ALL_ONE
N#define 	AT91C_US_RX_PP_ALL_ZERO             (0x1 << 24) // (USART) ALL_ZERO
N#define 	AT91C_US_RX_PP_ZERO_ONE             (0x2 << 24) // (USART) ZERO_ONE
N#define 	AT91C_US_RX_PP_ONE_ZERO             (0x3 << 24) // (USART) ONE_ZERO
N#define AT91C_US_RX_MPOL      (0x1 << 28) // (USART) Receiver Manchester Polarity
N#define AT91C_US_DRIFT        (0x1 << 30) // (USART) Drift compensation
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Synchronous Serial Controller Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_SSC {
N	AT91_REG	 SSC_CR; 	// Control Register
N	AT91_REG	 SSC_CMR; 	// Clock Mode Register
N	AT91_REG	 Reserved0[2]; 	// 
N	AT91_REG	 SSC_RCMR; 	// Receive Clock ModeRegister
N	AT91_REG	 SSC_RFMR; 	// Receive Frame Mode Register
N	AT91_REG	 SSC_TCMR; 	// Transmit Clock Mode Register
N	AT91_REG	 SSC_TFMR; 	// Transmit Frame Mode Register
N	AT91_REG	 SSC_RHR; 	// Receive Holding Register
N	AT91_REG	 SSC_THR; 	// Transmit Holding Register
N	AT91_REG	 Reserved1[2]; 	// 
N	AT91_REG	 SSC_RSHR; 	// Receive Sync Holding Register
N	AT91_REG	 SSC_TSHR; 	// Transmit Sync Holding Register
N	AT91_REG	 Reserved2[2]; 	// 
N	AT91_REG	 SSC_SR; 	// Status Register
N	AT91_REG	 SSC_IER; 	// Interrupt Enable Register
N	AT91_REG	 SSC_IDR; 	// Interrupt Disable Register
N	AT91_REG	 SSC_IMR; 	// Interrupt Mask Register
N	AT91_REG	 Reserved3[39]; 	// 
N	AT91_REG	 SSC_ADDRSIZE; 	// SSC ADDRSIZE REGISTER 
N	AT91_REG	 SSC_IPNAME1; 	// SSC IPNAME1 REGISTER 
N	AT91_REG	 SSC_IPNAME2; 	// SSC IPNAME2 REGISTER 
N	AT91_REG	 SSC_FEATURES; 	// SSC FEATURES REGISTER 
N	AT91_REG	 SSC_VER; 	// Version Register
N	AT91_REG	 SSC_RPR; 	// Receive Pointer Register
N	AT91_REG	 SSC_RCR; 	// Receive Counter Register
N	AT91_REG	 SSC_TPR; 	// Transmit Pointer Register
N	AT91_REG	 SSC_TCR; 	// Transmit Counter Register
N	AT91_REG	 SSC_RNPR; 	// Receive Next Pointer Register
N	AT91_REG	 SSC_RNCR; 	// Receive Next Counter Register
N	AT91_REG	 SSC_TNPR; 	// Transmit Next Pointer Register
N	AT91_REG	 SSC_TNCR; 	// Transmit Next Counter Register
N	AT91_REG	 SSC_PTCR; 	// PDC Transfer Control Register
N	AT91_REG	 SSC_PTSR; 	// PDC Transfer Status Register
N} AT91S_SSC, *AT91PS_SSC;
N#else
S#define SSC_CR          (AT91_CAST(AT91_REG *) 	0x00000000) // (SSC_CR) Control Register
S#define SSC_CMR         (AT91_CAST(AT91_REG *) 	0x00000004) // (SSC_CMR) Clock Mode Register
S#define SSC_RCMR        (AT91_CAST(AT91_REG *) 	0x00000010) // (SSC_RCMR) Receive Clock ModeRegister
S#define SSC_RFMR        (AT91_CAST(AT91_REG *) 	0x00000014) // (SSC_RFMR) Receive Frame Mode Register
S#define SSC_TCMR        (AT91_CAST(AT91_REG *) 	0x00000018) // (SSC_TCMR) Transmit Clock Mode Register
S#define SSC_TFMR        (AT91_CAST(AT91_REG *) 	0x0000001C) // (SSC_TFMR) Transmit Frame Mode Register
S#define SSC_RHR         (AT91_CAST(AT91_REG *) 	0x00000020) // (SSC_RHR) Receive Holding Register
S#define SSC_THR         (AT91_CAST(AT91_REG *) 	0x00000024) // (SSC_THR) Transmit Holding Register
S#define SSC_RSHR        (AT91_CAST(AT91_REG *) 	0x00000030) // (SSC_RSHR) Receive Sync Holding Register
S#define SSC_TSHR        (AT91_CAST(AT91_REG *) 	0x00000034) // (SSC_TSHR) Transmit Sync Holding Register
S#define SSC_SR          (AT91_CAST(AT91_REG *) 	0x00000040) // (SSC_SR) Status Register
S#define SSC_IER         (AT91_CAST(AT91_REG *) 	0x00000044) // (SSC_IER) Interrupt Enable Register
S#define SSC_IDR         (AT91_CAST(AT91_REG *) 	0x00000048) // (SSC_IDR) Interrupt Disable Register
S#define SSC_IMR         (AT91_CAST(AT91_REG *) 	0x0000004C) // (SSC_IMR) Interrupt Mask Register
S#define SSC_ADDRSIZE    (AT91_CAST(AT91_REG *) 	0x000000EC) // (SSC_ADDRSIZE) SSC ADDRSIZE REGISTER 
S#define SSC_IPNAME1     (AT91_CAST(AT91_REG *) 	0x000000F0) // (SSC_IPNAME1) SSC IPNAME1 REGISTER 
S#define SSC_IPNAME2     (AT91_CAST(AT91_REG *) 	0x000000F4) // (SSC_IPNAME2) SSC IPNAME2 REGISTER 
S#define SSC_FEATURES    (AT91_CAST(AT91_REG *) 	0x000000F8) // (SSC_FEATURES) SSC FEATURES REGISTER 
S#define SSC_VER         (AT91_CAST(AT91_REG *) 	0x000000FC) // (SSC_VER) Version Register
S
N#endif
N// -------- SSC_CR : (SSC Offset: 0x0) SSC Control Register -------- 
N#define AT91C_SSC_RXEN        (0x1 <<  0) // (SSC) Receive Enable
N#define AT91C_SSC_RXDIS       (0x1 <<  1) // (SSC) Receive Disable
N#define AT91C_SSC_TXEN        (0x1 <<  8) // (SSC) Transmit Enable
N#define AT91C_SSC_TXDIS       (0x1 <<  9) // (SSC) Transmit Disable
N#define AT91C_SSC_SWRST       (0x1 << 15) // (SSC) Software Reset
N// -------- SSC_RCMR : (SSC Offset: 0x10) SSC Receive Clock Mode Register -------- 
N#define AT91C_SSC_CKS         (0x3 <<  0) // (SSC) Receive/Transmit Clock Selection
N#define 	AT91C_SSC_CKS_DIV                  (0x0) // (SSC) Divided Clock
N#define 	AT91C_SSC_CKS_TK                   (0x1) // (SSC) TK Clock signal
N#define 	AT91C_SSC_CKS_RK                   (0x2) // (SSC) RK pin
N#define AT91C_SSC_CKO         (0x7 <<  2) // (SSC) Receive/Transmit Clock Output Mode Selection
N#define 	AT91C_SSC_CKO_NONE                 (0x0 <<  2) // (SSC) Receive/Transmit Clock Output Mode: None RK pin: Input-only
N#define 	AT91C_SSC_CKO_CONTINOUS            (0x1 <<  2) // (SSC) Continuous Receive/Transmit Clock RK pin: Output
N#define 	AT91C_SSC_CKO_DATA_TX              (0x2 <<  2) // (SSC) Receive/Transmit Clock only during data transfers RK pin: Output
N#define AT91C_SSC_CKI         (0x1 <<  5) // (SSC) Receive/Transmit Clock Inversion
N#define AT91C_SSC_CKG         (0x3 <<  6) // (SSC) Receive/Transmit Clock Gating Selection
N#define 	AT91C_SSC_CKG_NONE                 (0x0 <<  6) // (SSC) Receive/Transmit Clock Gating: None, continuous clock
N#define 	AT91C_SSC_CKG_LOW                  (0x1 <<  6) // (SSC) Receive/Transmit Clock enabled only if RF Low
N#define 	AT91C_SSC_CKG_HIGH                 (0x2 <<  6) // (SSC) Receive/Transmit Clock enabled only if RF High
N#define AT91C_SSC_START       (0xF <<  8) // (SSC) Receive/Transmit Start Selection
N#define 	AT91C_SSC_START_CONTINOUS            (0x0 <<  8) // (SSC) Continuous, as soon as the receiver is enabled, and immediately after the end of transfer of the previous data.
N#define 	AT91C_SSC_START_TX                   (0x1 <<  8) // (SSC) Transmit/Receive start
N#define 	AT91C_SSC_START_LOW_RF               (0x2 <<  8) // (SSC) Detection of a low level on RF input
N#define 	AT91C_SSC_START_HIGH_RF              (0x3 <<  8) // (SSC) Detection of a high level on RF input
N#define 	AT91C_SSC_START_FALL_RF              (0x4 <<  8) // (SSC) Detection of a falling edge on RF input
N#define 	AT91C_SSC_START_RISE_RF              (0x5 <<  8) // (SSC) Detection of a rising edge on RF input
N#define 	AT91C_SSC_START_LEVEL_RF             (0x6 <<  8) // (SSC) Detection of any level change on RF input
N#define 	AT91C_SSC_START_EDGE_RF              (0x7 <<  8) // (SSC) Detection of any edge on RF input
N#define 	AT91C_SSC_START_0                    (0x8 <<  8) // (SSC) Compare 0
N#define AT91C_SSC_STOP        (0x1 << 12) // (SSC) Receive Stop Selection
N#define AT91C_SSC_STTDLY      (0xFF << 16) // (SSC) Receive/Transmit Start Delay
N#define AT91C_SSC_PERIOD      (0xFF << 24) // (SSC) Receive/Transmit Period Divider Selection
N// -------- SSC_RFMR : (SSC Offset: 0x14) SSC Receive Frame Mode Register -------- 
N#define AT91C_SSC_DATLEN      (0x1F <<  0) // (SSC) Data Length
N#define AT91C_SSC_LOOP        (0x1 <<  5) // (SSC) Loop Mode
N#define AT91C_SSC_MSBF        (0x1 <<  7) // (SSC) Most Significant Bit First
N#define AT91C_SSC_DATNB       (0xF <<  8) // (SSC) Data Number per Frame
N#define AT91C_SSC_FSLEN       (0xF << 16) // (SSC) Receive/Transmit Frame Sync length
N#define AT91C_SSC_FSOS        (0x7 << 20) // (SSC) Receive/Transmit Frame Sync Output Selection
N#define 	AT91C_SSC_FSOS_NONE                 (0x0 << 20) // (SSC) Selected Receive/Transmit Frame Sync Signal: None RK pin Input-only
N#define 	AT91C_SSC_FSOS_NEGATIVE             (0x1 << 20) // (SSC) Selected Receive/Transmit Frame Sync Signal: Negative Pulse
N#define 	AT91C_SSC_FSOS_POSITIVE             (0x2 << 20) // (SSC) Selected Receive/Transmit Frame Sync Signal: Positive Pulse
N#define 	AT91C_SSC_FSOS_LOW                  (0x3 << 20) // (SSC) Selected Receive/Transmit Frame Sync Signal: Driver Low during data transfer
N#define 	AT91C_SSC_FSOS_HIGH                 (0x4 << 20) // (SSC) Selected Receive/Transmit Frame Sync Signal: Driver High during data transfer
N#define 	AT91C_SSC_FSOS_TOGGLE               (0x5 << 20) // (SSC) Selected Receive/Transmit Frame Sync Signal: Toggling at each start of data transfer
N#define AT91C_SSC_FSEDGE      (0x1 << 24) // (SSC) Frame Sync Edge Detection
N// -------- SSC_TCMR : (SSC Offset: 0x18) SSC Transmit Clock Mode Register -------- 
N// -------- SSC_TFMR : (SSC Offset: 0x1c) SSC Transmit Frame Mode Register -------- 
N#define AT91C_SSC_DATDEF      (0x1 <<  5) // (SSC) Data Default Value
N#define AT91C_SSC_FSDEN       (0x1 << 23) // (SSC) Frame Sync Data Enable
N// -------- SSC_SR : (SSC Offset: 0x40) SSC Status Register -------- 
N#define AT91C_SSC_TXRDY       (0x1 <<  0) // (SSC) Transmit Ready
N#define AT91C_SSC_TXEMPTY     (0x1 <<  1) // (SSC) Transmit Empty
N#define AT91C_SSC_ENDTX       (0x1 <<  2) // (SSC) End Of Transmission
N#define AT91C_SSC_TXBUFE      (0x1 <<  3) // (SSC) Transmit Buffer Empty
N#define AT91C_SSC_RXRDY       (0x1 <<  4) // (SSC) Receive Ready
N#define AT91C_SSC_OVRUN       (0x1 <<  5) // (SSC) Receive Overrun
N#define AT91C_SSC_ENDRX       (0x1 <<  6) // (SSC) End of Reception
N#define AT91C_SSC_RXBUFF      (0x1 <<  7) // (SSC) Receive Buffer Full
N#define AT91C_SSC_CP0         (0x1 <<  8) // (SSC) Compare 0
N#define AT91C_SSC_CP1         (0x1 <<  9) // (SSC) Compare 1
N#define AT91C_SSC_TXSYN       (0x1 << 10) // (SSC) Transmit Sync
N#define AT91C_SSC_RXSYN       (0x1 << 11) // (SSC) Receive Sync
N#define AT91C_SSC_TXENA       (0x1 << 16) // (SSC) Transmit Enable
N#define AT91C_SSC_RXENA       (0x1 << 17) // (SSC) Receive Enable
N// -------- SSC_IER : (SSC Offset: 0x44) SSC Interrupt Enable Register -------- 
N// -------- SSC_IDR : (SSC Offset: 0x48) SSC Interrupt Disable Register -------- 
N// -------- SSC_IMR : (SSC Offset: 0x4c) SSC Interrupt Mask Register -------- 
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR PWMC Channel Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_PWMC_CH {
N	AT91_REG	 PWMC_CMR; 	// Channel Mode Register
N	AT91_REG	 PWMC_CDTYR; 	// Channel Duty Cycle Register
N	AT91_REG	 PWMC_CPRDR; 	// Channel Period Register
N	AT91_REG	 PWMC_CCNTR; 	// Channel Counter Register
N	AT91_REG	 PWMC_CUPDR; 	// Channel Update Register
N	AT91_REG	 PWMC_Reserved[3]; 	// Reserved
N} AT91S_PWMC_CH, *AT91PS_PWMC_CH;
N#else
S#define PWMC_CMR        (AT91_CAST(AT91_REG *) 	0x00000000) // (PWMC_CMR) Channel Mode Register
S#define PWMC_CDTYR      (AT91_CAST(AT91_REG *) 	0x00000004) // (PWMC_CDTYR) Channel Duty Cycle Register
S#define PWMC_CPRDR      (AT91_CAST(AT91_REG *) 	0x00000008) // (PWMC_CPRDR) Channel Period Register
S#define PWMC_CCNTR      (AT91_CAST(AT91_REG *) 	0x0000000C) // (PWMC_CCNTR) Channel Counter Register
S#define PWMC_CUPDR      (AT91_CAST(AT91_REG *) 	0x00000010) // (PWMC_CUPDR) Channel Update Register
S#define Reserved        (AT91_CAST(AT91_REG *) 	0x00000014) // (Reserved) Reserved
S
N#endif
N// -------- PWMC_CMR : (PWMC_CH Offset: 0x0) PWMC Channel Mode Register -------- 
N#define AT91C_PWMC_CPRE       (0xF <<  0) // (PWMC_CH) Channel Pre-scaler : PWMC_CLKx
N#define 	AT91C_PWMC_CPRE_MCK                  (0x0) // (PWMC_CH) 
N#define 	AT91C_PWMC_CPRE_MCKA                 (0xB) // (PWMC_CH) 
N#define 	AT91C_PWMC_CPRE_MCKB                 (0xC) // (PWMC_CH) 
N#define AT91C_PWMC_CALG       (0x1 <<  8) // (PWMC_CH) Channel Alignment
N#define AT91C_PWMC_CPOL       (0x1 <<  9) // (PWMC_CH) Channel Polarity
N#define AT91C_PWMC_CPD        (0x1 << 10) // (PWMC_CH) Channel Update Period
N// -------- PWMC_CDTYR : (PWMC_CH Offset: 0x4) PWMC Channel Duty Cycle Register -------- 
N#define AT91C_PWMC_CDTY       (0x0 <<  0) // (PWMC_CH) Channel Duty Cycle
N// -------- PWMC_CPRDR : (PWMC_CH Offset: 0x8) PWMC Channel Period Register -------- 
N#define AT91C_PWMC_CPRD       (0x0 <<  0) // (PWMC_CH) Channel Period
N// -------- PWMC_CCNTR : (PWMC_CH Offset: 0xc) PWMC Channel Counter Register -------- 
N#define AT91C_PWMC_CCNT       (0x0 <<  0) // (PWMC_CH) Channel Counter
N// -------- PWMC_CUPDR : (PWMC_CH Offset: 0x10) PWMC Channel Update Register -------- 
N#define AT91C_PWMC_CUPD       (0x0 <<  0) // (PWMC_CH) Channel Update
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Pulse Width Modulation Controller Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_PWMC {
N	AT91_REG	 PWMC_MR; 	// PWMC Mode Register
N	AT91_REG	 PWMC_ENA; 	// PWMC Enable Register
N	AT91_REG	 PWMC_DIS; 	// PWMC Disable Register
N	AT91_REG	 PWMC_SR; 	// PWMC Status Register
N	AT91_REG	 PWMC_IER; 	// PWMC Interrupt Enable Register
N	AT91_REG	 PWMC_IDR; 	// PWMC Interrupt Disable Register
N	AT91_REG	 PWMC_IMR; 	// PWMC Interrupt Mask Register
N	AT91_REG	 PWMC_ISR; 	// PWMC Interrupt Status Register
N	AT91_REG	 Reserved0[55]; 	// 
N	AT91_REG	 PWMC_VR; 	// PWMC Version Register
N	AT91_REG	 Reserved1[64]; 	// 
N	AT91S_PWMC_CH	 PWMC_CH[32]; 	// PWMC Channel
N} AT91S_PWMC, *AT91PS_PWMC;
N#else
S#define PWMC_MR         (AT91_CAST(AT91_REG *) 	0x00000000) // (PWMC_MR) PWMC Mode Register
S#define PWMC_ENA        (AT91_CAST(AT91_REG *) 	0x00000004) // (PWMC_ENA) PWMC Enable Register
S#define PWMC_DIS        (AT91_CAST(AT91_REG *) 	0x00000008) // (PWMC_DIS) PWMC Disable Register
S#define PWMC_SR         (AT91_CAST(AT91_REG *) 	0x0000000C) // (PWMC_SR) PWMC Status Register
S#define PWMC_IER        (AT91_CAST(AT91_REG *) 	0x00000010) // (PWMC_IER) PWMC Interrupt Enable Register
S#define PWMC_IDR        (AT91_CAST(AT91_REG *) 	0x00000014) // (PWMC_IDR) PWMC Interrupt Disable Register
S#define PWMC_IMR        (AT91_CAST(AT91_REG *) 	0x00000018) // (PWMC_IMR) PWMC Interrupt Mask Register
S#define PWMC_ISR        (AT91_CAST(AT91_REG *) 	0x0000001C) // (PWMC_ISR) PWMC Interrupt Status Register
S#define PWMC_VR         (AT91_CAST(AT91_REG *) 	0x000000FC) // (PWMC_VR) PWMC Version Register
S
N#endif
N// -------- PWMC_MR : (PWMC Offset: 0x0) PWMC Mode Register -------- 
N#define AT91C_PWMC_DIVA       (0xFF <<  0) // (PWMC) CLKA divide factor.
N#define AT91C_PWMC_PREA       (0xF <<  8) // (PWMC) Divider Input Clock Prescaler A
N#define 	AT91C_PWMC_PREA_MCK                  (0x0 <<  8) // (PWMC) 
N#define AT91C_PWMC_DIVB       (0xFF << 16) // (PWMC) CLKB divide factor.
N#define AT91C_PWMC_PREB       (0xF << 24) // (PWMC) Divider Input Clock Prescaler B
N#define 	AT91C_PWMC_PREB_MCK                  (0x0 << 24) // (PWMC) 
N// -------- PWMC_ENA : (PWMC Offset: 0x4) PWMC Enable Register -------- 
N#define AT91C_PWMC_CHID0      (0x1 <<  0) // (PWMC) Channel ID 0
N#define AT91C_PWMC_CHID1      (0x1 <<  1) // (PWMC) Channel ID 1
N#define AT91C_PWMC_CHID2      (0x1 <<  2) // (PWMC) Channel ID 2
N#define AT91C_PWMC_CHID3      (0x1 <<  3) // (PWMC) Channel ID 3
N#define AT91C_PWMC_CHID4      (0x1 <<  4) // (PWMC) Channel ID 4
N#define AT91C_PWMC_CHID5      (0x1 <<  5) // (PWMC) Channel ID 5
N#define AT91C_PWMC_CHID6      (0x1 <<  6) // (PWMC) Channel ID 6
N#define AT91C_PWMC_CHID7      (0x1 <<  7) // (PWMC) Channel ID 7
N// -------- PWMC_DIS : (PWMC Offset: 0x8) PWMC Disable Register -------- 
N// -------- PWMC_SR : (PWMC Offset: 0xc) PWMC Status Register -------- 
N// -------- PWMC_IER : (PWMC Offset: 0x10) PWMC Interrupt Enable Register -------- 
N// -------- PWMC_IDR : (PWMC Offset: 0x14) PWMC Interrupt Disable Register -------- 
N// -------- PWMC_IMR : (PWMC Offset: 0x18) PWMC Interrupt Mask Register -------- 
N// -------- PWMC_ISR : (PWMC Offset: 0x1c) PWMC Interrupt Status Register -------- 
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Serial Parallel Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_SPI {
N	AT91_REG	 SPI_CR; 	// Control Register
N	AT91_REG	 SPI_MR; 	// Mode Register
N	AT91_REG	 SPI_RDR; 	// Receive Data Register
N	AT91_REG	 SPI_TDR; 	// Transmit Data Register
N	AT91_REG	 SPI_SR; 	// Status Register
N	AT91_REG	 SPI_IER; 	// Interrupt Enable Register
N	AT91_REG	 SPI_IDR; 	// Interrupt Disable Register
N	AT91_REG	 SPI_IMR; 	// Interrupt Mask Register
N	AT91_REG	 Reserved0[4]; 	// 
N	AT91_REG	 SPI_CSR[4]; 	// Chip Select Register
N	AT91_REG	 Reserved1[48]; 	// 
N	AT91_REG	 SPI_RPR; 	// Receive Pointer Register
N	AT91_REG	 SPI_RCR; 	// Receive Counter Register
N	AT91_REG	 SPI_TPR; 	// Transmit Pointer Register
N	AT91_REG	 SPI_TCR; 	// Transmit Counter Register
N	AT91_REG	 SPI_RNPR; 	// Receive Next Pointer Register
N	AT91_REG	 SPI_RNCR; 	// Receive Next Counter Register
N	AT91_REG	 SPI_TNPR; 	// Transmit Next Pointer Register
N	AT91_REG	 SPI_TNCR; 	// Transmit Next Counter Register
N	AT91_REG	 SPI_PTCR; 	// PDC Transfer Control Register
N	AT91_REG	 SPI_PTSR; 	// PDC Transfer Status Register
N} AT91S_SPI, *AT91PS_SPI;
N#else
S#define SPI_CR          (AT91_CAST(AT91_REG *) 	0x00000000) // (SPI_CR) Control Register
S#define SPI_MR          (AT91_CAST(AT91_REG *) 	0x00000004) // (SPI_MR) Mode Register
S#define SPI_RDR         (AT91_CAST(AT91_REG *) 	0x00000008) // (SPI_RDR) Receive Data Register
S#define SPI_TDR         (AT91_CAST(AT91_REG *) 	0x0000000C) // (SPI_TDR) Transmit Data Register
S#define SPI_SR          (AT91_CAST(AT91_REG *) 	0x00000010) // (SPI_SR) Status Register
S#define SPI_IER         (AT91_CAST(AT91_REG *) 	0x00000014) // (SPI_IER) Interrupt Enable Register
S#define SPI_IDR         (AT91_CAST(AT91_REG *) 	0x00000018) // (SPI_IDR) Interrupt Disable Register
S#define SPI_IMR         (AT91_CAST(AT91_REG *) 	0x0000001C) // (SPI_IMR) Interrupt Mask Register
S#define SPI_CSR         (AT91_CAST(AT91_REG *) 	0x00000030) // (SPI_CSR) Chip Select Register
S
N#endif
N// -------- SPI_CR : (SPI Offset: 0x0) SPI Control Register -------- 
N#define AT91C_SPI_SPIEN       (0x1 <<  0) // (SPI) SPI Enable
N#define AT91C_SPI_SPIDIS      (0x1 <<  1) // (SPI) SPI Disable
N#define AT91C_SPI_SWRST       (0x1 <<  7) // (SPI) SPI Software reset
N#define AT91C_SPI_LASTXFER    (0x1 << 24) // (SPI) SPI Last Transfer
N// -------- SPI_MR : (SPI Offset: 0x4) SPI Mode Register -------- 
N#define AT91C_SPI_MSTR        (0x1 <<  0) // (SPI) Master/Slave Mode
N#define AT91C_SPI_PS          (0x1 <<  1) // (SPI) Peripheral Select
N#define 	AT91C_SPI_PS_FIXED                (0x0 <<  1) // (SPI) Fixed Peripheral Select
N#define 	AT91C_SPI_PS_VARIABLE             (0x1 <<  1) // (SPI) Variable Peripheral Select
N#define AT91C_SPI_PCSDEC      (0x1 <<  2) // (SPI) Chip Select Decode
N#define AT91C_SPI_FDIV        (0x1 <<  3) // (SPI) Clock Selection
N#define AT91C_SPI_MODFDIS     (0x1 <<  4) // (SPI) Mode Fault Detection
N#define AT91C_SPI_LLB         (0x1 <<  7) // (SPI) Clock Selection
N#define AT91C_SPI_PCS         (0xF << 16) // (SPI) Peripheral Chip Select
N#define AT91C_SPI_DLYBCS      (0xFF << 24) // (SPI) Delay Between Chip Selects
N// -------- SPI_RDR : (SPI Offset: 0x8) Receive Data Register -------- 
N#define AT91C_SPI_RD          (0xFFFF <<  0) // (SPI) Receive Data
N#define AT91C_SPI_RPCS        (0xF << 16) // (SPI) Peripheral Chip Select Status
N// -------- SPI_TDR : (SPI Offset: 0xc) Transmit Data Register -------- 
N#define AT91C_SPI_TD          (0xFFFF <<  0) // (SPI) Transmit Data
N#define AT91C_SPI_TPCS        (0xF << 16) // (SPI) Peripheral Chip Select Status
N// -------- SPI_SR : (SPI Offset: 0x10) Status Register -------- 
N#define AT91C_SPI_RDRF        (0x1 <<  0) // (SPI) Receive Data Register Full
N#define AT91C_SPI_TDRE        (0x1 <<  1) // (SPI) Transmit Data Register Empty
N#define AT91C_SPI_MODF        (0x1 <<  2) // (SPI) Mode Fault Error
N#define AT91C_SPI_OVRES       (0x1 <<  3) // (SPI) Overrun Error Status
N#define AT91C_SPI_ENDRX       (0x1 <<  4) // (SPI) End of Receiver Transfer
N#define AT91C_SPI_ENDTX       (0x1 <<  5) // (SPI) End of Receiver Transfer
N#define AT91C_SPI_RXBUFF      (0x1 <<  6) // (SPI) RXBUFF Interrupt
N#define AT91C_SPI_TXBUFE      (0x1 <<  7) // (SPI) TXBUFE Interrupt
N#define AT91C_SPI_NSSR        (0x1 <<  8) // (SPI) NSSR Interrupt
N#define AT91C_SPI_TXEMPTY     (0x1 <<  9) // (SPI) TXEMPTY Interrupt
N#define AT91C_SPI_SPIENS      (0x1 << 16) // (SPI) Enable Status
N// -------- SPI_IER : (SPI Offset: 0x14) Interrupt Enable Register -------- 
N// -------- SPI_IDR : (SPI Offset: 0x18) Interrupt Disable Register -------- 
N// -------- SPI_IMR : (SPI Offset: 0x1c) Interrupt Mask Register -------- 
N// -------- SPI_CSR : (SPI Offset: 0x30) Chip Select Register -------- 
N#define AT91C_SPI_CPOL        (0x1 <<  0) // (SPI) Clock Polarity
N#define AT91C_SPI_NCPHA       (0x1 <<  1) // (SPI) Clock Phase
N#define AT91C_SPI_CSAAT       (0x1 <<  3) // (SPI) Chip Select Active After Transfer
N#define AT91C_SPI_BITS        (0xF <<  4) // (SPI) Bits Per Transfer
N#define 	AT91C_SPI_BITS_8                    (0x0 <<  4) // (SPI) 8 Bits Per transfer
N#define 	AT91C_SPI_BITS_9                    (0x1 <<  4) // (SPI) 9 Bits Per transfer
N#define 	AT91C_SPI_BITS_10                   (0x2 <<  4) // (SPI) 10 Bits Per transfer
N#define 	AT91C_SPI_BITS_11                   (0x3 <<  4) // (SPI) 11 Bits Per transfer
N#define 	AT91C_SPI_BITS_12                   (0x4 <<  4) // (SPI) 12 Bits Per transfer
N#define 	AT91C_SPI_BITS_13                   (0x5 <<  4) // (SPI) 13 Bits Per transfer
N#define 	AT91C_SPI_BITS_14                   (0x6 <<  4) // (SPI) 14 Bits Per transfer
N#define 	AT91C_SPI_BITS_15                   (0x7 <<  4) // (SPI) 15 Bits Per transfer
N#define 	AT91C_SPI_BITS_16                   (0x8 <<  4) // (SPI) 16 Bits Per transfer
N#define AT91C_SPI_SCBR        (0xFF <<  8) // (SPI) Serial Clock Baud Rate
N#define AT91C_SPI_DLYBS       (0xFF << 16) // (SPI) Delay Before SPCK
N#define AT91C_SPI_DLYBCT      (0xFF << 24) // (SPI) Delay Between Consecutive Transfers
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR TSADC
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_TSADC {
N	AT91_REG	 TSADC_CR; 	// Control Register
N	AT91_REG	 TSADC_MR; 	// Mode Register
N	AT91_REG	 TSADC_TRGR; 	// Trigger Register
N	AT91_REG	 TSADC_TSR; 	// Touch Screen Register
N	AT91_REG	 TSADC_CHER; 	// Channel Enable Register
N	AT91_REG	 TSADC_CHDR; 	// Channel Disable Register
N	AT91_REG	 TSADC_CHSR; 	// Channel Status Register
N	AT91_REG	 TSADC_SR; 	// Status Register
N	AT91_REG	 TSADC_LCDR; 	// Last Converted Register
N	AT91_REG	 TSADC_IER; 	// Interrupt Enable Register
N	AT91_REG	 TSADC_IDR; 	// Interrupt Disable Register
N	AT91_REG	 TSADC_IMR; 	// Interrupt Mask Register
N	AT91_REG	 TSADC_CDR0; 	// Channel Data Register 0
N	AT91_REG	 TSADC_CDR1; 	// Channel Data Register 1
N	AT91_REG	 TSADC_CDR2; 	// Channel Data Register 2
N	AT91_REG	 TSADC_CDR3; 	// Channel Data Register 3
N	AT91_REG	 TSADC_CDR4; 	// Channel Data Register 4
N	AT91_REG	 TSADC_CDR5; 	// Channel Data Register 5
N	AT91_REG	 TSADC_CDR6; 	// Channel Data Register 6
N	AT91_REG	 TSADC_CDR7; 	// Channel Data Register 7
N	AT91_REG	 Reserved0[44]; 	// 
N	AT91_REG	 TSADC_RPR; 	// Receive Pointer Register
N	AT91_REG	 TSADC_RCR; 	// Receive Counter Register
N	AT91_REG	 TSADC_TPR; 	// Transmit Pointer Register
N	AT91_REG	 TSADC_TCR; 	// Transmit Counter Register
N	AT91_REG	 TSADC_RNPR; 	// Receive Next Pointer Register
N	AT91_REG	 TSADC_RNCR; 	// Receive Next Counter Register
N	AT91_REG	 TSADC_TNPR; 	// Transmit Next Pointer Register
N	AT91_REG	 TSADC_TNCR; 	// Transmit Next Counter Register
N	AT91_REG	 TSADC_PTCR; 	// PDC Transfer Control Register
N	AT91_REG	 TSADC_PTSR; 	// PDC Transfer Status Register
N} AT91S_TSADC, *AT91PS_TSADC;
N#else
S#define TSADC_CR        (AT91_CAST(AT91_REG *) 	0x00000000) // (TSADC_CR) Control Register
S#define TSADC_MR        (AT91_CAST(AT91_REG *) 	0x00000004) // (TSADC_MR) Mode Register
S#define TSADC_TRGR      (AT91_CAST(AT91_REG *) 	0x00000008) // (TSADC_TRGR) Trigger Register
S#define TSADC_TSR       (AT91_CAST(AT91_REG *) 	0x0000000C) // (TSADC_TSR) Touch Screen Register
S#define TSADC_CHER      (AT91_CAST(AT91_REG *) 	0x00000010) // (TSADC_CHER) Channel Enable Register
S#define TSADC_CHDR      (AT91_CAST(AT91_REG *) 	0x00000014) // (TSADC_CHDR) Channel Disable Register
S#define TSADC_CHSR      (AT91_CAST(AT91_REG *) 	0x00000018) // (TSADC_CHSR) Channel Status Register
S#define TSADC_SR        (AT91_CAST(AT91_REG *) 	0x0000001C) // (TSADC_SR) Status Register
S#define TSADC_LCDR      (AT91_CAST(AT91_REG *) 	0x00000020) // (TSADC_LCDR) Last Converted Register
S#define TSADC_IER       (AT91_CAST(AT91_REG *) 	0x00000024) // (TSADC_IER) Interrupt Enable Register
S#define TSADC_IDR       (AT91_CAST(AT91_REG *) 	0x00000028) // (TSADC_IDR) Interrupt Disable Register
S#define TSADC_IMR       (AT91_CAST(AT91_REG *) 	0x0000002C) // (TSADC_IMR) Interrupt Mask Register
S#define TSADC_CDR0      (AT91_CAST(AT91_REG *) 	0x00000030) // (TSADC_CDR0) Channel Data Register 0
S#define TSADC_CDR1      (AT91_CAST(AT91_REG *) 	0x00000034) // (TSADC_CDR1) Channel Data Register 1
S#define TSADC_CDR2      (AT91_CAST(AT91_REG *) 	0x00000038) // (TSADC_CDR2) Channel Data Register 2
S#define TSADC_CDR3      (AT91_CAST(AT91_REG *) 	0x0000003C) // (TSADC_CDR3) Channel Data Register 3
S#define TSADC_CDR4      (AT91_CAST(AT91_REG *) 	0x00000040) // (TSADC_CDR4) Channel Data Register 4
S#define TSADC_CDR5      (AT91_CAST(AT91_REG *) 	0x00000044) // (TSADC_CDR5) Channel Data Register 5
S#define TSADC_CDR6      (AT91_CAST(AT91_REG *) 	0x00000048) // (TSADC_CDR6) Channel Data Register 6
S#define TSADC_CDR7      (AT91_CAST(AT91_REG *) 	0x0000004C) // (TSADC_CDR7) Channel Data Register 7
S
N#endif
N// -------- TSADC_CR : (TSADC Offset: 0x0) Control Register -------- 
N#define AT91C_TSADC_SWRST     (0x1 <<  0) // (TSADC) Software Reset
N#define AT91C_TSADC_START     (0x1 <<  1) // (TSADC) Start Conversion
N// -------- TSADC_MR : (TSADC Offset: 0x4) Mode Register -------- 
N#define AT91C_TSADC_TSAMOD    (0x3 <<  0) // (TSADC) Touch Screen ADC Mode
N#define 	AT91C_TSADC_TSAMOD_ADC_ONLY_MODE        (0x0) // (TSADC) ADC Mode
N#define 	AT91C_TSADC_TSAMOD_TS_ONLY_MODE         (0x1) // (TSADC) Touch Screen Only Mode
N#define AT91C_TSADC_LOWRES    (0x1 <<  4) // (TSADC) ADC Resolution
N#define AT91C_TSADC_SLEEP     (0x1 <<  5) // (TSADC) Sleep Mode
N#define AT91C_TSADC_PENDET    (0x1 <<  6) // (TSADC) Pen Detect Selection
N#define AT91C_TSADC_PRESCAL   (0xFF <<  8) // (TSADC) Prescaler Rate Selection
N#define AT91C_TSADC_STARTUP   (0x7F << 16) // (TSADC) Startup Time
N#define AT91C_TSADC_SHTIM     (0xF << 24) // (TSADC) Sample and Hold Time for ADC Channels
N#define AT91C_TSADC_PENDBC    (0xF << 28) // (TSADC) Pen Detect Debouncing Period
N// -------- TSADC_TRGR : (TSADC Offset: 0x8) Trigger Register -------- 
N#define AT91C_TSADC_TRGMOD    (0x7 <<  0) // (TSADC) Trigger Mode
N#define 	AT91C_TSADC_TRGMOD_NO_TRIGGER           (0x0) // (TSADC) No Trigger
N#define 	AT91C_TSADC_TRGMOD_EXTERNAL_TRIGGER_RE  (0x1) // (TSADC) External Trigger Rising Edge
N#define 	AT91C_TSADC_TRGMOD_EXTERNAL_TRIGGER_FE  (0x2) // (TSADC) External Trigger Falling Edge
N#define 	AT91C_TSADC_TRGMOD_EXTERNAL_TRIGGER_AE  (0x3) // (TSADC) External Trigger Any Edge
N#define 	AT91C_TSADC_TRGMOD_PENDET_TRIGGER       (0x4) // (TSADC) Pen Detect Trigger (only if PENDET is set and in Touch Screen mode only)
N#define 	AT91C_TSADC_TRGMOD_PERIODIC_TRIGGER     (0x5) // (TSADC) Periodic Trigger (wrt TRGPER)
N#define 	AT91C_TSADC_TRGMOD_CONT_TRIGGER         (0x6) // (TSADC) Continuous Trigger
N#define AT91C_TSADC_TRGPER    (0xFFFF << 16) // (TSADC) Trigger Period
N// -------- TSADC_TSR : (TSADC Offset: 0xc) Touch Screen Register -------- 
N#define AT91C_TSADC_TSSHTIM   (0xF << 24) // (TSADC) Sample and Hold Time for Touch Screen Channels
N// -------- TSADC_CHER : (TSADC Offset: 0x10) Channel Enable Register -------- 
N#define AT91C_TSADC_CHENA0    (0x1 <<  0) // (TSADC) Channel 0 Enable
N#define AT91C_TSADC_CHENA1    (0x1 <<  1) // (TSADC) Channel 1 Enable
N#define AT91C_TSADC_CHENA2    (0x1 <<  2) // (TSADC) Channel 2 Enable
N#define AT91C_TSADC_CHENA3    (0x1 <<  3) // (TSADC) Channel 3 Enable
N#define AT91C_TSADC_CHENA4    (0x1 <<  4) // (TSADC) Channel 4 Enable
N#define AT91C_TSADC_CHENA5    (0x1 <<  5) // (TSADC) Channel 5 Enable
N#define AT91C_TSADC_CHENA6    (0x1 <<  6) // (TSADC) Channel 6 Enable
N#define AT91C_TSADC_CHENA7    (0x1 <<  7) // (TSADC) Channel 7 Enable
N// -------- TSADC_CHDR : (TSADC Offset: 0x14) Channel Disable Register -------- 
N#define AT91C_TSADC_CHDIS0    (0x1 <<  0) // (TSADC) Channel 0 Disable
N#define AT91C_TSADC_CHDIS1    (0x1 <<  1) // (TSADC) Channel 1 Disable
N#define AT91C_TSADC_CHDIS2    (0x1 <<  2) // (TSADC) Channel 2 Disable
N#define AT91C_TSADC_CHDIS3    (0x1 <<  3) // (TSADC) Channel 3 Disable
N#define AT91C_TSADC_CHDIS4    (0x1 <<  4) // (TSADC) Channel 4 Disable
N#define AT91C_TSADC_CHDIS5    (0x1 <<  5) // (TSADC) Channel 5 Disable
N#define AT91C_TSADC_CHDIS6    (0x1 <<  6) // (TSADC) Channel 6 Disable
N#define AT91C_TSADC_CHDIS7    (0x1 <<  7) // (TSADC) Channel 7 Disable
N// -------- TSADC_CHSR : (TSADC Offset: 0x18) Channel Status Register -------- 
N#define AT91C_TSADC_CHS0      (0x1 <<  0) // (TSADC) Channel 0 Status
N#define AT91C_TSADC_CHS1      (0x1 <<  1) // (TSADC) Channel 1 Status
N#define AT91C_TSADC_CHS2      (0x1 <<  2) // (TSADC) Channel 2 Status
N#define AT91C_TSADC_CHS3      (0x1 <<  3) // (TSADC) Channel 3 Status
N#define AT91C_TSADC_CHS4      (0x1 <<  4) // (TSADC) Channel 4 Status
N#define AT91C_TSADC_CHS5      (0x1 <<  5) // (TSADC) Channel 5 Status
N#define AT91C_TSADC_CHS6      (0x1 <<  6) // (TSADC) Channel 6 Status
N#define AT91C_TSADC_CHS7      (0x1 <<  7) // (TSADC) Channel 7 Status
N// -------- TSADC_SR : (TSADC Offset: 0x1c) Status Register -------- 
N#define AT91C_TSADC_EOC0      (0x1 <<  0) // (TSADC) Channel 0 End Of Conversion
N#define AT91C_TSADC_EOC1      (0x1 <<  1) // (TSADC) Channel 1 End Of Conversion
N#define AT91C_TSADC_EOC2      (0x1 <<  2) // (TSADC) Channel 2 End Of Conversion
N#define AT91C_TSADC_EOC3      (0x1 <<  3) // (TSADC) Channel 3 End Of Conversion
N#define AT91C_TSADC_EOC4      (0x1 <<  4) // (TSADC) Channel 4 End Of Conversion
N#define AT91C_TSADC_EOC5      (0x1 <<  5) // (TSADC) Channel 5 End Of Conversion
N#define AT91C_TSADC_EOC6      (0x1 <<  6) // (TSADC) Channel 6 End Of Conversion
N#define AT91C_TSADC_EOC7      (0x1 <<  7) // (TSADC) Channel 7 End Of Conversion
N#define AT91C_TSADC_OVRE0     (0x1 <<  8) // (TSADC) Channel 0 Overrun Error
N#define AT91C_TSADC_OVRE1     (0x1 <<  9) // (TSADC) Channel 1 Overrun Error
N#define AT91C_TSADC_OVRE2     (0x1 << 10) // (TSADC) Channel 2 Overrun Error
N#define AT91C_TSADC_OVRE3     (0x1 << 11) // (TSADC) Channel 3 Overrun Error
N#define AT91C_TSADC_OVRE4     (0x1 << 12) // (TSADC) Channel 4 Overrun Error
N#define AT91C_TSADC_OVRE5     (0x1 << 13) // (TSADC) Channel 5 Overrun Error
N#define AT91C_TSADC_OVRE6     (0x1 << 14) // (TSADC) Channel 6 Overrun Error
N#define AT91C_TSADC_OVRE7     (0x1 << 15) // (TSADC) Channel 7 Overrun Error
N#define AT91C_TSADC_DRDY      (0x1 << 16) // (TSADC) Data Ready
N#define AT91C_TSADC_GOVRE     (0x1 << 17) // (TSADC) General Overrun Error
N#define AT91C_TSADC_ENDRX     (0x1 << 18) // (TSADC) End of RX Buffer
N#define AT91C_TSADC_RXBUFF    (0x1 << 19) // (TSADC) RX Buffer Full
N#define AT91C_TSADC_PENCNT    (0x1 << 20) // (TSADC) Pen Contact
N#define AT91C_TSADC_NOCNT     (0x1 << 21) // (TSADC) No Contact
N// -------- TSADC_LCDR : (TSADC Offset: 0x20) Last Converted Data Register -------- 
N#define AT91C_TSADC_LDATA     (0x3FF <<  0) // (TSADC) Last Converted Data
N// -------- TSADC_IER : (TSADC Offset: 0x24) Interrupt Enable Register -------- 
N#define AT91C_TSADC_IENAEOC0  (0x1 <<  0) // (TSADC) Channel 0 End Of Conversion Interrupt Enable
N#define AT91C_TSADC_IENAEOC1  (0x1 <<  1) // (TSADC) Channel 1 End Of Conversion Interrupt Enable
N#define AT91C_TSADC_IENAEOC2  (0x1 <<  2) // (TSADC) Channel 2 End Of Conversion Interrupt Enable
N#define AT91C_TSADC_IENAEOC3  (0x1 <<  3) // (TSADC) Channel 3 End Of Conversion Interrupt Enable
N#define AT91C_TSADC_IENAEOC4  (0x1 <<  4) // (TSADC) Channel 4 End Of Conversion Interrupt Enable
N#define AT91C_TSADC_IENAEOC5  (0x1 <<  5) // (TSADC) Channel 5 End Of Conversion Interrupt Enable
N#define AT91C_TSADC_IENAEOC6  (0x1 <<  6) // (TSADC) Channel 6 End Of Conversion Interrupt Enable
N#define AT91C_TSADC_IENAEOC7  (0x1 <<  7) // (TSADC) Channel 7 End Of Conversion Interrupt Enable
N#define AT91C_TSADC_IENAOVRE0 (0x1 <<  8) // (TSADC) Channel 0 Overrun Error Interrupt Enable
N#define AT91C_TSADC_IENAOVRE1 (0x1 <<  9) // (TSADC) Channel 1 Overrun Error Interrupt Enable
N#define AT91C_TSADC_IENAOVRE2 (0x1 << 10) // (TSADC) Channel 2 Overrun Error Interrupt Enable
N#define AT91C_TSADC_IENAOVRE3 (0x1 << 11) // (TSADC) Channel 3 Overrun Error Interrupt Enable
N#define AT91C_TSADC_IENAOVRE4 (0x1 << 12) // (TSADC) Channel 4 Overrun Error Interrupt Enable
N#define AT91C_TSADC_IENAOVRE5 (0x1 << 13) // (TSADC) Channel 5 Overrun Error Interrupt Enable
N#define AT91C_TSADC_IENAOVRE6 (0x1 << 14) // (TSADC) Channel 6 Overrun Error Interrupt Enable
N#define AT91C_TSADC_IENAOVRE7 (0x1 << 15) // (TSADC) Channel 7 Overrun Error Interrupt Enable
N#define AT91C_TSADC_IENADRDY  (0x1 << 16) // (TSADC) Data Ready Interrupt Enable
N#define AT91C_TSADC_IENAGOVRE (0x1 << 17) // (TSADC) General Overrun Error Interrupt Enable
N#define AT91C_TSADC_IENAENDRX (0x1 << 18) // (TSADC) End of RX Buffer Interrupt Enable
N#define AT91C_TSADC_IENARXBUFF (0x1 << 19) // (TSADC) RX Buffer Full Interrupt Enable
N#define AT91C_TSADC_IENAPENCNT (0x1 << 20) // (TSADC) Pen Contact Interrupt Enable
N#define AT91C_TSADC_IENANOCNT (0x1 << 21) // (TSADC) No Contact Interrupt Enable
N// -------- TSADC_IDR : (TSADC Offset: 0x28) Interrupt Disable Register -------- 
N#define AT91C_TSADC_IDISEOC0  (0x1 <<  0) // (TSADC) Channel 0 End Of Conversion Interrupt Disable
N#define AT91C_TSADC_IDISEOC1  (0x1 <<  1) // (TSADC) Channel 1 End Of Conversion Interrupt Disable
N#define AT91C_TSADC_IDISEOC2  (0x1 <<  2) // (TSADC) Channel 2 End Of Conversion Interrupt Disable
N#define AT91C_TSADC_IDISEOC3  (0x1 <<  3) // (TSADC) Channel 3 End Of Conversion Interrupt Disable
N#define AT91C_TSADC_IDISEOC4  (0x1 <<  4) // (TSADC) Channel 4 End Of Conversion Interrupt Disable
N#define AT91C_TSADC_IDISEOC5  (0x1 <<  5) // (TSADC) Channel 5 End Of Conversion Interrupt Disable
N#define AT91C_TSADC_IDISEOC6  (0x1 <<  6) // (TSADC) Channel 6 End Of Conversion Interrupt Disable
N#define AT91C_TSADC_IDISEOC7  (0x1 <<  7) // (TSADC) Channel 7 End Of Conversion Interrupt Disable
N#define AT91C_TSADC_IDISOVRE0 (0x1 <<  8) // (TSADC) Channel 0 Overrun Error Interrupt Disable
N#define AT91C_TSADC_IDISOVRE1 (0x1 <<  9) // (TSADC) Channel 1 Overrun Error Interrupt Disable
N#define AT91C_TSADC_IDISOVRE2 (0x1 << 10) // (TSADC) Channel 2 Overrun Error Interrupt Disable
N#define AT91C_TSADC_IDISOVRE3 (0x1 << 11) // (TSADC) Channel 3 Overrun Error Interrupt Disable
N#define AT91C_TSADC_IDISOVRE4 (0x1 << 12) // (TSADC) Channel 4 Overrun Error Interrupt Disable
N#define AT91C_TSADC_IDISOVRE5 (0x1 << 13) // (TSADC) Channel 5 Overrun Error Interrupt Disable
N#define AT91C_TSADC_IDISOVRE6 (0x1 << 14) // (TSADC) Channel 6 Overrun Error Interrupt Disable
N#define AT91C_TSADC_IDISOVRE7 (0x1 << 15) // (TSADC) Channel 7 Overrun Error Interrupt Disable
N#define AT91C_TSADC_IDISDRDY  (0x1 << 16) // (TSADC) Data Ready Interrupt Disable
N#define AT91C_TSADC_IDISGOVRE (0x1 << 17) // (TSADC) General Overrun Error Interrupt Disable
N#define AT91C_TSADC_IDISENDRX (0x1 << 18) // (TSADC) End of RX Buffer Interrupt Disable
N#define AT91C_TSADC_IDISRXBUFF (0x1 << 19) // (TSADC) RX Buffer Full Interrupt Disable
N#define AT91C_TSADC_IDISPENCNT (0x1 << 20) // (TSADC) Pen Contact Interrupt Disable
N#define AT91C_TSADC_IDISNOCNT (0x1 << 21) // (TSADC) No Contact Interrupt Disable
N// -------- TSADC_IMR : (TSADC Offset: 0x2c) Interrupt Mask Register -------- 
N#define AT91C_TSADC_IMSKEOC0  (0x1 <<  0) // (TSADC) Channel 0 End Of Conversion Interrupt Mask
N#define AT91C_TSADC_IMSKEOC1  (0x1 <<  1) // (TSADC) Channel 1 End Of Conversion Interrupt Mask
N#define AT91C_TSADC_IMSKEOC2  (0x1 <<  2) // (TSADC) Channel 2 End Of Conversion Interrupt Mask
N#define AT91C_TSADC_IMSKEOC3  (0x1 <<  3) // (TSADC) Channel 3 End Of Conversion Interrupt Mask
N#define AT91C_TSADC_IMSKEOC4  (0x1 <<  4) // (TSADC) Channel 4 End Of Conversion Interrupt Mask
N#define AT91C_TSADC_IMSKEOC5  (0x1 <<  5) // (TSADC) Channel 5 End Of Conversion Interrupt Mask
N#define AT91C_TSADC_IMSKEOC6  (0x1 <<  6) // (TSADC) Channel 6 End Of Conversion Interrupt Mask
N#define AT91C_TSADC_IMSKEOC7  (0x1 <<  7) // (TSADC) Channel 7 End Of Conversion Interrupt Mask
N#define AT91C_TSADC_IMSKOVRE0 (0x1 <<  8) // (TSADC) Channel 0 Overrun Error Interrupt Mask
N#define AT91C_TSADC_IMSKOVRE1 (0x1 <<  9) // (TSADC) Channel 1 Overrun Error Interrupt Mask
N#define AT91C_TSADC_IMSKOVRE2 (0x1 << 10) // (TSADC) Channel 2 Overrun Error Interrupt Mask
N#define AT91C_TSADC_IMSKOVRE3 (0x1 << 11) // (TSADC) Channel 3 Overrun Error Interrupt Mask
N#define AT91C_TSADC_IMSKOVRE4 (0x1 << 12) // (TSADC) Channel 4 Overrun Error Interrupt Mask
N#define AT91C_TSADC_IMSKOVRE5 (0x1 << 13) // (TSADC) Channel 5 Overrun Error Interrupt Mask
N#define AT91C_TSADC_IMSKOVRE6 (0x1 << 14) // (TSADC) Channel 6 Overrun Error Interrupt Mask
N#define AT91C_TSADC_IMSKOVRE7 (0x1 << 15) // (TSADC) Channel 7 Overrun Error Interrupt Mask
N#define AT91C_TSADC_IMSKDRDY  (0x1 << 16) // (TSADC) Data Ready Interrupt Mask
N#define AT91C_TSADC_IMSKGOVRE (0x1 << 17) // (TSADC) General Overrun Error Interrupt Mask
N#define AT91C_TSADC_IMSKENDRX (0x1 << 18) // (TSADC) End of RX Buffer Interrupt Mask
N#define AT91C_TSADC_IMSKRXBUFF (0x1 << 19) // (TSADC) RX Buffer Full Interrupt Mask
N#define AT91C_TSADC_IMSKPENCNT (0x1 << 20) // (TSADC) Pen Contact Interrupt Mask
N#define AT91C_TSADC_IMSKNOCNT (0x1 << 21) // (TSADC) No Contact Interrupt Mask
N// -------- TSADC_CDR0 : (TSADC Offset: 0x30) Channel 0 Data Register -------- 
N#define AT91C_TSADC_DATA0     (0x3FF <<  0) // (TSADC) Channel 0 Data
N// -------- TSADC_CDR1 : (TSADC Offset: 0x34) Channel 1 Data Register -------- 
N#define AT91C_TSADC_DATA1     (0x3FF <<  0) // (TSADC) Channel 1 Data
N// -------- TSADC_CDR2 : (TSADC Offset: 0x38) Channel 2 Data Register -------- 
N#define AT91C_TSADC_DATA2     (0x3FF <<  0) // (TSADC) Channel 2 Data
N// -------- TSADC_CDR3 : (TSADC Offset: 0x3c) Channel 3 Data Register -------- 
N#define AT91C_TSADC_DATA3     (0x3FF <<  0) // (TSADC) Channel 3 Data
N// -------- TSADC_CDR4 : (TSADC Offset: 0x40) Channel 4 Data Register -------- 
N#define AT91C_TSADC_DATA4     (0x3FF <<  0) // (TSADC) Channel 4 Data
N// -------- TSADC_CDR5 : (TSADC Offset: 0x44) Channel 5 Data Register -------- 
N#define AT91C_TSADC_DATA5     (0x3FF <<  0) // (TSADC) Channel 5 Data
N// -------- TSADC_CDR6 : (TSADC Offset: 0x48) Channel 6 Data Register -------- 
N#define AT91C_TSADC_DATA6     (0x3FF <<  0) // (TSADC) Channel 6 Data
N// -------- TSADC_CDR7 : (TSADC Offset: 0x4c) Channel 7 Data Register -------- 
N#define AT91C_TSADC_DATA7     (0x3FF <<  0) // (TSADC) Channel 7 Data
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR UDPHS Enpoint FIFO data register
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_UDPHS_EPTFIFO {
N	AT91_REG	 UDPHS_READEPT0[16384]; 	// FIFO Endpoint Data Register 0
N	AT91_REG	 UDPHS_READEPT1[16384]; 	// FIFO Endpoint Data Register 1
N	AT91_REG	 UDPHS_READEPT2[16384]; 	// FIFO Endpoint Data Register 2
N	AT91_REG	 UDPHS_READEPT3[16384]; 	// FIFO Endpoint Data Register 3
N	AT91_REG	 UDPHS_READEPT4[16384]; 	// FIFO Endpoint Data Register 4
N	AT91_REG	 UDPHS_READEPT5[16384]; 	// FIFO Endpoint Data Register 5
N	AT91_REG	 UDPHS_READEPT6[16384]; 	// FIFO Endpoint Data Register 6
N} AT91S_UDPHS_EPTFIFO, *AT91PS_UDPHS_EPTFIFO;
N#else
S#define UDPHS_READEPT0  (AT91_CAST(AT91_REG *) 	0x00000000) // (UDPHS_READEPT0) FIFO Endpoint Data Register 0
S#define UDPHS_READEPT1  (AT91_CAST(AT91_REG *) 	0x00010000) // (UDPHS_READEPT1) FIFO Endpoint Data Register 1
S#define UDPHS_READEPT2  (AT91_CAST(AT91_REG *) 	0x00020000) // (UDPHS_READEPT2) FIFO Endpoint Data Register 2
S#define UDPHS_READEPT3  (AT91_CAST(AT91_REG *) 	0x00030000) // (UDPHS_READEPT3) FIFO Endpoint Data Register 3
S#define UDPHS_READEPT4  (AT91_CAST(AT91_REG *) 	0x00040000) // (UDPHS_READEPT4) FIFO Endpoint Data Register 4
S#define UDPHS_READEPT5  (AT91_CAST(AT91_REG *) 	0x00050000) // (UDPHS_READEPT5) FIFO Endpoint Data Register 5
S#define UDPHS_READEPT6  (AT91_CAST(AT91_REG *) 	0x00060000) // (UDPHS_READEPT6) FIFO Endpoint Data Register 6
S
N#endif
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR UDPHS Endpoint struct
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_UDPHS_EPT {
N	AT91_REG	 UDPHS_EPTCFG; 	// UDPHS Endpoint Config Register
N	AT91_REG	 UDPHS_EPTCTLENB; 	// UDPHS Endpoint Control Enable Register
N	AT91_REG	 UDPHS_EPTCTLDIS; 	// UDPHS Endpoint Control Disable Register
N	AT91_REG	 UDPHS_EPTCTL; 	// UDPHS Endpoint Control Register
N	AT91_REG	 Reserved0[1]; 	// 
N	AT91_REG	 UDPHS_EPTSETSTA; 	// UDPHS Endpoint Set Status Register
N	AT91_REG	 UDPHS_EPTCLRSTA; 	// UDPHS Endpoint Clear Status Register
N	AT91_REG	 UDPHS_EPTSTA; 	// UDPHS Endpoint Status Register
N} AT91S_UDPHS_EPT, *AT91PS_UDPHS_EPT;
N#else
S#define UDPHS_EPTCFG    (AT91_CAST(AT91_REG *) 	0x00000000) // (UDPHS_EPTCFG) UDPHS Endpoint Config Register
S#define UDPHS_EPTCTLENB (AT91_CAST(AT91_REG *) 	0x00000004) // (UDPHS_EPTCTLENB) UDPHS Endpoint Control Enable Register
S#define UDPHS_EPTCTLDIS (AT91_CAST(AT91_REG *) 	0x00000008) // (UDPHS_EPTCTLDIS) UDPHS Endpoint Control Disable Register
S#define UDPHS_EPTCTL    (AT91_CAST(AT91_REG *) 	0x0000000C) // (UDPHS_EPTCTL) UDPHS Endpoint Control Register
S#define UDPHS_EPTSETSTA (AT91_CAST(AT91_REG *) 	0x00000014) // (UDPHS_EPTSETSTA) UDPHS Endpoint Set Status Register
S#define UDPHS_EPTCLRSTA (AT91_CAST(AT91_REG *) 	0x00000018) // (UDPHS_EPTCLRSTA) UDPHS Endpoint Clear Status Register
S#define UDPHS_EPTSTA    (AT91_CAST(AT91_REG *) 	0x0000001C) // (UDPHS_EPTSTA) UDPHS Endpoint Status Register
S
N#endif
N// -------- UDPHS_EPTCFG : (UDPHS_EPT Offset: 0x0) UDPHS Endpoint Config Register -------- 
N#define AT91C_UDPHS_EPT_SIZE  (0x7 <<  0) // (UDPHS_EPT) Endpoint Size
N#define 	AT91C_UDPHS_EPT_SIZE_8                    (0x0) // (UDPHS_EPT)    8 bytes
N#define 	AT91C_UDPHS_EPT_SIZE_16                   (0x1) // (UDPHS_EPT)   16 bytes
N#define 	AT91C_UDPHS_EPT_SIZE_32                   (0x2) // (UDPHS_EPT)   32 bytes
N#define 	AT91C_UDPHS_EPT_SIZE_64                   (0x3) // (UDPHS_EPT)   64 bytes
N#define 	AT91C_UDPHS_EPT_SIZE_128                  (0x4) // (UDPHS_EPT)  128 bytes
N#define 	AT91C_UDPHS_EPT_SIZE_256                  (0x5) // (UDPHS_EPT)  256 bytes (if possible)
N#define 	AT91C_UDPHS_EPT_SIZE_512                  (0x6) // (UDPHS_EPT)  512 bytes (if possible)
N#define 	AT91C_UDPHS_EPT_SIZE_1024                 (0x7) // (UDPHS_EPT) 1024 bytes (if possible)
N#define AT91C_UDPHS_EPT_DIR   (0x1 <<  3) // (UDPHS_EPT) Endpoint Direction 0:OUT, 1:IN
N#define 	AT91C_UDPHS_EPT_DIR_OUT                  (0x0 <<  3) // (UDPHS_EPT) Direction OUT
N#define 	AT91C_UDPHS_EPT_DIR_IN                   (0x1 <<  3) // (UDPHS_EPT) Direction IN
N#define AT91C_UDPHS_EPT_TYPE  (0x3 <<  4) // (UDPHS_EPT) Endpoint Type
N#define 	AT91C_UDPHS_EPT_TYPE_CTL_EPT              (0x0 <<  4) // (UDPHS_EPT) Control endpoint
N#define 	AT91C_UDPHS_EPT_TYPE_ISO_EPT              (0x1 <<  4) // (UDPHS_EPT) Isochronous endpoint
N#define 	AT91C_UDPHS_EPT_TYPE_BUL_EPT              (0x2 <<  4) // (UDPHS_EPT) Bulk endpoint
N#define 	AT91C_UDPHS_EPT_TYPE_INT_EPT              (0x3 <<  4) // (UDPHS_EPT) Interrupt endpoint
N#define AT91C_UDPHS_BK_NUMBER (0x3 <<  6) // (UDPHS_EPT) Number of Banks
N#define 	AT91C_UDPHS_BK_NUMBER_0                    (0x0 <<  6) // (UDPHS_EPT) Zero Bank, the EndPoint is not mapped in memory
N#define 	AT91C_UDPHS_BK_NUMBER_1                    (0x1 <<  6) // (UDPHS_EPT) One Bank (Bank0)
N#define 	AT91C_UDPHS_BK_NUMBER_2                    (0x2 <<  6) // (UDPHS_EPT) Double bank (Ping-Pong : Bank0 / Bank1)
N#define 	AT91C_UDPHS_BK_NUMBER_3                    (0x3 <<  6) // (UDPHS_EPT) Triple Bank (Bank0 / Bank1 / Bank2) (if possible)
N#define AT91C_UDPHS_NB_TRANS  (0x3 <<  8) // (UDPHS_EPT) Number Of Transaction per Micro-Frame (High-Bandwidth iso only)
N#define AT91C_UDPHS_EPT_MAPD  (0x1 << 31) // (UDPHS_EPT) Endpoint Mapped (read only
N// -------- UDPHS_EPTCTLENB : (UDPHS_EPT Offset: 0x4) UDPHS Endpoint Control Enable Register -------- 
N#define AT91C_UDPHS_EPT_ENABL (0x1 <<  0) // (UDPHS_EPT) Endpoint Enable
N#define AT91C_UDPHS_AUTO_VALID (0x1 <<  1) // (UDPHS_EPT) Packet Auto-Valid Enable/Disable
N#define AT91C_UDPHS_INTDIS_DMA (0x1 <<  3) // (UDPHS_EPT) Endpoint Interrupts DMA Request Enable/Disable
N#define AT91C_UDPHS_NYET_DIS  (0x1 <<  4) // (UDPHS_EPT) NYET Enable/Disable
N#define AT91C_UDPHS_DATAX_RX  (0x1 <<  6) // (UDPHS_EPT) DATAx Interrupt Enable/Disable
N#define AT91C_UDPHS_MDATA_RX  (0x1 <<  7) // (UDPHS_EPT) MDATA Interrupt Enabled/Disable
N#define AT91C_UDPHS_ERR_OVFLW (0x1 <<  8) // (UDPHS_EPT) OverFlow Error Interrupt Enable/Disable/Status
N#define AT91C_UDPHS_RX_BK_RDY (0x1 <<  9) // (UDPHS_EPT) Received OUT Data
N#define AT91C_UDPHS_TX_COMPLT (0x1 << 10) // (UDPHS_EPT) Transmitted IN Data Complete Interrupt Enable/Disable or Transmitted IN Data Complete (clear)
N#define AT91C_UDPHS_ERR_TRANS (0x1 << 11) // (UDPHS_EPT) Transaction Error Interrupt Enable/Disable
N#define AT91C_UDPHS_TX_PK_RDY (0x1 << 11) // (UDPHS_EPT) TX Packet Ready Interrupt Enable/Disable
N#define AT91C_UDPHS_RX_SETUP  (0x1 << 12) // (UDPHS_EPT) Received SETUP Interrupt Enable/Disable
N#define AT91C_UDPHS_ERR_FL_ISO (0x1 << 12) // (UDPHS_EPT) Error Flow Clear/Interrupt Enable/Disable
N#define AT91C_UDPHS_STALL_SNT (0x1 << 13) // (UDPHS_EPT) Stall Sent Clear
N#define AT91C_UDPHS_ERR_CRISO (0x1 << 13) // (UDPHS_EPT) CRC error / Error NB Trans / Interrupt Enable/Disable
N#define AT91C_UDPHS_NAK_IN    (0x1 << 14) // (UDPHS_EPT) NAKIN ERROR FLUSH / Clear / Interrupt Enable/Disable
N#define AT91C_UDPHS_NAK_OUT   (0x1 << 15) // (UDPHS_EPT) NAKOUT / Clear / Interrupt Enable/Disable
N#define AT91C_UDPHS_BUSY_BANK (0x1 << 18) // (UDPHS_EPT) Busy Bank Interrupt Enable/Disable
N#define AT91C_UDPHS_SHRT_PCKT (0x1 << 31) // (UDPHS_EPT) Short Packet / Interrupt Enable/Disable
N// -------- UDPHS_EPTCTLDIS : (UDPHS_EPT Offset: 0x8) UDPHS Endpoint Control Disable Register -------- 
N#define AT91C_UDPHS_EPT_DISABL (0x1 <<  0) // (UDPHS_EPT) Endpoint Disable
N// -------- UDPHS_EPTCTL : (UDPHS_EPT Offset: 0xc) UDPHS Endpoint Control Register -------- 
N// -------- UDPHS_EPTSETSTA : (UDPHS_EPT Offset: 0x14) UDPHS Endpoint Set Status Register -------- 
N#define AT91C_UDPHS_FRCESTALL (0x1 <<  5) // (UDPHS_EPT) Stall Handshake Request Set/Clear/Status
N#define AT91C_UDPHS_KILL_BANK (0x1 <<  9) // (UDPHS_EPT) KILL Bank
N// -------- UDPHS_EPTCLRSTA : (UDPHS_EPT Offset: 0x18) UDPHS Endpoint Clear Status Register -------- 
N#define AT91C_UDPHS_TOGGLESQ  (0x1 <<  6) // (UDPHS_EPT) Data Toggle Clear
N// -------- UDPHS_EPTSTA : (UDPHS_EPT Offset: 0x1c) UDPHS Endpoint Status Register -------- 
N#define AT91C_UDPHS_TOGGLESQ_STA (0x3 <<  6) // (UDPHS_EPT) Toggle Sequencing
N#define 	AT91C_UDPHS_TOGGLESQ_STA_00                   (0x0 <<  6) // (UDPHS_EPT) Data0
N#define 	AT91C_UDPHS_TOGGLESQ_STA_01                   (0x1 <<  6) // (UDPHS_EPT) Data1
N#define 	AT91C_UDPHS_TOGGLESQ_STA_10                   (0x2 <<  6) // (UDPHS_EPT) Data2 (only for High-Bandwidth Isochronous EndPoint)
N#define 	AT91C_UDPHS_TOGGLESQ_STA_11                   (0x3 <<  6) // (UDPHS_EPT) MData (only for High-Bandwidth Isochronous EndPoint)
N#define AT91C_UDPHS_CONTROL_DIR (0x3 << 16) // (UDPHS_EPT) 
N#define 	AT91C_UDPHS_CONTROL_DIR_00                   (0x0 << 16) // (UDPHS_EPT) Bank 0
N#define 	AT91C_UDPHS_CONTROL_DIR_01                   (0x1 << 16) // (UDPHS_EPT) Bank 1
N#define 	AT91C_UDPHS_CONTROL_DIR_10                   (0x2 << 16) // (UDPHS_EPT) Bank 2
N#define 	AT91C_UDPHS_CONTROL_DIR_11                   (0x3 << 16) // (UDPHS_EPT) Invalid
N#define AT91C_UDPHS_CURRENT_BANK (0x3 << 16) // (UDPHS_EPT) 
N#define 	AT91C_UDPHS_CURRENT_BANK_00                   (0x0 << 16) // (UDPHS_EPT) Bank 0
N#define 	AT91C_UDPHS_CURRENT_BANK_01                   (0x1 << 16) // (UDPHS_EPT) Bank 1
N#define 	AT91C_UDPHS_CURRENT_BANK_10                   (0x2 << 16) // (UDPHS_EPT) Bank 2
N#define 	AT91C_UDPHS_CURRENT_BANK_11                   (0x3 << 16) // (UDPHS_EPT) Invalid
N#define AT91C_UDPHS_BUSY_BANK_STA (0x3 << 18) // (UDPHS_EPT) Busy Bank Number
N#define 	AT91C_UDPHS_BUSY_BANK_STA_00                   (0x0 << 18) // (UDPHS_EPT) All banks are free
N#define 	AT91C_UDPHS_BUSY_BANK_STA_01                   (0x1 << 18) // (UDPHS_EPT) 1 busy bank
N#define 	AT91C_UDPHS_BUSY_BANK_STA_10                   (0x2 << 18) // (UDPHS_EPT) 2 busy banks
N#define 	AT91C_UDPHS_BUSY_BANK_STA_11                   (0x3 << 18) // (UDPHS_EPT) 3 busy banks (if possible)
N#define AT91C_UDPHS_BYTE_COUNT (0x7FF << 20) // (UDPHS_EPT) UDPHS Byte Count
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR UDPHS DMA struct
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_UDPHS_DMA {
N	AT91_REG	 UDPHS_DMANXTDSC; 	// UDPHS DMA Channel Next Descriptor Address
N	AT91_REG	 UDPHS_DMAADDRESS; 	// UDPHS DMA Channel Address Register
N	AT91_REG	 UDPHS_DMACONTROL; 	// UDPHS DMA Channel Control Register
N	AT91_REG	 UDPHS_DMASTATUS; 	// UDPHS DMA Channel Status Register
N} AT91S_UDPHS_DMA, *AT91PS_UDPHS_DMA;
N#else
S#define UDPHS_DMANXTDSC (AT91_CAST(AT91_REG *) 	0x00000000) // (UDPHS_DMANXTDSC) UDPHS DMA Channel Next Descriptor Address
S#define UDPHS_DMAADDRESS (AT91_CAST(AT91_REG *) 	0x00000004) // (UDPHS_DMAADDRESS) UDPHS DMA Channel Address Register
S#define UDPHS_DMACONTROL (AT91_CAST(AT91_REG *) 	0x00000008) // (UDPHS_DMACONTROL) UDPHS DMA Channel Control Register
S#define UDPHS_DMASTATUS (AT91_CAST(AT91_REG *) 	0x0000000C) // (UDPHS_DMASTATUS) UDPHS DMA Channel Status Register
S
N#endif
N// -------- UDPHS_DMANXTDSC : (UDPHS_DMA Offset: 0x0) UDPHS DMA Next Descriptor Address Register -------- 
N#define AT91C_UDPHS_NXT_DSC_ADD (0xFFFFFFF <<  4) // (UDPHS_DMA) next Channel Descriptor
N// -------- UDPHS_DMAADDRESS : (UDPHS_DMA Offset: 0x4) UDPHS DMA Channel Address Register -------- 
N#define AT91C_UDPHS_BUFF_ADD  (0x0 <<  0) // (UDPHS_DMA) starting address of a DMA Channel transfer
N// -------- UDPHS_DMACONTROL : (UDPHS_DMA Offset: 0x8) UDPHS DMA Channel Control Register -------- 
N#define AT91C_UDPHS_CHANN_ENB (0x1 <<  0) // (UDPHS_DMA) Channel Enabled
N#define AT91C_UDPHS_LDNXT_DSC (0x1 <<  1) // (UDPHS_DMA) Load Next Channel Transfer Descriptor Enable
N#define AT91C_UDPHS_END_TR_EN (0x1 <<  2) // (UDPHS_DMA) Buffer Close Input Enable
N#define AT91C_UDPHS_END_B_EN  (0x1 <<  3) // (UDPHS_DMA) End of DMA Buffer Packet Validation
N#define AT91C_UDPHS_END_TR_IT (0x1 <<  4) // (UDPHS_DMA) End Of Transfer Interrupt Enable
N#define AT91C_UDPHS_END_BUFFIT (0x1 <<  5) // (UDPHS_DMA) End Of Channel Buffer Interrupt Enable
N#define AT91C_UDPHS_DESC_LD_IT (0x1 <<  6) // (UDPHS_DMA) Descriptor Loaded Interrupt Enable
N#define AT91C_UDPHS_BURST_LCK (0x1 <<  7) // (UDPHS_DMA) Burst Lock Enable
N#define AT91C_UDPHS_BUFF_LENGTH (0xFFFF << 16) // (UDPHS_DMA) Buffer Byte Length (write only)
N// -------- UDPHS_DMASTATUS : (UDPHS_DMA Offset: 0xc) UDPHS DMA Channelx Status Register -------- 
N#define AT91C_UDPHS_CHANN_ACT (0x1 <<  1) // (UDPHS_DMA) 
N#define AT91C_UDPHS_END_TR_ST (0x1 <<  4) // (UDPHS_DMA) 
N#define AT91C_UDPHS_END_BF_ST (0x1 <<  5) // (UDPHS_DMA) 
N#define AT91C_UDPHS_DESC_LDST (0x1 <<  6) // (UDPHS_DMA) 
N#define AT91C_UDPHS_BUFF_COUNT (0xFFFF << 16) // (UDPHS_DMA) 
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR UDPHS High Speed Device Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_UDPHS {
N	AT91_REG	 UDPHS_CTRL; 	// UDPHS Control Register
N	AT91_REG	 UDPHS_FNUM; 	// UDPHS Frame Number Register
N	AT91_REG	 Reserved0[2]; 	// 
N	AT91_REG	 UDPHS_IEN; 	// UDPHS Interrupt Enable Register
N	AT91_REG	 UDPHS_INTSTA; 	// UDPHS Interrupt Status Register
N	AT91_REG	 UDPHS_CLRINT; 	// UDPHS Clear Interrupt Register
N	AT91_REG	 UDPHS_EPTRST; 	// UDPHS Endpoints Reset Register
N	AT91_REG	 Reserved1[44]; 	// 
N	AT91_REG	 UDPHS_TSTSOFCNT; 	// UDPHS Test SOF Counter Register
N	AT91_REG	 UDPHS_TSTCNTA; 	// UDPHS Test A Counter Register
N	AT91_REG	 UDPHS_TSTCNTB; 	// UDPHS Test B Counter Register
N	AT91_REG	 UDPHS_TSTMODREG; 	// UDPHS Test Mode Register
N	AT91_REG	 UDPHS_TST; 	// UDPHS Test Register
N	AT91_REG	 Reserved2[2]; 	// 
N	AT91_REG	 UDPHS_RIPPADDRSIZE; 	// UDPHS PADDRSIZE Register
N	AT91_REG	 UDPHS_RIPNAME1; 	// UDPHS Name1 Register
N	AT91_REG	 UDPHS_RIPNAME2; 	// UDPHS Name2 Register
N	AT91_REG	 UDPHS_IPFEATURES; 	// UDPHS Features Register
N	AT91_REG	 UDPHS_IPVERSION; 	// UDPHS Version Register
N	AT91S_UDPHS_EPT	 UDPHS_EPT[7]; 	// UDPHS Endpoint struct
N	AT91_REG	 Reserved3[72]; 	// 
N	AT91S_UDPHS_DMA	 UDPHS_DMA[6]; 	// UDPHS DMA channel struct (not use [0])
N} AT91S_UDPHS, *AT91PS_UDPHS;
N#else
S#define UDPHS_CTRL      (AT91_CAST(AT91_REG *) 	0x00000000) // (UDPHS_CTRL) UDPHS Control Register
S#define UDPHS_FNUM      (AT91_CAST(AT91_REG *) 	0x00000004) // (UDPHS_FNUM) UDPHS Frame Number Register
S#define UDPHS_IEN       (AT91_CAST(AT91_REG *) 	0x00000010) // (UDPHS_IEN) UDPHS Interrupt Enable Register
S#define UDPHS_INTSTA    (AT91_CAST(AT91_REG *) 	0x00000014) // (UDPHS_INTSTA) UDPHS Interrupt Status Register
S#define UDPHS_CLRINT    (AT91_CAST(AT91_REG *) 	0x00000018) // (UDPHS_CLRINT) UDPHS Clear Interrupt Register
S#define UDPHS_EPTRST    (AT91_CAST(AT91_REG *) 	0x0000001C) // (UDPHS_EPTRST) UDPHS Endpoints Reset Register
S#define UDPHS_TSTSOFCNT (AT91_CAST(AT91_REG *) 	0x000000D0) // (UDPHS_TSTSOFCNT) UDPHS Test SOF Counter Register
S#define UDPHS_TSTCNTA   (AT91_CAST(AT91_REG *) 	0x000000D4) // (UDPHS_TSTCNTA) UDPHS Test A Counter Register
S#define UDPHS_TSTCNTB   (AT91_CAST(AT91_REG *) 	0x000000D8) // (UDPHS_TSTCNTB) UDPHS Test B Counter Register
S#define UDPHS_TSTMODREG (AT91_CAST(AT91_REG *) 	0x000000DC) // (UDPHS_TSTMODREG) UDPHS Test Mode Register
S#define UDPHS_TST       (AT91_CAST(AT91_REG *) 	0x000000E0) // (UDPHS_TST) UDPHS Test Register
S#define UDPHS_RIPPADDRSIZE (AT91_CAST(AT91_REG *) 	0x000000EC) // (UDPHS_RIPPADDRSIZE) UDPHS PADDRSIZE Register
S#define UDPHS_RIPNAME1  (AT91_CAST(AT91_REG *) 	0x000000F0) // (UDPHS_RIPNAME1) UDPHS Name1 Register
S#define UDPHS_RIPNAME2  (AT91_CAST(AT91_REG *) 	0x000000F4) // (UDPHS_RIPNAME2) UDPHS Name2 Register
S#define UDPHS_IPFEATURES (AT91_CAST(AT91_REG *) 	0x000000F8) // (UDPHS_IPFEATURES) UDPHS Features Register
S#define UDPHS_IPVERSION (AT91_CAST(AT91_REG *) 	0x000000FC) // (UDPHS_IPVERSION) UDPHS Version Register
S
N#endif
N// -------- UDPHS_CTRL : (UDPHS Offset: 0x0) UDPHS Control Register -------- 
N#define AT91C_UDPHS_DEV_ADDR  (0x7F <<  0) // (UDPHS) UDPHS Address
N#define AT91C_UDPHS_FADDR_EN  (0x1 <<  7) // (UDPHS) Function Address Enable
N#define AT91C_UDPHS_EN_UDPHS  (0x1 <<  8) // (UDPHS) UDPHS Enable
N#define AT91C_UDPHS_DETACH    (0x1 <<  9) // (UDPHS) Detach Command
N#define AT91C_UDPHS_REWAKEUP  (0x1 << 10) // (UDPHS) Send Remote Wake Up
N#define AT91C_UDPHS_PULLD_DIS (0x1 << 11) // (UDPHS) PullDown Disable
N// -------- UDPHS_FNUM : (UDPHS Offset: 0x4) UDPHS Frame Number Register -------- 
N#define AT91C_UDPHS_MICRO_FRAME_NUM (0x7 <<  0) // (UDPHS) Micro Frame Number
N#define AT91C_UDPHS_FRAME_NUMBER (0x7FF <<  3) // (UDPHS) Frame Number as defined in the Packet Field Formats
N#define AT91C_UDPHS_FNUM_ERR  (0x1 << 31) // (UDPHS) Frame Number CRC Error
N// -------- UDPHS_IEN : (UDPHS Offset: 0x10) UDPHS Interrupt Enable Register -------- 
N#define AT91C_UDPHS_DET_SUSPD (0x1 <<  1) // (UDPHS) Suspend Interrupt Enable/Clear/Status
N#define AT91C_UDPHS_MICRO_SOF (0x1 <<  2) // (UDPHS) Micro-SOF Interrupt Enable/Clear/Status
N#define AT91C_UDPHS_IEN_SOF   (0x1 <<  3) // (UDPHS) SOF Interrupt Enable/Clear/Status
N#define AT91C_UDPHS_ENDRESET  (0x1 <<  4) // (UDPHS) End Of Reset Interrupt Enable/Clear/Status
N#define AT91C_UDPHS_WAKE_UP   (0x1 <<  5) // (UDPHS) Wake Up CPU Interrupt Enable/Clear/Status
N#define AT91C_UDPHS_ENDOFRSM  (0x1 <<  6) // (UDPHS) End Of Resume Interrupt Enable/Clear/Status
N#define AT91C_UDPHS_UPSTR_RES (0x1 <<  7) // (UDPHS) Upstream Resume Interrupt Enable/Clear/Status
N#define AT91C_UDPHS_EPT_INT_0 (0x1 <<  8) // (UDPHS) Endpoint 0 Interrupt Enable/Status
N#define AT91C_UDPHS_EPT_INT_1 (0x1 <<  9) // (UDPHS) Endpoint 1 Interrupt Enable/Status
N#define AT91C_UDPHS_EPT_INT_2 (0x1 << 10) // (UDPHS) Endpoint 2 Interrupt Enable/Status
N#define AT91C_UDPHS_EPT_INT_3 (0x1 << 11) // (UDPHS) Endpoint 3 Interrupt Enable/Status
N#define AT91C_UDPHS_EPT_INT_4 (0x1 << 12) // (UDPHS) Endpoint 4 Interrupt Enable/Status
N#define AT91C_UDPHS_EPT_INT_5 (0x1 << 13) // (UDPHS) Endpoint 5 Interrupt Enable/Status
N#define AT91C_UDPHS_EPT_INT_6 (0x1 << 14) // (UDPHS) Endpoint 6 Interrupt Enable/Status
N#define AT91C_UDPHS_DMA_INT_1 (0x1 << 25) // (UDPHS) DMA Channel 1 Interrupt Enable/Status
N#define AT91C_UDPHS_DMA_INT_2 (0x1 << 26) // (UDPHS) DMA Channel 2 Interrupt Enable/Status
N#define AT91C_UDPHS_DMA_INT_3 (0x1 << 27) // (UDPHS) DMA Channel 3 Interrupt Enable/Status
N#define AT91C_UDPHS_DMA_INT_4 (0x1 << 28) // (UDPHS) DMA Channel 4 Interrupt Enable/Status
N#define AT91C_UDPHS_DMA_INT_5 (0x1 << 29) // (UDPHS) DMA Channel 5 Interrupt Enable/Status
N#define AT91C_UDPHS_DMA_INT_6 (0x1 << 30) // (UDPHS) DMA Channel 6 Interrupt Enable/Status
N// -------- UDPHS_INTSTA : (UDPHS Offset: 0x14) UDPHS Interrupt Status Register -------- 
N#define AT91C_UDPHS_SPEED     (0x1 <<  0) // (UDPHS) Speed Status
N// -------- UDPHS_CLRINT : (UDPHS Offset: 0x18) UDPHS Clear Interrupt Register -------- 
N// -------- UDPHS_EPTRST : (UDPHS Offset: 0x1c) UDPHS Endpoints Reset Register -------- 
N#define AT91C_UDPHS_RST_EPT_0 (0x1 <<  0) // (UDPHS) Endpoint Reset 0
N#define AT91C_UDPHS_RST_EPT_1 (0x1 <<  1) // (UDPHS) Endpoint Reset 1
N#define AT91C_UDPHS_RST_EPT_2 (0x1 <<  2) // (UDPHS) Endpoint Reset 2
N#define AT91C_UDPHS_RST_EPT_3 (0x1 <<  3) // (UDPHS) Endpoint Reset 3
N#define AT91C_UDPHS_RST_EPT_4 (0x1 <<  4) // (UDPHS) Endpoint Reset 4
N#define AT91C_UDPHS_RST_EPT_5 (0x1 <<  5) // (UDPHS) Endpoint Reset 5
N#define AT91C_UDPHS_RST_EPT_6 (0x1 <<  6) // (UDPHS) Endpoint Reset 6
N// -------- UDPHS_TSTSOFCNT : (UDPHS Offset: 0xd0) UDPHS Test SOF Counter Register -------- 
N#define AT91C_UDPHS_SOFCNTMAX (0x3 <<  0) // (UDPHS) SOF Counter Max Value
N#define AT91C_UDPHS_SOFCTLOAD (0x1 <<  7) // (UDPHS) SOF Counter Load
N// -------- UDPHS_TSTCNTA : (UDPHS Offset: 0xd4) UDPHS Test A Counter Register -------- 
N#define AT91C_UDPHS_CNTAMAX   (0x7FFF <<  0) // (UDPHS) A Counter Max Value
N#define AT91C_UDPHS_CNTALOAD  (0x1 << 15) // (UDPHS) A Counter Load
N// -------- UDPHS_TSTCNTB : (UDPHS Offset: 0xd8) UDPHS Test B Counter Register -------- 
N#define AT91C_UDPHS_CNTBMAX   (0x7FFF <<  0) // (UDPHS) B Counter Max Value
N#define AT91C_UDPHS_CNTBLOAD  (0x1 << 15) // (UDPHS) B Counter Load
N// -------- UDPHS_TSTMODREG : (UDPHS Offset: 0xdc) UDPHS Test Mode Register -------- 
N#define AT91C_UDPHS_TSTMODE   (0x1F <<  1) // (UDPHS) UDPHS Core TestModeReg
N// -------- UDPHS_TST : (UDPHS Offset: 0xe0) UDPHS Test Register -------- 
N#define AT91C_UDPHS_SPEED_CFG (0x3 <<  0) // (UDPHS) Speed Configuration
N#define 	AT91C_UDPHS_SPEED_CFG_NM                   (0x0) // (UDPHS) Normal Mode
N#define 	AT91C_UDPHS_SPEED_CFG_RS                   (0x1) // (UDPHS) Reserved
N#define 	AT91C_UDPHS_SPEED_CFG_HS                   (0x2) // (UDPHS) Force High Speed
N#define 	AT91C_UDPHS_SPEED_CFG_FS                   (0x3) // (UDPHS) Force Full-Speed
N#define AT91C_UDPHS_TST_J     (0x1 <<  2) // (UDPHS) TestJMode
N#define AT91C_UDPHS_TST_K     (0x1 <<  3) // (UDPHS) TestKMode
N#define AT91C_UDPHS_TST_PKT   (0x1 <<  4) // (UDPHS) TestPacketMode
N#define AT91C_UDPHS_OPMODE2   (0x1 <<  5) // (UDPHS) OpMode2
N// -------- UDPHS_RIPPADDRSIZE : (UDPHS Offset: 0xec) UDPHS PADDRSIZE Register -------- 
N#define AT91C_UDPHS_IPPADDRSIZE (0x0 <<  0) // (UDPHS) 2^UDPHSDEV_PADDR_SIZE
N// -------- UDPHS_RIPNAME1 : (UDPHS Offset: 0xf0) UDPHS Name Register -------- 
N#define AT91C_UDPHS_IPNAME1   (0x0 <<  0) // (UDPHS) ASCII string HUSB
N// -------- UDPHS_RIPNAME2 : (UDPHS Offset: 0xf4) UDPHS Name Register -------- 
N#define AT91C_UDPHS_IPNAME2   (0x0 <<  0) // (UDPHS) ASCII string 2DEV
N// -------- UDPHS_IPFEATURES : (UDPHS Offset: 0xf8) UDPHS Features Register -------- 
N#define AT91C_UDPHS_EPT_NBR_MAX (0xF <<  0) // (UDPHS) Max Number of Endpoints
N#define AT91C_UDPHS_DMA_CHANNEL_NBR (0x7 <<  4) // (UDPHS) Number of DMA Channels
N#define AT91C_UDPHS_DMA_B_SIZ (0x1 <<  7) // (UDPHS) DMA Buffer Size
N#define AT91C_UDPHS_DMA_FIFO_WORD_DEPTH (0xF <<  8) // (UDPHS) DMA FIFO Depth in words
N#define AT91C_UDPHS_FIFO_MAX_SIZE (0x7 << 12) // (UDPHS) DPRAM size
N#define AT91C_UDPHS_BW_DPRAM  (0x1 << 15) // (UDPHS) DPRAM byte write capability
N#define AT91C_UDPHS_DATAB16_8 (0x1 << 16) // (UDPHS) UTMI DataBus16_8
N#define AT91C_UDPHS_ISO_EPT_1 (0x1 << 17) // (UDPHS) Endpoint 1 High Bandwidth Isochronous Capability
N#define AT91C_UDPHS_ISO_EPT_2 (0x1 << 18) // (UDPHS) Endpoint 2 High Bandwidth Isochronous Capability
N#define AT91C_UDPHS_ISO_EPT_5 (0x1 << 21) // (UDPHS) Endpoint 5 High Bandwidth Isochronous Capability
N#define AT91C_UDPHS_ISO_EPT_6 (0x1 << 22) // (UDPHS) Endpoint 6 High Bandwidth Isochronous Capability
N// -------- UDPHS_IPVERSION : (UDPHS Offset: 0xfc) UDPHS Version Register -------- 
N#define AT91C_UDPHS_VERSION_NUM (0xFFFF <<  0) // (UDPHS) Give the IP version
N#define AT91C_UDPHS_METAL_FIX_NUM (0x7 << 16) // (UDPHS) Give the number of metal fixes
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR AC97 Controller Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_AC97C {
N	AT91_REG	 Reserved0[2]; 	// 
N	AT91_REG	 AC97C_MR; 	// Mode Register
N	AT91_REG	 Reserved1[1]; 	// 
N	AT91_REG	 AC97C_ICA; 	// Input Channel AssignementRegister
N	AT91_REG	 AC97C_OCA; 	// Output Channel Assignement Register
N	AT91_REG	 Reserved2[2]; 	// 
N	AT91_REG	 AC97C_CARHR; 	// Channel A Receive Holding Register
N	AT91_REG	 AC97C_CATHR; 	// Channel A Transmit Holding Register
N	AT91_REG	 AC97C_CASR; 	// Channel A Status Register
N	AT91_REG	 AC97C_CAMR; 	// Channel A Mode Register
N	AT91_REG	 AC97C_CBRHR; 	// Channel B Receive Holding Register (optional)
N	AT91_REG	 AC97C_CBTHR; 	// Channel B Transmit Holding Register (optional)
N	AT91_REG	 AC97C_CBSR; 	// Channel B Status Register
N	AT91_REG	 AC97C_CBMR; 	// Channel B Mode Register
N	AT91_REG	 AC97C_CORHR; 	// COdec Transmit Holding Register
N	AT91_REG	 AC97C_COTHR; 	// COdec Transmit Holding Register
N	AT91_REG	 AC97C_COSR; 	// CODEC Status Register
N	AT91_REG	 AC97C_COMR; 	// CODEC Mask Status Register
N	AT91_REG	 AC97C_SR; 	// Status Register
N	AT91_REG	 AC97C_IER; 	// Interrupt Enable Register
N	AT91_REG	 AC97C_IDR; 	// Interrupt Disable Register
N	AT91_REG	 AC97C_IMR; 	// Interrupt Mask Register
N	AT91_REG	 Reserved3[39]; 	// 
N	AT91_REG	 AC97C_VERSION; 	// Version Register
N	AT91_REG	 AC97C_RPR; 	// Receive Pointer Register
N	AT91_REG	 AC97C_RCR; 	// Receive Counter Register
N	AT91_REG	 AC97C_TPR; 	// Transmit Pointer Register
N	AT91_REG	 AC97C_TCR; 	// Transmit Counter Register
N	AT91_REG	 AC97C_RNPR; 	// Receive Next Pointer Register
N	AT91_REG	 AC97C_RNCR; 	// Receive Next Counter Register
N	AT91_REG	 AC97C_TNPR; 	// Transmit Next Pointer Register
N	AT91_REG	 AC97C_TNCR; 	// Transmit Next Counter Register
N	AT91_REG	 AC97C_PTCR; 	// PDC Transfer Control Register
N	AT91_REG	 AC97C_PTSR; 	// PDC Transfer Status Register
N} AT91S_AC97C, *AT91PS_AC97C;
N#else
S#define AC97C_MR        (AT91_CAST(AT91_REG *) 	0x00000008) // (AC97C_MR) Mode Register
S#define AC97C_ICA       (AT91_CAST(AT91_REG *) 	0x00000010) // (AC97C_ICA) Input Channel AssignementRegister
S#define AC97C_OCA       (AT91_CAST(AT91_REG *) 	0x00000014) // (AC97C_OCA) Output Channel Assignement Register
S#define AC97C_CARHR     (AT91_CAST(AT91_REG *) 	0x00000020) // (AC97C_CARHR) Channel A Receive Holding Register
S#define AC97C_CATHR     (AT91_CAST(AT91_REG *) 	0x00000024) // (AC97C_CATHR) Channel A Transmit Holding Register
S#define AC97C_CASR      (AT91_CAST(AT91_REG *) 	0x00000028) // (AC97C_CASR) Channel A Status Register
S#define AC97C_CAMR      (AT91_CAST(AT91_REG *) 	0x0000002C) // (AC97C_CAMR) Channel A Mode Register
S#define AC97C_CBRHR     (AT91_CAST(AT91_REG *) 	0x00000030) // (AC97C_CBRHR) Channel B Receive Holding Register (optional)
S#define AC97C_CBTHR     (AT91_CAST(AT91_REG *) 	0x00000034) // (AC97C_CBTHR) Channel B Transmit Holding Register (optional)
S#define AC97C_CBSR      (AT91_CAST(AT91_REG *) 	0x00000038) // (AC97C_CBSR) Channel B Status Register
S#define AC97C_CBMR      (AT91_CAST(AT91_REG *) 	0x0000003C) // (AC97C_CBMR) Channel B Mode Register
S#define AC97C_CORHR     (AT91_CAST(AT91_REG *) 	0x00000040) // (AC97C_CORHR) COdec Transmit Holding Register
S#define AC97C_COTHR     (AT91_CAST(AT91_REG *) 	0x00000044) // (AC97C_COTHR) COdec Transmit Holding Register
S#define AC97C_COSR      (AT91_CAST(AT91_REG *) 	0x00000048) // (AC97C_COSR) CODEC Status Register
S#define AC97C_COMR      (AT91_CAST(AT91_REG *) 	0x0000004C) // (AC97C_COMR) CODEC Mask Status Register
S#define AC97C_SR        (AT91_CAST(AT91_REG *) 	0x00000050) // (AC97C_SR) Status Register
S#define AC97C_IER       (AT91_CAST(AT91_REG *) 	0x00000054) // (AC97C_IER) Interrupt Enable Register
S#define AC97C_IDR       (AT91_CAST(AT91_REG *) 	0x00000058) // (AC97C_IDR) Interrupt Disable Register
S#define AC97C_IMR       (AT91_CAST(AT91_REG *) 	0x0000005C) // (AC97C_IMR) Interrupt Mask Register
S#define AC97C_VERSION   (AT91_CAST(AT91_REG *) 	0x000000FC) // (AC97C_VERSION) Version Register
S
N#endif
N// -------- AC97C_MR : (AC97C Offset: 0x8) AC97C Mode Register -------- 
N#define AT91C_AC97C_ENA       (0x1 <<  0) // (AC97C) AC97 Controller Global Enable
N#define AT91C_AC97C_WRST      (0x1 <<  1) // (AC97C) Warm Reset
N#define AT91C_AC97C_VRA       (0x1 <<  2) // (AC97C) Variable RAte (for Data Slots)
N// -------- AC97C_ICA : (AC97C Offset: 0x10) AC97C Input Channel Assignement Register -------- 
N#define AT91C_AC97C_CHID3     (0x7 <<  0) // (AC97C) Channel Id for the input slot 3
N#define 	AT91C_AC97C_CHID3_NONE                 (0x0) // (AC97C) No data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID3_CA                   (0x1) // (AC97C) Channel A data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID3_CB                   (0x2) // (AC97C) Channel B data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID3_CC                   (0x3) // (AC97C) Channel C data will be transmitted during this slot
N#define AT91C_AC97C_CHID4     (0x7 <<  3) // (AC97C) Channel Id for the input slot 4
N#define 	AT91C_AC97C_CHID4_NONE                 (0x0 <<  3) // (AC97C) No data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID4_CA                   (0x1 <<  3) // (AC97C) Channel A data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID4_CB                   (0x2 <<  3) // (AC97C) Channel B data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID4_CC                   (0x3 <<  3) // (AC97C) Channel C data will be transmitted during this slot
N#define AT91C_AC97C_CHID5     (0x7 <<  6) // (AC97C) Channel Id for the input slot 5
N#define 	AT91C_AC97C_CHID5_NONE                 (0x0 <<  6) // (AC97C) No data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID5_CA                   (0x1 <<  6) // (AC97C) Channel A data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID5_CB                   (0x2 <<  6) // (AC97C) Channel B data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID5_CC                   (0x3 <<  6) // (AC97C) Channel C data will be transmitted during this slot
N#define AT91C_AC97C_CHID6     (0x7 <<  9) // (AC97C) Channel Id for the input slot 6
N#define 	AT91C_AC97C_CHID6_NONE                 (0x0 <<  9) // (AC97C) No data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID6_CA                   (0x1 <<  9) // (AC97C) Channel A data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID6_CB                   (0x2 <<  9) // (AC97C) Channel B data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID6_CC                   (0x3 <<  9) // (AC97C) Channel C data will be transmitted during this slot
N#define AT91C_AC97C_CHID7     (0x7 << 12) // (AC97C) Channel Id for the input slot 7
N#define 	AT91C_AC97C_CHID7_NONE                 (0x0 << 12) // (AC97C) No data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID7_CA                   (0x1 << 12) // (AC97C) Channel A data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID7_CB                   (0x2 << 12) // (AC97C) Channel B data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID7_CC                   (0x3 << 12) // (AC97C) Channel C data will be transmitted during this slot
N#define AT91C_AC97C_CHID8     (0x7 << 15) // (AC97C) Channel Id for the input slot 8
N#define 	AT91C_AC97C_CHID8_NONE                 (0x0 << 15) // (AC97C) No data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID8_CA                   (0x1 << 15) // (AC97C) Channel A data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID8_CB                   (0x2 << 15) // (AC97C) Channel B data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID8_CC                   (0x3 << 15) // (AC97C) Channel C data will be transmitted during this slot
N#define AT91C_AC97C_CHID9     (0x7 << 18) // (AC97C) Channel Id for the input slot 9
N#define 	AT91C_AC97C_CHID9_NONE                 (0x0 << 18) // (AC97C) No data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID9_CA                   (0x1 << 18) // (AC97C) Channel A data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID9_CB                   (0x2 << 18) // (AC97C) Channel B data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID9_CC                   (0x3 << 18) // (AC97C) Channel C data will be transmitted during this slot
N#define AT91C_AC97C_CHID10    (0x7 << 21) // (AC97C) Channel Id for the input slot 10
N#define 	AT91C_AC97C_CHID10_NONE                 (0x0 << 21) // (AC97C) No data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID10_CA                   (0x1 << 21) // (AC97C) Channel A data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID10_CB                   (0x2 << 21) // (AC97C) Channel B data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID10_CC                   (0x3 << 21) // (AC97C) Channel C data will be transmitted during this slot
N#define AT91C_AC97C_CHID11    (0x7 << 24) // (AC97C) Channel Id for the input slot 11
N#define 	AT91C_AC97C_CHID11_NONE                 (0x0 << 24) // (AC97C) No data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID11_CA                   (0x1 << 24) // (AC97C) Channel A data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID11_CB                   (0x2 << 24) // (AC97C) Channel B data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID11_CC                   (0x3 << 24) // (AC97C) Channel C data will be transmitted during this slot
N#define AT91C_AC97C_CHID12    (0x7 << 27) // (AC97C) Channel Id for the input slot 12
N#define 	AT91C_AC97C_CHID12_NONE                 (0x0 << 27) // (AC97C) No data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID12_CA                   (0x1 << 27) // (AC97C) Channel A data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID12_CB                   (0x2 << 27) // (AC97C) Channel B data will be transmitted during this slot
N#define 	AT91C_AC97C_CHID12_CC                   (0x3 << 27) // (AC97C) Channel C data will be transmitted during this slot
N// -------- AC97C_OCA : (AC97C Offset: 0x14) AC97C Output Channel Assignement Register -------- 
N// -------- AC97C_CARHR : (AC97C Offset: 0x20) AC97C Channel A Receive Holding Register -------- 
N#define AT91C_AC97C_RDATA     (0xFFFFF <<  0) // (AC97C) Receive data
N// -------- AC97C_CATHR : (AC97C Offset: 0x24) AC97C Channel A Transmit Holding Register -------- 
N#define AT91C_AC97C_TDATA     (0xFFFFF <<  0) // (AC97C) Transmit data
N// -------- AC97C_CASR : (AC97C Offset: 0x28) AC97C Channel A Status Register -------- 
N#define AT91C_AC97C_TXRDY     (0x1 <<  0) // (AC97C) 
N#define AT91C_AC97C_TXEMPTY   (0x1 <<  1) // (AC97C) 
N#define AT91C_AC97C_UNRUN     (0x1 <<  2) // (AC97C) 
N#define AT91C_AC97C_RXRDY     (0x1 <<  4) // (AC97C) 
N#define AT91C_AC97C_OVRUN     (0x1 <<  5) // (AC97C) 
N#define AT91C_AC97C_ENDTX     (0x1 << 10) // (AC97C) 
N#define AT91C_AC97C_TXBUFE    (0x1 << 11) // (AC97C) 
N#define AT91C_AC97C_ENDRX     (0x1 << 14) // (AC97C) 
N#define AT91C_AC97C_RXBUFF    (0x1 << 15) // (AC97C) 
N// -------- AC97C_CAMR : (AC97C Offset: 0x2c) AC97C Channel A Mode Register -------- 
N#define AT91C_AC97C_SIZE      (0x3 << 16) // (AC97C) 
N#define 	AT91C_AC97C_SIZE_20_BITS              (0x0 << 16) // (AC97C) Data size is 20 bits
N#define 	AT91C_AC97C_SIZE_18_BITS              (0x1 << 16) // (AC97C) Data size is 18 bits
N#define 	AT91C_AC97C_SIZE_16_BITS              (0x2 << 16) // (AC97C) Data size is 16 bits
N#define 	AT91C_AC97C_SIZE_10_BITS              (0x3 << 16) // (AC97C) Data size is 10 bits
N#define AT91C_AC97C_CEM       (0x1 << 18) // (AC97C) 
N#define AT91C_AC97C_CEN       (0x1 << 21) // (AC97C) 
N#define AT91C_AC97C_PDCEN     (0x1 << 22) // (AC97C) 
N// -------- AC97C_CBRHR : (AC97C Offset: 0x30) AC97C Channel B Receive Holding Register -------- 
N// -------- AC97C_CBTHR : (AC97C Offset: 0x34) AC97C Channel B Transmit Holding Register -------- 
N// -------- AC97C_CBSR : (AC97C Offset: 0x38) AC97C Channel B Status Register -------- 
N// -------- AC97C_CBMR : (AC97C Offset: 0x3c) AC97C Channel B Mode Register -------- 
N// -------- AC97C_CORHR : (AC97C Offset: 0x40) AC97C Codec Channel Receive Holding Register -------- 
N#define AT91C_AC97C_SDATA     (0xFFFF <<  0) // (AC97C) Status Data
N// -------- AC97C_COTHR : (AC97C Offset: 0x44) AC97C Codec Channel Transmit Holding Register -------- 
N#define AT91C_AC97C_CDATA     (0xFFFF <<  0) // (AC97C) Command Data
N#define AT91C_AC97C_CADDR     (0x7F << 16) // (AC97C) COdec control register index
N#define AT91C_AC97C_READ      (0x1 << 23) // (AC97C) Read/Write command
N// -------- AC97C_COSR : (AC97C Offset: 0x48) AC97C CODEC Status Register -------- 
N// -------- AC97C_COMR : (AC97C Offset: 0x4c) AC97C CODEC Mode Register -------- 
N// -------- AC97C_SR : (AC97C Offset: 0x50) AC97C Status Register -------- 
N#define AT91C_AC97C_SOF       (0x1 <<  0) // (AC97C) 
N#define AT91C_AC97C_WKUP      (0x1 <<  1) // (AC97C) 
N#define AT91C_AC97C_COEVT     (0x1 <<  2) // (AC97C) 
N#define AT91C_AC97C_CAEVT     (0x1 <<  3) // (AC97C) 
N#define AT91C_AC97C_CBEVT     (0x1 <<  4) // (AC97C) 
N// -------- AC97C_IER : (AC97C Offset: 0x54) AC97C Interrupt Enable Register -------- 
N// -------- AC97C_IDR : (AC97C Offset: 0x58) AC97C Interrupt Disable Register -------- 
N// -------- AC97C_IMR : (AC97C Offset: 0x5c) AC97C Interrupt Mask Register -------- 
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR LCD Controller
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_LCDC {
N	AT91_REG	 LCDC_BA1; 	// DMA Base Address Register 1
N	AT91_REG	 LCDC_BA2; 	// DMA Base Address Register 2
N	AT91_REG	 LCDC_FRMP1; 	// DMA Frame Pointer Register 1
N	AT91_REG	 LCDC_FRMP2; 	// DMA Frame Pointer Register 2
N	AT91_REG	 LCDC_FRMA1; 	// DMA Frame Address Register 1
N	AT91_REG	 LCDC_FRMA2; 	// DMA Frame Address Register 2
N	AT91_REG	 LCDC_FRMCFG; 	// DMA Frame Configuration Register
N	AT91_REG	 LCDC_DMACON; 	// DMA Control Register
N	AT91_REG	 LCDC_DMA2DCFG; 	// DMA 2D addressing configuration
N	AT91_REG	 Reserved0[503]; 	// 
N	AT91_REG	 LCDC_LCDCON1; 	// LCD Control 1 Register
N	AT91_REG	 LCDC_LCDCON2; 	// LCD Control 2 Register
N	AT91_REG	 LCDC_TIM1; 	// LCD Timing Config 1 Register
N	AT91_REG	 LCDC_TIM2; 	// LCD Timing Config 2 Register
N	AT91_REG	 LCDC_LCDFRCFG; 	// LCD Frame Config Register
N	AT91_REG	 LCDC_FIFO; 	// LCD FIFO Register
N	AT91_REG	 LCDC_MVAL; 	// LCD Mode Toggle Rate Value Register
N	AT91_REG	 LCDC_DP1_2; 	// Dithering Pattern DP1_2 Register
N	AT91_REG	 LCDC_DP4_7; 	// Dithering Pattern DP4_7 Register
N	AT91_REG	 LCDC_DP3_5; 	// Dithering Pattern DP3_5 Register
N	AT91_REG	 LCDC_DP2_3; 	// Dithering Pattern DP2_3 Register
N	AT91_REG	 LCDC_DP5_7; 	// Dithering Pattern DP5_7 Register
N	AT91_REG	 LCDC_DP3_4; 	// Dithering Pattern DP3_4 Register
N	AT91_REG	 LCDC_DP4_5; 	// Dithering Pattern DP4_5 Register
N	AT91_REG	 LCDC_DP6_7; 	// Dithering Pattern DP6_7 Register
N	AT91_REG	 LCDC_PWRCON; 	// Power Control Register
N	AT91_REG	 LCDC_CTRSTCON; 	// Contrast Control Register
N	AT91_REG	 LCDC_CTRSTVAL; 	// Contrast Value Register
N	AT91_REG	 LCDC_IER; 	// Interrupt Enable Register
N	AT91_REG	 LCDC_IDR; 	// Interrupt Disable Register
N	AT91_REG	 LCDC_IMR; 	// Interrupt Mask Register
N	AT91_REG	 LCDC_ISR; 	// Interrupt Enable Register
N	AT91_REG	 LCDC_ICR; 	// Interrupt Clear Register
N	AT91_REG	 LCDC_GPR; 	// General Purpose Register
N	AT91_REG	 LCDC_ITR; 	// Interrupts Test Register
N	AT91_REG	 LCDC_IRR; 	// Interrupts Raw Status Register
N	AT91_REG	 Reserved1[230]; 	// 
N	AT91_REG	 LCDC_LUT_ENTRY[256]; 	// LUT Entries Register
N} AT91S_LCDC, *AT91PS_LCDC;
N#else
S#define LCDC_BA1        (AT91_CAST(AT91_REG *) 	0x00000000) // (LCDC_BA1) DMA Base Address Register 1
S#define LCDC_BA2        (AT91_CAST(AT91_REG *) 	0x00000004) // (LCDC_BA2) DMA Base Address Register 2
S#define LCDC_FRMP1      (AT91_CAST(AT91_REG *) 	0x00000008) // (LCDC_FRMP1) DMA Frame Pointer Register 1
S#define LCDC_FRMP2      (AT91_CAST(AT91_REG *) 	0x0000000C) // (LCDC_FRMP2) DMA Frame Pointer Register 2
S#define LCDC_FRMA1      (AT91_CAST(AT91_REG *) 	0x00000010) // (LCDC_FRMA1) DMA Frame Address Register 1
S#define LCDC_FRMA2      (AT91_CAST(AT91_REG *) 	0x00000014) // (LCDC_FRMA2) DMA Frame Address Register 2
S#define LCDC_FRMCFG     (AT91_CAST(AT91_REG *) 	0x00000018) // (LCDC_FRMCFG) DMA Frame Configuration Register
S#define LCDC_DMACON     (AT91_CAST(AT91_REG *) 	0x0000001C) // (LCDC_DMACON) DMA Control Register
S#define LCDC_DMA2DCFG   (AT91_CAST(AT91_REG *) 	0x00000020) // (LCDC_DMA2DCFG) DMA 2D addressing configuration
S#define LCDC_LCDCON1    (AT91_CAST(AT91_REG *) 	0x00000800) // (LCDC_LCDCON1) LCD Control 1 Register
S#define LCDC_LCDCON2    (AT91_CAST(AT91_REG *) 	0x00000804) // (LCDC_LCDCON2) LCD Control 2 Register
S#define LCDC_TIM1       (AT91_CAST(AT91_REG *) 	0x00000808) // (LCDC_TIM1) LCD Timing Config 1 Register
S#define LCDC_TIM2       (AT91_CAST(AT91_REG *) 	0x0000080C) // (LCDC_TIM2) LCD Timing Config 2 Register
S#define LCDC_LCDFRCFG   (AT91_CAST(AT91_REG *) 	0x00000810) // (LCDC_LCDFRCFG) LCD Frame Config Register
S#define LCDC_FIFO       (AT91_CAST(AT91_REG *) 	0x00000814) // (LCDC_FIFO) LCD FIFO Register
S#define LCDC_MVAL       (AT91_CAST(AT91_REG *) 	0x00000818) // (LCDC_MVAL) LCD Mode Toggle Rate Value Register
S#define LCDC_DP1_2      (AT91_CAST(AT91_REG *) 	0x0000081C) // (LCDC_DP1_2) Dithering Pattern DP1_2 Register
S#define LCDC_DP4_7      (AT91_CAST(AT91_REG *) 	0x00000820) // (LCDC_DP4_7) Dithering Pattern DP4_7 Register
S#define LCDC_DP3_5      (AT91_CAST(AT91_REG *) 	0x00000824) // (LCDC_DP3_5) Dithering Pattern DP3_5 Register
S#define LCDC_DP2_3      (AT91_CAST(AT91_REG *) 	0x00000828) // (LCDC_DP2_3) Dithering Pattern DP2_3 Register
S#define LCDC_DP5_7      (AT91_CAST(AT91_REG *) 	0x0000082C) // (LCDC_DP5_7) Dithering Pattern DP5_7 Register
S#define LCDC_DP3_4      (AT91_CAST(AT91_REG *) 	0x00000830) // (LCDC_DP3_4) Dithering Pattern DP3_4 Register
S#define LCDC_DP4_5      (AT91_CAST(AT91_REG *) 	0x00000834) // (LCDC_DP4_5) Dithering Pattern DP4_5 Register
S#define LCDC_DP6_7      (AT91_CAST(AT91_REG *) 	0x00000838) // (LCDC_DP6_7) Dithering Pattern DP6_7 Register
S#define LCDC_PWRCON     (AT91_CAST(AT91_REG *) 	0x0000083C) // (LCDC_PWRCON) Power Control Register
S#define LCDC_CTRSTCON   (AT91_CAST(AT91_REG *) 	0x00000840) // (LCDC_CTRSTCON) Contrast Control Register
S#define LCDC_CTRSTVAL   (AT91_CAST(AT91_REG *) 	0x00000844) // (LCDC_CTRSTVAL) Contrast Value Register
S#define LCDC_IER        (AT91_CAST(AT91_REG *) 	0x00000848) // (LCDC_IER) Interrupt Enable Register
S#define LCDC_IDR        (AT91_CAST(AT91_REG *) 	0x0000084C) // (LCDC_IDR) Interrupt Disable Register
S#define LCDC_IMR        (AT91_CAST(AT91_REG *) 	0x00000850) // (LCDC_IMR) Interrupt Mask Register
S#define LCDC_ISR        (AT91_CAST(AT91_REG *) 	0x00000854) // (LCDC_ISR) Interrupt Enable Register
S#define LCDC_ICR        (AT91_CAST(AT91_REG *) 	0x00000858) // (LCDC_ICR) Interrupt Clear Register
S#define LCDC_GPR        (AT91_CAST(AT91_REG *) 	0x0000085C) // (LCDC_GPR) General Purpose Register
S#define LCDC_ITR        (AT91_CAST(AT91_REG *) 	0x00000860) // (LCDC_ITR) Interrupts Test Register
S#define LCDC_IRR        (AT91_CAST(AT91_REG *) 	0x00000864) // (LCDC_IRR) Interrupts Raw Status Register
S#define LCDC_LUT_ENTRY  (AT91_CAST(AT91_REG *) 	0x00000C00) // (LCDC_LUT_ENTRY) LUT Entries Register
S
N#endif
N// -------- LCDC_FRMP1 : (LCDC Offset: 0x8) DMA Frame Pointer 1 Register -------- 
N#define AT91C_LCDC_FRMPT1     (0x3FFFFF <<  0) // (LCDC) Frame Pointer Address 1
N// -------- LCDC_FRMP2 : (LCDC Offset: 0xc) DMA Frame Pointer 2 Register -------- 
N#define AT91C_LCDC_FRMPT2     (0x1FFFFF <<  0) // (LCDC) Frame Pointer Address 2
N// -------- LCDC_FRMCFG : (LCDC Offset: 0x18) DMA Frame Config Register -------- 
N#define AT91C_LCDC_FRSIZE     (0x7FFFFF <<  0) // (LCDC) FRAME SIZE
N#define AT91C_LCDC_BLENGTH    (0x7F << 24) // (LCDC) BURST LENGTH
N// -------- LCDC_DMACON : (LCDC Offset: 0x1c) DMA Control Register -------- 
N#define AT91C_LCDC_DMAEN      (0x1 <<  0) // (LCDC) DAM Enable
N#define AT91C_LCDC_DMARST     (0x1 <<  1) // (LCDC) DMA Reset (WO)
N#define AT91C_LCDC_DMABUSY    (0x1 <<  2) // (LCDC) DMA Reset (WO)
N#define AT91C_LCDC_DMAUPDT    (0x1 <<  3) // (LCDC) DMA Configuration Update
N#define AT91C_LCDC_DMA2DEN    (0x1 <<  4) // (LCDC) 2D Addressing Enable
N// -------- LCDC_DMA2DCFG : (LCDC Offset: 0x20) DMA 2D addressing configuration Register -------- 
N#define AT91C_LCDC_ADDRINC    (0xFFFF <<  0) // (LCDC) Number of 32b words that the DMA must jump when going to the next line
N#define AT91C_LCDC_PIXELOFF   (0x1F << 24) // (LCDC) Offset (in bits) of the first pixel of the screen in the memory word which contain it
N// -------- LCDC_LCDCON1 : (LCDC Offset: 0x800) LCD Control 1 Register -------- 
N#define AT91C_LCDC_BYPASS     (0x1 <<  0) // (LCDC) Bypass lcd_pccklk divider
N#define AT91C_LCDC_CLKVAL     (0x1FF << 12) // (LCDC) 9-bit Divider for pixel clock frequency
N#define AT91C_LCDC_LINCNT     (0x7FF << 21) // (LCDC) Line Counter (RO)
N// -------- LCDC_LCDCON2 : (LCDC Offset: 0x804) LCD Control 2 Register -------- 
N#define AT91C_LCDC_DISTYPE    (0x3 <<  0) // (LCDC) Display Type
N#define 	AT91C_LCDC_DISTYPE_STNMONO              (0x0) // (LCDC) STN Mono
N#define 	AT91C_LCDC_DISTYPE_STNCOLOR             (0x1) // (LCDC) STN Color
N#define 	AT91C_LCDC_DISTYPE_TFT                  (0x2) // (LCDC) TFT
N#define AT91C_LCDC_SCANMOD    (0x1 <<  2) // (LCDC) Scan Mode
N#define 	AT91C_LCDC_SCANMOD_SINGLESCAN           (0x0 <<  2) // (LCDC) Single Scan
N#define 	AT91C_LCDC_SCANMOD_DUALSCAN             (0x1 <<  2) // (LCDC) Dual Scan
N#define AT91C_LCDC_IFWIDTH    (0x3 <<  3) // (LCDC) Interface Width
N#define 	AT91C_LCDC_IFWIDTH_FOURBITSWIDTH        (0x0 <<  3) // (LCDC) 4 Bits
N#define 	AT91C_LCDC_IFWIDTH_EIGTHBITSWIDTH       (0x1 <<  3) // (LCDC) 8 Bits
N#define 	AT91C_LCDC_IFWIDTH_SIXTEENBITSWIDTH     (0x2 <<  3) // (LCDC) 16 Bits
N#define AT91C_LCDC_PIXELSIZE  (0x7 <<  5) // (LCDC) Bits per pixel
N#define 	AT91C_LCDC_PIXELSIZE_ONEBITSPERPIXEL      (0x0 <<  5) // (LCDC) 1 Bits
N#define 	AT91C_LCDC_PIXELSIZE_TWOBITSPERPIXEL      (0x1 <<  5) // (LCDC) 2 Bits
N#define 	AT91C_LCDC_PIXELSIZE_FOURBITSPERPIXEL     (0x2 <<  5) // (LCDC) 4 Bits
N#define 	AT91C_LCDC_PIXELSIZE_EIGTHBITSPERPIXEL    (0x3 <<  5) // (LCDC) 8 Bits
N#define 	AT91C_LCDC_PIXELSIZE_SIXTEENBITSPERPIXEL  (0x4 <<  5) // (LCDC) 16 Bits
N#define 	AT91C_LCDC_PIXELSIZE_TWENTYFOURBITSPERPIXEL (0x5 <<  5) // (LCDC) 24 Bits
N#define AT91C_LCDC_INVVD      (0x1 <<  8) // (LCDC) lcd datas polarity
N#define 	AT91C_LCDC_INVVD_NORMALPOL            (0x0 <<  8) // (LCDC) Normal Polarity
N#define 	AT91C_LCDC_INVVD_INVERTEDPOL          (0x1 <<  8) // (LCDC) Inverted Polarity
N#define AT91C_LCDC_INVFRAME   (0x1 <<  9) // (LCDC) lcd vsync polarity
N#define 	AT91C_LCDC_INVFRAME_NORMALPOL            (0x0 <<  9) // (LCDC) Normal Polarity
N#define 	AT91C_LCDC_INVFRAME_INVERTEDPOL          (0x1 <<  9) // (LCDC) Inverted Polarity
N#define AT91C_LCDC_INVLINE    (0x1 << 10) // (LCDC) lcd hsync polarity
N#define 	AT91C_LCDC_INVLINE_NORMALPOL            (0x0 << 10) // (LCDC) Normal Polarity
N#define 	AT91C_LCDC_INVLINE_INVERTEDPOL          (0x1 << 10) // (LCDC) Inverted Polarity
N#define AT91C_LCDC_INVCLK     (0x1 << 11) // (LCDC) lcd pclk polarity
N#define 	AT91C_LCDC_INVCLK_NORMALPOL            (0x0 << 11) // (LCDC) Normal Polarity
N#define 	AT91C_LCDC_INVCLK_INVERTEDPOL          (0x1 << 11) // (LCDC) Inverted Polarity
N#define AT91C_LCDC_INVDVAL    (0x1 << 12) // (LCDC) lcd dval polarity
N#define 	AT91C_LCDC_INVDVAL_NORMALPOL            (0x0 << 12) // (LCDC) Normal Polarity
N#define 	AT91C_LCDC_INVDVAL_INVERTEDPOL          (0x1 << 12) // (LCDC) Inverted Polarity
N#define AT91C_LCDC_CLKMOD     (0x1 << 15) // (LCDC) lcd pclk Mode
N#define 	AT91C_LCDC_CLKMOD_ACTIVEONLYDISP       (0x0 << 15) // (LCDC) Active during display period
N#define 	AT91C_LCDC_CLKMOD_ALWAYSACTIVE         (0x1 << 15) // (LCDC) Always Active
N#define AT91C_LCDC_MEMOR      (0x3 << 30) // (LCDC) Memory Ordering Format
N#define 	AT91C_LCDC_MEMOR_BIGIND               (0x0 << 30) // (LCDC) Big Endian
N#define 	AT91C_LCDC_MEMOR_LITTLEIND            (0x2 << 30) // (LCDC) Little Endian
N// -------- LCDC_TIM1 : (LCDC Offset: 0x808) LCDC Timing Config 1 Register -------- 
N#define AT91C_LCDC_VFP        (0xFF <<  0) // (LCDC) Vertical Front Porch
N#define AT91C_LCDC_VBP        (0xFF <<  8) // (LCDC) Vertical Back Porch
N#define AT91C_LCDC_VPW        (0x3F << 16) // (LCDC) Vertical Synchronization Pulse Width
N#define AT91C_LCDC_VHDLY      (0xF << 24) // (LCDC) Vertical to Horizontal Delay
N// -------- LCDC_TIM2 : (LCDC Offset: 0x80c) LCDC Timing Config 2 Register -------- 
N#define AT91C_LCDC_HBP        (0xFF <<  0) // (LCDC) Horizontal Back Porch
N#define AT91C_LCDC_HPW        (0x3F <<  8) // (LCDC) Horizontal Synchronization Pulse Width
N#define AT91C_LCDC_HFP        (0x7FF << 21) // (LCDC) Horizontal Front Porch
N// -------- LCDC_LCDFRCFG : (LCDC Offset: 0x810) LCD Frame Config Register -------- 
N#define AT91C_LCDC_LINEVAL    (0x7FF <<  0) // (LCDC) Vertical Size of LCD Module
N#define AT91C_LCDC_HOZVAL     (0x7FF << 21) // (LCDC) Horizontal Size of LCD Module
N// -------- LCDC_FIFO : (LCDC Offset: 0x814) LCD FIFO Register -------- 
N#define AT91C_LCDC_FIFOTH     (0xFFFF <<  0) // (LCDC) FIFO Threshold
N// -------- LCDC_MVAL : (LCDC Offset: 0x818) LCD Mode Toggle Rate Value Register -------- 
N#define AT91C_LCDC_MVALUE     (0xFF <<  0) // (LCDC) Toggle Rate Value
N#define AT91C_LCDC_MMODE      (0x1 << 31) // (LCDC) Toggle Rate Sel
N#define 	AT91C_LCDC_MMODE_EACHFRAME            (0x0 << 31) // (LCDC) Each Frame
N#define 	AT91C_LCDC_MMODE_MVALDEFINED          (0x1 << 31) // (LCDC) Defined by MVAL
N// -------- LCDC_DP1_2 : (LCDC Offset: 0x81c) Dithering Pattern 1/2 -------- 
N#define AT91C_LCDC_DP1_2_FIELD (0xFF <<  0) // (LCDC) Ratio
N// -------- LCDC_DP4_7 : (LCDC Offset: 0x820) Dithering Pattern 4/7 -------- 
N#define AT91C_LCDC_DP4_7_FIELD (0xFFFFFFF <<  0) // (LCDC) Ratio
N// -------- LCDC_DP3_5 : (LCDC Offset: 0x824) Dithering Pattern 3/5 -------- 
N#define AT91C_LCDC_DP3_5_FIELD (0xFFFFF <<  0) // (LCDC) Ratio
N// -------- LCDC_DP2_3 : (LCDC Offset: 0x828) Dithering Pattern 2/3 -------- 
N#define AT91C_LCDC_DP2_3_FIELD (0xFFF <<  0) // (LCDC) Ratio
N// -------- LCDC_DP5_7 : (LCDC Offset: 0x82c) Dithering Pattern 5/7 -------- 
N#define AT91C_LCDC_DP5_7_FIELD (0xFFFFFFF <<  0) // (LCDC) Ratio
N// -------- LCDC_DP3_4 : (LCDC Offset: 0x830) Dithering Pattern 3/4 -------- 
N#define AT91C_LCDC_DP3_4_FIELD (0xFFFF <<  0) // (LCDC) Ratio
N// -------- LCDC_DP4_5 : (LCDC Offset: 0x834) Dithering Pattern 4/5 -------- 
N#define AT91C_LCDC_DP4_5_FIELD (0xFFFFF <<  0) // (LCDC) Ratio
N// -------- LCDC_DP6_7 : (LCDC Offset: 0x838) Dithering Pattern 6/7 -------- 
N#define AT91C_LCDC_DP6_7_FIELD (0xFFFFFFF <<  0) // (LCDC) Ratio
N// -------- LCDC_PWRCON : (LCDC Offset: 0x83c) LCDC Power Control Register -------- 
N#define AT91C_LCDC_PWR        (0x1 <<  0) // (LCDC) LCD Module Power Control
N#define AT91C_LCDC_GUARDT     (0x7F <<  1) // (LCDC) Delay in Frame Period
N#define AT91C_LCDC_BUSY       (0x1 << 31) // (LCDC) Read Only : 1 indicates that LCDC is busy
N#define 	AT91C_LCDC_BUSY_LCDNOTBUSY           (0x0 << 31) // (LCDC) LCD is Not Busy
N#define 	AT91C_LCDC_BUSY_LCDBUSY              (0x1 << 31) // (LCDC) LCD is Busy
N// -------- LCDC_CTRSTCON : (LCDC Offset: 0x840) LCDC Contrast Control Register -------- 
N#define AT91C_LCDC_PS         (0x3 <<  0) // (LCDC) LCD Contrast Counter Prescaler
N#define 	AT91C_LCDC_PS_NOTDIVIDED           (0x0) // (LCDC) Counter Freq is System Freq.
N#define 	AT91C_LCDC_PS_DIVIDEDBYTWO         (0x1) // (LCDC) Counter Freq is System Freq divided by 2.
N#define 	AT91C_LCDC_PS_DIVIDEDBYFOUR        (0x2) // (LCDC) Counter Freq is System Freq divided by 4.
N#define 	AT91C_LCDC_PS_DIVIDEDBYEIGHT       (0x3) // (LCDC) Counter Freq is System Freq divided by 8.
N#define AT91C_LCDC_POL        (0x1 <<  2) // (LCDC) Polarity of output Pulse
N#define 	AT91C_LCDC_POL_NEGATIVEPULSE        (0x0 <<  2) // (LCDC) Negative Pulse
N#define 	AT91C_LCDC_POL_POSITIVEPULSE        (0x1 <<  2) // (LCDC) Positive Pulse
N#define AT91C_LCDC_ENA        (0x1 <<  3) // (LCDC) PWM generator Control
N#define 	AT91C_LCDC_ENA_PWMGEMDISABLED       (0x0 <<  3) // (LCDC) PWM Generator Disabled
N#define 	AT91C_LCDC_ENA_PWMGEMENABLED        (0x1 <<  3) // (LCDC) PWM Generator Disabled
N// -------- LCDC_CTRSTVAL : (LCDC Offset: 0x844) Contrast Value Register -------- 
N#define AT91C_LCDC_CVAL       (0xFF <<  0) // (LCDC) PWM Compare Value
N// -------- LCDC_IER : (LCDC Offset: 0x848) LCDC Interrupt Enable Register -------- 
N#define AT91C_LCDC_LNI        (0x1 <<  0) // (LCDC) Line Interrupt
N#define AT91C_LCDC_LSTLNI     (0x1 <<  1) // (LCDC) Last Line Interrupt
N#define AT91C_LCDC_EOFI       (0x1 <<  2) // (LCDC) End Of Frame Interrupt
N#define AT91C_LCDC_UFLWI      (0x1 <<  4) // (LCDC) FIFO Underflow Interrupt
N#define AT91C_LCDC_OWRI       (0x1 <<  5) // (LCDC) Over Write Interrupt
N#define AT91C_LCDC_MERI       (0x1 <<  6) // (LCDC) Memory Error  Interrupt
N// -------- LCDC_IDR : (LCDC Offset: 0x84c) LCDC Interrupt Disable Register -------- 
N// -------- LCDC_IMR : (LCDC Offset: 0x850) LCDC Interrupt Mask Register -------- 
N// -------- LCDC_ISR : (LCDC Offset: 0x854) LCDC Interrupt Status Register -------- 
N// -------- LCDC_ICR : (LCDC Offset: 0x858) LCDC Interrupt Clear Register -------- 
N// -------- LCDC_GPR : (LCDC Offset: 0x85c) LCDC General Purpose Register -------- 
N#define AT91C_LCDC_GPRBUS     (0xFF <<  0) // (LCDC) 8 bits available
N// -------- LCDC_ITR : (LCDC Offset: 0x860) Interrupts Test Register -------- 
N// -------- LCDC_IRR : (LCDC Offset: 0x864) Interrupts Raw Status Register -------- 
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR HDMA Channel structure
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_HDMA_CH {
N	AT91_REG	 HDMA_SADDR; 	// HDMA Channel Source Address Register
N	AT91_REG	 HDMA_DADDR; 	// HDMA Channel Destination Address Register
N	AT91_REG	 HDMA_DSCR; 	// HDMA Channel Descriptor Address Register
N	AT91_REG	 HDMA_CTRLA; 	// HDMA Channel Control A Register
N	AT91_REG	 HDMA_CTRLB; 	// HDMA Channel Control B Register
N	AT91_REG	 HDMA_CFG; 	// HDMA Channel Configuration Register
N	AT91_REG	 HDMA_SPIP; 	// HDMA Channel Source Picture in Picture Configuration Register
N	AT91_REG	 HDMA_DPIP; 	// HDMA Channel Destination Picture in Picture Configuration Register
N	AT91_REG	 HDMA_BDSCR; 	// HDMA Reserved
N	AT91_REG	 HDMA_CADDR; 	// HDMA Reserved
N} AT91S_HDMA_CH, *AT91PS_HDMA_CH;
N#else
S#define HDMA_SADDR      (AT91_CAST(AT91_REG *) 	0x00000000) // (HDMA_SADDR) HDMA Channel Source Address Register
S#define HDMA_DADDR      (AT91_CAST(AT91_REG *) 	0x00000004) // (HDMA_DADDR) HDMA Channel Destination Address Register
S#define HDMA_DSCR       (AT91_CAST(AT91_REG *) 	0x00000008) // (HDMA_DSCR) HDMA Channel Descriptor Address Register
S#define HDMA_CTRLA      (AT91_CAST(AT91_REG *) 	0x0000000C) // (HDMA_CTRLA) HDMA Channel Control A Register
S#define HDMA_CTRLB      (AT91_CAST(AT91_REG *) 	0x00000010) // (HDMA_CTRLB) HDMA Channel Control B Register
S#define HDMA_CFG        (AT91_CAST(AT91_REG *) 	0x00000014) // (HDMA_CFG) HDMA Channel Configuration Register
S#define HDMA_SPIP       (AT91_CAST(AT91_REG *) 	0x00000018) // (HDMA_SPIP) HDMA Channel Source Picture in Picture Configuration Register
S#define HDMA_DPIP       (AT91_CAST(AT91_REG *) 	0x0000001C) // (HDMA_DPIP) HDMA Channel Destination Picture in Picture Configuration Register
S#define HDMA_BDSCR      (AT91_CAST(AT91_REG *) 	0x00000020) // (HDMA_BDSCR) HDMA Reserved
S#define HDMA_CADDR      (AT91_CAST(AT91_REG *) 	0x00000024) // (HDMA_CADDR) HDMA Reserved
S
N#endif
N// -------- HDMA_SADDR : (HDMA_CH Offset: 0x0)  -------- 
N#define AT91C_SADDR           (0x0 <<  0) // (HDMA_CH) 
N// -------- HDMA_DADDR : (HDMA_CH Offset: 0x4)  -------- 
N#define AT91C_DADDR           (0x0 <<  0) // (HDMA_CH) 
N// -------- HDMA_DSCR : (HDMA_CH Offset: 0x8)  -------- 
N#define AT91C_HDMA_DSCR_IF    (0x3 <<  0) // (HDMA_CH) Select AHB-Lite Interface for current channel
N#define 	AT91C_HDMA_DSCR_IF_0                    (0x0) // (HDMA_CH) The Buffer Transfer descriptor is fetched via AHB-Lite Interface 0.
N#define 	AT91C_HDMA_DSCR_IF_1                    (0x1) // (HDMA_CH) The Buffer Transfer descriptor is fetched via AHB-Lite Interface 1.
N#define 	AT91C_HDMA_DSCR_IF_2                    (0x2) // (HDMA_CH) The Buffer Transfer descriptor is fetched via AHB-Lite Interface 2.
N#define 	AT91C_HDMA_DSCR_IF_3                    (0x3) // (HDMA_CH) The Buffer Transfer descriptor is fetched via AHB-Lite Interface 3.
N#define AT91C_HDMA_DSCR       (0x3FFFFFFF <<  2) // (HDMA_CH) Buffer Transfer descriptor address. This address is word aligned.
N// -------- HDMA_CTRLA : (HDMA_CH Offset: 0xc)  -------- 
N#define AT91C_HDMA_BTSIZE     (0xFFFF <<  0) // (HDMA_CH) Buffer Transfer Size.
N#define AT91C_HDMA_SCSIZE     (0x7 << 16) // (HDMA_CH) Source Chunk Transfer Size.
N#define 	AT91C_HDMA_SCSIZE_1                    (0x0 << 16) // (HDMA_CH) 1.
N#define 	AT91C_HDMA_SCSIZE_4                    (0x1 << 16) // (HDMA_CH) 4.
N#define 	AT91C_HDMA_SCSIZE_8                    (0x2 << 16) // (HDMA_CH) 8.
N#define 	AT91C_HDMA_SCSIZE_16                   (0x3 << 16) // (HDMA_CH) 16.
N#define 	AT91C_HDMA_SCSIZE_32                   (0x4 << 16) // (HDMA_CH) 32.
N#define 	AT91C_HDMA_SCSIZE_64                   (0x5 << 16) // (HDMA_CH) 64.
N#define 	AT91C_HDMA_SCSIZE_128                  (0x6 << 16) // (HDMA_CH) 128.
N#define 	AT91C_HDMA_SCSIZE_256                  (0x7 << 16) // (HDMA_CH) 256.
N#define AT91C_HDMA_DCSIZE     (0x7 << 20) // (HDMA_CH) Destination Chunk Transfer Size
N#define 	AT91C_HDMA_DCSIZE_1                    (0x0 << 20) // (HDMA_CH) 1.
N#define 	AT91C_HDMA_DCSIZE_4                    (0x1 << 20) // (HDMA_CH) 4.
N#define 	AT91C_HDMA_DCSIZE_8                    (0x2 << 20) // (HDMA_CH) 8.
N#define 	AT91C_HDMA_DCSIZE_16                   (0x3 << 20) // (HDMA_CH) 16.
N#define 	AT91C_HDMA_DCSIZE_32                   (0x4 << 20) // (HDMA_CH) 32.
N#define 	AT91C_HDMA_DCSIZE_64                   (0x5 << 20) // (HDMA_CH) 64.
N#define 	AT91C_HDMA_DCSIZE_128                  (0x6 << 20) // (HDMA_CH) 128.
N#define 	AT91C_HDMA_DCSIZE_256                  (0x7 << 20) // (HDMA_CH) 256.
N#define AT91C_HDMA_SRC_WIDTH  (0x3 << 24) // (HDMA_CH) Source Single Transfer Size
N#define 	AT91C_HDMA_SRC_WIDTH_BYTE                 (0x0 << 24) // (HDMA_CH) BYTE.
N#define 	AT91C_HDMA_SRC_WIDTH_HALFWORD             (0x1 << 24) // (HDMA_CH) HALF-WORD.
N#define 	AT91C_HDMA_SRC_WIDTH_WORD                 (0x2 << 24) // (HDMA_CH) WORD.
N#define AT91C_HDMA_DST_WIDTH  (0x3 << 28) // (HDMA_CH) Destination Single Transfer Size
N#define 	AT91C_HDMA_DST_WIDTH_BYTE                 (0x0 << 28) // (HDMA_CH) BYTE.
N#define 	AT91C_HDMA_DST_WIDTH_HALFWORD             (0x1 << 28) // (HDMA_CH) HALF-WORD.
N#define 	AT91C_HDMA_DST_WIDTH_WORD                 (0x2 << 28) // (HDMA_CH) WORD.
N#define AT91C_HDMA_DONE       (0x80000000) // (0x1 << 31) // (HDMA_CH) 
N// -------- HDMA_CTRLB : (HDMA_CH Offset: 0x10)  -------- 
N#define AT91C_HDMA_SIF        (0x3 <<  0) // (HDMA_CH) Source Interface Selection Field.
N#define 	AT91C_HDMA_SIF_0                    (0x0) // (HDMA_CH) The Source Transfer is done via AHB-Lite Interface 0.
N#define 	AT91C_HDMA_SIF_1                    (0x1) // (HDMA_CH) The Source Transfer is done via AHB-Lite Interface 1.
N#define 	AT91C_HDMA_SIF_2                    (0x2) // (HDMA_CH) The Source Transfer is done via AHB-Lite Interface 2.
N#define 	AT91C_HDMA_SIF_3                    (0x3) // (HDMA_CH) The Source Transfer is done via AHB-Lite Interface 3.
N#define AT91C_HDMA_DIF        (0x3 <<  4) // (HDMA_CH) Destination Interface Selection Field.
N#define 	AT91C_HDMA_DIF_0                    (0x0 <<  4) // (HDMA_CH) The Destination Transfer is done via AHB-Lite Interface 0.
N#define 	AT91C_HDMA_DIF_1                    (0x1 <<  4) // (HDMA_CH) The Destination Transfer is done via AHB-Lite Interface 1.
N#define 	AT91C_HDMA_DIF_2                    (0x2 <<  4) // (HDMA_CH) The Destination Transfer is done via AHB-Lite Interface 2.
N#define 	AT91C_HDMA_DIF_3                    (0x3 <<  4) // (HDMA_CH) The Destination Transfer is done via AHB-Lite Interface 3.
N#define AT91C_HDMA_SRC_PIP    (0x1 <<  8) // (HDMA_CH) Source Picture-in-Picture Mode
N#define 	AT91C_HDMA_SRC_PIP_DISABLE              (0x0 <<  8) // (HDMA_CH) Source Picture-in-Picture mode is disabled.
N#define 	AT91C_HDMA_SRC_PIP_ENABLE               (0x1 <<  8) // (HDMA_CH) Source Picture-in-Picture mode is enabled.
N#define AT91C_HDMA_DST_PIP    (0x1 << 12) // (HDMA_CH) Destination Picture-in-Picture Mode
N#define 	AT91C_HDMA_DST_PIP_DISABLE              (0x0 << 12) // (HDMA_CH) Destination Picture-in-Picture mode is disabled.
N#define 	AT91C_HDMA_DST_PIP_ENABLE               (0x1 << 12) // (HDMA_CH) Destination Picture-in-Picture mode is enabled.
N#define AT91C_HDMA_SRC_DSCR   (0x1 << 16) // (HDMA_CH) Source Buffer Descriptor Fetch operation
N#define 	AT91C_HDMA_SRC_DSCR_FETCH_FROM_MEM       (0x0 << 16) // (HDMA_CH) Source address is updated when the descriptor is fetched from the memory.
N#define 	AT91C_HDMA_SRC_DSCR_FETCH_DISABLE        (0x1 << 16) // (HDMA_CH) Buffer Descriptor Fetch operation is disabled for the Source.
N#define AT91C_HDMA_DST_DSCR   (0x1 << 20) // (HDMA_CH) Destination Buffer Descriptor operation
N#define 	AT91C_HDMA_DST_DSCR_FETCH_FROM_MEM       (0x0 << 20) // (HDMA_CH) Destination address is updated when the descriptor is fetched from the memory.
N#define 	AT91C_HDMA_DST_DSCR_FETCH_DISABLE        (0x1 << 20) // (HDMA_CH) Buffer Descriptor Fetch operation is disabled for the destination.
N#define AT91C_HDMA_FC         (0x7 << 21) // (HDMA_CH) This field defines which devices controls the size of the buffer transfer, also referred as to the Flow Controller.
N#define 	AT91C_HDMA_FC_MEM2MEM              (0x0 << 21) // (HDMA_CH) Memory-to-Memory (DMA Controller).
N#define 	AT91C_HDMA_FC_MEM2PER              (0x1 << 21) // (HDMA_CH) Memory-to-Peripheral (DMA Controller).
N#define 	AT91C_HDMA_FC_PER2MEM              (0x2 << 21) // (HDMA_CH) Peripheral-to-Memory (DMA Controller).
N#define 	AT91C_HDMA_FC_PER2PER              (0x3 << 21) // (HDMA_CH) Peripheral-to-Peripheral (DMA Controller).
N#define 	AT91C_HDMA_FC_PER2MEM_PER          (0x4 << 21) // (HDMA_CH) Peripheral-to-Memory (Peripheral).
N#define 	AT91C_HDMA_FC_MEM2PER_PER          (0x5 << 21) // (HDMA_CH) Memory-to-Peripheral (Peripheral).
N#define 	AT91C_HDMA_FC_PER2PER_PER          (0x6 << 21) // (HDMA_CH) Peripheral-to-Peripheral (Source Peripheral).
N#define AT91C_HDMA_SRC_ADDRESS_MODE (0x3 << 24) // (HDMA_CH) Type of addressing mode
N#define 	AT91C_HDMA_SRC_ADDRESS_MODE_INCR                 (0x0 << 24) // (HDMA_CH) Incrementing Mode.
N#define 	AT91C_HDMA_SRC_ADDRESS_MODE_DECR                 (0x1 << 24) // (HDMA_CH) Decrementing Mode.
N#define 	AT91C_HDMA_SRC_ADDRESS_MODE_FIXED                (0x2 << 24) // (HDMA_CH) Fixed Mode.
N#define AT91C_HDMA_DST_ADDRESS_MODE (0x3 << 28) // (HDMA_CH) Type of addressing mode
N#define 	AT91C_HDMA_DST_ADDRESS_MODE_INCR                 (0x0 << 28) // (HDMA_CH) Incrementing Mode.
N#define 	AT91C_HDMA_DST_ADDRESS_MODE_DECR                 (0x1 << 28) // (HDMA_CH) Decrementing Mode.
N#define 	AT91C_HDMA_DST_ADDRESS_MODE_FIXED                (0x2 << 28) // (HDMA_CH) Fixed Mode.
N#define AT91C_HDMA_AUTO       (0x1 << 31) // (HDMA_CH) Automatic multiple buffer transfer enable
N#define 	AT91C_HDMA_AUTO_DISABLE              (0x0 << 31) // (HDMA_CH) Automatic multiple buffer transfer is disabled.
N#define 	AT91C_HDMA_AUTO_ENABLE               (0x1 << 31) // (HDMA_CH) Automatic multiple buffer transfer is enabled. This enables replay mode or contiguous mode when several buffers are transferred.
N// -------- HDMA_CFG : (HDMA_CH Offset: 0x14)  -------- 
N#define AT91C_HDMA_SRC_PER    (0xF <<  0) // (HDMA_CH) Channel Source Request is associated with peripheral identifier coded SRC_PER handshaking interface.
N#define 	AT91C_HDMA_SRC_PER_0                    (0x0) // (HDMA_CH) HW Handshaking Interface number 0.
N#define 	AT91C_HDMA_SRC_PER_1                    (0x1) // (HDMA_CH) HW Handshaking Interface number 1.
N#define 	AT91C_HDMA_SRC_PER_2                    (0x2) // (HDMA_CH) HW Handshaking Interface number 2.
N#define 	AT91C_HDMA_SRC_PER_3                    (0x3) // (HDMA_CH) HW Handshaking Interface number 3.
N#define 	AT91C_HDMA_SRC_PER_4                    (0x4) // (HDMA_CH) HW Handshaking Interface number 4.
N#define 	AT91C_HDMA_SRC_PER_5                    (0x5) // (HDMA_CH) HW Handshaking Interface number 5.
N#define 	AT91C_HDMA_SRC_PER_6                    (0x6) // (HDMA_CH) HW Handshaking Interface number 6.
N#define 	AT91C_HDMA_SRC_PER_7                    (0x7) // (HDMA_CH) HW Handshaking Interface number 7.
N#define 	AT91C_HDMA_SRC_PER_8                    (0x8) // (HDMA_CH) HW Handshaking Interface number 8.
N#define 	AT91C_HDMA_SRC_PER_9                    (0x9) // (HDMA_CH) HW Handshaking Interface number 9.
N#define 	AT91C_HDMA_SRC_PER_10                   (0xA) // (HDMA_CH) HW Handshaking Interface number 10.
N#define 	AT91C_HDMA_SRC_PER_11                   (0xB) // (HDMA_CH) HW Handshaking Interface number 11.
N#define 	AT91C_HDMA_SRC_PER_12                   (0xC) // (HDMA_CH) HW Handshaking Interface number 12.
N#define 	AT91C_HDMA_SRC_PER_13                   (0xD) // (HDMA_CH) HW Handshaking Interface number 13.
N#define 	AT91C_HDMA_SRC_PER_14                   (0xE) // (HDMA_CH) HW Handshaking Interface number 14.
N#define 	AT91C_HDMA_SRC_PER_15                   (0xF) // (HDMA_CH) HW Handshaking Interface number 15.
N#define AT91C_HDMA_DST_PER    (0xF <<  4) // (HDMA_CH) Channel Destination Request is associated with peripheral identifier coded DST_PER handshaking interface.
N#define 	AT91C_HDMA_DST_PER_0                    (0x0 <<  4) // (HDMA_CH) HW Handshaking Interface number 0.
N#define 	AT91C_HDMA_DST_PER_1                    (0x1 <<  4) // (HDMA_CH) HW Handshaking Interface number 1.
N#define 	AT91C_HDMA_DST_PER_2                    (0x2 <<  4) // (HDMA_CH) HW Handshaking Interface number 2.
N#define 	AT91C_HDMA_DST_PER_3                    (0x3 <<  4) // (HDMA_CH) HW Handshaking Interface number 3.
N#define 	AT91C_HDMA_DST_PER_4                    (0x4 <<  4) // (HDMA_CH) HW Handshaking Interface number 4.
N#define 	AT91C_HDMA_DST_PER_5                    (0x5 <<  4) // (HDMA_CH) HW Handshaking Interface number 5.
N#define 	AT91C_HDMA_DST_PER_6                    (0x6 <<  4) // (HDMA_CH) HW Handshaking Interface number 6.
N#define 	AT91C_HDMA_DST_PER_7                    (0x7 <<  4) // (HDMA_CH) HW Handshaking Interface number 7.
N#define 	AT91C_HDMA_DST_PER_8                    (0x8 <<  4) // (HDMA_CH) HW Handshaking Interface number 8.
N#define 	AT91C_HDMA_DST_PER_9                    (0x9 <<  4) // (HDMA_CH) HW Handshaking Interface number 9.
N#define 	AT91C_HDMA_DST_PER_10                   (0xA <<  4) // (HDMA_CH) HW Handshaking Interface number 10.
N#define 	AT91C_HDMA_DST_PER_11                   (0xB <<  4) // (HDMA_CH) HW Handshaking Interface number 11.
N#define 	AT91C_HDMA_DST_PER_12                   (0xC <<  4) // (HDMA_CH) HW Handshaking Interface number 12.
N#define 	AT91C_HDMA_DST_PER_13                   (0xD <<  4) // (HDMA_CH) HW Handshaking Interface number 13.
N#define 	AT91C_HDMA_DST_PER_14                   (0xE <<  4) // (HDMA_CH) HW Handshaking Interface number 14.
N#define 	AT91C_HDMA_DST_PER_15                   (0xF <<  4) // (HDMA_CH) HW Handshaking Interface number 15.
N#define AT91C_HDMA_SRC_REP    (0x1 <<  8) // (HDMA_CH) Source Replay Mode
N#define 	AT91C_HDMA_SRC_REP_CONTIGUOUS_ADDR      (0x0 <<  8) // (HDMA_CH) When automatic mode is activated, source address is contiguous between two buffers.
N#define 	AT91C_HDMA_SRC_REP_RELOAD_ADDR          (0x1 <<  8) // (HDMA_CH) When automatic mode is activated, the source address and the control register are reloaded from previous transfer..
N#define AT91C_HDMA_SRC_H2SEL  (0x1 <<  9) // (HDMA_CH) Source Handshaking Mode
N#define 	AT91C_HDMA_SRC_H2SEL_SW                   (0x0 <<  9) // (HDMA_CH) Software handshaking interface is used to trigger a transfer request.
N#define 	AT91C_HDMA_SRC_H2SEL_HW                   (0x1 <<  9) // (HDMA_CH) Hardware handshaking interface is used to trigger a transfer request.
N#define AT91C_HDMA_DST_REP    (0x1 << 12) // (HDMA_CH) Destination Replay Mode
N#define 	AT91C_HDMA_DST_REP_CONTIGUOUS_ADDR      (0x0 << 12) // (HDMA_CH) When automatic mode is activated, destination address is contiguous between two buffers.
N#define 	AT91C_HDMA_DST_REP_RELOAD_ADDR          (0x1 << 12) // (HDMA_CH) When automatic mode is activated, the destination address and the control register are reloaded from previous transfer..
N#define AT91C_HDMA_DST_H2SEL  (0x1 << 13) // (HDMA_CH) Destination Handshaking Mode
N#define 	AT91C_HDMA_DST_H2SEL_SW                   (0x0 << 13) // (HDMA_CH) Software handshaking interface is used to trigger a transfer request.
N#define 	AT91C_HDMA_DST_H2SEL_HW                   (0x1 << 13) // (HDMA_CH) Hardware handshaking interface is used to trigger a transfer request.
N#define AT91C_HDMA_SOD        (0x1 << 16) // (HDMA_CH) STOP ON DONE
N#define 	AT91C_HDMA_SOD_DISABLE              (0x0 << 16) // (HDMA_CH) STOP ON DONE disabled, the descriptor fetch operation ignores DONE Field of CTRLA register.
N#define 	AT91C_HDMA_SOD_ENABLE               (0x1 << 16) // (HDMA_CH) STOP ON DONE activated, the DMAC module is automatically disabled if DONE FIELD is set to 1.
N#define AT91C_HDMA_LOCK_IF    (0x1 << 20) // (HDMA_CH) Interface Lock
N#define 	AT91C_HDMA_LOCK_IF_DISABLE              (0x0 << 20) // (HDMA_CH) Interface Lock capability is disabled.
N#define 	AT91C_HDMA_LOCK_IF_ENABLE               (0x1 << 20) // (HDMA_CH) Interface Lock capability is enabled.
N#define AT91C_HDMA_LOCK_B     (0x1 << 21) // (HDMA_CH) AHB Bus Lock
N#define 	AT91C_HDMA_LOCK_B_DISABLE              (0x0 << 21) // (HDMA_CH) AHB Bus Locking capability is disabled.
N#define 	AT91C_HDMA_LOCK_B_ENABLE               (0x1 << 21) // (HDMA_CH) AHB Bus Locking capability is enabled.
N#define AT91C_HDMA_LOCK_IF_L  (0x1 << 22) // (HDMA_CH) Master Interface Arbiter Lock
N#define 	AT91C_HDMA_LOCK_IF_L_CHUNK                (0x0 << 22) // (HDMA_CH) The Master Interface Arbiter is locked by the channel x for a chunk transfer.
N#define 	AT91C_HDMA_LOCK_IF_L_BUFFER               (0x1 << 22) // (HDMA_CH) The Master Interface Arbiter is locked by the channel x for a buffer transfer.
N#define AT91C_HDMA_AHB_PROT   (0x7 << 24) // (HDMA_CH) AHB Prot
N#define AT91C_HDMA_FIFOCFG    (0x3 << 28) // (HDMA_CH) FIFO Request Configuration
N#define 	AT91C_HDMA_FIFOCFG_LARGESTBURST         (0x0 << 28) // (HDMA_CH) The largest defined length AHB burst is performed on the destination AHB interface.
N#define 	AT91C_HDMA_FIFOCFG_HALFFIFO             (0x1 << 28) // (HDMA_CH) When half fifo size is available/filled a source/destination request is serviced.
N#define 	AT91C_HDMA_FIFOCFG_ENOUGHSPACE          (0x2 << 28) // (HDMA_CH) When there is enough space/data available to perfom a single AHB access then the request is serviced.
N// -------- HDMA_SPIP : (HDMA_CH Offset: 0x18)  -------- 
N#define AT91C_SPIP_HOLE       (0xFFFF <<  0) // (HDMA_CH) This field indicates the value to add to the address when the programmable boundary has been reached.
N#define AT91C_SPIP_BOUNDARY   (0x3FF << 16) // (HDMA_CH) This field indicates the number of source transfers to perform before the automatic address increment operation.
N// -------- HDMA_DPIP : (HDMA_CH Offset: 0x1c)  -------- 
N#define AT91C_DPIP_HOLE       (0xFFFF <<  0) // (HDMA_CH) This field indicates the value to add to the address when the programmable boundary has been reached.
N#define AT91C_DPIP_BOUNDARY   (0x3FF << 16) // (HDMA_CH) This field indicates the number of source transfers to perform before the automatic address increment operation.
N// -------- HDMA_BDSCR : (HDMA_CH Offset: 0x20)  -------- 
N// -------- HDMA_CADDR : (HDMA_CH Offset: 0x24)  -------- 
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR HDMA controller
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_HDMA {
N	AT91_REG	 HDMA_GCFG; 	// HDMA Global Configuration Register
N	AT91_REG	 HDMA_EN; 	// HDMA Controller Enable Register
N	AT91_REG	 HDMA_SREQ; 	// HDMA Software Single Request Register
N	AT91_REG	 HDMA_CREQ; 	// HDMA Software Chunk Transfer Request Register
N	AT91_REG	 HDMA_LAST; 	// HDMA Software Last Transfer Flag Register
N	AT91_REG	 HDMA_SYNC; 	// HDMA Request Synchronization Register
N	AT91_REG	 HDMA_EBCIER; 	// HDMA Error, Chained Buffer transfer completed and Buffer transfer completed Interrupt Enable register
N	AT91_REG	 HDMA_EBCIDR; 	// HDMA Error, Chained Buffer transfer completed and Buffer transfer completed Interrupt Disable register
N	AT91_REG	 HDMA_EBCIMR; 	// HDMA Error, Chained Buffer transfer completed and Buffer transfer completed Mask Register
N	AT91_REG	 HDMA_EBCISR; 	// HDMA Error, Chained Buffer transfer completed and Buffer transfer completed Status Register
N	AT91_REG	 HDMA_CHER; 	// HDMA Channel Handler Enable Register
N	AT91_REG	 HDMA_CHDR; 	// HDMA Channel Handler Disable Register
N	AT91_REG	 HDMA_CHSR; 	// HDMA Channel Handler Status Register
N	AT91_REG	 HDMA_RSVD0; 	// HDMA Reserved
N	AT91_REG	 HDMA_RSVD1; 	// HDMA Reserved
N	AT91S_HDMA_CH	 HDMA_CH[8]; 	// HDMA Channel structure
N} AT91S_HDMA, *AT91PS_HDMA;
N#else
S#define HDMA_GCFG       (AT91_CAST(AT91_REG *) 	0x00000000) // (HDMA_GCFG) HDMA Global Configuration Register
S#define HDMA_EN         (AT91_CAST(AT91_REG *) 	0x00000004) // (HDMA_EN) HDMA Controller Enable Register
S#define HDMA_SREQ       (AT91_CAST(AT91_REG *) 	0x00000008) // (HDMA_SREQ) HDMA Software Single Request Register
S#define HDMA_CREQ       (AT91_CAST(AT91_REG *) 	0x0000000C) // (HDMA_CREQ) HDMA Software Chunk Transfer Request Register
S#define HDMA_LAST       (AT91_CAST(AT91_REG *) 	0x00000010) // (HDMA_LAST) HDMA Software Last Transfer Flag Register
S#define HDMA_SYNC       (AT91_CAST(AT91_REG *) 	0x00000014) // (HDMA_SYNC) HDMA Request Synchronization Register
S#define HDMA_EBCIER     (AT91_CAST(AT91_REG *) 	0x00000018) // (HDMA_EBCIER) HDMA Error, Chained Buffer transfer completed and Buffer transfer completed Interrupt Enable register
S#define HDMA_EBCIDR     (AT91_CAST(AT91_REG *) 	0x0000001C) // (HDMA_EBCIDR) HDMA Error, Chained Buffer transfer completed and Buffer transfer completed Interrupt Disable register
S#define HDMA_EBCIMR     (AT91_CAST(AT91_REG *) 	0x00000020) // (HDMA_EBCIMR) HDMA Error, Chained Buffer transfer completed and Buffer transfer completed Mask Register
S#define HDMA_EBCISR     (AT91_CAST(AT91_REG *) 	0x00000024) // (HDMA_EBCISR) HDMA Error, Chained Buffer transfer completed and Buffer transfer completed Status Register
S#define HDMA_CHER       (AT91_CAST(AT91_REG *) 	0x00000028) // (HDMA_CHER) HDMA Channel Handler Enable Register
S#define HDMA_CHDR       (AT91_CAST(AT91_REG *) 	0x0000002C) // (HDMA_CHDR) HDMA Channel Handler Disable Register
S#define HDMA_CHSR       (AT91_CAST(AT91_REG *) 	0x00000030) // (HDMA_CHSR) HDMA Channel Handler Status Register
S#define HDMA_RSVD0      (AT91_CAST(AT91_REG *) 	0x00000034) // (HDMA_RSVD0) HDMA Reserved
S#define HDMA_RSVD1      (AT91_CAST(AT91_REG *) 	0x00000038) // (HDMA_RSVD1) HDMA Reserved
S
N#endif
N// -------- HDMA_GCFG : (HDMA Offset: 0x0)  -------- 
N#define AT91C_HDMA_IF0_BIGEND (0x1 <<  0) // (HDMA) AHB-Lite Interface 0 endian mode.
N#define 	AT91C_HDMA_IF0_BIGEND_IS_LITTLE_ENDIAN     (0x0) // (HDMA) AHB-Lite Interface 0 is little endian.
N#define 	AT91C_HDMA_IF0_BIGEND_IS_BIG_ENDIAN        (0x1) // (HDMA) AHB-Lite Interface 0 is big endian.
N#define AT91C_HDMA_IF1_BIGEND (0x1 <<  1) // (HDMA) AHB-Lite Interface 1 endian mode.
N#define 	AT91C_HDMA_IF1_BIGEND_IS_LITTLE_ENDIAN     (0x0 <<  1) // (HDMA) AHB-Lite Interface 1 is little endian.
N#define 	AT91C_HDMA_IF1_BIGEND_IS_BIG_ENDIAN        (0x1 <<  1) // (HDMA) AHB-Lite Interface 1 is big endian.
N#define AT91C_HDMA_IF2_BIGEND (0x1 <<  2) // (HDMA) AHB-Lite Interface 2 endian mode.
N#define 	AT91C_HDMA_IF2_BIGEND_IS_LITTLE_ENDIAN     (0x0 <<  2) // (HDMA) AHB-Lite Interface 2 is little endian.
N#define 	AT91C_HDMA_IF2_BIGEND_IS_BIG_ENDIAN        (0x1 <<  2) // (HDMA) AHB-Lite Interface 2 is big endian.
N#define AT91C_HDMA_IF3_BIGEND (0x1 <<  3) // (HDMA) AHB-Lite Interface 3 endian mode.
N#define 	AT91C_HDMA_IF3_BIGEND_IS_LITTLE_ENDIAN     (0x0 <<  3) // (HDMA) AHB-Lite Interface 3 is little endian.
N#define 	AT91C_HDMA_IF3_BIGEND_IS_BIG_ENDIAN        (0x1 <<  3) // (HDMA) AHB-Lite Interface 3 is big endian.
N#define AT91C_HDMA_ARB_CFG    (0x1 <<  4) // (HDMA) Arbiter mode.
N#define 	AT91C_HDMA_ARB_CFG_FIXED                (0x0 <<  4) // (HDMA) Fixed priority arbiter.
N#define 	AT91C_HDMA_ARB_CFG_ROUND_ROBIN          (0x1 <<  4) // (HDMA) Modified round robin arbiter.
N// -------- HDMA_EN : (HDMA Offset: 0x4)  -------- 
N#define AT91C_HDMA_ENABLE     (0x1 <<  0) // (HDMA) 
N#define 	AT91C_HDMA_ENABLE_DISABLE              (0x0) // (HDMA) Disables HDMA.
N#define 	AT91C_HDMA_ENABLE_ENABLE               (0x1) // (HDMA) Enables HDMA.
N// -------- HDMA_SREQ : (HDMA Offset: 0x8)  -------- 
N#define AT91C_HDMA_SSREQ0     (0x1 <<  0) // (HDMA) Request a source single transfer on channel 0
N#define 	AT91C_HDMA_SSREQ0_0                    (0x0) // (HDMA) No effect.
N#define 	AT91C_HDMA_SSREQ0_1                    (0x1) // (HDMA) Request a source single transfer on channel 0.
N#define AT91C_HDMA_DSREQ0     (0x1 <<  1) // (HDMA) Request a destination single transfer on channel 0
N#define 	AT91C_HDMA_DSREQ0_0                    (0x0 <<  1) // (HDMA) No effect.
N#define 	AT91C_HDMA_DSREQ0_1                    (0x1 <<  1) // (HDMA) Request a destination single transfer on channel 0.
N#define AT91C_HDMA_SSREQ1     (0x1 <<  2) // (HDMA) Request a source single transfer on channel 1
N#define 	AT91C_HDMA_SSREQ1_0                    (0x0 <<  2) // (HDMA) No effect.
N#define 	AT91C_HDMA_SSREQ1_1                    (0x1 <<  2) // (HDMA) Request a source single transfer on channel 1.
N#define AT91C_HDMA_DSREQ1     (0x1 <<  3) // (HDMA) Request a destination single transfer on channel 1
N#define 	AT91C_HDMA_DSREQ1_0                    (0x0 <<  3) // (HDMA) No effect.
N#define 	AT91C_HDMA_DSREQ1_1                    (0x1 <<  3) // (HDMA) Request a destination single transfer on channel 1.
N#define AT91C_HDMA_SSREQ2     (0x1 <<  4) // (HDMA) Request a source single transfer on channel 2
N#define 	AT91C_HDMA_SSREQ2_0                    (0x0 <<  4) // (HDMA) No effect.
N#define 	AT91C_HDMA_SSREQ2_1                    (0x1 <<  4) // (HDMA) Request a source single transfer on channel 2.
N#define AT91C_HDMA_DSREQ2     (0x1 <<  5) // (HDMA) Request a destination single transfer on channel 2
N#define 	AT91C_HDMA_DSREQ2_0                    (0x0 <<  5) // (HDMA) No effect.
N#define 	AT91C_HDMA_DSREQ2_1                    (0x1 <<  5) // (HDMA) Request a destination single transfer on channel 2.
N#define AT91C_HDMA_SSREQ3     (0x1 <<  6) // (HDMA) Request a source single transfer on channel 3
N#define 	AT91C_HDMA_SSREQ3_0                    (0x0 <<  6) // (HDMA) No effect.
N#define 	AT91C_HDMA_SSREQ3_1                    (0x1 <<  6) // (HDMA) Request a source single transfer on channel 3.
N#define AT91C_HDMA_DSREQ3     (0x1 <<  7) // (HDMA) Request a destination single transfer on channel 3
N#define 	AT91C_HDMA_DSREQ3_0                    (0x0 <<  7) // (HDMA) No effect.
N#define 	AT91C_HDMA_DSREQ3_1                    (0x1 <<  7) // (HDMA) Request a destination single transfer on channel 3.
N#define AT91C_HDMA_SSREQ4     (0x1 <<  8) // (HDMA) Request a source single transfer on channel 4
N#define 	AT91C_HDMA_SSREQ4_0                    (0x0 <<  8) // (HDMA) No effect.
N#define 	AT91C_HDMA_SSREQ4_1                    (0x1 <<  8) // (HDMA) Request a source single transfer on channel 4.
N#define AT91C_HDMA_DSREQ4     (0x1 <<  9) // (HDMA) Request a destination single transfer on channel 4
N#define 	AT91C_HDMA_DSREQ4_0                    (0x0 <<  9) // (HDMA) No effect.
N#define 	AT91C_HDMA_DSREQ4_1                    (0x1 <<  9) // (HDMA) Request a destination single transfer on channel 4.
N#define AT91C_HDMA_SSREQ5     (0x1 << 10) // (HDMA) Request a source single transfer on channel 5
N#define 	AT91C_HDMA_SSREQ5_0                    (0x0 << 10) // (HDMA) No effect.
N#define 	AT91C_HDMA_SSREQ5_1                    (0x1 << 10) // (HDMA) Request a source single transfer on channel 5.
N#define AT91C_HDMA_DSREQ6     (0x1 << 11) // (HDMA) Request a destination single transfer on channel 5
N#define 	AT91C_HDMA_DSREQ6_0                    (0x0 << 11) // (HDMA) No effect.
N#define 	AT91C_HDMA_DSREQ6_1                    (0x1 << 11) // (HDMA) Request a destination single transfer on channel 5.
N#define AT91C_HDMA_SSREQ6     (0x1 << 12) // (HDMA) Request a source single transfer on channel 6
N#define 	AT91C_HDMA_SSREQ6_0                    (0x0 << 12) // (HDMA) No effect.
N#define 	AT91C_HDMA_SSREQ6_1                    (0x1 << 12) // (HDMA) Request a source single transfer on channel 6.
N#define AT91C_HDMA_SSREQ7     (0x1 << 14) // (HDMA) Request a source single transfer on channel 7
N#define 	AT91C_HDMA_SSREQ7_0                    (0x0 << 14) // (HDMA) No effect.
N#define 	AT91C_HDMA_SSREQ7_1                    (0x1 << 14) // (HDMA) Request a source single transfer on channel 7.
N#define AT91C_HDMA_DSREQ7     (0x1 << 15) // (HDMA) Request a destination single transfer on channel 7
N#define 	AT91C_HDMA_DSREQ7_0                    (0x0 << 15) // (HDMA) No effect.
N#define 	AT91C_HDMA_DSREQ7_1                    (0x1 << 15) // (HDMA) Request a destination single transfer on channel 7.
N// -------- HDMA_CREQ : (HDMA Offset: 0xc)  -------- 
N#define AT91C_HDMA_SCREQ0     (0x1 <<  0) // (HDMA) Request a source chunk transfer on channel 0
N#define 	AT91C_HDMA_SCREQ0_0                    (0x0) // (HDMA) No effect.
N#define 	AT91C_HDMA_SCREQ0_1                    (0x1) // (HDMA) Request a source chunk transfer on channel 0.
N#define AT91C_HDMA_DCREQ0     (0x1 <<  1) // (HDMA) Request a destination chunk transfer on channel 0
N#define 	AT91C_HDMA_DCREQ0_0                    (0x0 <<  1) // (HDMA) No effect.
N#define 	AT91C_HDMA_DCREQ0_1                    (0x1 <<  1) // (HDMA) Request a destination chunk transfer on channel 0.
N#define AT91C_HDMA_SCREQ1     (0x1 <<  2) // (HDMA) Request a source chunk transfer on channel 1
N#define 	AT91C_HDMA_SCREQ1_0                    (0x0 <<  2) // (HDMA) No effect.
N#define 	AT91C_HDMA_SCREQ1_1                    (0x1 <<  2) // (HDMA) Request a source chunk transfer on channel 1.
N#define AT91C_HDMA_DCREQ1     (0x1 <<  3) // (HDMA) Request a destination chunk transfer on channel 1
N#define 	AT91C_HDMA_DCREQ1_0                    (0x0 <<  3) // (HDMA) No effect.
N#define 	AT91C_HDMA_DCREQ1_1                    (0x1 <<  3) // (HDMA) Request a destination chunk transfer on channel 1.
N#define AT91C_HDMA_SCREQ2     (0x1 <<  4) // (HDMA) Request a source chunk transfer on channel 2
N#define 	AT91C_HDMA_SCREQ2_0                    (0x0 <<  4) // (HDMA) No effect.
N#define 	AT91C_HDMA_SCREQ2_1                    (0x1 <<  4) // (HDMA) Request a source chunk transfer on channel 2.
N#define AT91C_HDMA_DCREQ2     (0x1 <<  5) // (HDMA) Request a destination chunk transfer on channel 2
N#define 	AT91C_HDMA_DCREQ2_0                    (0x0 <<  5) // (HDMA) No effect.
N#define 	AT91C_HDMA_DCREQ2_1                    (0x1 <<  5) // (HDMA) Request a destination chunk transfer on channel 2.
N#define AT91C_HDMA_SCREQ3     (0x1 <<  6) // (HDMA) Request a source chunk transfer on channel 3
N#define 	AT91C_HDMA_SCREQ3_0                    (0x0 <<  6) // (HDMA) No effect.
N#define 	AT91C_HDMA_SCREQ3_1                    (0x1 <<  6) // (HDMA) Request a source chunk transfer on channel 3.
N#define AT91C_HDMA_DCREQ3     (0x1 <<  7) // (HDMA) Request a destination chunk transfer on channel 3
N#define 	AT91C_HDMA_DCREQ3_0                    (0x0 <<  7) // (HDMA) No effect.
N#define 	AT91C_HDMA_DCREQ3_1                    (0x1 <<  7) // (HDMA) Request a destination chunk transfer on channel 3.
N#define AT91C_HDMA_SCREQ4     (0x1 <<  8) // (HDMA) Request a source chunk transfer on channel 4
N#define 	AT91C_HDMA_SCREQ4_0                    (0x0 <<  8) // (HDMA) No effect.
N#define 	AT91C_HDMA_SCREQ4_1                    (0x1 <<  8) // (HDMA) Request a source chunk transfer on channel 4.
N#define AT91C_HDMA_DCREQ4     (0x1 <<  9) // (HDMA) Request a destination chunk transfer on channel 4
N#define 	AT91C_HDMA_DCREQ4_0                    (0x0 <<  9) // (HDMA) No effect.
N#define 	AT91C_HDMA_DCREQ4_1                    (0x1 <<  9) // (HDMA) Request a destination chunk transfer on channel 4.
N#define AT91C_HDMA_SCREQ5     (0x1 << 10) // (HDMA) Request a source chunk transfer on channel 5
N#define 	AT91C_HDMA_SCREQ5_0                    (0x0 << 10) // (HDMA) No effect.
N#define 	AT91C_HDMA_SCREQ5_1                    (0x1 << 10) // (HDMA) Request a source chunk transfer on channel 5.
N#define AT91C_HDMA_DCREQ6     (0x1 << 11) // (HDMA) Request a destination chunk transfer on channel 5
N#define 	AT91C_HDMA_DCREQ6_0                    (0x0 << 11) // (HDMA) No effect.
N#define 	AT91C_HDMA_DCREQ6_1                    (0x1 << 11) // (HDMA) Request a destination chunk transfer on channel 5.
N#define AT91C_HDMA_SCREQ6     (0x1 << 12) // (HDMA) Request a source chunk transfer on channel 6
N#define 	AT91C_HDMA_SCREQ6_0                    (0x0 << 12) // (HDMA) No effect.
N#define 	AT91C_HDMA_SCREQ6_1                    (0x1 << 12) // (HDMA) Request a source chunk transfer on channel 6.
N#define AT91C_HDMA_SCREQ7     (0x1 << 14) // (HDMA) Request a source chunk transfer on channel 7
N#define 	AT91C_HDMA_SCREQ7_0                    (0x0 << 14) // (HDMA) No effect.
N#define 	AT91C_HDMA_SCREQ7_1                    (0x1 << 14) // (HDMA) Request a source chunk transfer on channel 7.
N#define AT91C_HDMA_DCREQ7     (0x1 << 15) // (HDMA) Request a destination chunk transfer on channel 7
N#define 	AT91C_HDMA_DCREQ7_0                    (0x0 << 15) // (HDMA) No effect.
N#define 	AT91C_HDMA_DCREQ7_1                    (0x1 << 15) // (HDMA) Request a destination chunk transfer on channel 7.
N// -------- HDMA_LAST : (HDMA Offset: 0x10)  -------- 
N#define AT91C_HDMA_SLAST0     (0x1 <<  0) // (HDMA) Indicates that this source request is the last transfer of the buffer on channel 0
N#define 	AT91C_HDMA_SLAST0_0                    (0x0) // (HDMA) No effect.
N#define 	AT91C_HDMA_SLAST0_1                    (0x1) // (HDMA) Writing one to SLASTx prior to writing one to SSREQx or SCREQx indicates that this source request is the last transfer of the buffer on channel 0.
N#define AT91C_HDMA_DLAST0     (0x1 <<  1) // (HDMA) Indicates that this destination request is the last transfer of the buffer on channel 0
N#define 	AT91C_HDMA_DLAST0_0                    (0x0 <<  1) // (HDMA) No effect.
N#define 	AT91C_HDMA_DLAST0_1                    (0x1 <<  1) // (HDMA) Writing one to DLASTx prior to writing one to DSREQx or DCREQx indicates that this destination request is the last transfer of the buffer on channel 0.
N#define AT91C_HDMA_SLAST1     (0x1 <<  2) // (HDMA) Indicates that this source request is the last transfer of the buffer on channel 1
N#define 	AT91C_HDMA_SLAST1_0                    (0x0 <<  2) // (HDMA) No effect.
N#define 	AT91C_HDMA_SLAST1_1                    (0x1 <<  2) // (HDMA) Writing one to SLASTx prior to writing one to SSREQx or SCREQx indicates that this source request is the last transfer of the buffer on channel 1.
N#define AT91C_HDMA_DLAST1     (0x1 <<  3) // (HDMA) Indicates that this destination request is the last transfer of the buffer on channel 1
N#define 	AT91C_HDMA_DLAST1_0                    (0x0 <<  3) // (HDMA) No effect.
N#define 	AT91C_HDMA_DLAST1_1                    (0x1 <<  3) // (HDMA) Writing one to DLASTx prior to writing one to DSREQx or DCREQx indicates that this destination request is the last transfer of the buffer on channel 1.
N#define AT91C_HDMA_SLAST2     (0x1 <<  4) // (HDMA) Indicates that this source request is the last transfer of the buffer on channel 2
N#define 	AT91C_HDMA_SLAST2_0                    (0x0 <<  4) // (HDMA) No effect.
N#define 	AT91C_HDMA_SLAST2_1                    (0x1 <<  4) // (HDMA) Writing one to SLASTx prior to writing one to SSREQx or SCREQx indicates that this source request is the last transfer of the buffer on channel 2.
N#define AT91C_HDMA_DLAST2     (0x1 <<  5) // (HDMA) Indicates that this destination request is the last transfer of the buffer on channel 2
N#define 	AT91C_HDMA_DLAST2_0                    (0x0 <<  5) // (HDMA) No effect.
N#define 	AT91C_HDMA_DLAST2_1                    (0x1 <<  5) // (HDMA) Writing one to DLASTx prior to writing one to DSREQx or DCREQx indicates that this destination request is the last transfer of the buffer on channel 2.
N#define AT91C_HDMA_SLAST3     (0x1 <<  6) // (HDMA) Indicates that this source request is the last transfer of the buffer on channel 3
N#define 	AT91C_HDMA_SLAST3_0                    (0x0 <<  6) // (HDMA) No effect.
N#define 	AT91C_HDMA_SLAST3_1                    (0x1 <<  6) // (HDMA) Writing one to SLASTx prior to writing one to SSREQx or SCREQx indicates that this source request is the last transfer of the buffer on channel 3.
N#define AT91C_HDMA_DLAST3     (0x1 <<  7) // (HDMA) Indicates that this destination request is the last transfer of the buffer on channel 3
N#define 	AT91C_HDMA_DLAST3_0                    (0x0 <<  7) // (HDMA) No effect.
N#define 	AT91C_HDMA_DLAST3_1                    (0x1 <<  7) // (HDMA) Writing one to DLASTx prior to writing one to DSREQx or DCREQx indicates that this destination request is the last transfer of the buffer on channel 3.
N#define AT91C_HDMA_SLAST4     (0x1 <<  8) // (HDMA) Indicates that this source request is the last transfer of the buffer on channel 4
N#define 	AT91C_HDMA_SLAST4_0                    (0x0 <<  8) // (HDMA) No effect.
N#define 	AT91C_HDMA_SLAST4_1                    (0x1 <<  8) // (HDMA) Writing one to SLASTx prior to writing one to SSREQx or SCREQx indicates that this source request is the last transfer of the buffer on channel 4.
N#define AT91C_HDMA_DLAST4     (0x1 <<  9) // (HDMA) Indicates that this destination request is the last transfer of the buffer on channel 4
N#define 	AT91C_HDMA_DLAST4_0                    (0x0 <<  9) // (HDMA) No effect.
N#define 	AT91C_HDMA_DLAST4_1                    (0x1 <<  9) // (HDMA) Writing one to DLASTx prior to writing one to DSREQx or DCREQx indicates that this destination request is the last transfer of the buffer on channel 4.
N#define AT91C_HDMA_SLAST5     (0x1 << 10) // (HDMA) Indicates that this source request is the last transfer of the buffer on channel 5
N#define 	AT91C_HDMA_SLAST5_0                    (0x0 << 10) // (HDMA) No effect.
N#define 	AT91C_HDMA_SLAST5_1                    (0x1 << 10) // (HDMA) Writing one to SLASTx prior to writing one to SSREQx or SCREQx indicates that this source request is the last transfer of the buffer on channel 5.
N#define AT91C_HDMA_DLAST6     (0x1 << 11) // (HDMA) Indicates that this destination request is the last transfer of the buffer on channel 5
N#define 	AT91C_HDMA_DLAST6_0                    (0x0 << 11) // (HDMA) No effect.
N#define 	AT91C_HDMA_DLAST6_1                    (0x1 << 11) // (HDMA) Writing one to DLASTx prior to writing one to DSREQx or DCREQx indicates that this destination request is the last transfer of the buffer on channel 5.
N#define AT91C_HDMA_SLAST6     (0x1 << 12) // (HDMA) Indicates that this source request is the last transfer of the buffer on channel 6
N#define 	AT91C_HDMA_SLAST6_0                    (0x0 << 12) // (HDMA) No effect.
N#define 	AT91C_HDMA_SLAST6_1                    (0x1 << 12) // (HDMA) Writing one to SLASTx prior to writing one to SSREQx or SCREQx indicates that this source request is the last transfer of the buffer on channel 6.
N#define AT91C_HDMA_SLAST7     (0x1 << 14) // (HDMA) Indicates that this source request is the last transfer of the buffer on channel 7
N#define 	AT91C_HDMA_SLAST7_0                    (0x0 << 14) // (HDMA) No effect.
N#define 	AT91C_HDMA_SLAST7_1                    (0x1 << 14) // (HDMA) Writing one to SLASTx prior to writing one to SSREQx or SCREQx indicates that this source request is the last transfer of the buffer on channel 7.
N#define AT91C_HDMA_DLAST7     (0x1 << 15) // (HDMA) Indicates that this destination request is the last transfer of the buffer on channel 7
N#define 	AT91C_HDMA_DLAST7_0                    (0x0 << 15) // (HDMA) No effect.
N#define 	AT91C_HDMA_DLAST7_1                    (0x1 << 15) // (HDMA) Writing one to DLASTx prior to writing one to DSREQx or DCREQx indicates that this destination request is the last transfer of the buffer on channel 7.
N// -------- HDMA_SYNC : (HDMA Offset: 0x14)  -------- 
N#define AT91C_SYNC_REQ        (0xFFFF <<  0) // (HDMA) 
N// -------- HDMA_EBCIER : (HDMA Offset: 0x18) Buffer Transfer Completed/Chained Buffer Transfer Completed/Access Error Interrupt Enable Register -------- 
N#define AT91C_HDMA_BTC0       (0x1 <<  0) // (HDMA) Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_BTC1       (0x1 <<  1) // (HDMA) Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_BTC2       (0x1 <<  2) // (HDMA) Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_BTC3       (0x1 <<  3) // (HDMA) Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_BTC4       (0x1 <<  4) // (HDMA) Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_BTC5       (0x1 <<  5) // (HDMA) Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_BTC6       (0x1 <<  6) // (HDMA) Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_BTC7       (0x1 <<  7) // (HDMA) Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_CBTC0      (0x1 <<  8) // (HDMA) Chained Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_CBTC1      (0x1 <<  9) // (HDMA) Chained Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_CBTC2      (0x1 << 10) // (HDMA) Chained Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_CBTC3      (0x1 << 11) // (HDMA) Chained Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_CBTC4      (0x1 << 12) // (HDMA) Chained Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_CBTC5      (0x1 << 13) // (HDMA) Chained Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_CBTC6      (0x1 << 14) // (HDMA) Chained Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_CBTC7      (0x1 << 15) // (HDMA) Chained Buffer Transfer Completed Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_ERR0       (0x1 << 16) // (HDMA) Access HDMA_Error Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_ERR1       (0x1 << 17) // (HDMA) Access HDMA_Error Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_ERR2       (0x1 << 18) // (HDMA) Access HDMA_Error Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_ERR3       (0x1 << 19) // (HDMA) Access HDMA_Error Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_ERR4       (0x1 << 20) // (HDMA) Access HDMA_Error Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_ERR5       (0x1 << 21) // (HDMA) Access HDMA_Error Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_ERR6       (0x1 << 22) // (HDMA) Access HDMA_Error Interrupt Enable/Disable/Status Register
N#define AT91C_HDMA_ERR7       (0x1 << 23) // (HDMA) Access HDMA_Error Interrupt Enable/Disable/Status Register
N// -------- HDMA_EBCIDR : (HDMA Offset: 0x1c)  -------- 
N// -------- HDMA_EBCIMR : (HDMA Offset: 0x20)  -------- 
N// -------- HDMA_EBCISR : (HDMA Offset: 0x24)  -------- 
N// -------- HDMA_CHER : (HDMA Offset: 0x28)  -------- 
N#define AT91C_HDMA_ENA0       (0x1 <<  0) // (HDMA) When set, channel 0 enabled.
N#define 	AT91C_HDMA_ENA0_0                    (0x0) // (HDMA) No effect.
N#define 	AT91C_HDMA_ENA0_1                    (0x1) // (HDMA) Channel 0 enabled.
N#define AT91C_HDMA_ENA1       (0x1 <<  1) // (HDMA) When set, channel 1 enabled.
N#define 	AT91C_HDMA_ENA1_0                    (0x0 <<  1) // (HDMA) No effect.
N#define 	AT91C_HDMA_ENA1_1                    (0x1 <<  1) // (HDMA) Channel 1 enabled.
N#define AT91C_HDMA_ENA2       (0x1 <<  2) // (HDMA) When set, channel 2 enabled.
N#define 	AT91C_HDMA_ENA2_0                    (0x0 <<  2) // (HDMA) No effect.
N#define 	AT91C_HDMA_ENA2_1                    (0x1 <<  2) // (HDMA) Channel 2 enabled.
N#define AT91C_HDMA_ENA3       (0x1 <<  3) // (HDMA) When set, channel 3 enabled.
N#define 	AT91C_HDMA_ENA3_0                    (0x0 <<  3) // (HDMA) No effect.
N#define 	AT91C_HDMA_ENA3_1                    (0x1 <<  3) // (HDMA) Channel 3 enabled.
N#define AT91C_HDMA_ENA4       (0x1 <<  4) // (HDMA) When set, channel 4 enabled.
N#define 	AT91C_HDMA_ENA4_0                    (0x0 <<  4) // (HDMA) No effect.
N#define 	AT91C_HDMA_ENA4_1                    (0x1 <<  4) // (HDMA) Channel 4 enabled.
N#define AT91C_HDMA_ENA5       (0x1 <<  5) // (HDMA) When set, channel 5 enabled.
N#define 	AT91C_HDMA_ENA5_0                    (0x0 <<  5) // (HDMA) No effect.
N#define 	AT91C_HDMA_ENA5_1                    (0x1 <<  5) // (HDMA) Channel 5 enabled.
N#define AT91C_HDMA_ENA6       (0x1 <<  6) // (HDMA) When set, channel 6 enabled.
N#define 	AT91C_HDMA_ENA6_0                    (0x0 <<  6) // (HDMA) No effect.
N#define 	AT91C_HDMA_ENA6_1                    (0x1 <<  6) // (HDMA) Channel 6 enabled.
N#define AT91C_HDMA_ENA7       (0x1 <<  7) // (HDMA) When set, channel 7 enabled.
N#define 	AT91C_HDMA_ENA7_0                    (0x0 <<  7) // (HDMA) No effect.
N#define 	AT91C_HDMA_ENA7_1                    (0x1 <<  7) // (HDMA) Channel 7 enabled.
N#define AT91C_HDMA_SUSP0      (0x1 <<  8) // (HDMA) When set, channel 0 freezed and its current context.
N#define 	AT91C_HDMA_SUSP0_0                    (0x0 <<  8) // (HDMA) No effect.
N#define 	AT91C_HDMA_SUSP0_1                    (0x1 <<  8) // (HDMA) Channel 0 freezed.
N#define AT91C_HDMA_SUSP1      (0x1 <<  9) // (HDMA) When set, channel 1 freezed and its current context.
N#define 	AT91C_HDMA_SUSP1_0                    (0x0 <<  9) // (HDMA) No effect.
N#define 	AT91C_HDMA_SUSP1_1                    (0x1 <<  9) // (HDMA) Channel 1 freezed.
N#define AT91C_HDMA_SUSP2      (0x1 << 10) // (HDMA) When set, channel 2 freezed and its current context.
N#define 	AT91C_HDMA_SUSP2_0                    (0x0 << 10) // (HDMA) No effect.
N#define 	AT91C_HDMA_SUSP2_1                    (0x1 << 10) // (HDMA) Channel 2 freezed.
N#define AT91C_HDMA_SUSP3      (0x1 << 11) // (HDMA) When set, channel 3 freezed and its current context.
N#define 	AT91C_HDMA_SUSP3_0                    (0x0 << 11) // (HDMA) No effect.
N#define 	AT91C_HDMA_SUSP3_1                    (0x1 << 11) // (HDMA) Channel 3 freezed.
N#define AT91C_HDMA_SUSP4      (0x1 << 12) // (HDMA) When set, channel 4 freezed and its current context.
N#define 	AT91C_HDMA_SUSP4_0                    (0x0 << 12) // (HDMA) No effect.
N#define 	AT91C_HDMA_SUSP4_1                    (0x1 << 12) // (HDMA) Channel 4 freezed.
N#define AT91C_HDMA_SUSP5      (0x1 << 13) // (HDMA) When set, channel 5 freezed and its current context.
N#define 	AT91C_HDMA_SUSP5_0                    (0x0 << 13) // (HDMA) No effect.
N#define 	AT91C_HDMA_SUSP5_1                    (0x1 << 13) // (HDMA) Channel 5 freezed.
N#define AT91C_HDMA_SUSP6      (0x1 << 14) // (HDMA) When set, channel 6 freezed and its current context.
N#define 	AT91C_HDMA_SUSP6_0                    (0x0 << 14) // (HDMA) No effect.
N#define 	AT91C_HDMA_SUSP6_1                    (0x1 << 14) // (HDMA) Channel 6 freezed.
N#define AT91C_HDMA_SUSP7      (0x1 << 15) // (HDMA) When set, channel 7 freezed and its current context.
N#define 	AT91C_HDMA_SUSP7_0                    (0x0 << 15) // (HDMA) No effect.
N#define 	AT91C_HDMA_SUSP7_1                    (0x1 << 15) // (HDMA) Channel 7 freezed.
N#define AT91C_HDMA_KEEP0      (0x1 << 24) // (HDMA) When set, it resumes the channel 0 from an automatic stall state.
N#define 	AT91C_HDMA_KEEP0_0                    (0x0 << 24) // (HDMA) No effect.
N#define 	AT91C_HDMA_KEEP0_1                    (0x1 << 24) // (HDMA) Resumes the channel 0.
N#define AT91C_HDMA_KEEP1      (0x1 << 25) // (HDMA) When set, it resumes the channel 1 from an automatic stall state.
N#define 	AT91C_HDMA_KEEP1_0                    (0x0 << 25) // (HDMA) No effect.
N#define 	AT91C_HDMA_KEEP1_1                    (0x1 << 25) // (HDMA) Resumes the channel 1.
N#define AT91C_HDMA_KEEP2      (0x1 << 26) // (HDMA) When set, it resumes the channel 2 from an automatic stall state.
N#define 	AT91C_HDMA_KEEP2_0                    (0x0 << 26) // (HDMA) No effect.
N#define 	AT91C_HDMA_KEEP2_1                    (0x1 << 26) // (HDMA) Resumes the channel 2.
N#define AT91C_HDMA_KEEP3      (0x1 << 27) // (HDMA) When set, it resumes the channel 3 from an automatic stall state.
N#define 	AT91C_HDMA_KEEP3_0                    (0x0 << 27) // (HDMA) No effect.
N#define 	AT91C_HDMA_KEEP3_1                    (0x1 << 27) // (HDMA) Resumes the channel 3.
N#define AT91C_HDMA_KEEP4      (0x1 << 28) // (HDMA) When set, it resumes the channel 4 from an automatic stall state.
N#define 	AT91C_HDMA_KEEP4_0                    (0x0 << 28) // (HDMA) No effect.
N#define 	AT91C_HDMA_KEEP4_1                    (0x1 << 28) // (HDMA) Resumes the channel 4.
N#define AT91C_HDMA_KEEP5      (0x1 << 29) // (HDMA) When set, it resumes the channel 5 from an automatic stall state.
N#define 	AT91C_HDMA_KEEP5_0                    (0x0 << 29) // (HDMA) No effect.
N#define 	AT91C_HDMA_KEEP5_1                    (0x1 << 29) // (HDMA) Resumes the channel 5.
N#define AT91C_HDMA_KEEP6      (0x1 << 30) // (HDMA) When set, it resumes the channel 6 from an automatic stall state.
N#define 	AT91C_HDMA_KEEP6_0                    (0x0 << 30) // (HDMA) No effect.
N#define 	AT91C_HDMA_KEEP6_1                    (0x1 << 30) // (HDMA) Resumes the channel 6.
N#define AT91C_HDMA_KEEP7      (0x1 << 31) // (HDMA) When set, it resumes the channel 7 from an automatic stall state.
N#define 	AT91C_HDMA_KEEP7_0                    (0x0 << 31) // (HDMA) No effect.
N#define 	AT91C_HDMA_KEEP7_1                    (0x1 << 31) // (HDMA) Resumes the channel 7.
N// -------- HDMA_CHDR : (HDMA Offset: 0x2c)  -------- 
N#define AT91C_HDMA_DIS0       (0x1 <<  0) // (HDMA) Write one to this field to disable the channel 0.
N#define 	AT91C_HDMA_DIS0_0                    (0x0) // (HDMA) No effect.
N#define 	AT91C_HDMA_DIS0_1                    (0x1) // (HDMA) Disables the channel 0.
N#define AT91C_HDMA_DIS1       (0x1 <<  1) // (HDMA) Write one to this field to disable the channel 1.
N#define 	AT91C_HDMA_DIS1_0                    (0x0 <<  1) // (HDMA) No effect.
N#define 	AT91C_HDMA_DIS1_1                    (0x1 <<  1) // (HDMA) Disables the channel 1.
N#define AT91C_HDMA_DIS2       (0x1 <<  2) // (HDMA) Write one to this field to disable the channel 2.
N#define 	AT91C_HDMA_DIS2_0                    (0x0 <<  2) // (HDMA) No effect.
N#define 	AT91C_HDMA_DIS2_1                    (0x1 <<  2) // (HDMA) Disables the channel 2.
N#define AT91C_HDMA_DIS3       (0x1 <<  3) // (HDMA) Write one to this field to disable the channel 3.
N#define 	AT91C_HDMA_DIS3_0                    (0x0 <<  3) // (HDMA) No effect.
N#define 	AT91C_HDMA_DIS3_1                    (0x1 <<  3) // (HDMA) Disables the channel 3.
N#define AT91C_HDMA_DIS4       (0x1 <<  4) // (HDMA) Write one to this field to disable the channel 4.
N#define 	AT91C_HDMA_DIS4_0                    (0x0 <<  4) // (HDMA) No effect.
N#define 	AT91C_HDMA_DIS4_1                    (0x1 <<  4) // (HDMA) Disables the channel 4.
N#define AT91C_HDMA_DIS5       (0x1 <<  5) // (HDMA) Write one to this field to disable the channel 5.
N#define 	AT91C_HDMA_DIS5_0                    (0x0 <<  5) // (HDMA) No effect.
N#define 	AT91C_HDMA_DIS5_1                    (0x1 <<  5) // (HDMA) Disables the channel 5.
N#define AT91C_HDMA_DIS6       (0x1 <<  6) // (HDMA) Write one to this field to disable the channel 6.
N#define 	AT91C_HDMA_DIS6_0                    (0x0 <<  6) // (HDMA) No effect.
N#define 	AT91C_HDMA_DIS6_1                    (0x1 <<  6) // (HDMA) Disables the channel 6.
N#define AT91C_HDMA_DIS7       (0x1 <<  7) // (HDMA) Write one to this field to disable the channel 7.
N#define 	AT91C_HDMA_DIS7_0                    (0x0 <<  7) // (HDMA) No effect.
N#define 	AT91C_HDMA_DIS7_1                    (0x1 <<  7) // (HDMA) Disables the channel 7.
N#define AT91C_HDMA_RES0       (0x1 <<  8) // (HDMA) Write one to this field to resume the channel 0 transfer restoring its context.
N#define 	AT91C_HDMA_RES0_0                    (0x0 <<  8) // (HDMA) No effect.
N#define 	AT91C_HDMA_RES0_1                    (0x1 <<  8) // (HDMA) Resumes the channel 0.
N#define AT91C_HDMA_RES1       (0x1 <<  9) // (HDMA) Write one to this field to resume the channel 1 transfer restoring its context.
N#define 	AT91C_HDMA_RES1_0                    (0x0 <<  9) // (HDMA) No effect.
N#define 	AT91C_HDMA_RES1_1                    (0x1 <<  9) // (HDMA) Resumes the channel 1.
N#define AT91C_HDMA_RES2       (0x1 << 10) // (HDMA) Write one to this field to resume the channel 2 transfer restoring its context.
N#define 	AT91C_HDMA_RES2_0                    (0x0 << 10) // (HDMA) No effect.
N#define 	AT91C_HDMA_RES2_1                    (0x1 << 10) // (HDMA) Resumes the channel 2.
N#define AT91C_HDMA_RES3       (0x1 << 11) // (HDMA) Write one to this field to resume the channel 3 transfer restoring its context.
N#define 	AT91C_HDMA_RES3_0                    (0x0 << 11) // (HDMA) No effect.
N#define 	AT91C_HDMA_RES3_1                    (0x1 << 11) // (HDMA) Resumes the channel 3.
N#define AT91C_HDMA_RES4       (0x1 << 12) // (HDMA) Write one to this field to resume the channel 4 transfer restoring its context.
N#define 	AT91C_HDMA_RES4_0                    (0x0 << 12) // (HDMA) No effect.
N#define 	AT91C_HDMA_RES4_1                    (0x1 << 12) // (HDMA) Resumes the channel 4.
N#define AT91C_HDMA_RES5       (0x1 << 13) // (HDMA) Write one to this field to resume the channel 5 transfer restoring its context.
N#define 	AT91C_HDMA_RES5_0                    (0x0 << 13) // (HDMA) No effect.
N#define 	AT91C_HDMA_RES5_1                    (0x1 << 13) // (HDMA) Resumes the channel 5.
N#define AT91C_HDMA_RES6       (0x1 << 14) // (HDMA) Write one to this field to resume the channel 6 transfer restoring its context.
N#define 	AT91C_HDMA_RES6_0                    (0x0 << 14) // (HDMA) No effect.
N#define 	AT91C_HDMA_RES6_1                    (0x1 << 14) // (HDMA) Resumes the channel 6.
N#define AT91C_HDMA_RES7       (0x1 << 15) // (HDMA) Write one to this field to resume the channel 7 transfer restoring its context.
N#define 	AT91C_HDMA_RES7_0                    (0x0 << 15) // (HDMA) No effect.
N#define 	AT91C_HDMA_RES7_1                    (0x1 << 15) // (HDMA) Resumes the channel 7.
N// -------- HDMA_CHSR : (HDMA Offset: 0x30)  -------- 
N#define AT91C_HDMA_EMPT0      (0x1 << 16) // (HDMA) When set, channel 0 is empty.
N#define 	AT91C_HDMA_EMPT0_0                    (0x0 << 16) // (HDMA) No effect.
N#define 	AT91C_HDMA_EMPT0_1                    (0x1 << 16) // (HDMA) Channel 0 empty.
N#define AT91C_HDMA_EMPT1      (0x1 << 17) // (HDMA) When set, channel 1 is empty.
N#define 	AT91C_HDMA_EMPT1_0                    (0x0 << 17) // (HDMA) No effect.
N#define 	AT91C_HDMA_EMPT1_1                    (0x1 << 17) // (HDMA) Channel 1 empty.
N#define AT91C_HDMA_EMPT2      (0x1 << 18) // (HDMA) When set, channel 2 is empty.
N#define 	AT91C_HDMA_EMPT2_0                    (0x0 << 18) // (HDMA) No effect.
N#define 	AT91C_HDMA_EMPT2_1                    (0x1 << 18) // (HDMA) Channel 2 empty.
N#define AT91C_HDMA_EMPT3      (0x1 << 19) // (HDMA) When set, channel 3 is empty.
N#define 	AT91C_HDMA_EMPT3_0                    (0x0 << 19) // (HDMA) No effect.
N#define 	AT91C_HDMA_EMPT3_1                    (0x1 << 19) // (HDMA) Channel 3 empty.
N#define AT91C_HDMA_EMPT4      (0x1 << 20) // (HDMA) When set, channel 4 is empty.
N#define 	AT91C_HDMA_EMPT4_0                    (0x0 << 20) // (HDMA) No effect.
N#define 	AT91C_HDMA_EMPT4_1                    (0x1 << 20) // (HDMA) Channel 4 empty.
N#define AT91C_HDMA_EMPT5      (0x1 << 21) // (HDMA) When set, channel 5 is empty.
N#define 	AT91C_HDMA_EMPT5_0                    (0x0 << 21) // (HDMA) No effect.
N#define 	AT91C_HDMA_EMPT5_1                    (0x1 << 21) // (HDMA) Channel 5 empty.
N#define AT91C_HDMA_EMPT6      (0x1 << 22) // (HDMA) When set, channel 6 is empty.
N#define 	AT91C_HDMA_EMPT6_0                    (0x0 << 22) // (HDMA) No effect.
N#define 	AT91C_HDMA_EMPT6_1                    (0x1 << 22) // (HDMA) Channel 6 empty.
N#define AT91C_HDMA_EMPT7      (0x1 << 23) // (HDMA) When set, channel 7 is empty.
N#define 	AT91C_HDMA_EMPT7_0                    (0x0 << 23) // (HDMA) No effect.
N#define 	AT91C_HDMA_EMPT7_1                    (0x1 << 23) // (HDMA) Channel 7 empty.
N#define AT91C_HDMA_STAL0      (0x1 << 24) // (HDMA) When set, channel 0 is stalled.
N#define 	AT91C_HDMA_STAL0_0                    (0x0 << 24) // (HDMA) No effect.
N#define 	AT91C_HDMA_STAL0_1                    (0x1 << 24) // (HDMA) Channel 0 stalled.
N#define AT91C_HDMA_STAL1      (0x1 << 25) // (HDMA) When set, channel 1 is stalled.
N#define 	AT91C_HDMA_STAL1_0                    (0x0 << 25) // (HDMA) No effect.
N#define 	AT91C_HDMA_STAL1_1                    (0x1 << 25) // (HDMA) Channel 1 stalled.
N#define AT91C_HDMA_STAL2      (0x1 << 26) // (HDMA) When set, channel 2 is stalled.
N#define 	AT91C_HDMA_STAL2_0                    (0x0 << 26) // (HDMA) No effect.
N#define 	AT91C_HDMA_STAL2_1                    (0x1 << 26) // (HDMA) Channel 2 stalled.
N#define AT91C_HDMA_STAL3      (0x1 << 27) // (HDMA) When set, channel 3 is stalled.
N#define 	AT91C_HDMA_STAL3_0                    (0x0 << 27) // (HDMA) No effect.
N#define 	AT91C_HDMA_STAL3_1                    (0x1 << 27) // (HDMA) Channel 3 stalled.
N#define AT91C_HDMA_STAL4      (0x1 << 28) // (HDMA) When set, channel 4 is stalled.
N#define 	AT91C_HDMA_STAL4_0                    (0x0 << 28) // (HDMA) No effect.
N#define 	AT91C_HDMA_STAL4_1                    (0x1 << 28) // (HDMA) Channel 4 stalled.
N#define AT91C_HDMA_STAL5      (0x1 << 29) // (HDMA) When set, channel 5 is stalled.
N#define 	AT91C_HDMA_STAL5_0                    (0x0 << 29) // (HDMA) No effect.
N#define 	AT91C_HDMA_STAL5_1                    (0x1 << 29) // (HDMA) Channel 5 stalled.
N#define AT91C_HDMA_STAL6      (0x1 << 30) // (HDMA) When set, channel 6 is stalled.
N#define 	AT91C_HDMA_STAL6_0                    (0x0 << 30) // (HDMA) No effect.
N#define 	AT91C_HDMA_STAL6_1                    (0x1 << 30) // (HDMA) Channel 6 stalled.
N#define AT91C_HDMA_STAL7      (0x1 << 31) // (HDMA) When set, channel 7 is stalled.
N#define 	AT91C_HDMA_STAL7_0                    (0x0 << 31) // (HDMA) No effect.
N#define 	AT91C_HDMA_STAL7_1                    (0x1 << 31) // (HDMA) Channel 7 stalled.
N// -------- HDMA_RSVD : (HDMA Offset: 0x34)  -------- 
N// -------- HDMA_RSVD : (HDMA Offset: 0x38)  -------- 
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Error Correction Code controller
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_ECC {
N	AT91_REG	 ECC_CR; 	//  ECC reset register
N	AT91_REG	 ECC_MR; 	//  ECC Page size register
N	AT91_REG	 ECC_SR; 	//  ECC Status register
N	AT91_REG	 ECC_PR; 	//  ECC Parity register
N	AT91_REG	 ECC_NPR; 	//  ECC Parity N register
N	AT91_REG	 Reserved0[58]; 	// 
N	AT91_REG	 ECC_VR; 	//  ECC Version register
N} AT91S_ECC, *AT91PS_ECC;
N#else
S#define ECC_CR          (AT91_CAST(AT91_REG *) 	0x00000000) // (ECC_CR)  ECC reset register
S#define ECC_MR          (AT91_CAST(AT91_REG *) 	0x00000004) // (ECC_MR)  ECC Page size register
S#define ECC_SR          (AT91_CAST(AT91_REG *) 	0x00000008) // (ECC_SR)  ECC Status register
S#define ECC_PR          (AT91_CAST(AT91_REG *) 	0x0000000C) // (ECC_PR)  ECC Parity register
S#define ECC_NPR         (AT91_CAST(AT91_REG *) 	0x00000010) // (ECC_NPR)  ECC Parity N register
S#define ECC_VR          (AT91_CAST(AT91_REG *) 	0x000000FC) // (ECC_VR)  ECC Version register
S
N#endif
N// -------- ECC_CR : (ECC Offset: 0x0) ECC reset register -------- 
N#define AT91C_ECC_RST         (0x1 <<  0) // (ECC) ECC reset parity
N// -------- ECC_MR : (ECC Offset: 0x4) ECC page size register -------- 
N#define AT91C_ECC_PAGE_SIZE   (0x3 <<  0) // (ECC) Nand Flash page size
N// -------- ECC_SR : (ECC Offset: 0x8) ECC status register -------- 
N#define AT91C_ECC_RECERR      (0x1 <<  0) // (ECC) ECC error
N#define AT91C_ECC_ECCERR      (0x1 <<  1) // (ECC) ECC single error
N#define AT91C_ECC_MULERR      (0x1 <<  2) // (ECC) ECC_MULERR
N// -------- ECC_PR : (ECC Offset: 0xc) ECC parity register -------- 
N#define AT91C_ECC_BITADDR     (0xF <<  0) // (ECC) Bit address error
N#define AT91C_ECC_WORDADDR    (0xFFF <<  4) // (ECC) address of the failing bit
N// -------- ECC_NPR : (ECC Offset: 0x10) ECC N parity register -------- 
N#define AT91C_ECC_NPARITY     (0xFFFF <<  0) // (ECC) ECC parity N 
N// -------- ECC_VR : (ECC Offset: 0xfc) ECC version register -------- 
N#define AT91C_ECC_VR          (0xF <<  0) // (ECC) ECC version register
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Ethernet MAC 10/100
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_EMAC {
N	AT91_REG	 EMAC_NCR; 	// Network Control Register
N	AT91_REG	 EMAC_NCFGR; 	// Network Configuration Register
N	AT91_REG	 EMAC_NSR; 	// Network Status Register
N	AT91_REG	 Reserved0[2]; 	// 
N	AT91_REG	 EMAC_TSR; 	// Transmit Status Register
N	AT91_REG	 EMAC_RBQP; 	// Receive Buffer Queue Pointer
N	AT91_REG	 EMAC_TBQP; 	// Transmit Buffer Queue Pointer
N	AT91_REG	 EMAC_RSR; 	// Receive Status Register
N	AT91_REG	 EMAC_ISR; 	// Interrupt Status Register
N	AT91_REG	 EMAC_IER; 	// Interrupt Enable Register
N	AT91_REG	 EMAC_IDR; 	// Interrupt Disable Register
N	AT91_REG	 EMAC_IMR; 	// Interrupt Mask Register
N	AT91_REG	 EMAC_MAN; 	// PHY Maintenance Register
N	AT91_REG	 EMAC_PTR; 	// Pause Time Register
N	AT91_REG	 EMAC_PFR; 	// Pause Frames received Register
N	AT91_REG	 EMAC_FTO; 	// Frames Transmitted OK Register
N	AT91_REG	 EMAC_SCF; 	// Single Collision Frame Register
N	AT91_REG	 EMAC_MCF; 	// Multiple Collision Frame Register
N	AT91_REG	 EMAC_FRO; 	// Frames Received OK Register
N	AT91_REG	 EMAC_FCSE; 	// Frame Check Sequence Error Register
N	AT91_REG	 EMAC_ALE; 	// Alignment Error Register
N	AT91_REG	 EMAC_DTF; 	// Deferred Transmission Frame Register
N	AT91_REG	 EMAC_LCOL; 	// Late Collision Register
N	AT91_REG	 EMAC_ECOL; 	// Excessive Collision Register
N	AT91_REG	 EMAC_TUND; 	// Transmit Underrun Error Register
N	AT91_REG	 EMAC_CSE; 	// Carrier Sense Error Register
N	AT91_REG	 EMAC_RRE; 	// Receive Ressource Error Register
N	AT91_REG	 EMAC_ROV; 	// Receive Overrun Errors Register
N	AT91_REG	 EMAC_RSE; 	// Receive Symbol Errors Register
N	AT91_REG	 EMAC_ELE; 	// Excessive Length Errors Register
N	AT91_REG	 EMAC_RJA; 	// Receive Jabbers Register
N	AT91_REG	 EMAC_USF; 	// Undersize Frames Register
N	AT91_REG	 EMAC_STE; 	// SQE Test Error Register
N	AT91_REG	 EMAC_RLE; 	// Receive Length Field Mismatch Register
N	AT91_REG	 EMAC_TPF; 	// Transmitted Pause Frames Register
N	AT91_REG	 EMAC_HRB; 	// Hash Address Bottom[31:0]
N	AT91_REG	 EMAC_HRT; 	// Hash Address Top[63:32]
N	AT91_REG	 EMAC_SA1L; 	// Specific Address 1 Bottom, First 4 bytes
N	AT91_REG	 EMAC_SA1H; 	// Specific Address 1 Top, Last 2 bytes
N	AT91_REG	 EMAC_SA2L; 	// Specific Address 2 Bottom, First 4 bytes
N	AT91_REG	 EMAC_SA2H; 	// Specific Address 2 Top, Last 2 bytes
N	AT91_REG	 EMAC_SA3L; 	// Specific Address 3 Bottom, First 4 bytes
N	AT91_REG	 EMAC_SA3H; 	// Specific Address 3 Top, Last 2 bytes
N	AT91_REG	 EMAC_SA4L; 	// Specific Address 4 Bottom, First 4 bytes
N	AT91_REG	 EMAC_SA4H; 	// Specific Address 4 Top, Last 2 bytes
N	AT91_REG	 EMAC_TID; 	// Type ID Checking Register
N	AT91_REG	 EMAC_TPQ; 	// Transmit Pause Quantum Register
N	AT91_REG	 EMAC_USRIO; 	// USER Input/Output Register
N	AT91_REG	 EMAC_WOL; 	// Wake On LAN Register
N	AT91_REG	 Reserved1[13]; 	// 
N	AT91_REG	 EMAC_REV; 	// Revision Register
N} AT91S_EMAC, *AT91PS_EMAC;
N#else
S#define EMAC_NCR        (AT91_CAST(AT91_REG *) 	0x00000000) // (EMAC_NCR) Network Control Register
S#define EMAC_NCFGR      (AT91_CAST(AT91_REG *) 	0x00000004) // (EMAC_NCFGR) Network Configuration Register
S#define EMAC_NSR        (AT91_CAST(AT91_REG *) 	0x00000008) // (EMAC_NSR) Network Status Register
S#define EMAC_TSR        (AT91_CAST(AT91_REG *) 	0x00000014) // (EMAC_TSR) Transmit Status Register
S#define EMAC_RBQP       (AT91_CAST(AT91_REG *) 	0x00000018) // (EMAC_RBQP) Receive Buffer Queue Pointer
S#define EMAC_TBQP       (AT91_CAST(AT91_REG *) 	0x0000001C) // (EMAC_TBQP) Transmit Buffer Queue Pointer
S#define EMAC_RSR        (AT91_CAST(AT91_REG *) 	0x00000020) // (EMAC_RSR) Receive Status Register
S#define EMAC_ISR        (AT91_CAST(AT91_REG *) 	0x00000024) // (EMAC_ISR) Interrupt Status Register
S#define EMAC_IER        (AT91_CAST(AT91_REG *) 	0x00000028) // (EMAC_IER) Interrupt Enable Register
S#define EMAC_IDR        (AT91_CAST(AT91_REG *) 	0x0000002C) // (EMAC_IDR) Interrupt Disable Register
S#define EMAC_IMR        (AT91_CAST(AT91_REG *) 	0x00000030) // (EMAC_IMR) Interrupt Mask Register
S#define EMAC_MAN        (AT91_CAST(AT91_REG *) 	0x00000034) // (EMAC_MAN) PHY Maintenance Register
S#define EMAC_PTR        (AT91_CAST(AT91_REG *) 	0x00000038) // (EMAC_PTR) Pause Time Register
S#define EMAC_PFR        (AT91_CAST(AT91_REG *) 	0x0000003C) // (EMAC_PFR) Pause Frames received Register
S#define EMAC_FTO        (AT91_CAST(AT91_REG *) 	0x00000040) // (EMAC_FTO) Frames Transmitted OK Register
S#define EMAC_SCF        (AT91_CAST(AT91_REG *) 	0x00000044) // (EMAC_SCF) Single Collision Frame Register
S#define EMAC_MCF        (AT91_CAST(AT91_REG *) 	0x00000048) // (EMAC_MCF) Multiple Collision Frame Register
S#define EMAC_FRO        (AT91_CAST(AT91_REG *) 	0x0000004C) // (EMAC_FRO) Frames Received OK Register
S#define EMAC_FCSE       (AT91_CAST(AT91_REG *) 	0x00000050) // (EMAC_FCSE) Frame Check Sequence Error Register
S#define EMAC_ALE        (AT91_CAST(AT91_REG *) 	0x00000054) // (EMAC_ALE) Alignment Error Register
S#define EMAC_DTF        (AT91_CAST(AT91_REG *) 	0x00000058) // (EMAC_DTF) Deferred Transmission Frame Register
S#define EMAC_LCOL       (AT91_CAST(AT91_REG *) 	0x0000005C) // (EMAC_LCOL) Late Collision Register
S#define EMAC_ECOL       (AT91_CAST(AT91_REG *) 	0x00000060) // (EMAC_ECOL) Excessive Collision Register
S#define EMAC_TUND       (AT91_CAST(AT91_REG *) 	0x00000064) // (EMAC_TUND) Transmit Underrun Error Register
S#define EMAC_CSE        (AT91_CAST(AT91_REG *) 	0x00000068) // (EMAC_CSE) Carrier Sense Error Register
S#define EMAC_RRE        (AT91_CAST(AT91_REG *) 	0x0000006C) // (EMAC_RRE) Receive Ressource Error Register
S#define EMAC_ROV        (AT91_CAST(AT91_REG *) 	0x00000070) // (EMAC_ROV) Receive Overrun Errors Register
S#define EMAC_RSE        (AT91_CAST(AT91_REG *) 	0x00000074) // (EMAC_RSE) Receive Symbol Errors Register
S#define EMAC_ELE        (AT91_CAST(AT91_REG *) 	0x00000078) // (EMAC_ELE) Excessive Length Errors Register
S#define EMAC_RJA        (AT91_CAST(AT91_REG *) 	0x0000007C) // (EMAC_RJA) Receive Jabbers Register
S#define EMAC_USF        (AT91_CAST(AT91_REG *) 	0x00000080) // (EMAC_USF) Undersize Frames Register
S#define EMAC_STE        (AT91_CAST(AT91_REG *) 	0x00000084) // (EMAC_STE) SQE Test Error Register
S#define EMAC_RLE        (AT91_CAST(AT91_REG *) 	0x00000088) // (EMAC_RLE) Receive Length Field Mismatch Register
S#define EMAC_TPF        (AT91_CAST(AT91_REG *) 	0x0000008C) // (EMAC_TPF) Transmitted Pause Frames Register
S#define EMAC_HRB        (AT91_CAST(AT91_REG *) 	0x00000090) // (EMAC_HRB) Hash Address Bottom[31:0]
S#define EMAC_HRT        (AT91_CAST(AT91_REG *) 	0x00000094) // (EMAC_HRT) Hash Address Top[63:32]
S#define EMAC_SA1L       (AT91_CAST(AT91_REG *) 	0x00000098) // (EMAC_SA1L) Specific Address 1 Bottom, First 4 bytes
S#define EMAC_SA1H       (AT91_CAST(AT91_REG *) 	0x0000009C) // (EMAC_SA1H) Specific Address 1 Top, Last 2 bytes
S#define EMAC_SA2L       (AT91_CAST(AT91_REG *) 	0x000000A0) // (EMAC_SA2L) Specific Address 2 Bottom, First 4 bytes
S#define EMAC_SA2H       (AT91_CAST(AT91_REG *) 	0x000000A4) // (EMAC_SA2H) Specific Address 2 Top, Last 2 bytes
S#define EMAC_SA3L       (AT91_CAST(AT91_REG *) 	0x000000A8) // (EMAC_SA3L) Specific Address 3 Bottom, First 4 bytes
S#define EMAC_SA3H       (AT91_CAST(AT91_REG *) 	0x000000AC) // (EMAC_SA3H) Specific Address 3 Top, Last 2 bytes
S#define EMAC_SA4L       (AT91_CAST(AT91_REG *) 	0x000000B0) // (EMAC_SA4L) Specific Address 4 Bottom, First 4 bytes
S#define EMAC_SA4H       (AT91_CAST(AT91_REG *) 	0x000000B4) // (EMAC_SA4H) Specific Address 4 Top, Last 2 bytes
S#define EMAC_TID        (AT91_CAST(AT91_REG *) 	0x000000B8) // (EMAC_TID) Type ID Checking Register
S#define EMAC_TPQ        (AT91_CAST(AT91_REG *) 	0x000000BC) // (EMAC_TPQ) Transmit Pause Quantum Register
S#define EMAC_USRIO      (AT91_CAST(AT91_REG *) 	0x000000C0) // (EMAC_USRIO) USER Input/Output Register
S#define EMAC_WOL        (AT91_CAST(AT91_REG *) 	0x000000C4) // (EMAC_WOL) Wake On LAN Register
S#define EMAC_REV        (AT91_CAST(AT91_REG *) 	0x000000FC) // (EMAC_REV) Revision Register
S
N#endif
N// -------- EMAC_NCR : (EMAC Offset: 0x0)  -------- 
N#define AT91C_EMAC_LB         (0x1 <<  0) // (EMAC) Loopback. Optional. When set, loopback signal is at high level.
N#define AT91C_EMAC_LLB        (0x1 <<  1) // (EMAC) Loopback local. 
N#define AT91C_EMAC_RE         (0x1 <<  2) // (EMAC) Receive enable. 
N#define AT91C_EMAC_TE         (0x1 <<  3) // (EMAC) Transmit enable. 
N#define AT91C_EMAC_MPE        (0x1 <<  4) // (EMAC) Management port enable. 
N#define AT91C_EMAC_CLRSTAT    (0x1 <<  5) // (EMAC) Clear statistics registers. 
N#define AT91C_EMAC_INCSTAT    (0x1 <<  6) // (EMAC) Increment statistics registers. 
N#define AT91C_EMAC_WESTAT     (0x1 <<  7) // (EMAC) Write enable for statistics registers. 
N#define AT91C_EMAC_BP         (0x1 <<  8) // (EMAC) Back pressure. 
N#define AT91C_EMAC_TSTART     (0x1 <<  9) // (EMAC) Start Transmission. 
N#define AT91C_EMAC_THALT      (0x1 << 10) // (EMAC) Transmission Halt. 
N#define AT91C_EMAC_TPFR       (0x1 << 11) // (EMAC) Transmit pause frame 
N#define AT91C_EMAC_TZQ        (0x1 << 12) // (EMAC) Transmit zero quantum pause frame
N// -------- EMAC_NCFGR : (EMAC Offset: 0x4) Network Configuration Register -------- 
N#define AT91C_EMAC_SPD        (0x1 <<  0) // (EMAC) Speed. 
N#define AT91C_EMAC_FD         (0x1 <<  1) // (EMAC) Full duplex. 
N#define AT91C_EMAC_JFRAME     (0x1 <<  3) // (EMAC) Jumbo Frames. 
N#define AT91C_EMAC_CAF        (0x1 <<  4) // (EMAC) Copy all frames. 
N#define AT91C_EMAC_NBC        (0x1 <<  5) // (EMAC) No broadcast. 
N#define AT91C_EMAC_MTI        (0x1 <<  6) // (EMAC) Multicast hash event enable
N#define AT91C_EMAC_UNI        (0x1 <<  7) // (EMAC) Unicast hash enable. 
N#define AT91C_EMAC_BIG        (0x1 <<  8) // (EMAC) Receive 1522 bytes. 
N#define AT91C_EMAC_EAE        (0x1 <<  9) // (EMAC) External address match enable. 
N#define AT91C_EMAC_CLK        (0x3 << 10) // (EMAC) 
N#define 	AT91C_EMAC_CLK_HCLK_8               (0x0 << 10) // (EMAC) HCLK divided by 8
N#define 	AT91C_EMAC_CLK_HCLK_16              (0x1 << 10) // (EMAC) HCLK divided by 16
N#define 	AT91C_EMAC_CLK_HCLK_32              (0x2 << 10) // (EMAC) HCLK divided by 32
N#define 	AT91C_EMAC_CLK_HCLK_64              (0x3 << 10) // (EMAC) HCLK divided by 64
N#define AT91C_EMAC_RTY        (0x1 << 12) // (EMAC) 
N#define AT91C_EMAC_PAE        (0x1 << 13) // (EMAC) 
N#define AT91C_EMAC_RBOF       (0x3 << 14) // (EMAC) 
N#define 	AT91C_EMAC_RBOF_OFFSET_0             (0x0 << 14) // (EMAC) no offset from start of receive buffer
N#define 	AT91C_EMAC_RBOF_OFFSET_1             (0x1 << 14) // (EMAC) one byte offset from start of receive buffer
N#define 	AT91C_EMAC_RBOF_OFFSET_2             (0x2 << 14) // (EMAC) two bytes offset from start of receive buffer
N#define 	AT91C_EMAC_RBOF_OFFSET_3             (0x3 << 14) // (EMAC) three bytes offset from start of receive buffer
N#define AT91C_EMAC_RLCE       (0x1 << 16) // (EMAC) Receive Length field Checking Enable
N#define AT91C_EMAC_DRFCS      (0x1 << 17) // (EMAC) Discard Receive FCS
N#define AT91C_EMAC_EFRHD      (0x1 << 18) // (EMAC) 
N#define AT91C_EMAC_IRXFCS     (0x1 << 19) // (EMAC) Ignore RX FCS
N// -------- EMAC_NSR : (EMAC Offset: 0x8) Network Status Register -------- 
N#define AT91C_EMAC_LINKR      (0x1 <<  0) // (EMAC) 
N#define AT91C_EMAC_MDIO       (0x1 <<  1) // (EMAC) 
N#define AT91C_EMAC_IDLE       (0x1 <<  2) // (EMAC) 
N// -------- EMAC_TSR : (EMAC Offset: 0x14) Transmit Status Register -------- 
N#define AT91C_EMAC_UBR        (0x1 <<  0) // (EMAC) 
N#define AT91C_EMAC_COL        (0x1 <<  1) // (EMAC) 
N#define AT91C_EMAC_RLES       (0x1 <<  2) // (EMAC) 
N#define AT91C_EMAC_TGO        (0x1 <<  3) // (EMAC) Transmit Go
N#define AT91C_EMAC_BEX        (0x1 <<  4) // (EMAC) Buffers exhausted mid frame
N#define AT91C_EMAC_COMP       (0x1 <<  5) // (EMAC) 
N#define AT91C_EMAC_UND        (0x1 <<  6) // (EMAC) 
N// -------- EMAC_RSR : (EMAC Offset: 0x20) Receive Status Register -------- 
N#define AT91C_EMAC_BNA        (0x1 <<  0) // (EMAC) 
N#define AT91C_EMAC_REC        (0x1 <<  1) // (EMAC) 
N#define AT91C_EMAC_OVR        (0x1 <<  2) // (EMAC) 
N// -------- EMAC_ISR : (EMAC Offset: 0x24) Interrupt Status Register -------- 
N#define AT91C_EMAC_MFD        (0x1 <<  0) // (EMAC) 
N#define AT91C_EMAC_RCOMP      (0x1 <<  1) // (EMAC) 
N#define AT91C_EMAC_RXUBR      (0x1 <<  2) // (EMAC) 
N#define AT91C_EMAC_TXUBR      (0x1 <<  3) // (EMAC) 
N#define AT91C_EMAC_TUNDR      (0x1 <<  4) // (EMAC) 
N#define AT91C_EMAC_RLEX       (0x1 <<  5) // (EMAC) 
N#define AT91C_EMAC_TXERR      (0x1 <<  6) // (EMAC) 
N#define AT91C_EMAC_TCOMP      (0x1 <<  7) // (EMAC) 
N#define AT91C_EMAC_LINK       (0x1 <<  9) // (EMAC) 
N#define AT91C_EMAC_ROVR       (0x1 << 10) // (EMAC) 
N#define AT91C_EMAC_HRESP      (0x1 << 11) // (EMAC) 
N#define AT91C_EMAC_PFRE       (0x1 << 12) // (EMAC) 
N#define AT91C_EMAC_PTZ        (0x1 << 13) // (EMAC) 
N#define AT91C_EMAC_WOLEV      (0x1 << 14) // (EMAC) 
N// -------- EMAC_IER : (EMAC Offset: 0x28) Interrupt Enable Register -------- 
N#define AT91C_                (0x0 << 14) // (EMAC) 
N// -------- EMAC_IDR : (EMAC Offset: 0x2c) Interrupt Disable Register -------- 
N// -------- EMAC_IMR : (EMAC Offset: 0x30) Interrupt Mask Register -------- 
N// -------- EMAC_MAN : (EMAC Offset: 0x34) PHY Maintenance Register -------- 
N#define AT91C_EMAC_DATA       (0xFFFF <<  0) // (EMAC) 
N#define AT91C_EMAC_CODE       (0x3 << 16) // (EMAC) 
N#define AT91C_EMAC_REGA       (0x1F << 18) // (EMAC) 
N#define AT91C_EMAC_PHYA       (0x1F << 23) // (EMAC) 
N#define AT91C_EMAC_RW         (0x3 << 28) // (EMAC) 
N#define AT91C_EMAC_SOF        (0x3 << 30) // (EMAC) 
N// -------- EMAC_USRIO : (EMAC Offset: 0xc0) USER Input Output Register -------- 
N#define AT91C_EMAC_RMII       (0x1 <<  0) // (EMAC) Reduce MII
N#define AT91C_EMAC_CLKEN      (0x1 <<  1) // (EMAC) Clock Enable
N// -------- EMAC_WOL : (EMAC Offset: 0xc4) Wake On LAN Register -------- 
N#define AT91C_EMAC_IP         (0xFFFF <<  0) // (EMAC) ARP request IP address
N#define AT91C_EMAC_MAG        (0x1 << 16) // (EMAC) Magic packet event enable
N#define AT91C_EMAC_ARP        (0x1 << 17) // (EMAC) ARP request event enable
N#define AT91C_EMAC_SA1        (0x1 << 18) // (EMAC) Specific address register 1 event enable
N// -------- EMAC_REV : (EMAC Offset: 0xfc) Revision Register -------- 
N#define AT91C_EMAC_REVREF     (0xFFFF <<  0) // (EMAC) 
N#define AT91C_EMAC_PARTREF    (0xFFFF << 16) // (EMAC) 
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR Image Sensor Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_ISI {
N	AT91_REG	 ISI_CFG1; 	// Configuration Register 1
N	AT91_REG	 ISI_CFG2; 	// Configuration Register 2
N	AT91_REG	 ISI_PSIZE; 	// Preview Size Register
N	AT91_REG	 ISI_PDECF; 	// Preview Decimation Factor Register
N	AT91_REG	 ISI_Y2RSET0; 	// Color Space Conversion YCrCb to RGB Register
N	AT91_REG	 ISI_Y2RSET1; 	// Color Space Conversion YCrCb to RGB Register
N	AT91_REG	 ISI_R2YSET0; 	// Color Space Conversion RGB to YCrCb Register
N	AT91_REG	 ISI_R2YSET1; 	// Color Space Conversion RGB to YCrCb Register
N	AT91_REG	 ISI_R2YSET2; 	// Color Space Conversion RGB to YCrCb Register
N	AT91_REG	 ISI_CTRL; 	// Control Register
N	AT91_REG	 ISI_SR; 	// Status Register
N	AT91_REG	 ISI_IER; 	// Interrupt Enable Register
N	AT91_REG	 ISI_IDR; 	// Interrupt Disable Register
N	AT91_REG	 ISI_IMR; 	// Interrupt Mask Register
N	AT91_REG	 ISI_DMACHER; 	// DMA Channel Enable Register
N	AT91_REG	 ISI_DMACHDR; 	// DMA Channel Disable Register
N	AT91_REG	 ISI_DMACHSR; 	// DMA Channel Status Register
N	AT91_REG	 ISI_DMAPADDR; 	// DMA Preview Base Address Register
N	AT91_REG	 ISI_DMAPCTRL; 	// DMA Preview Control Register
N	AT91_REG	 ISI_DMAPDSCR; 	// DMA Preview Descriptor Address Register
N	AT91_REG	 ISI_DMACADDR; 	// DMA Codec Base Address Register
N	AT91_REG	 ISI_DMACCTRL; 	// DMA Codec Control Register
N	AT91_REG	 ISI_DMACDSCR; 	// DMA Codec Descriptor Address Register
N	AT91_REG	 Reserved0[34]; 	// 
N	AT91_REG	 ISI_WPCR; 	// Write Protection Control Register
N	AT91_REG	 ISI_WPSR; 	// Write Protection Status Register
N	AT91_REG	 Reserved1[4]; 	// 
N	AT91_REG	 ISI_VER; 	// Version Register
N} AT91S_ISI, *AT91PS_ISI;
N#else
S#define ISI_CFG1        (AT91_CAST(AT91_REG *) 	0x00000000) // (ISI_CFG1) Configuration Register 1
S#define ISI_CFG2        (AT91_CAST(AT91_REG *) 	0x00000004) // (ISI_CFG2) Configuration Register 2
S#define ISI_PSIZE       (AT91_CAST(AT91_REG *) 	0x00000008) // (ISI_PSIZE) Preview Size Register
S#define ISI_PDECF       (AT91_CAST(AT91_REG *) 	0x0000000C) // (ISI_PDECF) Preview Decimation Factor Register
S#define ISI_Y2RSET0     (AT91_CAST(AT91_REG *) 	0x00000010) // (ISI_Y2RSET0) Color Space Conversion YCrCb to RGB Register
S#define ISI_Y2RSET1     (AT91_CAST(AT91_REG *) 	0x00000014) // (ISI_Y2RSET1) Color Space Conversion YCrCb to RGB Register
S#define ISI_R2YSET0     (AT91_CAST(AT91_REG *) 	0x00000018) // (ISI_R2YSET0) Color Space Conversion RGB to YCrCb Register
S#define ISI_R2YSET1     (AT91_CAST(AT91_REG *) 	0x0000001C) // (ISI_R2YSET1) Color Space Conversion RGB to YCrCb Register
S#define ISI_R2YSET2     (AT91_CAST(AT91_REG *) 	0x00000020) // (ISI_R2YSET2) Color Space Conversion RGB to YCrCb Register
S#define ISI_CTRL        (AT91_CAST(AT91_REG *) 	0x00000024) // (ISI_CTRL) Control Register
S#define ISI_SR          (AT91_CAST(AT91_REG *) 	0x00000028) // (ISI_SR) Status Register
S#define ISI_IER         (AT91_CAST(AT91_REG *) 	0x0000002C) // (ISI_IER) Interrupt Enable Register
S#define ISI_IDR         (AT91_CAST(AT91_REG *) 	0x00000030) // (ISI_IDR) Interrupt Disable Register
S#define ISI_IMR         (AT91_CAST(AT91_REG *) 	0x00000034) // (ISI_IMR) Interrupt Mask Register
S#define ISI_DMACHER     (AT91_CAST(AT91_REG *) 	0x00000038) // (ISI_DMACHER) DMA Channel Enable Register
S#define ISI_DMACHDR     (AT91_CAST(AT91_REG *) 	0x0000003C) // (ISI_DMACHDR) DMA Channel Disable Register
S#define ISI_DMACHSR     (AT91_CAST(AT91_REG *) 	0x00000040) // (ISI_DMACHSR) DMA Channel Status Register
S#define ISI_DMAPADDR    (AT91_CAST(AT91_REG *) 	0x00000044) // (ISI_DMAPADDR) DMA Preview Base Address Register
S#define ISI_DMAPCTRL    (AT91_CAST(AT91_REG *) 	0x00000048) // (ISI_DMAPCTRL) DMA Preview Control Register
S#define ISI_DMAPDSCR    (AT91_CAST(AT91_REG *) 	0x0000004C) // (ISI_DMAPDSCR) DMA Preview Descriptor Address Register
S#define ISI_DMACADDR    (AT91_CAST(AT91_REG *) 	0x00000050) // (ISI_DMACADDR) DMA Codec Base Address Register
S#define ISI_DMACCTRL    (AT91_CAST(AT91_REG *) 	0x00000054) // (ISI_DMACCTRL) DMA Codec Control Register
S#define ISI_DMACDSCR    (AT91_CAST(AT91_REG *) 	0x00000058) // (ISI_DMACDSCR) DMA Codec Descriptor Address Register
S#define ISI_WPCR        (AT91_CAST(AT91_REG *) 	0x000000E4) // (ISI_WPCR) Write Protection Control Register
S#define ISI_WPSR        (AT91_CAST(AT91_REG *) 	0x000000E8) // (ISI_WPSR) Write Protection Status Register
S#define ISI_VER         (AT91_CAST(AT91_REG *) 	0x000000FC) // (ISI_VER) Version Register
S
N#endif
N// -------- ISI_CFG1 : (ISI Offset: 0x0) ISI Configuration Register 1 -------- 
N#define AT91C_ISI_HSYNC_POL   (0x1 <<  2) // (ISI) Horizontal synchronization polarity
N#define 	AT91C_ISI_HSYNC_POL_ACTIVE_HIGH          (0x0 <<  2) // (ISI) HSYNC active high.
N#define 	AT91C_ISI_HSYNC_POL_ACTIVE_LOW           (0x1 <<  2) // (ISI) HSYNC active low.
N#define AT91C_ISI_VSYNC_POL   (0x1 <<  3) // (ISI) Vertical synchronization polarity
N#define 	AT91C_ISI_VSYNC_POL_ACTIVE_HIGH          (0x0 <<  3) // (ISI) VSYNC active high.
N#define 	AT91C_ISI_VSYNC_POL_ACTIVE_LOW           (0x1 <<  3) // (ISI) VSYNC active low.
N#define AT91C_ISI_PIXCLK_POL  (0x1 <<  4) // (ISI) Pixel Clock Polarity
N#define 	AT91C_ISI_PIXCLK_POL_RISING_EDGE          (0x0 <<  4) // (ISI) Data is sampled on rising edge of pixel clock.
N#define 	AT91C_ISI_PIXCLK_POL_FALLING_EDGE         (0x1 <<  4) // (ISI) Data is sampled on falling edge of pixel clock.
N#define AT91C_ISI_EMB_SYNC    (0x1 <<  6) // (ISI) Embedded synchronisation
N#define 	AT91C_ISI_EMB_SYNC_HSYNC_VSYNC          (0x0 <<  6) // (ISI) Synchronization by HSYNC, VSYNC.
N#define 	AT91C_ISI_EMB_SYNC_SAV_EAV              (0x1 <<  6) // (ISI) Synchronisation by Embedded Synchronization Sequence SAV/EAV.
N#define AT91C_ISI_CRC_SYNC    (0x1 <<  7) // (ISI) CRC correction
N#define 	AT91C_ISI_CRC_SYNC_CORRECTION_OFF       (0x0 <<  7) // (ISI) No CRC correction performed on embedded synchronization.
N#define 	AT91C_ISI_CRC_SYNC_CORRECTION_ON        (0x1 <<  7) // (ISI) CRC correction is performed.
N#define AT91C_ISI_FRATE       (0x7 <<  8) // (ISI) Frame rate capture
N#define AT91C_ISI_FULL        (0x1 << 12) // (ISI) Full mode is allowed
N#define 	AT91C_ISI_FULL_MODE_DISABLE         (0x0 << 12) // (ISI) Full mode disabled.
N#define 	AT91C_ISI_FULL_MODE_ENABLE          (0x1 << 12) // (ISI) both codec and preview datapath are working simultaneously.
N#define AT91C_ISI_THMASK      (0x3 << 13) // (ISI) DMA Burst Mask
N#define 	AT91C_ISI_THMASK_4_BURST              (0x0 << 13) // (ISI) Only 4 beats AHB bursts are allowed
N#define 	AT91C_ISI_THMASK_4_8_BURST            (0x1 << 13) // (ISI) Only 4 and 8 beats AHB bursts are allowed
N#define 	AT91C_ISI_THMASK_4_8_16_BURST         (0x2 << 13) // (ISI) 4, 8 and 16 beats AHB bursts are allowed
N#define AT91C_ISI_SLD         (0xFF << 16) // (ISI) Start of Line Delay
N#define AT91C_ISI_SFD         (0xFF << 24) // (ISI) Start of frame Delay
N// -------- ISI_CFG2 : (ISI Offset: 0x4) ISI Control Register 2 -------- 
N#define AT91C_ISI_IM_VSIZE    (0x7FF <<  0) // (ISI) Vertical size of the Image sensor [0..2047]
N#define AT91C_ISI_GS_MODE     (0x1 << 11) // (ISI) Grayscale Memory Mode
N#define 	AT91C_ISI_GS_MODE_2_PIXELS             (0x0 << 11) // (ISI) 2 pixels per word.
N#define 	AT91C_ISI_GS_MODE_1_PIXEL              (0x1 << 11) // (ISI) 1 pixel per word.
N#define AT91C_ISI_RGB_MODE    (0x1 << 12) // (ISI) RGB mode
N#define 	AT91C_ISI_RGB_MODE_RGB_888              (0x0 << 12) // (ISI) RGB 8:8:8 24 bits
N#define 	AT91C_ISI_RGB_MODE_RGB_565              (0x1 << 12) // (ISI) RGB 5:6:5 16 bits
N#define AT91C_ISI_GRAYSCALE   (0x1 << 13) // (ISI) Grayscale Mode
N#define 	AT91C_ISI_GRAYSCALE_DISABLE              (0x0 << 13) // (ISI) Grayscale mode is disabled
N#define 	AT91C_ISI_GRAYSCALE_ENABLE               (0x1 << 13) // (ISI) Input image is assumed to be grayscale coded
N#define AT91C_ISI_RGB_SWAP    (0x1 << 14) // (ISI) RGB Swap
N#define 	AT91C_ISI_RGB_SWAP_DISABLE              (0x0 << 14) // (ISI) D7 -> R7
N#define 	AT91C_ISI_RGB_SWAP_ENABLE               (0x1 << 14) // (ISI) D0 -> R7
N#define AT91C_ISI_COL_SPACE   (0x1 << 15) // (ISI) Color space for the image data
N#define 	AT91C_ISI_COL_SPACE_YCBCR                (0x0 << 15) // (ISI) YCbCr
N#define 	AT91C_ISI_COL_SPACE_RGB                  (0x1 << 15) // (ISI) RGB
N#define AT91C_ISI_IM_HSIZE    (0x7FF << 16) // (ISI) Horizontal size of the Image sensor [0..2047]
N#define AT91C_ISI_YCC_SWAP    (0x3 << 28) // (ISI) Ycc swap
N#define 	AT91C_ISI_YCC_SWAP_YCC_DEFAULT          (0x0 << 28) // (ISI) Cb(i) Y(i) Cr(i) Y(i+1)
N#define 	AT91C_ISI_YCC_SWAP_YCC_MODE1            (0x1 << 28) // (ISI) Cr(i) Y(i) Cb(i) Y(i+1)
N#define 	AT91C_ISI_YCC_SWAP_YCC_MODE2            (0x2 << 28) // (ISI) Y(i) Cb(i) Y(i+1) Cr(i)
N#define 	AT91C_ISI_YCC_SWAP_YCC_MODE3            (0x3 << 28) // (ISI) Y(i) Cr(i) Y(i+1) Cb(i)
N#define AT91C_ISI_RGB_CFG     (0x3 << 30) // (ISI) RGB configuration
N#define 	AT91C_ISI_RGB_CFG_RGB_DEFAULT          (0x0 << 30) // (ISI) R/G(MSB)  G(LSB)/B  R/G(MSB)  G(LSB)/B
N#define 	AT91C_ISI_RGB_CFG_RGB_MODE1            (0x1 << 30) // (ISI) B/G(MSB)  G(LSB)/R  B/G(MSB)  G(LSB)/R
N#define 	AT91C_ISI_RGB_CFG_RGB_MODE2            (0x2 << 30) // (ISI) G(LSB)/R  B/G(MSB)  G(LSB)/R  B/G(MSB)
N#define 	AT91C_ISI_RGB_CFG_RGB_MODE3            (0x3 << 30) // (ISI) G(LSB)/B  R/G(MSB)  G(LSB)/B  R/G(MSB)
N// -------- ISI_PSIZE : (ISI Offset: 0x8) ISI Preview Register -------- 
N#define AT91C_ISI_PREV_VSIZE  (0x3FF <<  0) // (ISI) Vertical size for the preview path
N#define AT91C_ISI_PREV_HSIZE  (0x3FF << 16) // (ISI) Horizontal size for the preview path
N// -------- ISI_PDECF : (ISI Offset: 0xc) ISI Preview Decimation Factor Register -------- 
N#define AT91C_ISI_DEC_FACTOR  (0xFF <<  0) // (ISI) Decimation factor
N// -------- ISI_Y2RSET0 : (ISI Offset: 0x10) Color Space Conversion YCrCb to RGB Register -------- 
N#define AT91C_ISI_Y2R_C0      (0xFF <<  0) // (ISI) Color Space Conversion Matrix Coefficient C0
N#define AT91C_ISI_Y2R_C1      (0xFF <<  8) // (ISI) Color Space Conversion Matrix Coefficient C1
N#define AT91C_ISI_Y2R_C2      (0xFF << 16) // (ISI) Color Space Conversion Matrix Coefficient C2
N#define AT91C_ISI_Y2R_C3      (0xFF << 24) // (ISI) Color Space Conversion Matrix Coefficient C3
N// -------- ISI_Y2RSET1 : (ISI Offset: 0x14) ISI Color Space Conversion YCrCb to RGB set 1 Register -------- 
N#define AT91C_ISI_Y2R_C4      (0x1FF <<  0) // (ISI) Color Space Conversion Matrix Coefficient C4
N#define AT91C_ISI_Y2R_YOFF    (0x1 << 12) // (ISI) Color Space Conversion Luninance default offset
N#define 	AT91C_ISI_Y2R_YOFF_0                    (0x0 << 12) // (ISI) Offset is 0
N#define 	AT91C_ISI_Y2R_YOFF_128                  (0x1 << 12) // (ISI) Offset is 128
N#define AT91C_ISI_Y2R_CROFF   (0x1 << 13) // (ISI) Color Space Conversion Red Chrominance default offset
N#define 	AT91C_ISI_Y2R_CROFF_0                    (0x0 << 13) // (ISI) Offset is 0
N#define 	AT91C_ISI_Y2R_CROFF_16                   (0x1 << 13) // (ISI) Offset is 16
N#define AT91C_ISI_Y2R_CBOFF   (0x1 << 14) // (ISI) Color Space Conversion Blue Chrominance default offset
N#define 	AT91C_ISI_Y2R_CBOFF_0                    (0x0 << 14) // (ISI) Offset is 0
N#define 	AT91C_ISI_Y2R_CBOFF_16                   (0x1 << 14) // (ISI) Offset is 16
N// -------- ISI_R2YSET0 : (ISI Offset: 0x18) Color Space Conversion RGB to YCrCb set 0 register -------- 
N#define AT91C_ISI_R2Y_C0      (0x7F <<  0) // (ISI) Color Space Conversion RGB to YCrCb Matrix coefficient C0
N#define AT91C_ISI_R2Y_C1      (0x7F <<  8) // (ISI) Color Space Conversion RGB to YCrCb Matrix coefficient C1
N#define AT91C_ISI_R2Y_C2      (0x7F << 16) // (ISI) Color Space Conversion RGB to YCrCb Matrix coefficient C2
N#define AT91C_ISI_R2Y_ROFF    (0x1 << 24) // (ISI) Color Space Conversion Red component offset
N#define 	AT91C_ISI_R2Y_ROFF_0                    (0x0 << 24) // (ISI) Offset is 0
N#define 	AT91C_ISI_R2Y_ROFF_16                   (0x1 << 24) // (ISI) Offset is 16
N// -------- ISI_R2YSET1 : (ISI Offset: 0x1c) Color Space Conversion RGB to YCrCb set 1 register -------- 
N#define AT91C_ISI_R2Y_C3      (0x7F <<  0) // (ISI) Color Space Conversion RGB to YCrCb Matrix coefficient C3
N#define AT91C_ISI_R2Y_C4      (0x7F <<  8) // (ISI) Color Space Conversion RGB to YCrCb Matrix coefficient C4
N#define AT91C_ISI_R2Y_C5      (0x7F << 16) // (ISI) Color Space Conversion RGB to YCrCb Matrix coefficient C5
N#define AT91C_ISI_R2Y_GOFF    (0x1 << 24) // (ISI) Color Space Conversion Green component offset
N#define 	AT91C_ISI_R2Y_GOFF_0                    (0x0 << 24) // (ISI) Offset is 0
N#define 	AT91C_ISI_R2Y_GOFF_128                  (0x1 << 24) // (ISI) Offset is 128
N// -------- ISI_R2YSET2 : (ISI Offset: 0x20) Color Space Conversion RGB to YCrCb set 2 register -------- 
N#define AT91C_ISI_R2Y_C6      (0x7F <<  0) // (ISI) Color Space Conversion RGB to YCrCb Matrix coefficient C6
N#define AT91C_ISI_R2Y_C7      (0x7F <<  8) // (ISI) Color Space Conversion RGB to YCrCb Matrix coefficient C7
N#define AT91C_ISI_R2Y_C8      (0x7F << 16) // (ISI) Color Space Conversion RGB to YCrCb Matrix coefficient C8
N#define AT91C_ISI_R2Y_BOFF    (0x1 << 24) // (ISI) Color Space Conversion Blue component offset
N#define 	AT91C_ISI_R2Y_BOFF_0                    (0x0 << 24) // (ISI) Offset is 0
N#define 	AT91C_ISI_R2Y_BOFF_128                  (0x1 << 24) // (ISI) Offset is 128
N// -------- ISI_CTRL : (ISI Offset: 0x24) ISI Control Register -------- 
N#define AT91C_ISI_EN          (0x1 <<  0) // (ISI) Image Sensor Interface Enable Request
N#define 	AT91C_ISI_EN_0                    (0x0) // (ISI) No effect
N#define 	AT91C_ISI_EN_1                    (0x1) // (ISI) Enable the module and the capture
N#define AT91C_ISI_DIS         (0x1 <<  1) // (ISI) Image Sensor Interface Disable Request
N#define 	AT91C_ISI_DIS_0                    (0x0 <<  1) // (ISI) No effect
N#define 	AT91C_ISI_DIS_1                    (0x1 <<  1) // (ISI) Disable the module and the capture
N#define AT91C_ISI_SRST        (0x1 <<  2) // (ISI) Software Reset Request
N#define 	AT91C_ISI_SRST_0                    (0x0 <<  2) // (ISI) No effect
N#define 	AT91C_ISI_SRST_1                    (0x1 <<  2) // (ISI) Reset the module
N#define AT91C_ISI_CDC         (0x1 <<  8) // (ISI) Codec Request
N#define 	AT91C_ISI_CDC_0                    (0x0 <<  8) // (ISI) No effect
N#define 	AT91C_ISI_CDC_1                    (0x1 <<  8) // (ISI) Enable the Codec
N// -------- ISI_SR : (ISI Offset: 0x28) ISI Status Register -------- 
N#define AT91C_ISI_VSYNC       (0x1 << 10) // (ISI) Vertical Synchronization
N#define 	AT91C_ISI_VSYNC_0                    (0x0 << 10) // (ISI) No effect
N#define 	AT91C_ISI_VSYNC_1                    (0x1 << 10) // (ISI) Indicates that a Vertical Synchronization has been detected since last read
N#define AT91C_ISI_PXFR_DONE   (0x1 << 16) // (ISI) Preview DMA transfer terminated
N#define 	AT91C_ISI_PXFR_DONE_0                    (0x0 << 16) // (ISI) No effect
N#define 	AT91C_ISI_PXFR_DONE_1                    (0x1 << 16) // (ISI) Indicates that DATA transfer on preview channel has completed since last read
N#define AT91C_ISI_CXFR_DONE   (0x1 << 17) // (ISI) Codec DMA transfer terminated
N#define 	AT91C_ISI_CXFR_DONE_0                    (0x0 << 17) // (ISI) No effect
N#define 	AT91C_ISI_CXFR_DONE_1                    (0x1 << 17) // (ISI) Indicates that DATA transfer on preview channel has completed since last read
N#define AT91C_ISI_SIP         (0x1 << 19) // (ISI) Synchronization In Progress
N#define 	AT91C_ISI_SIP_0                    (0x0 << 19) // (ISI) No effect
N#define 	AT91C_ISI_SIP_1                    (0x1 << 19) // (ISI) Indicates that Synchronization is in progress
N#define AT91C_ISI_P_OVR       (0x1 << 24) // (ISI) Fifo Preview Overflow 
N#define 	AT91C_ISI_P_OVR_0                    (0x0 << 24) // (ISI) No error
N#define 	AT91C_ISI_P_OVR_1                    (0x1 << 24) // (ISI) An overrun condition has occurred in input FIFO on the preview path
N#define AT91C_ISI_C_OVR       (0x1 << 25) // (ISI) Fifo Codec Overflow 
N#define 	AT91C_ISI_C_OVR_0                    (0x0 << 25) // (ISI) No error
N#define 	AT91C_ISI_C_OVR_1                    (0x1 << 25) // (ISI) An overrun condition has occurred in input FIFO on the codec path
N#define AT91C_ISI_CRC_ERR     (0x1 << 26) // (ISI) CRC synchronisation error
N#define 	AT91C_ISI_CRC_ERR_0                    (0x0 << 26) // (ISI) No error
N#define 	AT91C_ISI_CRC_ERR_1                    (0x1 << 26) // (ISI) CRC_SYNC is enabled in the control register and an error has been detected and not corrected. The frame is discarded and the ISI waits for a new one.
N#define AT91C_ISI_FR_OVR      (0x1 << 27) // (ISI) Frame rate overun
N#define 	AT91C_ISI_FR_OVR_0                    (0x0 << 27) // (ISI) No error
N#define 	AT91C_ISI_FR_OVR_1                    (0x1 << 27) // (ISI) Frame overrun, the current frame is being skipped because a vsync signal has been detected while flushing FIFOs.
N// -------- ISI_IER : (ISI Offset: 0x2c) ISI Interrupt Enable Register -------- 
N// -------- ISI_IDR : (ISI Offset: 0x30) ISI Interrupt Disable Register -------- 
N// -------- ISI_IMR : (ISI Offset: 0x34) ISI Interrupt Mask Register -------- 
N// -------- ISI_DMACHER : (ISI Offset: 0x38) DMA Channel Enable Register -------- 
N#define AT91C_ISI_P_CH_EN     (0x1 <<  0) // (ISI) Preview Channel Enable
N#define 	AT91C_ISI_P_CH_EN_0                    (0x0) // (ISI) No effect
N#define 	AT91C_ISI_P_CH_EN_1                    (0x1) // (ISI) Enable the Preview Channel
N#define AT91C_ISI_C_CH_EN     (0x1 <<  1) // (ISI) Codec Channel Enable
N#define 	AT91C_ISI_C_CH_EN_0                    (0x0 <<  1) // (ISI) No effect
N#define 	AT91C_ISI_C_CH_EN_1                    (0x1 <<  1) // (ISI) Enable the Codec Channel
N// -------- ISI_DMACHDR : (ISI Offset: 0x3c) DMA Channel Enable Register -------- 
N#define AT91C_ISI_P_CH_DIS    (0x1 <<  0) // (ISI) Preview Channel Disable
N#define 	AT91C_ISI_P_CH_DIS_0                    (0x0) // (ISI) No effect
N#define 	AT91C_ISI_P_CH_DIS_1                    (0x1) // (ISI) Disable the Preview Channel
N#define AT91C_ISI_C_CH_DIS    (0x1 <<  1) // (ISI) Codec Channel Disable
N#define 	AT91C_ISI_C_CH_DIS_0                    (0x0 <<  1) // (ISI) No effect
N#define 	AT91C_ISI_C_CH_DIS_1                    (0x1 <<  1) // (ISI) Disable the Codec Channel
N// -------- ISI_DMACHSR : (ISI Offset: 0x40) DMA Channel Status Register -------- 
N#define AT91C_ISI_P_CH_S      (0x1 <<  0) // (ISI) Preview Channel Disable
N#define 	AT91C_ISI_P_CH_S_0                    (0x0) // (ISI) Preview Channel is disabled
N#define 	AT91C_ISI_P_CH_S_1                    (0x1) // (ISI) Preview Channel is enabled
N#define AT91C_ISI_C_CH_S      (0x1 <<  1) // (ISI) Codec Channel Disable
N#define 	AT91C_ISI_C_CH_S_0                    (0x0 <<  1) // (ISI) Codec Channel is disabled
N#define 	AT91C_ISI_C_CH_S_1                    (0x1 <<  1) // (ISI) Codec Channel is enabled
N// -------- ISI_DMAPCTRL : (ISI Offset: 0x48) DMA Preview Control Register -------- 
N#define AT91C_ISI_P_FETCH     (0x1 <<  0) // (ISI) Preview Descriptor Fetch Control Field
N#define 	AT91C_ISI_P_FETCH_DISABLE              (0x0) // (ISI) Preview Channel Fetch Operation is disabled
N#define 	AT91C_ISI_P_FETCH_ENABLE               (0x1) // (ISI) Preview Channel Fetch Operation is enabled
N#define AT91C_ISI_P_DONE      (0x1 <<  1) // (ISI) Preview Transfer Done Flag
N#define 	AT91C_ISI_P_DONE_0                    (0x0 <<  1) // (ISI) Preview Transfer has not been performed
N#define 	AT91C_ISI_P_DONE_1                    (0x1 <<  1) // (ISI) Preview Transfer has completed
N// -------- ISI_DMACCTRL : (ISI Offset: 0x54) DMA Codec Control Register -------- 
N#define AT91C_ISI_C_FETCH     (0x1 <<  0) // (ISI) Codec Descriptor Fetch Control Field
N#define 	AT91C_ISI_C_FETCH_DISABLE              (0x0) // (ISI) Codec Channel Fetch Operation is disabled
N#define 	AT91C_ISI_C_FETCH_ENABLE               (0x1) // (ISI) Codec Channel Fetch Operation is enabled
N#define AT91C_ISI_C_DONE      (0x1 <<  1) // (ISI) Codec Transfer Done Flag
N#define 	AT91C_ISI_C_DONE_0                    (0x0 <<  1) // (ISI) Codec Transfer has not been performed
N#define 	AT91C_ISI_C_DONE_1                    (0x1 <<  1) // (ISI) Codec Transfer has completed
N// -------- ISI_WPCR : (ISI Offset: 0xe4) Write Protection Control Register -------- 
N#define AT91C_ISI_WP_EN       (0x1 <<  0) // (ISI) Write Protection Enable
N#define 	AT91C_ISI_WP_EN_DISABLE              (0x0) // (ISI) Write Operation is disabled (if WP_KEY corresponds)
N#define 	AT91C_ISI_WP_EN_ENABLE               (0x1) // (ISI) Write Operation is enabled (if WP_KEY corresponds)
N#define AT91C_ISI_WP_KEY      (0xFFFFFF <<  8) // (ISI) Write Protection Key
N// -------- ISI_WPSR : (ISI Offset: 0xe8) Write Protection Status Register -------- 
N#define AT91C_ISI_WP_VS       (0xF <<  0) // (ISI) Write Protection Violation Status
N#define 	AT91C_ISI_WP_VS_NO_VIOLATION         (0x0) // (ISI) No Write Protection Violation detected since last read
N#define 	AT91C_ISI_WP_VS_ON_WRITE             (0x1) // (ISI) Write Protection Violation detected since last read
N#define 	AT91C_ISI_WP_VS_ON_RESET             (0x2) // (ISI) Software Reset Violation detected since last read
N#define 	AT91C_ISI_WP_VS_ON_BOTH              (0x3) // (ISI) Write Protection and Software Reset Violation detected since last read
N#define AT91C_ISI_WP_VSRC     (0xF <<  8) // (ISI) Write Protection Violation Source
N#define 	AT91C_ISI_WP_VSRC_NO_VIOLATION         (0x0 <<  8) // (ISI) No Write Protection Violation detected since last read
N#define 	AT91C_ISI_WP_VSRC_ISI_CFG1             (0x1 <<  8) // (ISI) Write Protection Violation detected on ISI_CFG1 since last read
N#define 	AT91C_ISI_WP_VSRC_ISI_CFG2             (0x2 <<  8) // (ISI) Write Protection Violation detected on ISI_CFG2 since last read
N#define 	AT91C_ISI_WP_VSRC_ISI_PSIZE            (0x3 <<  8) // (ISI) Write Protection Violation detected on ISI_PSIZE since last read
N#define 	AT91C_ISI_WP_VSRC_ISI_PDECF            (0x4 <<  8) // (ISI) Write Protection Violation detected on ISI_PDECF since last read
N#define 	AT91C_ISI_WP_VSRC_ISI_Y2RSET0          (0x5 <<  8) // (ISI) Write Protection Violation detected on ISI_Y2RSET0 since last read
N#define 	AT91C_ISI_WP_VSRC_ISI_Y2RSET1          (0x6 <<  8) // (ISI) Write Protection Violation detected on ISI_Y2RSET1 since last read
N#define 	AT91C_ISI_WP_VSRC_ISI_R2YSET0          (0x7 <<  8) // (ISI) Write Protection Violation detected on ISI_R2YSET0 since last read
N#define 	AT91C_ISI_WP_VSRC_ISI_R2YSET1          (0x8 <<  8) // (ISI) Write Protection Violation detected on ISI_R2YSET1 since last read
N#define 	AT91C_ISI_WP_VSRC_ISI_R2YSET2          (0x9 <<  8) // (ISI) Write Protection Violation detected on ISI_R2YSET2 since last read
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR HANTRO VDEC 7190
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_VDEC {
N	AT91_REG	 VDEC_IDR; 	// ID Register
N	AT91_REG	 VDEC_ISR; 	// Interrupt Status Register
N	AT91_REG	 VDEC_DCR; 	// Device Configuration Register
N} AT91S_VDEC, *AT91PS_VDEC;
N#else
S#define VDEC_IDR        (AT91_CAST(AT91_REG *) 	0x00000000) // (VDEC_IDR) ID Register
S#define VDEC_ISR        (AT91_CAST(AT91_REG *) 	0x00000004) // (VDEC_ISR) Interrupt Status Register
S#define VDEC_DCR        (AT91_CAST(AT91_REG *) 	0x00000008) // (VDEC_DCR) Device Configuration Register
S
N#endif
N// -------- VDEC_IDR : (VDEC Offset: 0x0) VDEC ID Register -------- 
N#define AT91C_VDEC_ID         (0x0 <<  0) // (VDEC) VDEC identification number
N// -------- VDEC_ISR : (VDEC Offset: 0x4) VDEC Interrupt Status Register -------- 
N#define AT91C_VDEC_DEC_E      (0x1 <<  0) // (VDEC) VDEC Decoder Enable
N#define AT91C_VDEC_DEC_IRQ_DIS (0x1 <<  4) // (VDEC) VDEC IRQ disable
N#define AT91C_VDEC_DEC_IRQ    (0x1 <<  8) // (VDEC) VDEC Interrupt Request
N#define AT91C_VDEC_DEC_RDY_INT (0x1 << 12) // (VDEC) VDEC Decoder Ready
N#define AT91C_VDEC_DEC_BUS_INT (0x1 << 13) // (VDEC) VDEC Error response from bus
N#define AT91C_VDEC_DEC_BUFFER_INT (0x1 << 14) // (VDEC) VDEC Buffer empty
N#define AT91C_VDEC_DEC_ASO_INT (0x1 << 15) // (VDEC) VDEC ASO detected
N#define AT91C_VDEC_DEC_ERROR_INT (0x1 << 16) // (VDEC) VDEC Input Data Stream Error
N#define AT91C_VDEC_DEC_SLICE_INT (0x1 << 17) // (VDEC) VDEC JPEG Slice Decoded Interrupt
N#define AT91C_VDEC_DEC_TIMEOUT (0x1 << 18) // (VDEC) VDEC Decoder Timeout
N// -------- VDEC_DCR : (VDEC Offset: 0x8) VDEC Device Configuration Register -------- 
N#define AT91C_VDEC_DEC_MAX_BURST (0x1F <<  0) // (VDEC) VDEC maximum burst length
N#define 	AT91C_VDEC_DEC_MAX_BURST_4                    (0x4) // (VDEC) INCR4
N#define 	AT91C_VDEC_DEC_MAX_BURST_8                    (0x8) // (VDEC) INCR8
N#define 	AT91C_VDEC_DEC_MAX_BURST_16                   (0x10) // (VDEC) INCR16
N#define AT91C_VDEC_PRIORITY_MODE (0x7 <<  5) // (VDEC) VDEC priority mode
N#define 	AT91C_VDEC_PRIORITY_MODE_HW                   (0x0 <<  5) // (VDEC) 
N#define 	AT91C_VDEC_PRIORITY_MODE_WRITE_FT             (0x1 <<  5) // (VDEC) 
N#define 	AT91C_VDEC_PRIORITY_MODE_WRITE_PP             (0x2 <<  5) // (VDEC) 
N#define 	AT91C_VDEC_PRIORITY_MODE_READ_FT              (0x3 <<  5) // (VDEC) 
N#define 	AT91C_VDEC_PRIORITY_MODE_READ_PP              (0x4 <<  5) // (VDEC) 
N#define AT91C_VDEC_DEC_OUT_ENDIAN (0x1 <<  8) // (VDEC) VDEC decoder output endian mode
N#define 	AT91C_VDEC_DEC_OUT_ENDIAN_BIG                  (0x0 <<  8) // (VDEC) BIG ENDIAN
N#define 	AT91C_VDEC_DEC_OUT_ENDIAN_LIT                  (0x1 <<  8) // (VDEC) LITTLE ENDIAN
N#define AT91C_VDEC_DEC_IN_ENDIAN (0x1 <<  9) // (VDEC) VDEC decoder input endian mode
N#define 	AT91C_VDEC_DEC_IN_ENDIAN_BIG                  (0x0 <<  9) // (VDEC) BIG ENDIAN
N#define 	AT91C_VDEC_DEC_IN_ENDIAN_LIT                  (0x1 <<  9) // (VDEC) LITTLE ENDIAN
N#define AT91C_VDEC_DEC_CLK_GATE_E (0x1 << 10) // (VDEC) VDEC dynamic clock gating enable
N#define AT91C_VDEC_DEC_LATENCY (0x3F << 11) // (VDEC) VDEC decoder latency compensation
N#define AT91C_VDEC_DEC_OUT_TILED_E (0x1 << 17) // (VDEC) VDEC identification number
N#define AT91C_VDEC_DEC_DATA_DISC_E (0x1 << 18) // (VDEC) VDEC data discard enable
N#define AT91C_VDEC_DEC_OUTSWAP32_E (0x1 << 19) // (VDEC) VDEC output 32bit data swap
N#define AT91C_VDEC_DEC_INSWAP32_E (0x1 << 20) // (VDEC) VDEC input 32bit data swap
N#define AT91C_VDEC_DEC_STRENDIAN_E (0x1 << 21) // (VDEC) VDEC data stream endian mode
N#define 	AT91C_VDEC_DEC_STRENDIAN_E_BIG                  (0x0 << 21) // (VDEC) BIG ENDIAN
N#define 	AT91C_VDEC_DEC_STRENDIAN_E_LIT                  (0x1 << 21) // (VDEC) LITTLE ENDIAN
N#define AT91C_VDEC_DEC_STRSWAP32_E (0x1 << 22) // (VDEC) VDEC input 32bit data swap for stream data
N#define AT91C_VDEC_DEC_TIMEOUT_E (0x1 << 23) // (VDEC) VDEC timeout interrupt enable
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR USB Host Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_UHPHS_OHCI {
N	AT91_REG	 UHPHS_OHCI_HcRevision; 	// Revision
N	AT91_REG	 UHPHS_OHCI_HcControl; 	// Operating modes for the Host Controller
N	AT91_REG	 UHPHS_OHCI_HcCommandStatus; 	// Command & status Register
N	AT91_REG	 UHPHS_OHCI_HcInterruptStatus; 	// Interrupt Status Register
N	AT91_REG	 UHPHS_OHCI_HcInterruptEnable; 	// Interrupt Enable Register
N	AT91_REG	 UHPHS_OHCI_HcInterruptDisable; 	// Interrupt Disable Register
N	AT91_REG	 UHPHS_OHCI_HcHCCA; 	// Pointer to the Host Controller Communication Area
N	AT91_REG	 UHPHS_OHCI_HcPeriodCurrentED; 	// Current Isochronous or Interrupt Endpoint Descriptor
N	AT91_REG	 UHPHS_OHCI_HcControlHeadED; 	// First Endpoint Descriptor of the Control list
N	AT91_REG	 UHPHS_OHCI_HcControlCurrentED; 	// Endpoint Control and Status Register
N	AT91_REG	 UHPHS_OHCI_HcBulkHeadED; 	// First endpoint register of the Bulk list
N	AT91_REG	 UHPHS_OHCI_HcBulkCurrentED; 	// Current endpoint of the Bulk list
N	AT91_REG	 UHPHS_OHCI_HcBulkDoneHead; 	// Last completed transfer descriptor
N	AT91_REG	 UHPHS_OHCI_HcFmInterval; 	// Bit time between 2 consecutive SOFs
N	AT91_REG	 UHPHS_OHCI_HcFmRemaining; 	// Bit time remaining in the current Frame
N	AT91_REG	 UHPHS_OHCI_HcFmNumber; 	// Frame number
N	AT91_REG	 UHPHS_OHCI_HcPeriodicStart; 	// Periodic Start
N	AT91_REG	 UHPHS_OHCI_HcLSThreshold; 	// LS Threshold
N	AT91_REG	 UHPHS_OHCI_HcRhDescriptorA; 	// Root Hub characteristics A
N	AT91_REG	 UHPHS_OHCI_HcRhDescriptorB; 	// Root Hub characteristics B
N	AT91_REG	 UHPHS_OHCI_HcRhStatus; 	// Root Hub Status register
N	AT91_REG	 UHPHS_OHCI_HcRhPortStatus[2]; 	// Root Hub Port Status Register
N} AT91S_UHPHS_OHCI, *AT91PS_UHPHS_OHCI;
N#else
S#define HcRevision      (AT91_CAST(AT91_REG *) 	0x00000000) // (HcRevision) Revision
S#define HcControl       (AT91_CAST(AT91_REG *) 	0x00000004) // (HcControl) Operating modes for the Host Controller
S#define HcCommandStatus (AT91_CAST(AT91_REG *) 	0x00000008) // (HcCommandStatus) Command & status Register
S#define HcInterruptStatus (AT91_CAST(AT91_REG *) 	0x0000000C) // (HcInterruptStatus) Interrupt Status Register
S#define HcInterruptEnable (AT91_CAST(AT91_REG *) 	0x00000010) // (HcInterruptEnable) Interrupt Enable Register
S#define HcInterruptDisable (AT91_CAST(AT91_REG *) 	0x00000014) // (HcInterruptDisable) Interrupt Disable Register
S#define HcHCCA          (AT91_CAST(AT91_REG *) 	0x00000018) // (HcHCCA) Pointer to the Host Controller Communication Area
S#define HcPeriodCurrentED (AT91_CAST(AT91_REG *) 	0x0000001C) // (HcPeriodCurrentED) Current Isochronous or Interrupt Endpoint Descriptor
S#define HcControlHeadED (AT91_CAST(AT91_REG *) 	0x00000020) // (HcControlHeadED) First Endpoint Descriptor of the Control list
S#define HcControlCurrentED (AT91_CAST(AT91_REG *) 	0x00000024) // (HcControlCurrentED) Endpoint Control and Status Register
S#define HcBulkHeadED    (AT91_CAST(AT91_REG *) 	0x00000028) // (HcBulkHeadED) First endpoint register of the Bulk list
S#define HcBulkCurrentED (AT91_CAST(AT91_REG *) 	0x0000002C) // (HcBulkCurrentED) Current endpoint of the Bulk list
S#define HcBulkDoneHead  (AT91_CAST(AT91_REG *) 	0x00000030) // (HcBulkDoneHead) Last completed transfer descriptor
S#define HcFmInterval    (AT91_CAST(AT91_REG *) 	0x00000034) // (HcFmInterval) Bit time between 2 consecutive SOFs
S#define HcFmRemaining   (AT91_CAST(AT91_REG *) 	0x00000038) // (HcFmRemaining) Bit time remaining in the current Frame
S#define HcFmNumber      (AT91_CAST(AT91_REG *) 	0x0000003C) // (HcFmNumber) Frame number
S#define HcPeriodicStart (AT91_CAST(AT91_REG *) 	0x00000040) // (HcPeriodicStart) Periodic Start
S#define HcLSThreshold   (AT91_CAST(AT91_REG *) 	0x00000044) // (HcLSThreshold) LS Threshold
S#define HcRhDescriptorA (AT91_CAST(AT91_REG *) 	0x00000048) // (HcRhDescriptorA) Root Hub characteristics A
S#define HcRhDescriptorB (AT91_CAST(AT91_REG *) 	0x0000004C) // (HcRhDescriptorB) Root Hub characteristics B
S#define HcRhStatus      (AT91_CAST(AT91_REG *) 	0x00000050) // (HcRhStatus) Root Hub Status register
S#define HcRhPortStatus  (AT91_CAST(AT91_REG *) 	0x00000054) // (HcRhPortStatus) Root Hub Port Status Register
S
N#endif
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR USB Host Interface
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_UHPHS_EHCI {
N	AT91_REG	 UHPHS_EHCI_VERSION; 	// 
N	AT91_REG	 UHPHS_EHCI_HCSPARAMS; 	// 
N	AT91_REG	 UHPHS_EHCI_HCCPARAMS; 	// 
N	AT91_REG	 UHPHS_EHCI_HCSPPORTROUTE; 	// 
N	AT91_REG	 UHPHS_EHCI_USBCMD; 	// 
N	AT91_REG	 UHPHS_EHCI_USBSTS; 	// 
N	AT91_REG	 UHPHS_EHCI_USBINTR; 	// 
N	AT91_REG	 UHPHS_EHCI_FRINDEX; 	// 
N	AT91_REG	 UHPHS_EHCI_CTRLDSSEGMENT; 	// 
N	AT91_REG	 UHPHS_EHCI_PERIODICLISTBASE; 	// 
N	AT91_REG	 UHPHS_EHCI_ASYNCLISTADDR; 	// 
N	AT91_REG	 Reserved0[9]; 	// 
N	AT91_REG	 UHPHS_EHCI_CONFIGFLAG; 	// 
N	AT91_REG	 UHPHS_EHCI_PORTSC[2]; 	// 
N	AT91_REG	 Reserved1[13]; 	// 
N	AT91_REG	 UHPHS_EHCI_INSNREG00; 	// 
N	AT91_REG	 UHPHS_EHCI_INSNREG01; 	// 
N	AT91_REG	 UHPHS_EHCI_INSNREG02; 	// 
N	AT91_REG	 UHPHS_EHCI_INSNREG03; 	// 
N	AT91_REG	 UHPHS_EHCI_INSNREG04; 	// 
N	AT91_REG	 UHPHS_EHCI_INSNREG05; 	// 
N} AT91S_UHPHS_EHCI, *AT91PS_UHPHS_EHCI;
N#else
S#define VERSION         (AT91_CAST(AT91_REG *) 	0x00000000) // (VERSION) 
S#define HCSPARAMS       (AT91_CAST(AT91_REG *) 	0x00000004) // (HCSPARAMS) 
S#define HCCPARAMS       (AT91_CAST(AT91_REG *) 	0x00000008) // (HCCPARAMS) 
S#define HCSPPORTROUTE   (AT91_CAST(AT91_REG *) 	0x0000000C) // (HCSPPORTROUTE) 
S#define USBCMD          (AT91_CAST(AT91_REG *) 	0x00000010) // (USBCMD) 
S#define USBSTS          (AT91_CAST(AT91_REG *) 	0x00000014) // (USBSTS) 
S#define USBINTR         (AT91_CAST(AT91_REG *) 	0x00000018) // (USBINTR) 
S#define FRINDEX         (AT91_CAST(AT91_REG *) 	0x0000001C) // (FRINDEX) 
S#define CTRLDSSEGMENT   (AT91_CAST(AT91_REG *) 	0x00000020) // (CTRLDSSEGMENT) 
S#define PERIODICLISTBASE (AT91_CAST(AT91_REG *) 	0x00000024) // (PERIODICLISTBASE) 
S#define ASYNCLISTADDR   (AT91_CAST(AT91_REG *) 	0x00000028) // (ASYNCLISTADDR) 
S#define CONFIGFLAG      (AT91_CAST(AT91_REG *) 	0x00000050) // (CONFIGFLAG) 
S#define PORTSC          (AT91_CAST(AT91_REG *) 	0x00000054) // (PORTSC) 
S#define INSNREG00       (AT91_CAST(AT91_REG *) 	0x00000090) // (INSNREG00) 
S#define INSNREG01       (AT91_CAST(AT91_REG *) 	0x00000094) // (INSNREG01) 
S#define INSNREG02       (AT91_CAST(AT91_REG *) 	0x00000098) // (INSNREG02) 
S#define INSNREG03       (AT91_CAST(AT91_REG *) 	0x0000009C) // (INSNREG03) 
S#define INSNREG04       (AT91_CAST(AT91_REG *) 	0x000000A0) // (INSNREG04) 
S#define INSNREG05       (AT91_CAST(AT91_REG *) 	0x000000A4) // (INSNREG05) 
S
N#endif
N// -------- VERSION : (UHPHS_EHCI Offset: 0x0)  -------- 
N#define AT91C_UHPHS_CAPLENGTH (0xFF <<  0) // (UHPHS_EHCI) CapLength : Offset for control registers
N#define AT91C_UHPHS_HCIVERSION (0xFF << 16) // (UHPHS_EHCI) Hci Version
N
N// *****************************************************************************
N//              SOFTWARE API DEFINITION  FOR True Random Generator
N// *****************************************************************************
N#ifndef __ASSEMBLY__
Ntypedef struct _AT91S_TRNG {
N	AT91_REG	 TRNG_CR; 	// Control Register
N	AT91_REG	 Reserved0[3]; 	// 
N	AT91_REG	 TRNG_IER; 	// Interrupt Enable Register
N	AT91_REG	 TRNG_IDR; 	// Interrupt Disable Register
N	AT91_REG	 TRNG_IMR; 	// Interrupt Mask Register
N	AT91_REG	 TRNG_ISR; 	// Interrupt Status Register
N	AT91_REG	 Reserved1[12]; 	// 
N	AT91_REG	 TRNG_ODATA; 	// Output Data Register
N	AT91_REG	 Reserved2[42]; 	// 
N	AT91_REG	 TRNG_VERSION; 	// TRNG Version Register
N} AT91S_TRNG, *AT91PS_TRNG;
N#else
S#define TRNG_CR         (AT91_CAST(AT91_REG *) 	0x00000000) // (TRNG_CR) Control Register
S#define TRNG_IER        (AT91_CAST(AT91_REG *) 	0x00000010) // (TRNG_IER) Interrupt Enable Register
S#define TRNG_IDR        (AT91_CAST(AT91_REG *) 	0x00000014) // (TRNG_IDR) Interrupt Disable Register
S#define TRNG_IMR        (AT91_CAST(AT91_REG *) 	0x00000018) // (TRNG_IMR) Interrupt Mask Register
S#define TRNG_ISR        (AT91_CAST(AT91_REG *) 	0x0000001C) // (TRNG_ISR) Interrupt Status Register
S#define TRNG_ODATA      (AT91_CAST(AT91_REG *) 	0x00000050) // (TRNG_ODATA) Output Data Register
S#define TRNG_VERSION    (AT91_CAST(AT91_REG *) 	0x000000FC) // (TRNG_VERSION) TRNG Version Register
S
N#endif
N// -------- TRNG_CR : (TRNG Offset: 0x0) Control Register -------- 
N#define AT91C_TRNG_ENABLE     (0x1 <<  0) // (TRNG) Enable TRNG
N// -------- TRNG_IER : (TRNG Offset: 0x10) Interrupt Enable Register -------- 
N#define AT91C_TRNG_DATRDY     (0x1 <<  0) // (TRNG) DATRDY
N// -------- TRNG_IDR : (TRNG Offset: 0x14) Interrupt Disable Register -------- 
N// -------- TRNG_IMR : (TRNG Offset: 0x18) Interrupt Mask Register -------- 
N// -------- TRNG_ISR : (TRNG Offset: 0x1c) Interrupt Status Register -------- 
N
N// *****************************************************************************
N//               REGISTER ADDRESS DEFINITION FOR AT91SAM9M10
N// *****************************************************************************
N// ========== Register definition for SFR peripheral ========== 
N#define AT91C_SFR_INT   (AT91_CAST(AT91_REG *) 	0xFFF74014) // (SFR) OHCI suspend Interrupt status
N#define AT91C_SFR_DDRCFG (AT91_CAST(AT91_REG *) 	0xFFF74004) // (SFR) DDR2 SSTL18 control
N#define AT91C_SFR_UTMICFG (AT91_CAST(AT91_REG *) 	0xFFF74010) // (SFR) UTMI Software Reset, and OHCI suspend interrupt control
N#define AT91C_SFR_EBIDELAY (AT91_CAST(AT91_REG *) 	0xFFF7400C) // (SFR) EBI DDR controller clock delay
N#define AT91C_SFR_DDRDELAY (AT91_CAST(AT91_REG *) 	0xFFF74008) // (SFR) DDR2 controller clock delay
N#define AT91C_SFR_EMA   (AT91_CAST(AT91_REG *) 	0xFFF74000) // (SFR) memory Extra Margin Adjustment control
N// ========== Register definition for SYS peripheral ========== 
N#define AT91C_SYS_SLCKSEL (AT91_CAST(AT91_REG *) 	0xFFFFFD50) // (SYS) Slow Clock Selection Register
N#define AT91C_SYS_GPBR  (AT91_CAST(AT91_REG *) 	0xFFFFFD60) // (SYS) General Purpose Register
N// ========== Register definition for EBI peripheral ========== 
N#define AT91C_EBI_DUMMY (AT91_CAST(AT91_REG *) 	0xFFFFE200) // (EBI) Dummy register - Do not use
N// ========== Register definition for DDR2CP1 peripheral ========== 
N#define AT91C_DDR2CP1_DELAY2 (AT91_CAST(AT91_REG *) 	0xFFFFE434) // (DDR2CP1) Pad delay2 Register
N#define AT91C_DDR2CP1_RTR (AT91_CAST(AT91_REG *) 	0xFFFFE404) // (DDR2CP1) Refresh Timer Register
N#define AT91C_DDR2CP1_T0PR (AT91_CAST(AT91_REG *) 	0xFFFFE40C) // (DDR2CP1) Timing0 Register
N#define AT91C_DDR2CP1_WPSR (AT91_CAST(AT91_REG *) 	0xFFFFE4E8) // (DDR2CP1) Write Protect Status Register
N#define AT91C_DDR2CP1_DELAY8 (AT91_CAST(AT91_REG *) 	0xFFFFE44C) // (DDR2CP1) Pad delay8 Register
N#define AT91C_DDR2CP1_LPR (AT91_CAST(AT91_REG *) 	0xFFFFE41C) // (DDR2CP1) Low-power Register
N#define AT91C_DDR2CP1_VER (AT91_CAST(AT91_REG *) 	0xFFFFE428) // (DDR2CP1) DLL Version Register
N#define AT91C_DDR2CP1_DELAY7 (AT91_CAST(AT91_REG *) 	0xFFFFE448) // (DDR2CP1) Pad delay7 Register
N#define AT91C_DDR2CP1_CR (AT91_CAST(AT91_REG *) 	0xFFFFE408) // (DDR2CP1) Configuration Register
N#define AT91C_DDR2CP1_WPMR (AT91_CAST(AT91_REG *) 	0xFFFFE4E4) // (DDR2CP1) Write Protect Mode Register
N#define AT91C_DDR2CP1_MR (AT91_CAST(AT91_REG *) 	0xFFFFE400) // (DDR2CP1) Mode Register
N#define AT91C_DDR2CP1_DELAY5 (AT91_CAST(AT91_REG *) 	0xFFFFE440) // (DDR2CP1) Pad delay5 Register
N#define AT91C_DDR2CP1_T2PR (AT91_CAST(AT91_REG *) 	0xFFFFE414) // (DDR2CP1) Timing2 Register
N#define AT91C_DDR2CP1_HS (AT91_CAST(AT91_REG *) 	0xFFFFE42C) // (DDR2CP1) High Speed Register
N#define AT91C_DDR2CP1_MDR (AT91_CAST(AT91_REG *) 	0xFFFFE420) // (DDR2CP1) Memory Device Register
N#define AT91C_DDR2CP1_DELAY4 (AT91_CAST(AT91_REG *) 	0xFFFFE43C) // (DDR2CP1) Pad delay4 Register
N#define AT91C_DDR2CP1_DELAY1 (AT91_CAST(AT91_REG *) 	0xFFFFE430) // (DDR2CP1) Pad delay1 Register
N#define AT91C_DDR2CP1_DELAY6 (AT91_CAST(AT91_REG *) 	0xFFFFE444) // (DDR2CP1) Pad delay6 Register
N#define AT91C_DDR2CP1_DLL (AT91_CAST(AT91_REG *) 	0xFFFFE424) // (DDR2CP1) DLL Information Register
N#define AT91C_DDR2CP1_DELAY3 (AT91_CAST(AT91_REG *) 	0xFFFFE438) // (DDR2CP1) Pad delay3 Register
N#define AT91C_DDR2CP1_VERSION (AT91_CAST(AT91_REG *) 	0xFFFFE4FC) // (DDR2CP1) Version Register
N#define AT91C_DDR2CP1_T1PR (AT91_CAST(AT91_REG *) 	0xFFFFE410) // (DDR2CP1) Timing1 Register
N// ========== Register definition for DDR2C peripheral ========== 
N#define AT91C_DDR2C_DELAY8 (AT91_CAST(AT91_REG *) 	0xFFFFE64C) // (DDR2C) Pad delay8 Register
N#define AT91C_DDR2C_VER (AT91_CAST(AT91_REG *) 	0xFFFFE628) // (DDR2C) DLL Version Register
N#define AT91C_DDR2C_RTR (AT91_CAST(AT91_REG *) 	0xFFFFE604) // (DDR2C) Refresh Timer Register
N#define AT91C_DDR2C_T0PR (AT91_CAST(AT91_REG *) 	0xFFFFE60C) // (DDR2C) Timing0 Register
N#define AT91C_DDR2C_DELAY5 (AT91_CAST(AT91_REG *) 	0xFFFFE640) // (DDR2C) Pad delay5 Register
N#define AT91C_DDR2C_LPR (AT91_CAST(AT91_REG *) 	0xFFFFE61C) // (DDR2C) Low-power Register
N#define AT91C_DDR2C_HS  (AT91_CAST(AT91_REG *) 	0xFFFFE62C) // (DDR2C) High Speed Register
N#define AT91C_DDR2C_DELAY2 (AT91_CAST(AT91_REG *) 	0xFFFFE634) // (DDR2C) Pad delay2 Register
N#define AT91C_DDR2C_T2PR (AT91_CAST(AT91_REG *) 	0xFFFFE614) // (DDR2C) Timing2 Register
N#define AT91C_DDR2C_DELAY1 (AT91_CAST(AT91_REG *) 	0xFFFFE630) // (DDR2C) Pad delay1 Register
N#define AT91C_DDR2C_T1PR (AT91_CAST(AT91_REG *) 	0xFFFFE610) // (DDR2C) Timing1 Register
N#define AT91C_DDR2C_MDR (AT91_CAST(AT91_REG *) 	0xFFFFE620) // (DDR2C) Memory Device Register
N#define AT91C_DDR2C_DELAY6 (AT91_CAST(AT91_REG *) 	0xFFFFE644) // (DDR2C) Pad delay6 Register
N#define AT91C_DDR2C_VERSION (AT91_CAST(AT91_REG *) 	0xFFFFE6FC) // (DDR2C) Version Register
N#define AT91C_DDR2C_MR  (AT91_CAST(AT91_REG *) 	0xFFFFE600) // (DDR2C) Mode Register
N#define AT91C_DDR2C_DLL (AT91_CAST(AT91_REG *) 	0xFFFFE624) // (DDR2C) DLL Information Register
N#define AT91C_DDR2C_DELAY4 (AT91_CAST(AT91_REG *) 	0xFFFFE63C) // (DDR2C) Pad delay4 Register
N#define AT91C_DDR2C_WPMR (AT91_CAST(AT91_REG *) 	0xFFFFE6E4) // (DDR2C) Write Protect Mode Register
N#define AT91C_DDR2C_CR  (AT91_CAST(AT91_REG *) 	0xFFFFE608) // (DDR2C) Configuration Register
N#define AT91C_DDR2C_DELAY3 (AT91_CAST(AT91_REG *) 	0xFFFFE638) // (DDR2C) Pad delay3 Register
N#define AT91C_DDR2C_WPSR (AT91_CAST(AT91_REG *) 	0xFFFFE6E8) // (DDR2C) Write Protect Status Register
N#define AT91C_DDR2C_DELAY7 (AT91_CAST(AT91_REG *) 	0xFFFFE648) // (DDR2C) Pad delay7 Register
N// ========== Register definition for SMC peripheral ========== 
N#define AT91C_SMC_PULSE7 (AT91_CAST(AT91_REG *) 	0xFFFFE874) // (SMC)  Pulse Register for CS 7
N#define AT91C_SMC_DELAY1 (AT91_CAST(AT91_REG *) 	0xFFFFE8C0) // (SMC) SMC Delay Control Register
N#define AT91C_SMC_CYCLE2 (AT91_CAST(AT91_REG *) 	0xFFFFE828) // (SMC)  Cycle Register for CS 2
N#define AT91C_SMC_DELAY5 (AT91_CAST(AT91_REG *) 	0xFFFFE8D0) // (SMC) SMC Delay Control Register
N#define AT91C_SMC_DELAY6 (AT91_CAST(AT91_REG *) 	0xFFFFE8D4) // (SMC) SMC Delay Control Register
N#define AT91C_SMC_PULSE2 (AT91_CAST(AT91_REG *) 	0xFFFFE824) // (SMC)  Pulse Register for CS 2
N#define AT91C_SMC_SETUP6 (AT91_CAST(AT91_REG *) 	0xFFFFE860) // (SMC)  Setup Register for CS 6
N#define AT91C_SMC_SETUP5 (AT91_CAST(AT91_REG *) 	0xFFFFE850) // (SMC)  Setup Register for CS 5
N#define AT91C_SMC_CYCLE6 (AT91_CAST(AT91_REG *) 	0xFFFFE868) // (SMC)  Cycle Register for CS 6
N#define AT91C_SMC_PULSE6 (AT91_CAST(AT91_REG *) 	0xFFFFE864) // (SMC)  Pulse Register for CS 6
N#define AT91C_SMC_CTRL5 (AT91_CAST(AT91_REG *) 	0xFFFFE85C) // (SMC)  Control Register for CS 5
N#define AT91C_SMC_CTRL3 (AT91_CAST(AT91_REG *) 	0xFFFFE83C) // (SMC)  Control Register for CS 3
N#define AT91C_SMC_DELAY7 (AT91_CAST(AT91_REG *) 	0xFFFFE8D8) // (SMC) SMC Delay Control Register
N#define AT91C_SMC_DELAY3 (AT91_CAST(AT91_REG *) 	0xFFFFE8C8) // (SMC) SMC Delay Control Register
N#define AT91C_SMC_CYCLE0 (AT91_CAST(AT91_REG *) 	0xFFFFE808) // (SMC)  Cycle Register for CS 0
N#define AT91C_SMC_SETUP1 (AT91_CAST(AT91_REG *) 	0xFFFFE810) // (SMC)  Setup Register for CS 1
N#define AT91C_SMC_PULSE5 (AT91_CAST(AT91_REG *) 	0xFFFFE854) // (SMC)  Pulse Register for CS 5
N#define AT91C_SMC_SETUP7 (AT91_CAST(AT91_REG *) 	0xFFFFE870) // (SMC)  Setup Register for CS 7
N#define AT91C_SMC_CTRL4 (AT91_CAST(AT91_REG *) 	0xFFFFE84C) // (SMC)  Control Register for CS 4
N#define AT91C_SMC_DELAY2 (AT91_CAST(AT91_REG *) 	0xFFFFE8C4) // (SMC) SMC Delay Control Register
N#define AT91C_SMC_PULSE3 (AT91_CAST(AT91_REG *) 	0xFFFFE834) // (SMC)  Pulse Register for CS 3
N#define AT91C_SMC_CYCLE4 (AT91_CAST(AT91_REG *) 	0xFFFFE848) // (SMC)  Cycle Register for CS 4
N#define AT91C_SMC_CTRL1 (AT91_CAST(AT91_REG *) 	0xFFFFE81C) // (SMC)  Control Register for CS 1
N#define AT91C_SMC_SETUP3 (AT91_CAST(AT91_REG *) 	0xFFFFE830) // (SMC)  Setup Register for CS 3
N#define AT91C_SMC_CTRL0 (AT91_CAST(AT91_REG *) 	0xFFFFE80C) // (SMC)  Control Register for CS 0
N#define AT91C_SMC_CYCLE7 (AT91_CAST(AT91_REG *) 	0xFFFFE878) // (SMC)  Cycle Register for CS 7
N#define AT91C_SMC_DELAY4 (AT91_CAST(AT91_REG *) 	0xFFFFE8CC) // (SMC) SMC Delay Control Register
N#define AT91C_SMC_CYCLE1 (AT91_CAST(AT91_REG *) 	0xFFFFE818) // (SMC)  Cycle Register for CS 1
N#define AT91C_SMC_SETUP2 (AT91_CAST(AT91_REG *) 	0xFFFFE820) // (SMC)  Setup Register for CS 2
N#define AT91C_SMC_PULSE1 (AT91_CAST(AT91_REG *) 	0xFFFFE814) // (SMC)  Pulse Register for CS 1
N#define AT91C_SMC_DELAY8 (AT91_CAST(AT91_REG *) 	0xFFFFE8DC) // (SMC) SMC Delay Control Register
N#define AT91C_SMC_CTRL2 (AT91_CAST(AT91_REG *) 	0xFFFFE82C) // (SMC)  Control Register for CS 2
N#define AT91C_SMC_PULSE4 (AT91_CAST(AT91_REG *) 	0xFFFFE844) // (SMC)  Pulse Register for CS 4
N#define AT91C_SMC_SETUP4 (AT91_CAST(AT91_REG *) 	0xFFFFE840) // (SMC)  Setup Register for CS 4
N#define AT91C_SMC_CYCLE3 (AT91_CAST(AT91_REG *) 	0xFFFFE838) // (SMC)  Cycle Register for CS 3
N#define AT91C_SMC_SETUP0 (AT91_CAST(AT91_REG *) 	0xFFFFE800) // (SMC)  Setup Register for CS 0
N#define AT91C_SMC_CYCLE5 (AT91_CAST(AT91_REG *) 	0xFFFFE858) // (SMC)  Cycle Register for CS 5
N#define AT91C_SMC_PULSE0 (AT91_CAST(AT91_REG *) 	0xFFFFE804) // (SMC)  Pulse Register for CS 0
N#define AT91C_SMC_CTRL6 (AT91_CAST(AT91_REG *) 	0xFFFFE86C) // (SMC)  Control Register for CS 6
N#define AT91C_SMC_CTRL7 (AT91_CAST(AT91_REG *) 	0xFFFFE87C) // (SMC)  Control Register for CS 7
N// ========== Register definition for MATRIX peripheral ========== 
N#define AT91C_MATRIX_SCFG1 (AT91_CAST(AT91_REG *) 	0xFFFFEA44) // (MATRIX)  Slave Configuration Register 1 : SRAM S1
N#define AT91C_MATRIX_MRCR (AT91_CAST(AT91_REG *) 	0xFFFFEB00) // (MATRIX)  Master Remap Control Register 
N#define AT91C_MATRIX_PRAS2 (AT91_CAST(AT91_REG *) 	0xFFFFEA90) // (MATRIX)  PRAS2 : SRAM S2
N#define AT91C_MATRIX_PRAS1 (AT91_CAST(AT91_REG *) 	0xFFFFEA88) // (MATRIX)  PRAS1 : SRAM S1
N#define AT91C_MATRIX_PRAS0 (AT91_CAST(AT91_REG *) 	0xFFFFEA80) // (MATRIX)  PRAS0 : SRAM S0
N#define AT91C_MATRIX_MCFG8 (AT91_CAST(AT91_REG *) 	0xFFFFEA20) // (MATRIX)  Master Configuration Register 8 : eMAC
N#define AT91C_MATRIX_MCFG2 (AT91_CAST(AT91_REG *) 	0xFFFFEA08) // (MATRIX)  Master Configuration Register 2 : pdc
N#define AT91C_MATRIX_PRAS4 (AT91_CAST(AT91_REG *) 	0xFFFFEAA0) // (MATRIX)  PRAS4 : ROM + USB Dev + USB EHCI + USB OHCI + LCD + Video Decoder
N#define AT91C_MATRIX_MCFG3 (AT91_CAST(AT91_REG *) 	0xFFFFEA0C) // (MATRIX)  Master Configuration Register 3 : USB Host OHCI
N#define AT91C_MATRIX_SCFG0 (AT91_CAST(AT91_REG *) 	0xFFFFEA40) // (MATRIX)  Slave Configuration Register 0 : SRAM S0
N#define AT91C_MATRIX_MCFG7 (AT91_CAST(AT91_REG *) 	0xFFFFEA1C) // (MATRIX)  Master Configuration Register 7 : lcdc
N#define AT91C_MATRIX_PRAS6 (AT91_CAST(AT91_REG *) 	0xFFFFEAB0) // (MATRIX)  PRAS6 : DDR2 S1
N#define AT91C_MATRIX_SCFG7 (AT91_CAST(AT91_REG *) 	0xFFFFEA5C) // (MATRIX)  Slave Configuration Register 7 : DDR2 S2
N#define AT91C_MATRIX_PRAS7 (AT91_CAST(AT91_REG *) 	0xFFFFEAB8) // (MATRIX)  PRAS7 : DDR2 S2
N#define AT91C_MATRIX_SCFG2 (AT91_CAST(AT91_REG *) 	0xFFFFEA48) // (MATRIX)  Slave Configuration Register 2 : SRAM S2
N#define AT91C_MATRIX_WRPROTST (AT91_CAST(AT91_REG *) 	0xFFFFEBE8) // (MATRIX)  Write Protection Status Register 
N#define AT91C_MATRIX_PRBS0 (AT91_CAST(AT91_REG *) 	0xFFFFEA84) // (MATRIX)  PRBS0 : SRAM S0
N#define AT91C_MATRIX_PRBS2 (AT91_CAST(AT91_REG *) 	0xFFFFEA94) // (MATRIX)  PRBS2 : SRAM S2
N#define AT91C_MATRIX_MCFG4 (AT91_CAST(AT91_REG *) 	0xFFFFEA10) // (MATRIX)  Master Configuration Register 4 : DMA0
N#define AT91C_MATRIX_SCFG5 (AT91_CAST(AT91_REG *) 	0xFFFFEA54) // (MATRIX)  Slave Configuration Register 5 : DDR2 S0
N#define AT91C_MATRIX_PRBS6 (AT91_CAST(AT91_REG *) 	0xFFFFEAB4) // (MATRIX)  PRBS6 : DDR2 S1
N#define AT91C_MATRIX_MCFG1 (AT91_CAST(AT91_REG *) 	0xFFFFEA04) // (MATRIX)  Master Configuration Register 1 ; ARM-D
N#define AT91C_MATRIX_SCFG6 (AT91_CAST(AT91_REG *) 	0xFFFFEA58) // (MATRIX)  Slave Configuration Register 6 : DDR2 S1
N#define AT91C_MATRIX_SCFG4 (AT91_CAST(AT91_REG *) 	0xFFFFEA50) // (MATRIX)  Slave Configuration Register 4 ; ROM + USB Dev + USB EHCI + USB OHCI + LCD + Video Decoder
N#define AT91C_MATRIX_PRBS1 (AT91_CAST(AT91_REG *) 	0xFFFFEA8C) // (MATRIX)  PRBS1 : SRAM S1
N#define AT91C_MATRIX_PRBS3 (AT91_CAST(AT91_REG *) 	0xFFFFEA9C) // (MATRIX)  PRBS3 : SRAM S3
N#define AT91C_MATRIX_WRPROTEN (AT91_CAST(AT91_REG *) 	0xFFFFEBE4) // (MATRIX)  Write Protection Control Register 
N#define AT91C_MATRIX_MCFG11 (AT91_CAST(AT91_REG *) 	0xFFFFEA2C) // (MATRIX)  Master Configuration Register 11 : Video Decoder
N#define AT91C_MATRIX_MCFG0 (AT91_CAST(AT91_REG *) 	0xFFFFEA00) // (MATRIX)  Master Configuration Register 0 : ARM-I
N#define AT91C_MATRIX_PRAS5 (AT91_CAST(AT91_REG *) 	0xFFFFEAA8) // (MATRIX)  PRAS5 : DDR2 S0
N#define AT91C_MATRIX_PRBS4 (AT91_CAST(AT91_REG *) 	0xFFFFEAA4) // (MATRIX)  PRBS4 : ROM + USB Dev + USB EHCI + USB OHCI + LCD + Video Decoder
N#define AT91C_MATRIX_MCFG6 (AT91_CAST(AT91_REG *) 	0xFFFFEA18) // (MATRIX)  Master Configuration Register 6 : hisi
N#define AT91C_MATRIX_PRBS5 (AT91_CAST(AT91_REG *) 	0xFFFFEAAC) // (MATRIX)  PRBS5 : DDR2 S0
N#define AT91C_MATRIX_MCFG9 (AT91_CAST(AT91_REG *) 	0xFFFFEA24) // (MATRIX)  Master Configuration Register 9 : USB Device
N#define AT91C_MATRIX_MCFG5 (AT91_CAST(AT91_REG *) 	0xFFFFEA14) // (MATRIX)  Master Configuration Register 5 : DMA1
N#define AT91C_MATRIX_PRBS7 (AT91_CAST(AT91_REG *) 	0xFFFFEABC) // (MATRIX)  PRBS7 : DDR2 S2
N#define AT91C_MATRIX_MCFG10 (AT91_CAST(AT91_REG *) 	0xFFFFEA28) // (MATRIX)  Master Configuration Register 10 : USB Host EHCI
N#define AT91C_MATRIX_PRAS3 (AT91_CAST(AT91_REG *) 	0xFFFFEA98) // (MATRIX)  PRAS3 : SRAM S3
N#define AT91C_MATRIX_SCFG3 (AT91_CAST(AT91_REG *) 	0xFFFFEA4C) // (MATRIX)  Slave Configuration Register 3 : SRAM S3
N// ========== Register definition for CCFG peripheral ========== 
N#define AT91C_CCFG_TCMR (AT91_CAST(AT91_REG *) 	0xFFFFEB10) // (CCFG)  TCM configuration
N#define AT91C_CCFG_VIDEO (AT91_CAST(AT91_REG *) 	0xFFFFEB18) // (CCFG)  Video Mode configuration
N#define AT91C_CCFG_MATRIXVERSION (AT91_CAST(AT91_REG *) 	0xFFFFEBFC) // (CCFG)  Version Register
N#define AT91C_CCFG_UDPHS (AT91_CAST(AT91_REG *) 	0xFFFFEB14) // (CCFG)  USB HS configuration
N#define AT91C_CCFG_EBICSA (AT91_CAST(AT91_REG *) 	0xFFFFEB28) // (CCFG)  EBI Chip Select Assignement Register
N// ========== Register definition for AIC peripheral ========== 
N#define AT91C_AIC_IVR   (AT91_CAST(AT91_REG *) 	0xFFFFF100) // (AIC) IRQ Vector Register
N#define AT91C_AIC_SMR   (AT91_CAST(AT91_REG *) 	0xFFFFF000) // (AIC) Source Mode Register
N#define AT91C_AIC_FVR   (AT91_CAST(AT91_REG *) 	0xFFFFF104) // (AIC) FIQ Vector Register
N#define AT91C_AIC_DCR   (AT91_CAST(AT91_REG *) 	0xFFFFF138) // (AIC) Debug Control Register (Protect)
N#define AT91C_AIC_EOICR (AT91_CAST(AT91_REG *) 	0xFFFFF130) // (AIC) End of Interrupt Command Register
N#define AT91C_AIC_SVR   (AT91_CAST(AT91_REG *) 	0xFFFFF080) // (AIC) Source Vector Register
N#define AT91C_AIC_FFSR  (AT91_CAST(AT91_REG *) 	0xFFFFF148) // (AIC) Fast Forcing Status Register
N#define AT91C_AIC_ICCR  (AT91_CAST(AT91_REG *) 	0xFFFFF128) // (AIC) Interrupt Clear Command Register
N#define AT91C_AIC_ISR   (AT91_CAST(AT91_REG *) 	0xFFFFF108) // (AIC) Interrupt Status Register
N#define AT91C_AIC_IMR   (AT91_CAST(AT91_REG *) 	0xFFFFF110) // (AIC) Interrupt Mask Register
N#define AT91C_AIC_IPR   (AT91_CAST(AT91_REG *) 	0xFFFFF10C) // (AIC) Interrupt Pending Register
N#define AT91C_AIC_FFER  (AT91_CAST(AT91_REG *) 	0xFFFFF140) // (AIC) Fast Forcing Enable Register
N#define AT91C_AIC_IECR  (AT91_CAST(AT91_REG *) 	0xFFFFF120) // (AIC) Interrupt Enable Command Register
N#define AT91C_AIC_ISCR  (AT91_CAST(AT91_REG *) 	0xFFFFF12C) // (AIC) Interrupt Set Command Register
N#define AT91C_AIC_FFDR  (AT91_CAST(AT91_REG *) 	0xFFFFF144) // (AIC) Fast Forcing Disable Register
N#define AT91C_AIC_CISR  (AT91_CAST(AT91_REG *) 	0xFFFFF114) // (AIC) Core Interrupt Status Register
N#define AT91C_AIC_IDCR  (AT91_CAST(AT91_REG *) 	0xFFFFF124) // (AIC) Interrupt Disable Command Register
N#define AT91C_AIC_SPU   (AT91_CAST(AT91_REG *) 	0xFFFFF134) // (AIC) Spurious Vector Register
N// ========== Register definition for PDC_DBGU peripheral ========== 
N#define AT91C_DBGU_PTCR (AT91_CAST(AT91_REG *) 	0xFFFFEF20) // (PDC_DBGU) PDC Transfer Control Register
N#define AT91C_DBGU_RCR  (AT91_CAST(AT91_REG *) 	0xFFFFEF04) // (PDC_DBGU) Receive Counter Register
N#define AT91C_DBGU_TCR  (AT91_CAST(AT91_REG *) 	0xFFFFEF0C) // (PDC_DBGU) Transmit Counter Register
N#define AT91C_DBGU_RNCR (AT91_CAST(AT91_REG *) 	0xFFFFEF14) // (PDC_DBGU) Receive Next Counter Register
N#define AT91C_DBGU_TNPR (AT91_CAST(AT91_REG *) 	0xFFFFEF18) // (PDC_DBGU) Transmit Next Pointer Register
N#define AT91C_DBGU_RNPR (AT91_CAST(AT91_REG *) 	0xFFFFEF10) // (PDC_DBGU) Receive Next Pointer Register
N#define AT91C_DBGU_PTSR (AT91_CAST(AT91_REG *) 	0xFFFFEF24) // (PDC_DBGU) PDC Transfer Status Register
N#define AT91C_DBGU_RPR  (AT91_CAST(AT91_REG *) 	0xFFFFEF00) // (PDC_DBGU) Receive Pointer Register
N#define AT91C_DBGU_TPR  (AT91_CAST(AT91_REG *) 	0xFFFFEF08) // (PDC_DBGU) Transmit Pointer Register
N#define AT91C_DBGU_TNCR (AT91_CAST(AT91_REG *) 	0xFFFFEF1C) // (PDC_DBGU) Transmit Next Counter Register
N// ========== Register definition for DBGU peripheral ========== 
N#define AT91C_DBGU_BRGR (AT91_CAST(AT91_REG *) 	0xFFFFEE20) // (DBGU) Baud Rate Generator Register
N#define AT91C_DBGU_CR   (AT91_CAST(AT91_REG *) 	0xFFFFEE00) // (DBGU) Control Register
N#define AT91C_DBGU_THR  (AT91_CAST(AT91_REG *) 	0xFFFFEE1C) // (DBGU) Transmitter Holding Register
N#define AT91C_DBGU_IDR  (AT91_CAST(AT91_REG *) 	0xFFFFEE0C) // (DBGU) Interrupt Disable Register
N#define AT91C_DBGU_EXID (AT91_CAST(AT91_REG *) 	0xFFFFEE44) // (DBGU) Chip ID Extension Register
N#define AT91C_DBGU_IMR  (AT91_CAST(AT91_REG *) 	0xFFFFEE10) // (DBGU) Interrupt Mask Register
N#define AT91C_DBGU_FNTR (AT91_CAST(AT91_REG *) 	0xFFFFEE48) // (DBGU) Force NTRST Register
N#define AT91C_DBGU_IER  (AT91_CAST(AT91_REG *) 	0xFFFFEE08) // (DBGU) Interrupt Enable Register
N#define AT91C_DBGU_CSR  (AT91_CAST(AT91_REG *) 	0xFFFFEE14) // (DBGU) Channel Status Register
N#define AT91C_DBGU_MR   (AT91_CAST(AT91_REG *) 	0xFFFFEE04) // (DBGU) Mode Register
N#define AT91C_DBGU_RHR  (AT91_CAST(AT91_REG *) 	0xFFFFEE18) // (DBGU) Receiver Holding Register
N#define AT91C_DBGU_CIDR (AT91_CAST(AT91_REG *) 	0xFFFFEE40) // (DBGU) Chip ID Register
N// ========== Register definition for PIOA peripheral ========== 
N#define AT91C_PIOA_OWDR (AT91_CAST(AT91_REG *) 	0xFFFFF2A4) // (PIOA) Output Write Disable Register
N#define AT91C_PIOA_DELAY3 (AT91_CAST(AT91_REG *) 	0xFFFFF2C8) // (PIOA) PIO Delay Control Register
N#define AT91C_PIOA_ISR  (AT91_CAST(AT91_REG *) 	0xFFFFF24C) // (PIOA) Interrupt Status Register
N#define AT91C_PIOA_PDR  (AT91_CAST(AT91_REG *) 	0xFFFFF204) // (PIOA) PIO Disable Register
N#define AT91C_PIOA_OSR  (AT91_CAST(AT91_REG *) 	0xFFFFF218) // (PIOA) Output Status Register
N#define AT91C_PIOA_ABSR (AT91_CAST(AT91_REG *) 	0xFFFFF278) // (PIOA) AB Select Status Register
N#define AT91C_PIOA_DELAY2 (AT91_CAST(AT91_REG *) 	0xFFFFF2C4) // (PIOA) PIO Delay Control Register
N#define AT91C_PIOA_PDSR (AT91_CAST(AT91_REG *) 	0xFFFFF23C) // (PIOA) Pin Data Status Register
N#define AT91C_PIOA_BSR  (AT91_CAST(AT91_REG *) 	0xFFFFF274) // (PIOA) Select B Register
N#define AT91C_PIOA_DELAY1 (AT91_CAST(AT91_REG *) 	0xFFFFF2C0) // (PIOA) PIO Delay Control Register
N#define AT91C_PIOA_PPUER (AT91_CAST(AT91_REG *) 	0xFFFFF264) // (PIOA) Pull-up Enable Register
N#define AT91C_PIOA_OER  (AT91_CAST(AT91_REG *) 	0xFFFFF210) // (PIOA) Output Enable Register
N#define AT91C_PIOA_PER  (AT91_CAST(AT91_REG *) 	0xFFFFF200) // (PIOA) PIO Enable Register
N#define AT91C_PIOA_VERSION (AT91_CAST(AT91_REG *) 	0xFFFFF2FC) // (PIOA) PIO Version Register
N#define AT91C_PIOA_PPUDR (AT91_CAST(AT91_REG *) 	0xFFFFF260) // (PIOA) Pull-up Disable Register
N#define AT91C_PIOA_ODSR (AT91_CAST(AT91_REG *) 	0xFFFFF238) // (PIOA) Output Data Status Register
N#define AT91C_PIOA_SLEWRATE1 (AT91_CAST(AT91_REG *) 	0xFFFFF2B0) // (PIOA) PIO Slewrate Control Register
N#define AT91C_PIOA_MDDR (AT91_CAST(AT91_REG *) 	0xFFFFF254) // (PIOA) Multi-driver Disable Register
N#define AT91C_PIOA_IFSR (AT91_CAST(AT91_REG *) 	0xFFFFF228) // (PIOA) Input Filter Status Register
N#define AT91C_PIOA_CODR (AT91_CAST(AT91_REG *) 	0xFFFFF234) // (PIOA) Clear Output Data Register
N#define AT91C_PIOA_ASR  (AT91_CAST(AT91_REG *) 	0xFFFFF270) // (PIOA) Select A Register
N#define AT91C_PIOA_OWSR (AT91_CAST(AT91_REG *) 	0xFFFFF2A8) // (PIOA) Output Write Status Register
N#define AT91C_PIOA_IMR  (AT91_CAST(AT91_REG *) 	0xFFFFF248) // (PIOA) Interrupt Mask Register
N#define AT91C_PIOA_PPUSR (AT91_CAST(AT91_REG *) 	0xFFFFF268) // (PIOA) Pull-up Status Register
N#define AT91C_PIOA_MDER (AT91_CAST(AT91_REG *) 	0xFFFFF250) // (PIOA) Multi-driver Enable Register
N#define AT91C_PIOA_IFDR (AT91_CAST(AT91_REG *) 	0xFFFFF224) // (PIOA) Input Filter Disable Register
N#define AT91C_PIOA_SODR (AT91_CAST(AT91_REG *) 	0xFFFFF230) // (PIOA) Set Output Data Register
N#define AT91C_PIOA_OWER (AT91_CAST(AT91_REG *) 	0xFFFFF2A0) // (PIOA) Output Write Enable Register
N#define AT91C_PIOA_IDR  (AT91_CAST(AT91_REG *) 	0xFFFFF244) // (PIOA) Interrupt Disable Register
N#define AT91C_PIOA_IFER (AT91_CAST(AT91_REG *) 	0xFFFFF220) // (PIOA) Input Filter Enable Register
N#define AT91C_PIOA_IER  (AT91_CAST(AT91_REG *) 	0xFFFFF240) // (PIOA) Interrupt Enable Register
N#define AT91C_PIOA_ODR  (AT91_CAST(AT91_REG *) 	0xFFFFF214) // (PIOA) Output Disable Registerr
N#define AT91C_PIOA_MDSR (AT91_CAST(AT91_REG *) 	0xFFFFF258) // (PIOA) Multi-driver Status Register
N#define AT91C_PIOA_DELAY4 (AT91_CAST(AT91_REG *) 	0xFFFFF2CC) // (PIOA) PIO Delay Control Register
N#define AT91C_PIOA_PSR  (AT91_CAST(AT91_REG *) 	0xFFFFF208) // (PIOA) PIO Status Register
N// ========== Register definition for PIOB peripheral ========== 
N#define AT91C_PIOB_ODR  (AT91_CAST(AT91_REG *) 	0xFFFFF414) // (PIOB) Output Disable Registerr
N#define AT91C_PIOB_DELAY4 (AT91_CAST(AT91_REG *) 	0xFFFFF4CC) // (PIOB) PIO Delay Control Register
N#define AT91C_PIOB_SODR (AT91_CAST(AT91_REG *) 	0xFFFFF430) // (PIOB) Set Output Data Register
N#define AT91C_PIOB_ISR  (AT91_CAST(AT91_REG *) 	0xFFFFF44C) // (PIOB) Interrupt Status Register
N#define AT91C_PIOB_ABSR (AT91_CAST(AT91_REG *) 	0xFFFFF478) // (PIOB) AB Select Status Register
N#define AT91C_PIOB_IMR  (AT91_CAST(AT91_REG *) 	0xFFFFF448) // (PIOB) Interrupt Mask Register
N#define AT91C_PIOB_MDSR (AT91_CAST(AT91_REG *) 	0xFFFFF458) // (PIOB) Multi-driver Status Register
N#define AT91C_PIOB_PPUSR (AT91_CAST(AT91_REG *) 	0xFFFFF468) // (PIOB) Pull-up Status Register
N#define AT91C_PIOB_PDSR (AT91_CAST(AT91_REG *) 	0xFFFFF43C) // (PIOB) Pin Data Status Register
N#define AT91C_PIOB_DELAY3 (AT91_CAST(AT91_REG *) 	0xFFFFF4C8) // (PIOB) PIO Delay Control Register
N#define AT91C_PIOB_MDDR (AT91_CAST(AT91_REG *) 	0xFFFFF454) // (PIOB) Multi-driver Disable Register
N#define AT91C_PIOB_CODR (AT91_CAST(AT91_REG *) 	0xFFFFF434) // (PIOB) Clear Output Data Register
N#define AT91C_PIOB_MDER (AT91_CAST(AT91_REG *) 	0xFFFFF450) // (PIOB) Multi-driver Enable Register
N#define AT91C_PIOB_PDR  (AT91_CAST(AT91_REG *) 	0xFFFFF404) // (PIOB) PIO Disable Register
N#define AT91C_PIOB_IFSR (AT91_CAST(AT91_REG *) 	0xFFFFF428) // (PIOB) Input Filter Status Register
N#define AT91C_PIOB_PSR  (AT91_CAST(AT91_REG *) 	0xFFFFF408) // (PIOB) PIO Status Register
N#define AT91C_PIOB_SLEWRATE1 (AT91_CAST(AT91_REG *) 	0xFFFFF4B0) // (PIOB) PIO Slewrate Control Register
N#define AT91C_PIOB_IER  (AT91_CAST(AT91_REG *) 	0xFFFFF440) // (PIOB) Interrupt Enable Register
N#define AT91C_PIOB_PPUDR (AT91_CAST(AT91_REG *) 	0xFFFFF460) // (PIOB) Pull-up Disable Register
N#define AT91C_PIOB_PER  (AT91_CAST(AT91_REG *) 	0xFFFFF400) // (PIOB) PIO Enable Register
N#define AT91C_PIOB_IFDR (AT91_CAST(AT91_REG *) 	0xFFFFF424) // (PIOB) Input Filter Disable Register
N#define AT91C_PIOB_IDR  (AT91_CAST(AT91_REG *) 	0xFFFFF444) // (PIOB) Interrupt Disable Register
N#define AT91C_PIOB_OWDR (AT91_CAST(AT91_REG *) 	0xFFFFF4A4) // (PIOB) Output Write Disable Register
N#define AT91C_PIOB_ODSR (AT91_CAST(AT91_REG *) 	0xFFFFF438) // (PIOB) Output Data Status Register
N#define AT91C_PIOB_DELAY2 (AT91_CAST(AT91_REG *) 	0xFFFFF4C4) // (PIOB) PIO Delay Control Register
N#define AT91C_PIOB_OWSR (AT91_CAST(AT91_REG *) 	0xFFFFF4A8) // (PIOB) Output Write Status Register
N#define AT91C_PIOB_BSR  (AT91_CAST(AT91_REG *) 	0xFFFFF474) // (PIOB) Select B Register
N#define AT91C_PIOB_IFER (AT91_CAST(AT91_REG *) 	0xFFFFF420) // (PIOB) Input Filter Enable Register
N#define AT91C_PIOB_OWER (AT91_CAST(AT91_REG *) 	0xFFFFF4A0) // (PIOB) Output Write Enable Register
N#define AT91C_PIOB_PPUER (AT91_CAST(AT91_REG *) 	0xFFFFF464) // (PIOB) Pull-up Enable Register
N#define AT91C_PIOB_OSR  (AT91_CAST(AT91_REG *) 	0xFFFFF418) // (PIOB) Output Status Register
N#define AT91C_PIOB_ASR  (AT91_CAST(AT91_REG *) 	0xFFFFF470) // (PIOB) Select A Register
N#define AT91C_PIOB_OER  (AT91_CAST(AT91_REG *) 	0xFFFFF410) // (PIOB) Output Enable Register
N#define AT91C_PIOB_VERSION (AT91_CAST(AT91_REG *) 	0xFFFFF4FC) // (PIOB) PIO Version Register
N#define AT91C_PIOB_DELAY1 (AT91_CAST(AT91_REG *) 	0xFFFFF4C0) // (PIOB) PIO Delay Control Register
N// ========== Register definition for PIOC peripheral ========== 
N#define AT91C_PIOC_OWDR (AT91_CAST(AT91_REG *) 	0xFFFFF6A4) // (PIOC) Output Write Disable Register
N#define AT91C_PIOC_IMR  (AT91_CAST(AT91_REG *) 	0xFFFFF648) // (PIOC) Interrupt Mask Register
N#define AT91C_PIOC_ASR  (AT91_CAST(AT91_REG *) 	0xFFFFF670) // (PIOC) Select A Register
N#define AT91C_PIOC_PPUDR (AT91_CAST(AT91_REG *) 	0xFFFFF660) // (PIOC) Pull-up Disable Register
N#define AT91C_PIOC_CODR (AT91_CAST(AT91_REG *) 	0xFFFFF634) // (PIOC) Clear Output Data Register
N#define AT91C_PIOC_OWER (AT91_CAST(AT91_REG *) 	0xFFFFF6A0) // (PIOC) Output Write Enable Register
N#define AT91C_PIOC_ABSR (AT91_CAST(AT91_REG *) 	0xFFFFF678) // (PIOC) AB Select Status Register
N#define AT91C_PIOC_IFDR (AT91_CAST(AT91_REG *) 	0xFFFFF624) // (PIOC) Input Filter Disable Register
N#define AT91C_PIOC_VERSION (AT91_CAST(AT91_REG *) 	0xFFFFF6FC) // (PIOC) PIO Version Register
N#define AT91C_PIOC_ODR  (AT91_CAST(AT91_REG *) 	0xFFFFF614) // (PIOC) Output Disable Registerr
N#define AT91C_PIOC_PPUER (AT91_CAST(AT91_REG *) 	0xFFFFF664) // (PIOC) Pull-up Enable Register
N#define AT91C_PIOC_SODR (AT91_CAST(AT91_REG *) 	0xFFFFF630) // (PIOC) Set Output Data Register
N#define AT91C_PIOC_ISR  (AT91_CAST(AT91_REG *) 	0xFFFFF64C) // (PIOC) Interrupt Status Register
N#define AT91C_PIOC_OSR  (AT91_CAST(AT91_REG *) 	0xFFFFF618) // (PIOC) Output Status Register
N#define AT91C_PIOC_MDSR (AT91_CAST(AT91_REG *) 	0xFFFFF658) // (PIOC) Multi-driver Status Register
N#define AT91C_PIOC_IFER (AT91_CAST(AT91_REG *) 	0xFFFFF620) // (PIOC) Input Filter Enable Register
N#define AT91C_PIOC_DELAY2 (AT91_CAST(AT91_REG *) 	0xFFFFF6C4) // (PIOC) PIO Delay Control Register
N#define AT91C_PIOC_MDER (AT91_CAST(AT91_REG *) 	0xFFFFF650) // (PIOC) Multi-driver Enable Register
N#define AT91C_PIOC_PPUSR (AT91_CAST(AT91_REG *) 	0xFFFFF668) // (PIOC) Pull-up Status Register
N#define AT91C_PIOC_PSR  (AT91_CAST(AT91_REG *) 	0xFFFFF608) // (PIOC) PIO Status Register
N#define AT91C_PIOC_DELAY4 (AT91_CAST(AT91_REG *) 	0xFFFFF6CC) // (PIOC) PIO Delay Control Register
N#define AT91C_PIOC_DELAY3 (AT91_CAST(AT91_REG *) 	0xFFFFF6C8) // (PIOC) PIO Delay Control Register
N#define AT91C_PIOC_IER  (AT91_CAST(AT91_REG *) 	0xFFFFF640) // (PIOC) Interrupt Enable Register
N#define AT91C_PIOC_SLEWRATE1 (AT91_CAST(AT91_REG *) 	0xFFFFF6B0) // (PIOC) PIO Slewrate Control Register
N#define AT91C_PIOC_IDR  (AT91_CAST(AT91_REG *) 	0xFFFFF644) // (PIOC) Interrupt Disable Register
N#define AT91C_PIOC_PDSR (AT91_CAST(AT91_REG *) 	0xFFFFF63C) // (PIOC) Pin Data Status Register
N#define AT91C_PIOC_DELAY1 (AT91_CAST(AT91_REG *) 	0xFFFFF6C0) // (PIOC) PIO Delay Control Register
N#define AT91C_PIOC_PDR  (AT91_CAST(AT91_REG *) 	0xFFFFF604) // (PIOC) PIO Disable Register
N#define AT91C_PIOC_OWSR (AT91_CAST(AT91_REG *) 	0xFFFFF6A8) // (PIOC) Output Write Status Register
N#define AT91C_PIOC_IFSR (AT91_CAST(AT91_REG *) 	0xFFFFF628) // (PIOC) Input Filter Status Register
N#define AT91C_PIOC_ODSR (AT91_CAST(AT91_REG *) 	0xFFFFF638) // (PIOC) Output Data Status Register
N#define AT91C_PIOC_OER  (AT91_CAST(AT91_REG *) 	0xFFFFF610) // (PIOC) Output Enable Register
N#define AT91C_PIOC_MDDR (AT91_CAST(AT91_REG *) 	0xFFFFF654) // (PIOC) Multi-driver Disable Register
N#define AT91C_PIOC_BSR  (AT91_CAST(AT91_REG *) 	0xFFFFF674) // (PIOC) Select B Register
N#define AT91C_PIOC_PER  (AT91_CAST(AT91_REG *) 	0xFFFFF600) // (PIOC) PIO Enable Register
N// ========== Register definition for PIOD peripheral ========== 
N#define AT91C_PIOD_DELAY1 (AT91_CAST(AT91_REG *) 	0xFFFFF8C0) // (PIOD) PIO Delay Control Register
N#define AT91C_PIOD_OWDR (AT91_CAST(AT91_REG *) 	0xFFFFF8A4) // (PIOD) Output Write Disable Register
N#define AT91C_PIOD_SODR (AT91_CAST(AT91_REG *) 	0xFFFFF830) // (PIOD) Set Output Data Register
N#define AT91C_PIOD_PPUER (AT91_CAST(AT91_REG *) 	0xFFFFF864) // (PIOD) Pull-up Enable Register
N#define AT91C_PIOD_CODR (AT91_CAST(AT91_REG *) 	0xFFFFF834) // (PIOD) Clear Output Data Register
N#define AT91C_PIOD_DELAY4 (AT91_CAST(AT91_REG *) 	0xFFFFF8CC) // (PIOD) PIO Delay Control Register
N#define AT91C_PIOD_PSR  (AT91_CAST(AT91_REG *) 	0xFFFFF808) // (PIOD) PIO Status Register
N#define AT91C_PIOD_PDR  (AT91_CAST(AT91_REG *) 	0xFFFFF804) // (PIOD) PIO Disable Register
N#define AT91C_PIOD_ODR  (AT91_CAST(AT91_REG *) 	0xFFFFF814) // (PIOD) Output Disable Registerr
N#define AT91C_PIOD_PPUSR (AT91_CAST(AT91_REG *) 	0xFFFFF868) // (PIOD) Pull-up Status Register
N#define AT91C_PIOD_IFSR (AT91_CAST(AT91_REG *) 	0xFFFFF828) // (PIOD) Input Filter Status Register
N#define AT91C_PIOD_IMR  (AT91_CAST(AT91_REG *) 	0xFFFFF848) // (PIOD) Interrupt Mask Register
N#define AT91C_PIOD_ASR  (AT91_CAST(AT91_REG *) 	0xFFFFF870) // (PIOD) Select A Register
N#define AT91C_PIOD_DELAY2 (AT91_CAST(AT91_REG *) 	0xFFFFF8C4) // (PIOD) PIO Delay Control Register
N#define AT91C_PIOD_OWSR (AT91_CAST(AT91_REG *) 	0xFFFFF8A8) // (PIOD) Output Write Status Register
N#define AT91C_PIOD_PER  (AT91_CAST(AT91_REG *) 	0xFFFFF800) // (PIOD) PIO Enable Register
N#define AT91C_PIOD_MDER (AT91_CAST(AT91_REG *) 	0xFFFFF850) // (PIOD) Multi-driver Enable Register
N#define AT91C_PIOD_PDSR (AT91_CAST(AT91_REG *) 	0xFFFFF83C) // (PIOD) Pin Data Status Register
N#define AT91C_PIOD_MDSR (AT91_CAST(AT91_REG *) 	0xFFFFF858) // (PIOD) Multi-driver Status Register
N#define AT91C_PIOD_OWER (AT91_CAST(AT91_REG *) 	0xFFFFF8A0) // (PIOD) Output Write Enable Register
N#define AT91C_PIOD_BSR  (AT91_CAST(AT91_REG *) 	0xFFFFF874) // (PIOD) Select B Register
N#define AT91C_PIOD_IFDR (AT91_CAST(AT91_REG *) 	0xFFFFF824) // (PIOD) Input Filter Disable Register
N#define AT91C_PIOD_DELAY3 (AT91_CAST(AT91_REG *) 	0xFFFFF8C8) // (PIOD) PIO Delay Control Register
N#define AT91C_PIOD_ABSR (AT91_CAST(AT91_REG *) 	0xFFFFF878) // (PIOD) AB Select Status Register
N#define AT91C_PIOD_OER  (AT91_CAST(AT91_REG *) 	0xFFFFF810) // (PIOD) Output Enable Register
N#define AT91C_PIOD_MDDR (AT91_CAST(AT91_REG *) 	0xFFFFF854) // (PIOD) Multi-driver Disable Register
N#define AT91C_PIOD_IDR  (AT91_CAST(AT91_REG *) 	0xFFFFF844) // (PIOD) Interrupt Disable Register
N#define AT91C_PIOD_IER  (AT91_CAST(AT91_REG *) 	0xFFFFF840) // (PIOD) Interrupt Enable Register
N#define AT91C_PIOD_PPUDR (AT91_CAST(AT91_REG *) 	0xFFFFF860) // (PIOD) Pull-up Disable Register
N#define AT91C_PIOD_VERSION (AT91_CAST(AT91_REG *) 	0xFFFFF8FC) // (PIOD) PIO Version Register
N#define AT91C_PIOD_ISR  (AT91_CAST(AT91_REG *) 	0xFFFFF84C) // (PIOD) Interrupt Status Register
N#define AT91C_PIOD_ODSR (AT91_CAST(AT91_REG *) 	0xFFFFF838) // (PIOD) Output Data Status Register
N#define AT91C_PIOD_OSR  (AT91_CAST(AT91_REG *) 	0xFFFFF818) // (PIOD) Output Status Register
N#define AT91C_PIOD_IFER (AT91_CAST(AT91_REG *) 	0xFFFFF820) // (PIOD) Input Filter Enable Register
N#define AT91C_PIOD_SLEWRATE1 (AT91_CAST(AT91_REG *) 	0xFFFFF8B0) // (PIOD) PIO Slewrate Control Register
N// ========== Register definition for PIOE peripheral ========== 
N#define AT91C_PIOE_ODSR (AT91_CAST(AT91_REG *) 	0xFFFFFA38) // (PIOE) Output Data Status Register
N#define AT91C_PIOE_ABSR (AT91_CAST(AT91_REG *) 	0xFFFFFA78) // (PIOE) AB Select Status Register
N#define AT91C_PIOE_PSR  (AT91_CAST(AT91_REG *) 	0xFFFFFA08) // (PIOE) PIO Status Register
N#define AT91C_PIOE_PPUDR (AT91_CAST(AT91_REG *) 	0xFFFFFA60) // (PIOE) Pull-up Disable Register
N#define AT91C_PIOE_OER  (AT91_CAST(AT91_REG *) 	0xFFFFFA10) // (PIOE) Output Enable Register
N#define AT91C_PIOE_IFSR (AT91_CAST(AT91_REG *) 	0xFFFFFA28) // (PIOE) Input Filter Status Register
N#define AT91C_PIOE_IFER (AT91_CAST(AT91_REG *) 	0xFFFFFA20) // (PIOE) Input Filter Enable Register
N#define AT91C_PIOE_DELAY3 (AT91_CAST(AT91_REG *) 	0xFFFFFAC8) // (PIOE) PIO Delay Control Register
N#define AT91C_PIOE_ODR  (AT91_CAST(AT91_REG *) 	0xFFFFFA14) // (PIOE) Output Disable Registerr
N#define AT91C_PIOE_IDR  (AT91_CAST(AT91_REG *) 	0xFFFFFA44) // (PIOE) Interrupt Disable Register
N#define AT91C_PIOE_DELAY1 (AT91_CAST(AT91_REG *) 	0xFFFFFAC0) // (PIOE) PIO Delay Control Register
N#define AT91C_PIOE_OSR  (AT91_CAST(AT91_REG *) 	0xFFFFFA18) // (PIOE) Output Status Register
N#define AT91C_PIOE_CODR (AT91_CAST(AT91_REG *) 	0xFFFFFA34) // (PIOE) Clear Output Data Register
N#define AT91C_PIOE_VERSION (AT91_CAST(AT91_REG *) 	0xFFFFFAFC) // (PIOE) PIO Version Register
N#define AT91C_PIOE_MDSR (AT91_CAST(AT91_REG *) 	0xFFFFFA58) // (PIOE) Multi-driver Status Register
N#define AT91C_PIOE_PDR  (AT91_CAST(AT91_REG *) 	0xFFFFFA04) // (PIOE) PIO Disable Register
N#define AT91C_PIOE_IER  (AT91_CAST(AT91_REG *) 	0xFFFFFA40) // (PIOE) Interrupt Enable Register
N#define AT91C_PIOE_OWSR (AT91_CAST(AT91_REG *) 	0xFFFFFAA8) // (PIOE) Output Write Status Register
N#define AT91C_PIOE_BSR  (AT91_CAST(AT91_REG *) 	0xFFFFFA74) // (PIOE) Select B Register
N#define AT91C_PIOE_SLEWRATE1 (AT91_CAST(AT91_REG *) 	0xFFFFFAB0) // (PIOE) PIO Slewrate Control Register
N#define AT91C_PIOE_DELAY4 (AT91_CAST(AT91_REG *) 	0xFFFFFACC) // (PIOE) PIO Delay Control Register
N#define AT91C_PIOE_PER  (AT91_CAST(AT91_REG *) 	0xFFFFFA00) // (PIOE) PIO Enable Register
N#define AT91C_PIOE_OWDR (AT91_CAST(AT91_REG *) 	0xFFFFFAA4) // (PIOE) Output Write Disable Register
N#define AT91C_PIOE_IFDR (AT91_CAST(AT91_REG *) 	0xFFFFFA24) // (PIOE) Input Filter Disable Register
N#define AT91C_PIOE_PPUSR (AT91_CAST(AT91_REG *) 	0xFFFFFA68) // (PIOE) Pull-up Status Register
N#define AT91C_PIOE_PDSR (AT91_CAST(AT91_REG *) 	0xFFFFFA3C) // (PIOE) Pin Data Status Register
N#define AT91C_PIOE_PPUER (AT91_CAST(AT91_REG *) 	0xFFFFFA64) // (PIOE) Pull-up Enable Register
N#define AT91C_PIOE_MDDR (AT91_CAST(AT91_REG *) 	0xFFFFFA54) // (PIOE) Multi-driver Disable Register
N#define AT91C_PIOE_ISR  (AT91_CAST(AT91_REG *) 	0xFFFFFA4C) // (PIOE) Interrupt Status Register
N#define AT91C_PIOE_DELAY2 (AT91_CAST(AT91_REG *) 	0xFFFFFAC4) // (PIOE) PIO Delay Control Register
N#define AT91C_PIOE_SODR (AT91_CAST(AT91_REG *) 	0xFFFFFA30) // (PIOE) Set Output Data Register
N#define AT91C_PIOE_ASR  (AT91_CAST(AT91_REG *) 	0xFFFFFA70) // (PIOE) Select A Register
N#define AT91C_PIOE_IMR  (AT91_CAST(AT91_REG *) 	0xFFFFFA48) // (PIOE) Interrupt Mask Register
N#define AT91C_PIOE_OWER (AT91_CAST(AT91_REG *) 	0xFFFFFAA0) // (PIOE) Output Write Enable Register
N#define AT91C_PIOE_MDER (AT91_CAST(AT91_REG *) 	0xFFFFFA50) // (PIOE) Multi-driver Enable Register
N// ========== Register definition for PMC peripheral ========== 
N#define AT91C_PMC_ADDRSIZE (AT91_CAST(AT91_REG *) 	0xFFFFFCEC) // (PMC) 
N#define AT91C_PMC_PCER  (AT91_CAST(AT91_REG *) 	0xFFFFFC10) // (PMC) Peripheral Clock Enable Register
N#define AT91C_PMC_PCKR  (AT91_CAST(AT91_REG *) 	0xFFFFFC40) // (PMC) Programmable Clock 0 Register
N#define AT91C_PMC_MCKR  (AT91_CAST(AT91_REG *) 	0xFFFFFC30) // (PMC) Master Clock Register
N#define AT91C_PMC_PLLAR (AT91_CAST(AT91_REG *) 	0xFFFFFC28) // (PMC) PLL A Register
N#define AT91C_PMC_NAME2 (AT91_CAST(AT91_REG *) 	0xFFFFFCF4) // (PMC) 
N#define AT91C_PMC_PCDR  (AT91_CAST(AT91_REG *) 	0xFFFFFC14) // (PMC) Peripheral Clock Disable Register
N#define AT91C_PMC_SCSR  (AT91_CAST(AT91_REG *) 	0xFFFFFC08) // (PMC) System Clock Status Register
N#define AT91C_PMC_MCFR  (AT91_CAST(AT91_REG *) 	0xFFFFFC24) // (PMC) Main Clock  Frequency Register
N#define AT91C_PMC_FEATURES (AT91_CAST(AT91_REG *) 	0xFFFFFCF8) // (PMC) 
N#define AT91C_PMC_PLLICPR (AT91_CAST(AT91_REG *) 	0xFFFFFC80) // (PMC) PLL Charge Pump Current Register
N#define AT91C_PMC_IMR   (AT91_CAST(AT91_REG *) 	0xFFFFFC6C) // (PMC) Interrupt Mask Register
N#define AT91C_PMC_IER   (AT91_CAST(AT91_REG *) 	0xFFFFFC60) // (PMC) Interrupt Enable Register
N#define AT91C_PMC_UCKR  (AT91_CAST(AT91_REG *) 	0xFFFFFC1C) // (PMC) UTMI Clock Configuration Register
N#define AT91C_PMC_USB   (AT91_CAST(AT91_REG *) 	0xFFFFFC38) // (PMC) USB clock register
N#define AT91C_PMC_MOR   (AT91_CAST(AT91_REG *) 	0xFFFFFC20) // (PMC) Main Oscillator Register
N#define AT91C_PMC_IDR   (AT91_CAST(AT91_REG *) 	0xFFFFFC64) // (PMC) Interrupt Disable Register
N#define AT91C_PMC_NAME1 (AT91_CAST(AT91_REG *) 	0xFFFFFCF0) // (PMC) 
N#define AT91C_PMC_SCDR  (AT91_CAST(AT91_REG *) 	0xFFFFFC04) // (PMC) System Clock Disable Register
N#define AT91C_PMC_PCSR  (AT91_CAST(AT91_REG *) 	0xFFFFFC18) // (PMC) Peripheral Clock Status Register
N#define AT91C_PMC_SCER  (AT91_CAST(AT91_REG *) 	0xFFFFFC00) // (PMC) System Clock Enable Register
N#define AT91C_PMC_VERSION (AT91_CAST(AT91_REG *) 	0xFFFFFCFC) // (PMC) 
N#define AT91C_PMC_SR    (AT91_CAST(AT91_REG *) 	0xFFFFFC68) // (PMC) Status Register
N// ========== Register definition for CKGR peripheral ========== 
N#define AT91C_CKGR_MOR  (AT91_CAST(AT91_REG *) 	0xFFFFFC20) // (CKGR) Main Oscillator Register
N#define AT91C_CKGR_MCFR (AT91_CAST(AT91_REG *) 	0xFFFFFC24) // (CKGR) Main Clock  Frequency Register
N#define AT91C_CKGR_PLLAR (AT91_CAST(AT91_REG *) 	0xFFFFFC28) // (CKGR) PLL A Register
N#define AT91C_CKGR_UCKR (AT91_CAST(AT91_REG *) 	0xFFFFFC1C) // (CKGR) UTMI Clock Configuration Register
N// ========== Register definition for RSTC peripheral ========== 
N#define AT91C_RSTC_RCR  (AT91_CAST(AT91_REG *) 	0xFFFFFD00) // (RSTC) Reset Control Register
N#define AT91C_RSTC_VER  (AT91_CAST(AT91_REG *) 	0xFFFFFDFC) // (RSTC) Version Register
N#define AT91C_RSTC_RMR  (AT91_CAST(AT91_REG *) 	0xFFFFFD08) // (RSTC) Reset Mode Register
N#define AT91C_RSTC_RSR  (AT91_CAST(AT91_REG *) 	0xFFFFFD04) // (RSTC) Reset Status Register
N// ========== Register definition for SHDWC peripheral ========== 
N#define AT91C_SHDWC_SHSR (AT91_CAST(AT91_REG *) 	0xFFFFFD18) // (SHDWC) Shut Down Status Register
N#define AT91C_SHDWC_SHMR (AT91_CAST(AT91_REG *) 	0xFFFFFD14) // (SHDWC) Shut Down Mode Register
N#define AT91C_SHDWC_SHCR (AT91_CAST(AT91_REG *) 	0xFFFFFD10) // (SHDWC) Shut Down Control Register
N// ========== Register definition for RTTC peripheral ========== 
N#define AT91C_RTTC_RTSR (AT91_CAST(AT91_REG *) 	0xFFFFFD2C) // (RTTC) Real-time Status Register
N#define AT91C_RTTC_RTMR (AT91_CAST(AT91_REG *) 	0xFFFFFD20) // (RTTC) Real-time Mode Register
N#define AT91C_RTTC_RTVR (AT91_CAST(AT91_REG *) 	0xFFFFFD28) // (RTTC) Real-time Value Register
N#define AT91C_RTTC_RTAR (AT91_CAST(AT91_REG *) 	0xFFFFFD24) // (RTTC) Real-time Alarm Register
N// ========== Register definition for PITC peripheral ========== 
N#define AT91C_PITC_PIVR (AT91_CAST(AT91_REG *) 	0xFFFFFD38) // (PITC) Period Interval Value Register
N#define AT91C_PITC_PISR (AT91_CAST(AT91_REG *) 	0xFFFFFD34) // (PITC) Period Interval Status Register
N#define AT91C_PITC_PIIR (AT91_CAST(AT91_REG *) 	0xFFFFFD3C) // (PITC) Period Interval Image Register
N#define AT91C_PITC_PIMR (AT91_CAST(AT91_REG *) 	0xFFFFFD30) // (PITC) Period Interval Mode Register
N// ========== Register definition for WDTC peripheral ========== 
N#define AT91C_WDTC_WDCR (AT91_CAST(AT91_REG *) 	0xFFFFFD40) // (WDTC) Watchdog Control Register
N#define AT91C_WDTC_WDSR (AT91_CAST(AT91_REG *) 	0xFFFFFD48) // (WDTC) Watchdog Status Register
N#define AT91C_WDTC_WDMR (AT91_CAST(AT91_REG *) 	0xFFFFFD44) // (WDTC) Watchdog Mode Register
N// ========== Register definition for RTC peripheral ========== 
N#define AT91C_RTC_IDR   (AT91_CAST(AT91_REG *) 	0xFFFFFDD4) // (RTC) Interrupt Disable Register
N#define AT91C_RTC_SR    (AT91_CAST(AT91_REG *) 	0xFFFFFDC8) // (RTC) Status Register
N#define AT91C_RTC_MR    (AT91_CAST(AT91_REG *) 	0xFFFFFDB4) // (RTC) Mode Register
N#define AT91C_RTC_IER   (AT91_CAST(AT91_REG *) 	0xFFFFFDD0) // (RTC) Interrupt Enable Register
N#define AT91C_RTC_TIMALR (AT91_CAST(AT91_REG *) 	0xFFFFFDC0) // (RTC) Time Alarm Register
N#define AT91C_RTC_CALALR (AT91_CAST(AT91_REG *) 	0xFFFFFDC4) // (RTC) Calendar Alarm Register
N#define AT91C_RTC_CR    (AT91_CAST(AT91_REG *) 	0xFFFFFDB0) // (RTC) Control Register
N#define AT91C_RTC_TIMR  (AT91_CAST(AT91_REG *) 	0xFFFFFDB8) // (RTC) Time Register
N#define AT91C_RTC_CALR  (AT91_CAST(AT91_REG *) 	0xFFFFFDBC) // (RTC) Calendar Register
N#define AT91C_RTC_VER   (AT91_CAST(AT91_REG *) 	0xFFFFFDDC) // (RTC) Valid Entry Register
N#define AT91C_RTC_SCCR  (AT91_CAST(AT91_REG *) 	0xFFFFFDCC) // (RTC) Status Clear Command Register
N#define AT91C_RTC_IMR   (AT91_CAST(AT91_REG *) 	0xFFFFFDD8) // (RTC) Interrupt Mask Register
N// ========== Register definition for TC0 peripheral ========== 
N#define AT91C_TC0_IER   (AT91_CAST(AT91_REG *) 	0xFFF7C024) // (TC0) Interrupt Enable Register
N#define AT91C_TC0_IMR   (AT91_CAST(AT91_REG *) 	0xFFF7C02C) // (TC0) Interrupt Mask Register
N#define AT91C_TC0_CCR   (AT91_CAST(AT91_REG *) 	0xFFF7C000) // (TC0) Channel Control Register
N#define AT91C_TC0_RB    (AT91_CAST(AT91_REG *) 	0xFFF7C018) // (TC0) Register B
N#define AT91C_TC0_CV    (AT91_CAST(AT91_REG *) 	0xFFF7C010) // (TC0) Counter Value
N#define AT91C_TC0_SR    (AT91_CAST(AT91_REG *) 	0xFFF7C020) // (TC0) Status Register
N#define AT91C_TC0_CMR   (AT91_CAST(AT91_REG *) 	0xFFF7C004) // (TC0) Channel Mode Register (Capture Mode / Waveform Mode)
N#define AT91C_TC0_RA    (AT91_CAST(AT91_REG *) 	0xFFF7C014) // (TC0) Register A
N#define AT91C_TC0_RC    (AT91_CAST(AT91_REG *) 	0xFFF7C01C) // (TC0) Register C
N#define AT91C_TC0_IDR   (AT91_CAST(AT91_REG *) 	0xFFF7C028) // (TC0) Interrupt Disable Register
N// ========== Register definition for TC1 peripheral ========== 
N#define AT91C_TC1_IER   (AT91_CAST(AT91_REG *) 	0xFFF7C064) // (TC1) Interrupt Enable Register
N#define AT91C_TC1_SR    (AT91_CAST(AT91_REG *) 	0xFFF7C060) // (TC1) Status Register
N#define AT91C_TC1_RC    (AT91_CAST(AT91_REG *) 	0xFFF7C05C) // (TC1) Register C
N#define AT91C_TC1_CV    (AT91_CAST(AT91_REG *) 	0xFFF7C050) // (TC1) Counter Value
N#define AT91C_TC1_RA    (AT91_CAST(AT91_REG *) 	0xFFF7C054) // (TC1) Register A
N#define AT91C_TC1_CMR   (AT91_CAST(AT91_REG *) 	0xFFF7C044) // (TC1) Channel Mode Register (Capture Mode / Waveform Mode)
N#define AT91C_TC1_IDR   (AT91_CAST(AT91_REG *) 	0xFFF7C068) // (TC1) Interrupt Disable Register
N#define AT91C_TC1_RB    (AT91_CAST(AT91_REG *) 	0xFFF7C058) // (TC1) Register B
N#define AT91C_TC1_IMR   (AT91_CAST(AT91_REG *) 	0xFFF7C06C) // (TC1) Interrupt Mask Register
N#define AT91C_TC1_CCR   (AT91_CAST(AT91_REG *) 	0xFFF7C040) // (TC1) Channel Control Register
N// ========== Register definition for TC2 peripheral ========== 
N#define AT91C_TC2_SR    (AT91_CAST(AT91_REG *) 	0xFFF7C0A0) // (TC2) Status Register
N#define AT91C_TC2_IMR   (AT91_CAST(AT91_REG *) 	0xFFF7C0AC) // (TC2) Interrupt Mask Register
N#define AT91C_TC2_IER   (AT91_CAST(AT91_REG *) 	0xFFF7C0A4) // (TC2) Interrupt Enable Register
N#define AT91C_TC2_CV    (AT91_CAST(AT91_REG *) 	0xFFF7C090) // (TC2) Counter Value
N#define AT91C_TC2_RB    (AT91_CAST(AT91_REG *) 	0xFFF7C098) // (TC2) Register B
N#define AT91C_TC2_CCR   (AT91_CAST(AT91_REG *) 	0xFFF7C080) // (TC2) Channel Control Register
N#define AT91C_TC2_CMR   (AT91_CAST(AT91_REG *) 	0xFFF7C084) // (TC2) Channel Mode Register (Capture Mode / Waveform Mode)
N#define AT91C_TC2_RA    (AT91_CAST(AT91_REG *) 	0xFFF7C094) // (TC2) Register A
N#define AT91C_TC2_IDR   (AT91_CAST(AT91_REG *) 	0xFFF7C0A8) // (TC2) Interrupt Disable Register
N#define AT91C_TC2_RC    (AT91_CAST(AT91_REG *) 	0xFFF7C09C) // (TC2) Register C
N// ========== Register definition for TC3 peripheral ========== 
N#define AT91C_TC3_SR    (AT91_CAST(AT91_REG *) 	0xFFFD4020) // (TC3) Status Register
N#define AT91C_TC3_RC    (AT91_CAST(AT91_REG *) 	0xFFFD401C) // (TC3) Register C
N#define AT91C_TC3_IER   (AT91_CAST(AT91_REG *) 	0xFFFD4024) // (TC3) Interrupt Enable Register
N#define AT91C_TC3_CV    (AT91_CAST(AT91_REG *) 	0xFFFD4010) // (TC3) Counter Value
N#define AT91C_TC3_IDR   (AT91_CAST(AT91_REG *) 	0xFFFD4028) // (TC3) Interrupt Disable Register
N#define AT91C_TC3_IMR   (AT91_CAST(AT91_REG *) 	0xFFFD402C) // (TC3) Interrupt Mask Register
N#define AT91C_TC3_CMR   (AT91_CAST(AT91_REG *) 	0xFFFD4004) // (TC3) Channel Mode Register (Capture Mode / Waveform Mode)
N#define AT91C_TC3_RB    (AT91_CAST(AT91_REG *) 	0xFFFD4018) // (TC3) Register B
N#define AT91C_TC3_CCR   (AT91_CAST(AT91_REG *) 	0xFFFD4000) // (TC3) Channel Control Register
N#define AT91C_TC3_RA    (AT91_CAST(AT91_REG *) 	0xFFFD4014) // (TC3) Register A
N// ========== Register definition for TC4 peripheral ========== 
N#define AT91C_TC4_CV    (AT91_CAST(AT91_REG *) 	0xFFFD4050) // (TC4) Counter Value
N#define AT91C_TC4_RA    (AT91_CAST(AT91_REG *) 	0xFFFD4054) // (TC4) Register A
N#define AT91C_TC4_IDR   (AT91_CAST(AT91_REG *) 	0xFFFD4068) // (TC4) Interrupt Disable Register
N#define AT91C_TC4_SR    (AT91_CAST(AT91_REG *) 	0xFFFD4060) // (TC4) Status Register
N#define AT91C_TC4_CMR   (AT91_CAST(AT91_REG *) 	0xFFFD4044) // (TC4) Channel Mode Register (Capture Mode / Waveform Mode)
N#define AT91C_TC4_CCR   (AT91_CAST(AT91_REG *) 	0xFFFD4040) // (TC4) Channel Control Register
N#define AT91C_TC4_RB    (AT91_CAST(AT91_REG *) 	0xFFFD4058) // (TC4) Register B
N#define AT91C_TC4_RC    (AT91_CAST(AT91_REG *) 	0xFFFD405C) // (TC4) Register C
N#define AT91C_TC4_IER   (AT91_CAST(AT91_REG *) 	0xFFFD4064) // (TC4) Interrupt Enable Register
N#define AT91C_TC4_IMR   (AT91_CAST(AT91_REG *) 	0xFFFD406C) // (TC4) Interrupt Mask Register
N// ========== Register definition for TC5 peripheral ========== 
N#define AT91C_TC5_IER   (AT91_CAST(AT91_REG *) 	0xFFFD40A4) // (TC5) Interrupt Enable Register
N#define AT91C_TC5_IDR   (AT91_CAST(AT91_REG *) 	0xFFFD40A8) // (TC5) Interrupt Disable Register
N#define AT91C_TC5_RA    (AT91_CAST(AT91_REG *) 	0xFFFD4094) // (TC5) Register A
N#define AT91C_TC5_RB    (AT91_CAST(AT91_REG *) 	0xFFFD4098) // (TC5) Register B
N#define AT91C_TC5_CCR   (AT91_CAST(AT91_REG *) 	0xFFFD4080) // (TC5) Channel Control Register
N#define AT91C_TC5_SR    (AT91_CAST(AT91_REG *) 	0xFFFD40A0) // (TC5) Status Register
N#define AT91C_TC5_CV    (AT91_CAST(AT91_REG *) 	0xFFFD4090) // (TC5) Counter Value
N#define AT91C_TC5_RC    (AT91_CAST(AT91_REG *) 	0xFFFD409C) // (TC5) Register C
N#define AT91C_TC5_IMR   (AT91_CAST(AT91_REG *) 	0xFFFD40AC) // (TC5) Interrupt Mask Register
N#define AT91C_TC5_CMR   (AT91_CAST(AT91_REG *) 	0xFFFD4084) // (TC5) Channel Mode Register (Capture Mode / Waveform Mode)
N// ========== Register definition for TCB0 peripheral ========== 
N#define AT91C_TCB0_IPNAME1 (AT91_CAST(AT91_REG *) 	0xFFF7C0F0) // (TCB0) TC IPNAME1 REGISTER 
N#define AT91C_TCB0_IPNAME2 (AT91_CAST(AT91_REG *) 	0xFFF7C0F4) // (TCB0) TC IPNAME2 REGISTER 
N#define AT91C_TCB0_FEATURES (AT91_CAST(AT91_REG *) 	0xFFF7C0F8) // (TCB0) TC FEATURES REGISTER 
N#define AT91C_TCB0_BCR  (AT91_CAST(AT91_REG *) 	0xFFF7C0C0) // (TCB0) TC Block Control Register
N#define AT91C_TCB0_VER  (AT91_CAST(AT91_REG *) 	0xFFF7C0FC) // (TCB0)  Version Register
N#define AT91C_TCB0_BMR  (AT91_CAST(AT91_REG *) 	0xFFF7C0C4) // (TCB0) TC Block Mode Register
N#define AT91C_TCB0_ADDRSIZE (AT91_CAST(AT91_REG *) 	0xFFF7C0EC) // (TCB0) TC ADDRSIZE REGISTER 
N// ========== Register definition for TCB1 peripheral ========== 
N#define AT91C_TCB1_VER  (AT91_CAST(AT91_REG *) 	0xFFFD40FC) // (TCB1)  Version Register
N#define AT91C_TCB1_IPNAME2 (AT91_CAST(AT91_REG *) 	0xFFFD40F4) // (TCB1) TC IPNAME2 REGISTER 
N#define AT91C_TCB1_ADDRSIZE (AT91_CAST(AT91_REG *) 	0xFFFD40EC) // (TCB1) TC ADDRSIZE REGISTER 
N#define AT91C_TCB1_BMR  (AT91_CAST(AT91_REG *) 	0xFFFD40C4) // (TCB1) TC Block Mode Register
N#define AT91C_TCB1_FEATURES (AT91_CAST(AT91_REG *) 	0xFFFD40F8) // (TCB1) TC FEATURES REGISTER 
N#define AT91C_TCB1_IPNAME1 (AT91_CAST(AT91_REG *) 	0xFFFD40F0) // (TCB1) TC IPNAME1 REGISTER 
N#define AT91C_TCB1_BCR  (AT91_CAST(AT91_REG *) 	0xFFFD40C0) // (TCB1) TC Block Control Register
N// ========== Register definition for MCI0 peripheral ========== 
N#define AT91C_MCI0_IMR  (AT91_CAST(AT91_REG *) 	0xFFF8004C) // (MCI0) MCI Interrupt Mask Register
N#define AT91C_MCI0_MR   (AT91_CAST(AT91_REG *) 	0xFFF80004) // (MCI0) MCI Mode Register
N#define AT91C_MCI0_ADDRSIZE (AT91_CAST(AT91_REG *) 	0xFFF800EC) // (MCI0) MCI ADDRSIZE REGISTER 
N#define AT91C_MCI0_CR   (AT91_CAST(AT91_REG *) 	0xFFF80000) // (MCI0) MCI Control Register
N#define AT91C_MCI0_IPNAME2 (AT91_CAST(AT91_REG *) 	0xFFF800F4) // (MCI0) MCI IPNAME2 REGISTER 
N#define AT91C_MCI0_IER  (AT91_CAST(AT91_REG *) 	0xFFF80044) // (MCI0) MCI Interrupt Enable Register
N#define AT91C_MCI0_FIFO (AT91_CAST(AT91_REG *) 	0xFFF80200) // (MCI0) MCI FIFO Aperture Register
N#define AT91C_MCI0_DTOR (AT91_CAST(AT91_REG *) 	0xFFF80008) // (MCI0) MCI Data Timeout Register
N#define AT91C_MCI0_SDCR (AT91_CAST(AT91_REG *) 	0xFFF8000C) // (MCI0) MCI SD/SDIO Card Register
N#define AT91C_MCI0_BLKR (AT91_CAST(AT91_REG *) 	0xFFF80018) // (MCI0) MCI Block Register
N#define AT91C_MCI0_VER  (AT91_CAST(AT91_REG *) 	0xFFF800FC) // (MCI0) MCI VERSION REGISTER 
N#define AT91C_MCI0_WPSR (AT91_CAST(AT91_REG *) 	0xFFF800E8) // (MCI0) MCI Write Protection Status Register
N#define AT91C_MCI0_CMDR (AT91_CAST(AT91_REG *) 	0xFFF80014) // (MCI0) MCI Command Register
N#define AT91C_MCI0_CSTOR (AT91_CAST(AT91_REG *) 	0xFFF8001C) // (MCI0) MCI Completion Signal Timeout Register
N#define AT91C_MCI0_IPNAME1 (AT91_CAST(AT91_REG *) 	0xFFF800F0) // (MCI0) MCI IPNAME1 REGISTER 
N#define AT91C_MCI0_DMA  (AT91_CAST(AT91_REG *) 	0xFFF80050) // (MCI0) MCI DMA Configuration Register
N#define AT91C_MCI0_FEATURES (AT91_CAST(AT91_REG *) 	0xFFF800F8) // (MCI0) MCI FEATURES REGISTER 
N#define AT91C_MCI0_RDR  (AT91_CAST(AT91_REG *) 	0xFFF80030) // (MCI0) MCI Receive Data Register
N#define AT91C_MCI0_SR   (AT91_CAST(AT91_REG *) 	0xFFF80040) // (MCI0) MCI Status Register
N#define AT91C_MCI0_TDR  (AT91_CAST(AT91_REG *) 	0xFFF80034) // (MCI0) MCI Transmit Data Register
N#define AT91C_MCI0_CFG  (AT91_CAST(AT91_REG *) 	0xFFF80054) // (MCI0) MCI Configuration Register
N#define AT91C_MCI0_ARGR (AT91_CAST(AT91_REG *) 	0xFFF80010) // (MCI0) MCI Argument Register
N#define AT91C_MCI0_RSPR (AT91_CAST(AT91_REG *) 	0xFFF80020) // (MCI0) MCI Response Register
N#define AT91C_MCI0_WPCR (AT91_CAST(AT91_REG *) 	0xFFF800E4) // (MCI0) MCI Write Protection Control Register
N#define AT91C_MCI0_IDR  (AT91_CAST(AT91_REG *) 	0xFFF80048) // (MCI0) MCI Interrupt Disable Register
N// ========== Register definition for MCI1 peripheral ========== 
N#define AT91C_MCI1_IPNAME1 (AT91_CAST(AT91_REG *) 	0xFFFD00F0) // (MCI1) MCI IPNAME1 REGISTER 
N#define AT91C_MCI1_IDR  (AT91_CAST(AT91_REG *) 	0xFFFD0048) // (MCI1) MCI Interrupt Disable Register
N#define AT91C_MCI1_IPNAME2 (AT91_CAST(AT91_REG *) 	0xFFFD00F4) // (MCI1) MCI IPNAME2 REGISTER 
N#define AT91C_MCI1_MR   (AT91_CAST(AT91_REG *) 	0xFFFD0004) // (MCI1) MCI Mode Register
N#define AT91C_MCI1_SR   (AT91_CAST(AT91_REG *) 	0xFFFD0040) // (MCI1) MCI Status Register
N#define AT91C_MCI1_DTOR (AT91_CAST(AT91_REG *) 	0xFFFD0008) // (MCI1) MCI Data Timeout Register
N#define AT91C_MCI1_WPCR (AT91_CAST(AT91_REG *) 	0xFFFD00E4) // (MCI1) MCI Write Protection Control Register
N#define AT91C_MCI1_ADDRSIZE (AT91_CAST(AT91_REG *) 	0xFFFD00EC) // (MCI1) MCI ADDRSIZE REGISTER 
N#define AT91C_MCI1_ARGR (AT91_CAST(AT91_REG *) 	0xFFFD0010) // (MCI1) MCI Argument Register
N#define AT91C_MCI1_FIFO (AT91_CAST(AT91_REG *) 	0xFFFD0200) // (MCI1) MCI FIFO Aperture Register
N#define AT91C_MCI1_IER  (AT91_CAST(AT91_REG *) 	0xFFFD0044) // (MCI1) MCI Interrupt Enable Register
N#define AT91C_MCI1_SDCR (AT91_CAST(AT91_REG *) 	0xFFFD000C) // (MCI1) MCI SD/SDIO Card Register
N#define AT91C_MCI1_FEATURES (AT91_CAST(AT91_REG *) 	0xFFFD00F8) // (MCI1) MCI FEATURES REGISTER 
N#define AT91C_MCI1_CR   (AT91_CAST(AT91_REG *) 	0xFFFD0000) // (MCI1) MCI Control Register
N#define AT91C_MCI1_CSTOR (AT91_CAST(AT91_REG *) 	0xFFFD001C) // (MCI1) MCI Completion Signal Timeout Register
N#define AT91C_MCI1_RSPR (AT91_CAST(AT91_REG *) 	0xFFFD0020) // (MCI1) MCI Response Register
N#define AT91C_MCI1_IMR  (AT91_CAST(AT91_REG *) 	0xFFFD004C) // (MCI1) MCI Interrupt Mask Register
N#define AT91C_MCI1_DMA  (AT91_CAST(AT91_REG *) 	0xFFFD0050) // (MCI1) MCI DMA Configuration Register
N#define AT91C_MCI1_BLKR (AT91_CAST(AT91_REG *) 	0xFFFD0018) // (MCI1) MCI Block Register
N#define AT91C_MCI1_RDR  (AT91_CAST(AT91_REG *) 	0xFFFD0030) // (MCI1) MCI Receive Data Register
N#define AT91C_MCI1_CFG  (AT91_CAST(AT91_REG *) 	0xFFFD0054) // (MCI1) MCI Configuration Register
N#define AT91C_MCI1_WPSR (AT91_CAST(AT91_REG *) 	0xFFFD00E8) // (MCI1) MCI Write Protection Status Register
N#define AT91C_MCI1_CMDR (AT91_CAST(AT91_REG *) 	0xFFFD0014) // (MCI1) MCI Command Register
N#define AT91C_MCI1_TDR  (AT91_CAST(AT91_REG *) 	0xFFFD0034) // (MCI1) MCI Transmit Data Register
N#define AT91C_MCI1_VER  (AT91_CAST(AT91_REG *) 	0xFFFD00FC) // (MCI1) MCI VERSION REGISTER 
N// ========== Register definition for TWI0 peripheral ========== 
N#define AT91C_TWI0_RHR  (AT91_CAST(AT91_REG *) 	0xFFF84030) // (TWI0) Receive Holding Register
N#define AT91C_TWI0_ADDRSIZE (AT91_CAST(AT91_REG *) 	0xFFF840EC) // (TWI0) TWI ADDRSIZE REGISTER 
N#define AT91C_TWI0_SMR  (AT91_CAST(AT91_REG *) 	0xFFF84008) // (TWI0) Slave Mode Register
N#define AT91C_TWI0_IDR  (AT91_CAST(AT91_REG *) 	0xFFF84028) // (TWI0) Interrupt Disable Register
N#define AT91C_TWI0_CWGR (AT91_CAST(AT91_REG *) 	0xFFF84010) // (TWI0) Clock Waveform Generator Register
N#define AT91C_TWI0_IER  (AT91_CAST(AT91_REG *) 	0xFFF84024) // (TWI0) Interrupt Enable Register
N#define AT91C_TWI0_THR  (AT91_CAST(AT91_REG *) 	0xFFF84034) // (TWI0) Transmit Holding Register
N#define AT91C_TWI0_IPNAME2 (AT91_CAST(AT91_REG *) 	0xFFF840F4) // (TWI0) TWI IPNAME2 REGISTER 
N#define AT91C_TWI0_CR   (AT91_CAST(AT91_REG *) 	0xFFF84000) // (TWI0) Control Register
N#define AT91C_TWI0_MMR  (AT91_CAST(AT91_REG *) 	0xFFF84004) // (TWI0) Master Mode Register
N#define AT91C_TWI0_SR   (AT91_CAST(AT91_REG *) 	0xFFF84020) // (TWI0) Status Register
N#define AT91C_TWI0_IMR  (AT91_CAST(AT91_REG *) 	0xFFF8402C) // (TWI0) Interrupt Mask Register
N#define AT91C_TWI0_FEATURES (AT91_CAST(AT91_REG *) 	0xFFF840F8) // (TWI0) TWI FEATURES REGISTER 
N#define AT91C_TWI0_IADR (AT91_CAST(AT91_REG *) 	0xFFF8400C) // (TWI0) Internal Address Register
N#define AT91C_TWI0_IPNAME1 (AT91_CAST(AT91_REG *) 	0xFFF840F0) // (TWI0) TWI IPNAME1 REGISTER 
N#define AT91C_TWI0_VER  (AT91_CAST(AT91_REG *) 	0xFFF840FC) // (TWI0) Version Register
N// ========== Register definition for TWI1 peripheral ========== 
N#define AT91C_TWI1_VER  (AT91_CAST(AT91_REG *) 	0xFFF880FC) // (TWI1) Version Register
N#define AT91C_TWI1_IMR  (AT91_CAST(AT91_REG *) 	0xFFF8802C) // (TWI1) Interrupt Mask Register
N#define AT91C_TWI1_THR  (AT91_CAST(AT91_REG *) 	0xFFF88034) // (TWI1) Transmit Holding Register
N#define AT91C_TWI1_IER  (AT91_CAST(AT91_REG *) 	0xFFF88024) // (TWI1) Interrupt Enable Register
N#define AT91C_TWI1_MMR  (AT91_CAST(AT91_REG *) 	0xFFF88004) // (TWI1) Master Mode Register
N#define AT91C_TWI1_IPNAME1 (AT91_CAST(AT91_REG *) 	0xFFF880F0) // (TWI1) TWI IPNAME1 REGISTER 
N#define AT91C_TWI1_CR   (AT91_CAST(AT91_REG *) 	0xFFF88000) // (TWI1) Control Register
N#define AT91C_TWI1_SR   (AT91_CAST(AT91_REG *) 	0xFFF88020) // (TWI1) Status Register
N#define AT91C_TWI1_CWGR (AT91_CAST(AT91_REG *) 	0xFFF88010) // (TWI1) Clock Waveform Generator Register
N#define AT91C_TWI1_IPNAME2 (AT91_CAST(AT91_REG *) 	0xFFF880F4) // (TWI1) TWI IPNAME2 REGISTER 
N#define AT91C_TWI1_IDR  (AT91_CAST(AT91_REG *) 	0xFFF88028) // (TWI1) Interrupt Disable Register
N#define AT91C_TWI1_RHR  (AT91_CAST(AT91_REG *) 	0xFFF88030) // (TWI1) Receive Holding Register
N#define AT91C_TWI1_IADR (AT91_CAST(AT91_REG *) 	0xFFF8800C) // (TWI1) Internal Address Register
N#define AT91C_TWI1_SMR  (AT91_CAST(AT91_REG *) 	0xFFF88008) // (TWI1) Slave Mode Register
N#define AT91C_TWI1_FEATURES (AT91_CAST(AT91_REG *) 	0xFFF880F8) // (TWI1) TWI FEATURES REGISTER 
N#define AT91C_TWI1_ADDRSIZE (AT91_CAST(AT91_REG *) 	0xFFF880EC) // (TWI1) TWI ADDRSIZE REGISTER 
N// ========== Register definition for PDC_US0 peripheral ========== 
N#define AT91C_US0_TNPR  (AT91_CAST(AT91_REG *) 	0xFFF8C118) // (PDC_US0) Transmit Next Pointer Register
N#define AT91C_US0_PTSR  (AT91_CAST(AT91_REG *) 	0xFFF8C124) // (PDC_US0) PDC Transfer Status Register
N#define AT91C_US0_PTCR  (AT91_CAST(AT91_REG *) 	0xFFF8C120) // (PDC_US0) PDC Transfer Control Register
N#define AT91C_US0_RNCR  (AT91_CAST(AT91_REG *) 	0xFFF8C114) // (PDC_US0) Receive Next Counter Register
N#define AT91C_US0_RCR   (AT91_CAST(AT91_REG *) 	0xFFF8C104) // (PDC_US0) Receive Counter Register
N#define AT91C_US0_TNCR  (AT91_CAST(AT91_REG *) 	0xFFF8C11C) // (PDC_US0) Transmit Next Counter Register
N#define AT91C_US0_TCR   (AT91_CAST(AT91_REG *) 	0xFFF8C10C) // (PDC_US0) Transmit Counter Register
N#define AT91C_US0_RNPR  (AT91_CAST(AT91_REG *) 	0xFFF8C110) // (PDC_US0) Receive Next Pointer Register
N#define AT91C_US0_RPR   (AT91_CAST(AT91_REG *) 	0xFFF8C100) // (PDC_US0) Receive Pointer Register
N#define AT91C_US0_TPR   (AT91_CAST(AT91_REG *) 	0xFFF8C108) // (PDC_US0) Transmit Pointer Register
N// ========== Register definition for US0 peripheral ========== 
N#define AT91C_US0_MAN   (AT91_CAST(AT91_REG *) 	0xFFF8C050) // (US0) Manchester Encoder Decoder Register
N#define AT91C_US0_MR    (AT91_CAST(AT91_REG *) 	0xFFF8C004) // (US0) Mode Register
N#define AT91C_US0_RHR   (AT91_CAST(AT91_REG *) 	0xFFF8C018) // (US0) Receiver Holding Register
N#define AT91C_US0_CSR   (AT91_CAST(AT91_REG *) 	0xFFF8C014) // (US0) Channel Status Register
N#define AT91C_US0_CR    (AT91_CAST(AT91_REG *) 	0xFFF8C000) // (US0) Control Register
N#define AT91C_US0_VER   (AT91_CAST(AT91_REG *) 	0xFFF8C0FC) // (US0) VERSION Register
N#define AT91C_US0_IER   (AT91_CAST(AT91_REG *) 	0xFFF8C008) // (US0) Interrupt Enable Register
N#define AT91C_US0_BRGR  (AT91_CAST(AT91_REG *) 	0xFFF8C020) // (US0) Baud Rate Generator Register
N#define AT91C_US0_FEATURES (AT91_CAST(AT91_REG *) 	0xFFF8C0F8) // (US0) US FEATURES REGISTER 
N#define AT91C_US0_RTOR  (AT91_CAST(AT91_REG *) 	0xFFF8C024) // (US0) Receiver Time-out Register
N#define AT91C_US0_THR   (AT91_CAST(AT91_REG *) 	0xFFF8C01C) // (US0) Transmitter Holding Register
N#define AT91C_US0_NER   (AT91_CAST(AT91_REG *) 	0xFFF8C044) // (US0) Nb Errors Register
N#define AT91C_US0_IPNAME1 (AT91_CAST(AT91_REG *) 	0xFFF8C0F0) // (US0) US IPNAME1 REGISTER 
N#define AT91C_US0_IMR   (AT91_CAST(AT91_REG *) 	0xFFF8C010) // (US0) Interrupt Mask Register
N#define AT91C_US0_ADDRSIZE (AT91_CAST(AT91_REG *) 	0xFFF8C0EC) // (US0) US ADDRSIZE REGISTER 
N#define AT91C_US0_IDR   (AT91_CAST(AT91_REG *) 	0xFFF8C00C) // (US0) Interrupt Disable Register
N#define AT91C_US0_FIDI  (AT91_CAST(AT91_REG *) 	0xFFF8C040) // (US0) FI_DI_Ratio Register
N#define AT91C_US0_IPNAME2 (AT91_CAST(AT91_REG *) 	0xFFF8C0F4) // (US0) US IPNAME2 REGISTER 
N#define AT91C_US0_TTGR  (AT91_CAST(AT91_REG *) 	0xFFF8C028) // (US0) Transmitter Time-guard Register
N#define AT91C_US0_IF    (AT91_CAST(AT91_REG *) 	0xFFF8C04C) // (US0) IRDA_FILTER Register
N// ========== Register definition for PDC_US1 peripheral ========== 
N#define AT91C_US1_PTCR  (AT91_CAST(AT91_REG *) 	0xFFF90120) // (PDC_US1) PDC Transfer Control Register
N#define AT91C_US1_TNCR  (AT91_CAST(AT91_REG *) 	0xFFF9011C) // (PDC_US1) Transmit Next Counter Register
N#define AT91C_US1_RCR   (AT91_CAST(AT91_REG *) 	0xFFF90104) // (PDC_US1) Receive Counter Register
N#define AT91C_US1_RPR   (AT91_CAST(AT91_REG *) 	0xFFF90100) // (PDC_US1) Receive Pointer Register
N#define AT91C_US1_TPR   (AT91_CAST(AT91_REG *) 	0xFFF90108) // (PDC_US1) Transmit Pointer Register
N#define AT91C_US1_TCR   (AT91_CAST(AT91_REG *) 	0xFFF9010C) // (PDC_US1) Transmit Counter Register
N#define AT91C_US1_RNPR  (AT91_CAST(AT91_REG *) 	0xFFF90110) // (PDC_US1) Receive Next Pointer Register
N#define AT91C_US1_TNPR  (AT91_CAST(AT91_REG *) 	0xFFF90118) // (PDC_US1) Transmit Next Pointer Register
N#define AT91C_US1_RNCR  (AT91_CAST(AT91_REG *) 	0xFFF90114) // (PDC_US1) Receive Next Counter Register
N#define AT91C_US1_PTSR  (AT91_CAST(AT91_REG *) 	0xFFF90124) // (PDC_US1) PDC Transfer Status Register
N// ========== Register definition for US1 peripheral ========== 
N#define AT91C_US1_FEATURES (AT91_CAST(AT91_REG *) 	0xFFF900F8) // (US1) US FEATURES REGISTER 
N#define AT91C_US1_ADDRSIZE (AT91_CAST(AT91_REG *) 	0xFFF900EC) // (US1) US ADDRSIZE REGISTER 
N#define AT91C_US1_NER   (AT91_CAST(AT91_REG *) 	0xFFF90044) // (US1) Nb Errors Register
N#define AT91C_US1_RHR   (AT91_CAST(AT91_REG *) 	0xFFF90018) // (US1) Receiver Holding Register
N#define AT91C_US1_IF    (AT91_CAST(AT91_REG *) 	0xFFF9004C) // (US1) IRDA_FILTER Register
N#define AT91C_US1_CR    (AT91_CAST(AT91_REG *) 	0xFFF90000) // (US1) Control Register
N#define AT91C_US1_TTGR  (AT91_CAST(AT91_REG *) 	0xFFF90028) // (US1) Transmitter Time-guard Register
N#define AT91C_US1_MR    (AT91_CAST(AT91_REG *) 	0xFFF90004) // (US1) Mode Register
N#define AT91C_US1_FIDI  (AT91_CAST(AT91_REG *) 	0xFFF90040) // (US1) FI_DI_Ratio Register
N#define AT91C_US1_RTOR  (AT91_CAST(AT91_REG *) 	0xFFF90024) // (US1) Receiver Time-out Register
N#define AT91C_US1_IER   (AT91_CAST(AT91_REG *) 	0xFFF90008) // (US1) Interrupt Enable Register
N#define AT91C_US1_MAN   (AT91_CAST(AT91_REG *) 	0xFFF90050) // (US1) Manchester Encoder Decoder Register
N#define AT91C_US1_IPNAME2 (AT91_CAST(AT91_REG *) 	0xFFF900F4) // (US1) US IPNAME2 REGISTER 
N#define AT91C_US1_IMR   (AT91_CAST(AT91_REG *) 	0xFFF90010) // (US1) Interrupt Mask Register
N#define AT91C_US1_IDR   (AT91_CAST(AT91_REG *) 	0xFFF9000C) // (US1) Interrupt Disable Register
N#define AT91C_US1_CSR   (AT91_CAST(AT91_REG *) 	0xFFF90014) // (US1) Channel Status Register
N#define AT91C_US1_BRGR  (AT91_CAST(AT91_REG *) 	0xFFF90020) // (US1) Baud Rate Generator Register
N#define AT91C_US1_THR   (AT91_CAST(AT91_REG *) 	0xFFF9001C) // (US1) Transmitter Holding Register
N#define AT91C_US1_VER   (AT91_CAST(AT91_REG *) 	0xFFF900FC) // (US1) VERSION Register
N#define AT91C_US1_IPNAME1 (AT91_CAST(AT91_REG *) 	0xFFF900F0) // (US1) US IPNAME1 REGISTER 
N// ========== Register definition for PDC_US2 peripheral ========== 
N#define AT91C_US2_RNCR  (AT91_CAST(AT91_REG *) 	0xFFF94114) // (PDC_US2) Receive Next Counter Register
N#define AT91C_US2_PTCR  (AT91_CAST(AT91_REG *) 	0xFFF94120) // (PDC_US2) PDC Transfer Control Register
N#define AT91C_US2_TNPR  (AT91_CAST(AT91_REG *) 	0xFFF94118) // (PDC_US2) Transmit Next Pointer Register
N#define AT91C_US2_TNCR  (AT91_CAST(AT91_REG *) 	0xFFF9411C) // (PDC_US2) Transmit Next Counter Register
N#define AT91C_US2_TPR   (AT91_CAST(AT91_REG *) 	0xFFF94108) // (PDC_US2) Transmit Pointer Register
N#define AT91C_US2_RCR   (AT91_CAST(AT91_REG *) 	0xFFF94104) // (PDC_US2) Receive Counter Register
N#define AT91C_US2_PTSR  (AT91_CAST(AT91_REG *) 	0xFFF94124) // (PDC_US2) PDC Transfer Status Register
N#define AT91C_US2_TCR   (AT91_CAST(AT91_REG *) 	0xFFF9410C) // (PDC_US2) Transmit Counter Register
N#define AT91C_US2_RPR   (AT91_CAST(AT91_REG *) 	0xFFF94100) // (PDC_US2) Receive Pointer Register
N#define AT91C_US2_RNPR  (AT91_CAST(AT91_REG *) 	0xFFF94110) // (PDC_US2) Receive Next Pointer Register
N// ========== Register definition for US2 peripheral ========== 
N#define AT91C_US2_TTGR  (AT91_CAST(AT91_REG *) 	0xFFF94028) // (US2) Transmitter Time-guard Register
N#define AT91C_US2_IER   (AT91_CAST(AT91_REG *) 	0xFFF94008) // (US2) Interrupt Enable Register
N#define AT91C_US2_ADDRSIZE (AT91_CAST(AT91_REG *) 	0xFFF940EC) // (US2) US ADDRSIZE REGISTER 
N#define AT91C_US2_NER   (AT91_CAST(AT91_REG *) 	0xFFF94044) // (US2) Nb Errors Register
N#define AT91C_US2_CR    (AT91_CAST(AT91_REG *) 	0xFFF94000) // (US2) Control Register
N#define AT91C_US2_IDR   (AT91_CAST(AT91_REG *) 	0xFFF9400C) // (US2) Interrupt Disable Register
N#define AT91C_US2_VER   (AT91_CAST(AT91_REG *) 	0xFFF940FC) // (US2) VERSION Register
N#define AT91C_US2_THR   (AT91_CAST(AT91_REG *) 	0xFFF9401C) // (US2) Transmitter Holding Register
N#define AT91C_US2_BRGR  (AT91_CAST(AT91_REG *) 	0xFFF94020) // (US2) Baud Rate Generator Register
N#define AT91C_US2_CSR   (AT91_CAST(AT91_REG *) 	0xFFF94014) // (US2) Channel Status Register
N#define AT91C_US2_IPNAME2 (AT91_CAST(AT91_REG *) 	0xFFF940F4) // (US2) US IPNAME2 REGISTER 
N#define AT91C_US2_IMR   (AT91_CAST(AT91_REG *) 	0xFFF94010) // (US2) Interrupt Mask Register
N#define AT91C_US2_RHR   (AT91_CAST(AT91_REG *) 	0xFFF94018) // (US2) Receiver Holding Register
N#define AT91C_US2_MR    (AT91_CAST(AT91_REG *) 	0xFFF94004) // (US2) Mode Register
N#define AT91C_US2_FIDI  (AT91_CAST(AT91_REG *) 	0xFFF94040) // (US2) FI_DI_Ratio Register
N#define AT91C_US2_MAN   (AT91_CAST(AT91_REG *) 	0xFFF94050) // (US2) Manchester Encoder Decoder Register
N#define AT91C_US2_IF    (AT91_CAST(AT91_REG *) 	0xFFF9404C) // (US2) IRDA_FILTER Register
N#define AT91C_US2_FEATURES (AT91_CAST(AT91_REG *) 	0xFFF940F8) // (US2) US FEATURES REGISTER 
N#define AT91C_US2_IPNAME1 (AT91_CAST(AT91_REG *) 	0xFFF940F0) // (US2) US IPNAME1 REGISTER 
N#define AT91C_US2_RTOR  (AT91_CAST(AT91_REG *) 	0xFFF94024) // (US2) Receiver Time-out Register
N// ========== Register definition for PDC_US3 peripheral ========== 
N#define AT91C_US3_PTSR  (AT91_CAST(AT91_REG *) 	0xFFF98124) // (PDC_US3) PDC Transfer Status Register
N#define AT91C_US3_TCR   (AT91_CAST(AT91_REG *) 	0xFFF9810C) // (PDC_US3) Transmit Counter Register
N#define AT91C_US3_RNPR  (AT91_CAST(AT91_REG *) 	0xFFF98110) // (PDC_US3) Receive Next Pointer Register
N#define AT91C_US3_RNCR  (AT91_CAST(AT91_REG *) 	0xFFF98114) // (PDC_US3) Receive Next Counter Register
N#define AT91C_US3_TNPR  (AT91_CAST(AT91_REG *) 	0xFFF98118) // (PDC_US3) Transmit Next Pointer Register
N#define AT91C_US3_RPR   (AT91_CAST(AT91_REG *) 	0xFFF98100) // (PDC_US3) Receive Pointer Register
N#define AT91C_US3_TPR   (AT91_CAST(AT91_REG *) 	0xFFF98108) // (PDC_US3) Transmit Pointer Register
N#define AT91C_US3_RCR   (AT91_CAST(AT91_REG *) 	0xFFF98104) // (PDC_US3) Receive Counter Register
N#define AT91C_US3_TNCR  (AT91_CAST(AT91_REG *) 	0xFFF9811C) // (PDC_US3) Transmit Next Counter Register
N#define AT91C_US3_PTCR  (AT91_CAST(AT91_REG *) 	0xFFF98120) // (PDC_US3) PDC Transfer Control Register
N// ========== Register definition for US3 peripheral ========== 
N#define AT91C_US3_VER   (AT91_CAST(AT91_REG *) 	0xFFF980FC) // (US3) VERSION Register
N#define AT91C_US3_BRGR  (AT91_CAST(AT91_REG *) 	0xFFF98020) // (US3) Baud Rate Generator Register
N#define AT91C_US3_TTGR  (AT91_CAST(AT91_REG *) 	0xFFF98028) // (US3) Transmitter Time-guard Register
N#define AT91C_US3_RTOR  (AT91_CAST(AT91_REG *) 	0xFFF98024) // (US3) Receiver Time-out Register
N#define AT91C_US3_MAN   (AT91_CAST(AT91_REG *) 	0xFFF98050) // (US3) Manchester Encoder Decoder Register
N#define AT91C_US3_NER   (AT91_CAST(AT91_REG *) 	0xFFF98044) // (US3) Nb Errors Register
N#define AT91C_US3_CR    (AT91_CAST(AT91_REG *) 	0xFFF98000) // (US3) Control Register
N#define AT91C_US3_IDR   (AT91_CAST(AT91_REG *) 	0xFFF9800C) // (US3) Interrupt Disable Register
N#define AT91C_US3_ADDRSIZE (AT91_CAST(AT91_REG *) 	0xFFF980EC) // (US3) US ADDRSIZE REGISTER 
N#define AT91C_US3_CSR   (AT91_CAST(AT91_REG *) 	0xFFF98014) // (US3) Channel Status Register
N#define AT91C_US3_IPNAME2 (AT91_CAST(AT91_REG *) 	0xFFF980F4) // (US3) US IPNAME2 REGISTER 
N#define AT91C_US3_IER   (AT91_CAST(AT91_REG *) 	0xFFF98008) // (US3) Interrupt Enable Register
N#define AT91C_US3_FEATURES (AT91_CAST(AT91_REG *) 	0xFFF980F8) // (US3) US FEATURES REGISTER 
N#define AT91C_US3_MR    (AT91_CAST(AT91_REG *) 	0xFFF98004) // (US3) Mode Register
N#define AT91C_US3_IF    (AT91_CAST(AT91_REG *) 	0xFFF9804C) // (US3) IRDA_FILTER Register
N#define AT91C_US3_THR   (AT91_CAST(AT91_REG *) 	0xFFF9801C) // (US3) Transmitter Holding Register
N#define AT91C_US3_IMR   (AT91_CAST(AT91_REG *) 	0xFFF98010) // (US3) Interrupt Mask Register
N#define AT91C_US3_FIDI  (AT91_CAST(AT91_REG *) 	0xFFF98040) // (US3) FI_DI_Ratio Register
N#define AT91C_US3_RHR   (AT91_CAST(AT91_REG *) 	0xFFF98018) // (US3) Receiver Holding Register
N#define AT91C_US3_IPNAME1 (AT91_CAST(AT91_REG *) 	0xFFF980F0) // (US3) US IPNAME1 REGISTER 
N// ========== Register definition for PDC_SSC0 peripheral ========== 
N#define AT91C_SSC0_TNPR (AT91_CAST(AT91_REG *) 	0xFFF9C118) // (PDC_SSC0) Transmit Next Pointer Register
N#define AT91C_SSC0_PTSR (AT91_CAST(AT91_REG *) 	0xFFF9C124) // (PDC_SSC0) PDC Transfer Status Register
N#define AT91C_SSC0_TNCR (AT91_CAST(AT91_REG *) 	0xFFF9C11C) // (PDC_SSC0) Transmit Next Counter Register
N#define AT91C_SSC0_RNCR (AT91_CAST(AT91_REG *) 	0xFFF9C114) // (PDC_SSC0) Receive Next Counter Register
N#define AT91C_SSC0_TPR  (AT91_CAST(AT91_REG *) 	0xFFF9C108) // (PDC_SSC0) Transmit Pointer Register
N#define AT91C_SSC0_RCR  (AT91_CAST(AT91_REG *) 	0xFFF9C104) // (PDC_SSC0) Receive Counter Register
N#define AT91C_SSC0_PTCR (AT91_CAST(AT91_REG *) 	0xFFF9C120) // (PDC_SSC0) PDC Transfer Control Register
N#define AT91C_SSC0_RNPR (AT91_CAST(AT91_REG *) 	0xFFF9C110) // (PDC_SSC0) Receive Next Pointer Register
N#define AT91C_SSC0_TCR  (AT91_CAST(AT91_REG *) 	0xFFF9C10C) // (PDC_SSC0) Transmit Counter Register
N#define AT91C_SSC0_RPR  (AT91_CAST(AT91_REG *) 	0xFFF9C100) // (PDC_SSC0) Receive Pointer Register
N// ========== Register definition for SSC0 peripheral ========== 
N#define AT91C_SSC0_IPNAME2 (AT91_CAST(AT91_REG *) 	0xFFF9C0F4) // (SSC0) SSC IPNAME2 REGISTER 
N#define AT91C_SSC0_SR   (AT91_CAST(AT91_REG *) 	0xFFF9C040) // (SSC0) Status Register
N#define AT91C_SSC0_TSHR (AT91_CAST(AT91_REG *) 	0xFFF9C034) // (SSC0) Transmit Sync Holding Register
N#define AT91C_SSC0_TCMR (AT91_CAST(AT91_REG *) 	0xFFF9C018) // (SSC0) Transmit Clock Mode Register
N#define AT91C_SSC0_ADDRSIZE (AT91_CAST(AT91_REG *) 	0xFFF9C0EC) // (SSC0) SSC ADDRSIZE REGISTER 
N#define AT91C_SSC0_IMR  (AT91_CAST(AT91_REG *) 	0xFFF9C04C) // (SSC0) Interrupt Mask Register
N#define AT91C_SSC0_IDR  (AT91_CAST(AT91_REG *) 	0xFFF9C048) // (SSC0) Interrupt Disable Register
N#define AT91C_SSC0_CR   (AT91_CAST(AT91_REG *) 	0xFFF9C000) // (SSC0) Control Register
N#define AT91C_SSC0_VER  (AT91_CAST(AT91_REG *) 	0xFFF9C0FC) // (SSC0) Version Register
N#define AT91C_SSC0_RHR  (AT91_CAST(AT91_REG *) 	0xFFF9C020) // (SSC0) Receive Holding Register
N#define AT91C_SSC0_THR  (AT91_CAST(AT91_REG *) 	0xFFF9C024) // (SSC0) Transmit Holding Register
N#define AT91C_SSC0_CMR  (AT91_CAST(AT91_REG *) 	0xFFF9C004) // (SSC0) Clock Mode Register
N#define AT91C_SSC0_FEATURES (AT91_CAST(AT91_REG *) 	0xFFF9C0F8) // (SSC0) SSC FEATURES REGISTER 
N#define AT91C_SSC0_RCMR (AT91_CAST(AT91_REG *) 	0xFFF9C010) // (SSC0) Receive Clock ModeRegister
N#define AT91C_SSC0_IPNAME1 (AT91_CAST(AT91_REG *) 	0xFFF9C0F0) // (SSC0) SSC IPNAME1 REGISTER 
N#define AT91C_SSC0_RSHR (AT91_CAST(AT91_REG *) 	0xFFF9C030) // (SSC0) Receive Sync Holding Register
N#define AT91C_SSC0_IER  (AT91_CAST(AT91_REG *) 	0xFFF9C044) // (SSC0) Interrupt Enable Register
N#define AT91C_SSC0_TFMR (AT91_CAST(AT91_REG *) 	0xFFF9C01C) // (SSC0) Transmit Frame Mode Register
N#define AT91C_SSC0_RFMR (AT91_CAST(AT91_REG *) 	0xFFF9C014) // (SSC0) Receive Frame Mode Register
N// ========== Register definition for PDC_SSC1 peripheral ========== 
N#define AT91C_SSC1_RNPR (AT91_CAST(AT91_REG *) 	0xFFFA0110) // (PDC_SSC1) Receive Next Pointer Register
N#define AT91C_SSC1_TCR  (AT91_CAST(AT91_REG *) 	0xFFFA010C) // (PDC_SSC1) Transmit Counter Register
N#define AT91C_SSC1_TNCR (AT91_CAST(AT91_REG *) 	0xFFFA011C) // (PDC_SSC1) Transmit Next Counter Register
N#define AT91C_SSC1_RCR  (AT91_CAST(AT91_REG *) 	0xFFFA0104) // (PDC_SSC1) Receive Counter Register
N#define AT91C_SSC1_RNCR (AT91_CAST(AT91_REG *) 	0xFFFA0114) // (PDC_SSC1) Receive Next Counter Register
N#define AT91C_SSC1_PTCR (AT91_CAST(AT91_REG *) 	0xFFFA0120) // (PDC_SSC1) PDC Transfer Control Register
N#define AT91C_SSC1_TPR  (AT91_CAST(AT91_REG *) 	0xFFFA0108) // (PDC_SSC1) Transmit Pointer Register
N#define AT91C_SSC1_RPR  (AT91_CAST(AT91_REG *) 	0xFFFA0100) // (PDC_SSC1) Receive Pointer Register
N#define AT91C_SSC1_PTSR (AT91_CAST(AT91_REG *) 	0xFFFA0124) // (PDC_SSC1) PDC Transfer Status Register
N#define AT91C_SSC1_TNPR (AT91_CAST(AT91_REG *) 	0xFFFA0118) // (PDC_SSC1) Transmit Next Pointer Register
N// ========== Register definition for SSC1 peripheral ========== 
N#define AT91C_SSC1_SR   (AT91_CAST(AT91_REG *) 	0xFFFA0040) // (SSC1) Status Register
N#define AT91C_SSC1_TFMR (AT91_CAST(AT91_REG *) 	0xFFFA001C) // (SSC1) Transmit Frame Mode Register
N#define AT91C_SSC1_IPNAME1 (AT91_CAST(AT91_REG *) 	0xFFFA00F0) // (SSC1) SSC IPNAME1 REGISTER 
N#define AT91C_SSC1_CMR  (AT91_CAST(AT91_REG *) 	0xFFFA0004) // (SSC1) Clock Mode Register
N#define AT91C_SSC1_THR  (AT91_CAST(AT91_REG *) 	0xFFFA0024) // (SSC1) Transmit Holding Register
N#define AT91C_SSC1_FEATURES (AT91_CAST(AT91_REG *) 	0xFFFA00F8) // (SSC1) SSC FEATURES REGISTER 
N#define AT91C_SSC1_TSHR (AT91_CAST(AT91_REG *) 	0xFFFA0034) // (SSC1) Transmit Sync Holding Register
N#define AT91C_SSC1_RCMR (AT91_CAST(AT91_REG *) 	0xFFFA0010) // (SSC1) Receive Clock ModeRegister
N#define AT91C_SSC1_RHR  (AT91_CAST(AT91_REG *) 	0xFFFA0020) // (SSC1) Receive Holding Register
N#define AT91C_SSC1_VER  (AT91_CAST(AT91_REG *) 	0xFFFA00FC) // (SSC1) Version Register
N#define AT91C_SSC1_TCMR (AT91_CAST(AT91_REG *) 	0xFFFA0018) // (SSC1) Transmit Clock Mode Register
N#define AT91C_SSC1_CR   (AT91_CAST(AT91_REG *) 	0xFFFA0000) // (SSC1) Control Register
N#define AT91C_SSC1_RSHR (AT91_CAST(AT91_REG *) 	0xFFFA0030) // (SSC1) Receive Sync Holding Register
N#define AT91C_SSC1_IER  (AT91_CAST(AT91_REG *) 	0xFFFA0044) // (SSC1) Interrupt Enable Register
N#define AT91C_SSC1_ADDRSIZE (AT91_CAST(AT91_REG *) 	0xFFFA00EC) // (SSC1) SSC ADDRSIZE REGISTER 
N#define AT91C_SSC1_RFMR (AT91_CAST(AT91_REG *) 	0xFFFA0014) // (SSC1) Receive Frame Mode Register
N#define AT91C_SSC1_IMR  (AT91_CAST(AT91_REG *) 	0xFFFA004C) // (SSC1) Interrupt Mask Register
N#define AT91C_SSC1_IDR  (AT91_CAST(AT91_REG *) 	0xFFFA0048) // (SSC1) Interrupt Disable Register
N#define AT91C_SSC1_IPNAME2 (AT91_CAST(AT91_REG *) 	0xFFFA00F4) // (SSC1) SSC IPNAME2 REGISTER 
N// ========== Register definition for PWMC_CH0 peripheral ========== 
N#define AT91C_PWMC_CH0_CCNTR (AT91_CAST(AT91_REG *) 	0xFFFB820C) // (PWMC_CH0) Channel Counter Register
N#define AT91C_PWMC_CH0_CPRDR (AT91_CAST(AT91_REG *) 	0xFFFB8208) // (PWMC_CH0) Channel Period Register
N#define AT91C_PWMC_CH0_CUPDR (AT91_CAST(AT91_REG *) 	0xFFFB8210) // (PWMC_CH0) Channel Update Register
N#define AT91C_PWMC_CH0_CDTYR (AT91_CAST(AT91_REG *) 	0xFFFB8204) // (PWMC_CH0) Channel Duty Cycle Register
N#define AT91C_PWMC_CH0_CMR (AT91_CAST(AT91_REG *) 	0xFFFB8200) // (PWMC_CH0) Channel Mode Register
N#define AT91C_PWMC_CH0_Reserved (AT91_CAST(AT91_REG *) 	0xFFFB8214) // (PWMC_CH0) Reserved
N// ========== Register definition for PWMC_CH1 peripheral ========== 
N#define AT91C_PWMC_CH1_CCNTR (AT91_CAST(AT91_REG *) 	0xFFFB822C) // (PWMC_CH1) Channel Counter Register
N#define AT91C_PWMC_CH1_CDTYR (AT91_CAST(AT91_REG *) 	0xFFFB8224) // (PWMC_CH1) Channel Duty Cycle Register
N#define AT91C_PWMC_CH1_CMR (AT91_CAST(AT91_REG *) 	0xFFFB8220) // (PWMC_CH1) Channel Mode Register
N#define AT91C_PWMC_CH1_CPRDR (AT91_CAST(AT91_REG *) 	0xFFFB8228) // (PWMC_CH1) Channel Period Register
N#define AT91C_PWMC_CH1_Reserved (AT91_CAST(AT91_REG *) 	0xFFFB8234) // (PWMC_CH1) Reserved
N#define AT91C_PWMC_CH1_CUPDR (AT91_CAST(AT91_REG *) 	0xFFFB8230) // (PWMC_CH1) Channel Update Register
N// ========== Register definition for PWMC_CH2 peripheral ========== 
N#define AT91C_PWMC_CH2_CUPDR (AT91_CAST(AT91_REG *) 	0xFFFB8250) // (PWMC_CH2) Channel Update Register
N#define AT91C_PWMC_CH2_CMR (AT91_CAST(AT91_REG *) 	0xFFFB8240) // (PWMC_CH2) Channel Mode Register
N#define AT91C_PWMC_CH2_Reserved (AT91_CAST(AT91_REG *) 	0xFFFB8254) // (PWMC_CH2) Reserved
N#define AT91C_PWMC_CH2_CPRDR (AT91_CAST(AT91_REG *) 	0xFFFB8248) // (PWMC_CH2) Channel Period Register
N#define AT91C_PWMC_CH2_CDTYR (AT91_CAST(AT91_REG *) 	0xFFFB8244) // (PWMC_CH2) Channel Duty Cycle Register
N#define AT91C_PWMC_CH2_CCNTR (AT91_CAST(AT91_REG *) 	0xFFFB824C) // (PWMC_CH2) Channel Counter Register
N// ========== Register definition for PWMC_CH3 peripheral ========== 
N#define AT91C_PWMC_CH3_CPRDR (AT91_CAST(AT91_REG *) 	0xFFFB8268) // (PWMC_CH3) Channel Period Register
N#define AT91C_PWMC_CH3_Reserved (AT91_CAST(AT91_REG *) 	0xFFFB8274) // (PWMC_CH3) Reserved
N#define AT91C_PWMC_CH3_CUPDR (AT91_CAST(AT91_REG *) 	0xFFFB8270) // (PWMC_CH3) Channel Update Register
N#define AT91C_PWMC_CH3_CDTYR (AT91_CAST(AT91_REG *) 	0xFFFB8264) // (PWMC_CH3) Channel Duty Cycle Register
N#define AT91C_PWMC_CH3_CCNTR (AT91_CAST(AT91_REG *) 	0xFFFB826C) // (PWMC_CH3) Channel Counter Register
N#define AT91C_PWMC_CH3_CMR (AT91_CAST(AT91_REG *) 	0xFFFB8260) // (PWMC_CH3) Channel Mode Register
N// ========== Register definition for PWMC peripheral ========== 
N#define AT91C_PWMC_IDR  (AT91_CAST(AT91_REG *) 	0xFFFB8014) // (PWMC) PWMC Interrupt Disable Register
N#define AT91C_PWMC_MR   (AT91_CAST(AT91_REG *) 	0xFFFB8000) // (PWMC) PWMC Mode Register
N#define AT91C_PWMC_VR   (AT91_CAST(AT91_REG *) 	0xFFFB80FC) // (PWMC) PWMC Version Register
N#define AT91C_PWMC_IMR  (AT91_CAST(AT91_REG *) 	0xFFFB8018) // (PWMC) PWMC Interrupt Mask Register
N#define AT91C_PWMC_SR   (AT91_CAST(AT91_REG *) 	0xFFFB800C) // (PWMC) PWMC Status Register
N#define AT91C_PWMC_ISR  (AT91_CAST(AT91_REG *) 	0xFFFB801C) // (PWMC) PWMC Interrupt Status Register
N#define AT91C_PWMC_ENA  (AT91_CAST(AT91_REG *) 	0xFFFB8004) // (PWMC) PWMC Enable Register
N#define AT91C_PWMC_IER  (AT91_CAST(AT91_REG *) 	0xFFFB8010) // (PWMC) PWMC Interrupt Enable Register
N#define AT91C_PWMC_DIS  (AT91_CAST(AT91_REG *) 	0xFFFB8008) // (PWMC) PWMC Disable Register
N// ========== Register definition for PDC_SPI0 peripheral ========== 
N#define AT91C_SPI0_TPR  (AT91_CAST(AT91_REG *) 	0xFFFA4108) // (PDC_SPI0) Transmit Pointer Register
N#define AT91C_SPI0_PTCR (AT91_CAST(AT91_REG *) 	0xFFFA4120) // (PDC_SPI0) PDC Transfer Control Register
N#define AT91C_SPI0_RNPR (AT91_CAST(AT91_REG *) 	0xFFFA4110) // (PDC_SPI0) Receive Next Pointer Register
N#define AT91C_SPI0_TNCR (AT91_CAST(AT91_REG *) 	0xFFFA411C) // (PDC_SPI0) Transmit Next Counter Register
N#define AT91C_SPI0_TCR  (AT91_CAST(AT91_REG *) 	0xFFFA410C) // (PDC_SPI0) Transmit Counter Register
N#define AT91C_SPI0_RCR  (AT91_CAST(AT91_REG *) 	0xFFFA4104) // (PDC_SPI0) Receive Counter Register
N#define AT91C_SPI0_RNCR (AT91_CAST(AT91_REG *) 	0xFFFA4114) // (PDC_SPI0) Receive Next Counter Register
N#define AT91C_SPI0_TNPR (AT91_CAST(AT91_REG *) 	0xFFFA4118) // (PDC_SPI0) Transmit Next Pointer Register
N#define AT91C_SPI0_RPR  (AT91_CAST(AT91_REG *) 	0xFFFA4100) // (PDC_SPI0) Receive Pointer Register
N#define AT91C_SPI0_PTSR (AT91_CAST(AT91_REG *) 	0xFFFA4124) // (PDC_SPI0) PDC Transfer Status Register
N// ========== Register definition for PDC_SPI1 peripheral ========== 
N#define AT91C_SPI1_RNCR (AT91_CAST(AT91_REG *) 	0xFFFA8114) // (PDC_SPI1) Receive Next Counter Register
N#define AT91C_SPI1_TCR  (AT91_CAST(AT91_REG *) 	0xFFFA810C) // (PDC_SPI1) Transmit Counter Register
N#define AT91C_SPI1_RCR  (AT91_CAST(AT91_REG *) 	0xFFFA8104) // (PDC_SPI1) Receive Counter Register
N#define AT91C_SPI1_TNPR (AT91_CAST(AT91_REG *) 	0xFFFA8118) // (PDC_SPI1) Transmit Next Pointer Register
N#define AT91C_SPI1_RNPR (AT91_CAST(AT91_REG *) 	0xFFFA8110) // (PDC_SPI1) Receive Next Pointer Register
N#define AT91C_SPI1_RPR  (AT91_CAST(AT91_REG *) 	0xFFFA8100) // (PDC_SPI1) Receive Pointer Register
N#define AT91C_SPI1_TNCR (AT91_CAST(AT91_REG *) 	0xFFFA811C) // (PDC_SPI1) Transmit Next Counter Register
N#define AT91C_SPI1_TPR  (AT91_CAST(AT91_REG *) 	0xFFFA8108) // (PDC_SPI1) Transmit Pointer Register
N#define AT91C_SPI1_PTSR (AT91_CAST(AT91_REG *) 	0xFFFA8124) // (PDC_SPI1) PDC Transfer Status Register
N#define AT91C_SPI1_PTCR (AT91_CAST(AT91_REG *) 	0xFFFA8120) // (PDC_SPI1) PDC Transfer Control Register
N// ========== Register definition for SPI0 peripheral ========== 
N#define AT91C_SPI0_MR   (AT91_CAST(AT91_REG *) 	0xFFFA4004) // (SPI0) Mode Register
N#define AT91C_SPI0_RDR  (AT91_CAST(AT91_REG *) 	0xFFFA4008) // (SPI0) Receive Data Register
N#define AT91C_SPI0_CR   (AT91_CAST(AT91_REG *) 	0xFFFA4000) // (SPI0) Control Register
N#define AT91C_SPI0_IER  (AT91_CAST(AT91_REG *) 	0xFFFA4014) // (SPI0) Interrupt Enable Register
N#define AT91C_SPI0_TDR  (AT91_CAST(AT91_REG *) 	0xFFFA400C) // (SPI0) Transmit Data Register
N#define AT91C_SPI0_IDR  (AT91_CAST(AT91_REG *) 	0xFFFA4018) // (SPI0) Interrupt Disable Register
N#define AT91C_SPI0_CSR  (AT91_CAST(AT91_REG *) 	0xFFFA4030) // (SPI0) Chip Select Register
N#define AT91C_SPI0_SR   (AT91_CAST(AT91_REG *) 	0xFFFA4010) // (SPI0) Status Register
N#define AT91C_SPI0_IMR  (AT91_CAST(AT91_REG *) 	0xFFFA401C) // (SPI0) Interrupt Mask Register
N// ========== Register definition for SPI1 peripheral ========== 
N#define AT91C_SPI1_CSR  (AT91_CAST(AT91_REG *) 	0xFFFA8030) // (SPI1) Chip Select Register
N#define AT91C_SPI1_IER  (AT91_CAST(AT91_REG *) 	0xFFFA8014) // (SPI1) Interrupt Enable Register
N#define AT91C_SPI1_RDR  (AT91_CAST(AT91_REG *) 	0xFFFA8008) // (SPI1) Receive Data Register
N#define AT91C_SPI1_IDR  (AT91_CAST(AT91_REG *) 	0xFFFA8018) // (SPI1) Interrupt Disable Register
N#define AT91C_SPI1_MR   (AT91_CAST(AT91_REG *) 	0xFFFA8004) // (SPI1) Mode Register
N#define AT91C_SPI1_CR   (AT91_CAST(AT91_REG *) 	0xFFFA8000) // (SPI1) Control Register
N#define AT91C_SPI1_SR   (AT91_CAST(AT91_REG *) 	0xFFFA8010) // (SPI1) Status Register
N#define AT91C_SPI1_TDR  (AT91_CAST(AT91_REG *) 	0xFFFA800C) // (SPI1) Transmit Data Register
N#define AT91C_SPI1_IMR  (AT91_CAST(AT91_REG *) 	0xFFFA801C) // (SPI1) Interrupt Mask Register
N// ========== Register definition for PDC_TSADC peripheral ========== 
N#define AT91C_TSADC_TCR (AT91_CAST(AT91_REG *) 	0xFFFB010C) // (PDC_TSADC) Transmit Counter Register
N#define AT91C_TSADC_PTCR (AT91_CAST(AT91_REG *) 	0xFFFB0120) // (PDC_TSADC) PDC Transfer Control Register
N#define AT91C_TSADC_RNCR (AT91_CAST(AT91_REG *) 	0xFFFB0114) // (PDC_TSADC) Receive Next Counter Register
N#define AT91C_TSADC_PTSR (AT91_CAST(AT91_REG *) 	0xFFFB0124) // (PDC_TSADC) PDC Transfer Status Register
N#define AT91C_TSADC_TNCR (AT91_CAST(AT91_REG *) 	0xFFFB011C) // (PDC_TSADC) Transmit Next Counter Register
N#define AT91C_TSADC_RNPR (AT91_CAST(AT91_REG *) 	0xFFFB0110) // (PDC_TSADC) Receive Next Pointer Register
N#define AT91C_TSADC_RCR (AT91_CAST(AT91_REG *) 	0xFFFB0104) // (PDC_TSADC) Receive Counter Register
N#define AT91C_TSADC_TPR (AT91_CAST(AT91_REG *) 	0xFFFB0108) // (PDC_TSADC) Transmit Pointer Register
N#define AT91C_TSADC_TNPR (AT91_CAST(AT91_REG *) 	0xFFFB0118) // (PDC_TSADC) Transmit Next Pointer Register
N#define AT91C_TSADC_RPR (AT91_CAST(AT91_REG *) 	0xFFFB0100) // (PDC_TSADC) Receive Pointer Register
N// ========== Register definition for TSADC peripheral ========== 
N#define AT91C_TSADC_CHSR (AT91_CAST(AT91_REG *) 	0xFFFB0018) // (TSADC) Channel Status Register
N#define AT91C_TSADC_CDR5 (AT91_CAST(AT91_REG *) 	0xFFFB0044) // (TSADC) Channel Data Register 5
N#define AT91C_TSADC_CR  (AT91_CAST(AT91_REG *) 	0xFFFB0000) // (TSADC) Control Register
N#define AT91C_TSADC_IMR (AT91_CAST(AT91_REG *) 	0xFFFB002C) // (TSADC) Interrupt Mask Register
N#define AT91C_TSADC_CHDR (AT91_CAST(AT91_REG *) 	0xFFFB0014) // (TSADC) Channel Disable Register
N#define AT91C_TSADC_LCDR (AT91_CAST(AT91_REG *) 	0xFFFB0020) // (TSADC) Last Converted Register
N#define AT91C_TSADC_IER (AT91_CAST(AT91_REG *) 	0xFFFB0024) // (TSADC) Interrupt Enable Register
N#define AT91C_TSADC_TSR (AT91_CAST(AT91_REG *) 	0xFFFB000C) // (TSADC) Touch Screen Register
N#define AT91C_TSADC_CDR2 (AT91_CAST(AT91_REG *) 	0xFFFB0038) // (TSADC) Channel Data Register 2
N#define AT91C_TSADC_CDR4 (AT91_CAST(AT91_REG *) 	0xFFFB0040) // (TSADC) Channel Data Register 4
N#define AT91C_TSADC_CHER (AT91_CAST(AT91_REG *) 	0xFFFB0010) // (TSADC) Channel Enable Register
N#define AT91C_TSADC_TRGR (AT91_CAST(AT91_REG *) 	0xFFFB0008) // (TSADC) Trigger Register
N#define AT91C_TSADC_CDR3 (AT91_CAST(AT91_REG *) 	0xFFFB003C) // (TSADC) Channel Data Register 3
N#define AT91C_TSADC_SR  (AT91_CAST(AT91_REG *) 	0xFFFB001C) // (TSADC) Status Register
N#define AT91C_TSADC_CDR0 (AT91_CAST(AT91_REG *) 	0xFFFB0030) // (TSADC) Channel Data Register 0
N#define AT91C_TSADC_CDR6 (AT91_CAST(AT91_REG *) 	0xFFFB0048) // (TSADC) Channel Data Register 6
N#define AT91C_TSADC_IDR (AT91_CAST(AT91_REG *) 	0xFFFB0028) // (TSADC) Interrupt Disable Register
N#define AT91C_TSADC_MR  (AT91_CAST(AT91_REG *) 	0xFFFB0004) // (TSADC) Mode Register
N#define AT91C_TSADC_CDR7 (AT91_CAST(AT91_REG *) 	0xFFFB004C) // (TSADC) Channel Data Register 7
N#define AT91C_TSADC_CDR1 (AT91_CAST(AT91_REG *) 	0xFFFB0034) // (TSADC) Channel Data Register 1
N// ========== Register definition for UDPHS_EPTFIFO peripheral ========== 
N#define AT91C_UDPHS_EPTFIFO_READEPT3 (AT91_CAST(AT91_REG *) 	0x00630000) // (UDPHS_EPTFIFO) FIFO Endpoint Data Register 3
N#define AT91C_UDPHS_EPTFIFO_READEPT5 (AT91_CAST(AT91_REG *) 	0x00650000) // (UDPHS_EPTFIFO) FIFO Endpoint Data Register 5
N#define AT91C_UDPHS_EPTFIFO_READEPT1 (AT91_CAST(AT91_REG *) 	0x00610000) // (UDPHS_EPTFIFO) FIFO Endpoint Data Register 1
N#define AT91C_UDPHS_EPTFIFO_READEPT0 (AT91_CAST(AT91_REG *) 	0x00600000) // (UDPHS_EPTFIFO) FIFO Endpoint Data Register 0
N#define AT91C_UDPHS_EPTFIFO_READEPT6 (AT91_CAST(AT91_REG *) 	0x00660000) // (UDPHS_EPTFIFO) FIFO Endpoint Data Register 6
N#define AT91C_UDPHS_EPTFIFO_READEPT2 (AT91_CAST(AT91_REG *) 	0x00620000) // (UDPHS_EPTFIFO) FIFO Endpoint Data Register 2
N#define AT91C_UDPHS_EPTFIFO_READEPT4 (AT91_CAST(AT91_REG *) 	0x00640000) // (UDPHS_EPTFIFO) FIFO Endpoint Data Register 4
N// ========== Register definition for UDPHS_EPT_0 peripheral ========== 
N#define AT91C_UDPHS_EPT_0_EPTSTA (AT91_CAST(AT91_REG *) 	0xFFF7811C) // (UDPHS_EPT_0) UDPHS Endpoint Status Register
N#define AT91C_UDPHS_EPT_0_EPTCTL (AT91_CAST(AT91_REG *) 	0xFFF7810C) // (UDPHS_EPT_0) UDPHS Endpoint Control Register
N#define AT91C_UDPHS_EPT_0_EPTCTLDIS (AT91_CAST(AT91_REG *) 	0xFFF78108) // (UDPHS_EPT_0) UDPHS Endpoint Control Disable Register
N#define AT91C_UDPHS_EPT_0_EPTCFG (AT91_CAST(AT91_REG *) 	0xFFF78100) // (UDPHS_EPT_0) UDPHS Endpoint Config Register
N#define AT91C_UDPHS_EPT_0_EPTCLRSTA (AT91_CAST(AT91_REG *) 	0xFFF78118) // (UDPHS_EPT_0) UDPHS Endpoint Clear Status Register
N#define AT91C_UDPHS_EPT_0_EPTSETSTA (AT91_CAST(AT91_REG *) 	0xFFF78114) // (UDPHS_EPT_0) UDPHS Endpoint Set Status Register
N#define AT91C_UDPHS_EPT_0_EPTCTLENB (AT91_CAST(AT91_REG *) 	0xFFF78104) // (UDPHS_EPT_0) UDPHS Endpoint Control Enable Register
N// ========== Register definition for UDPHS_EPT_1 peripheral ========== 
N#define AT91C_UDPHS_EPT_1_EPTCTLENB (AT91_CAST(AT91_REG *) 	0xFFF78124) // (UDPHS_EPT_1) UDPHS Endpoint Control Enable Register
N#define AT91C_UDPHS_EPT_1_EPTCFG (AT91_CAST(AT91_REG *) 	0xFFF78120) // (UDPHS_EPT_1) UDPHS Endpoint Config Register
N#define AT91C_UDPHS_EPT_1_EPTCTL (AT91_CAST(AT91_REG *) 	0xFFF7812C) // (UDPHS_EPT_1) UDPHS Endpoint Control Register
N#define AT91C_UDPHS_EPT_1_EPTSTA (AT91_CAST(AT91_REG *) 	0xFFF7813C) // (UDPHS_EPT_1) UDPHS Endpoint Status Register
N#define AT91C_UDPHS_EPT_1_EPTCLRSTA (AT91_CAST(AT91_REG *) 	0xFFF78138) // (UDPHS_EPT_1) UDPHS Endpoint Clear Status Register
N#define AT91C_UDPHS_EPT_1_EPTSETSTA (AT91_CAST(AT91_REG *) 	0xFFF78134) // (UDPHS_EPT_1) UDPHS Endpoint Set Status Register
N#define AT91C_UDPHS_EPT_1_EPTCTLDIS (AT91_CAST(AT91_REG *) 	0xFFF78128) // (UDPHS_EPT_1) UDPHS Endpoint Control Disable Register
N// ========== Register definition for UDPHS_EPT_2 peripheral ========== 
N#define AT91C_UDPHS_EPT_2_EPTCLRSTA (AT91_CAST(AT91_REG *) 	0xFFF78158) // (UDPHS_EPT_2) UDPHS Endpoint Clear Status Register
N#define AT91C_UDPHS_EPT_2_EPTCTLDIS (AT91_CAST(AT91_REG *) 	0xFFF78148) // (UDPHS_EPT_2) UDPHS Endpoint Control Disable Register
N#define AT91C_UDPHS_EPT_2_EPTSTA (AT91_CAST(AT91_REG *) 	0xFFF7815C) // (UDPHS_EPT_2) UDPHS Endpoint Status Register
N#define AT91C_UDPHS_EPT_2_EPTSETSTA (AT91_CAST(AT91_REG *) 	0xFFF78154) // (UDPHS_EPT_2) UDPHS Endpoint Set Status Register
N#define AT91C_UDPHS_EPT_2_EPTCTL (AT91_CAST(AT91_REG *) 	0xFFF7814C) // (UDPHS_EPT_2) UDPHS Endpoint Control Register
N#define AT91C_UDPHS_EPT_2_EPTCFG (AT91_CAST(AT91_REG *) 	0xFFF78140) // (UDPHS_EPT_2) UDPHS Endpoint Config Register
N#define AT91C_UDPHS_EPT_2_EPTCTLENB (AT91_CAST(AT91_REG *) 	0xFFF78144) // (UDPHS_EPT_2) UDPHS Endpoint Control Enable Register
N// ========== Register definition for UDPHS_EPT_3 peripheral ========== 
N#define AT91C_UDPHS_EPT_3_EPTCTL (AT91_CAST(AT91_REG *) 	0xFFF7816C) // (UDPHS_EPT_3) UDPHS Endpoint Control Register
N#define AT91C_UDPHS_EPT_3_EPTCLRSTA (AT91_CAST(AT91_REG *) 	0xFFF78178) // (UDPHS_EPT_3) UDPHS Endpoint Clear Status Register
N#define AT91C_UDPHS_EPT_3_EPTCTLDIS (AT91_CAST(AT91_REG *) 	0xFFF78168) // (UDPHS_EPT_3) UDPHS Endpoint Control Disable Register
N#define AT91C_UDPHS_EPT_3_EPTSTA (AT91_CAST(AT91_REG *) 	0xFFF7817C) // (UDPHS_EPT_3) UDPHS Endpoint Status Register
N#define AT91C_UDPHS_EPT_3_EPTSETSTA (AT91_CAST(AT91_REG *) 	0xFFF78174) // (UDPHS_EPT_3) UDPHS Endpoint Set Status Register
N#define AT91C_UDPHS_EPT_3_EPTCTLENB (AT91_CAST(AT91_REG *) 	0xFFF78164) // (UDPHS_EPT_3) UDPHS Endpoint Control Enable Register
N#define AT91C_UDPHS_EPT_3_EPTCFG (AT91_CAST(AT91_REG *) 	0xFFF78160) // (UDPHS_EPT_3) UDPHS Endpoint Config Register
N// ========== Register definition for UDPHS_EPT_4 peripheral ========== 
N#define AT91C_UDPHS_EPT_4_EPTCLRSTA (AT91_CAST(AT91_REG *) 	0xFFF78198) // (UDPHS_EPT_4) UDPHS Endpoint Clear Status Register
N#define AT91C_UDPHS_EPT_4_EPTCTL (AT91_CAST(AT91_REG *) 	0xFFF7818C) // (UDPHS_EPT_4) UDPHS Endpoint Control Register
N#define AT91C_UDPHS_EPT_4_EPTCTLENB (AT91_CAST(AT91_REG *) 	0xFFF78184) // (UDPHS_EPT_4) UDPHS Endpoint Control Enable Register
N#define AT91C_UDPHS_EPT_4_EPTSTA (AT91_CAST(AT91_REG *) 	0xFFF7819C) // (UDPHS_EPT_4) UDPHS Endpoint Status Register
N#define AT91C_UDPHS_EPT_4_EPTSETSTA (AT91_CAST(AT91_REG *) 	0xFFF78194) // (UDPHS_EPT_4) UDPHS Endpoint Set Status Register
N#define AT91C_UDPHS_EPT_4_EPTCFG (AT91_CAST(AT91_REG *) 	0xFFF78180) // (UDPHS_EPT_4) UDPHS Endpoint Config Register
N#define AT91C_UDPHS_EPT_4_EPTCTLDIS (AT91_CAST(AT91_REG *) 	0xFFF78188) // (UDPHS_EPT_4) UDPHS Endpoint Control Disable Register
N// ========== Register definition for UDPHS_EPT_5 peripheral ========== 
N#define AT91C_UDPHS_EPT_5_EPTSTA (AT91_CAST(AT91_REG *) 	0xFFF781BC) // (UDPHS_EPT_5) UDPHS Endpoint Status Register
N#define AT91C_UDPHS_EPT_5_EPTCLRSTA (AT91_CAST(AT91_REG *) 	0xFFF781B8) // (UDPHS_EPT_5) UDPHS Endpoint Clear Status Register
N#define AT91C_UDPHS_EPT_5_EPTCTLENB (AT91_CAST(AT91_REG *) 	0xFFF781A4) // (UDPHS_EPT_5) UDPHS Endpoint Control Enable Register
N#define AT91C_UDPHS_EPT_5_EPTSETSTA (AT91_CAST(AT91_REG *) 	0xFFF781B4) // (UDPHS_EPT_5) UDPHS Endpoint Set Status Register
N#define AT91C_UDPHS_EPT_5_EPTCTLDIS (AT91_CAST(AT91_REG *) 	0xFFF781A8) // (UDPHS_EPT_5) UDPHS Endpoint Control Disable Register
N#define AT91C_UDPHS_EPT_5_EPTCFG (AT91_CAST(AT91_REG *) 	0xFFF781A0) // (UDPHS_EPT_5) UDPHS Endpoint Config Register
N#define AT91C_UDPHS_EPT_5_EPTCTL (AT91_CAST(AT91_REG *) 	0xFFF781AC) // (UDPHS_EPT_5) UDPHS Endpoint Control Register
N// ========== Register definition for UDPHS_EPT_6 peripheral ========== 
N#define AT91C_UDPHS_EPT_6_EPTCLRSTA (AT91_CAST(AT91_REG *) 	0xFFF781D8) // (UDPHS_EPT_6) UDPHS Endpoint Clear Status Register
N#define AT91C_UDPHS_EPT_6_EPTCTLENB (AT91_CAST(AT91_REG *) 	0xFFF781C4) // (UDPHS_EPT_6) UDPHS Endpoint Control Enable Register
N#define AT91C_UDPHS_EPT_6_EPTCTL (AT91_CAST(AT91_REG *) 	0xFFF781CC) // (UDPHS_EPT_6) UDPHS Endpoint Control Register
N#define AT91C_UDPHS_EPT_6_EPTSETSTA (AT91_CAST(AT91_REG *) 	0xFFF781D4) // (UDPHS_EPT_6) UDPHS Endpoint Set Status Register
N#define AT91C_UDPHS_EPT_6_EPTCTLDIS (AT91_CAST(AT91_REG *) 	0xFFF781C8) // (UDPHS_EPT_6) UDPHS Endpoint Control Disable Register
N#define AT91C_UDPHS_EPT_6_EPTSTA (AT91_CAST(AT91_REG *) 	0xFFF781DC) // (UDPHS_EPT_6) UDPHS Endpoint Status Register
N#define AT91C_UDPHS_EPT_6_EPTCFG (AT91_CAST(AT91_REG *) 	0xFFF781C0) // (UDPHS_EPT_6) UDPHS Endpoint Config Register
N// ========== Register definition for UDPHS_DMA_1 peripheral ========== 
N#define AT91C_UDPHS_DMA_1_DMASTATUS (AT91_CAST(AT91_REG *) 	0xFFF7831C) // (UDPHS_DMA_1) UDPHS DMA Channel Status Register
N#define AT91C_UDPHS_DMA_1_DMANXTDSC (AT91_CAST(AT91_REG *) 	0xFFF78310) // (UDPHS_DMA_1) UDPHS DMA Channel Next Descriptor Address
N#define AT91C_UDPHS_DMA_1_DMACONTROL (AT91_CAST(AT91_REG *) 	0xFFF78318) // (UDPHS_DMA_1) UDPHS DMA Channel Control Register
N#define AT91C_UDPHS_DMA_1_DMAADDRESS (AT91_CAST(AT91_REG *) 	0xFFF78314) // (UDPHS_DMA_1) UDPHS DMA Channel Address Register
N// ========== Register definition for UDPHS_DMA_2 peripheral ========== 
N#define AT91C_UDPHS_DMA_2_DMACONTROL (AT91_CAST(AT91_REG *) 	0xFFF78328) // (UDPHS_DMA_2) UDPHS DMA Channel Control Register
N#define AT91C_UDPHS_DMA_2_DMASTATUS (AT91_CAST(AT91_REG *) 	0xFFF7832C) // (UDPHS_DMA_2) UDPHS DMA Channel Status Register
N#define AT91C_UDPHS_DMA_2_DMAADDRESS (AT91_CAST(AT91_REG *) 	0xFFF78324) // (UDPHS_DMA_2) UDPHS DMA Channel Address Register
N#define AT91C_UDPHS_DMA_2_DMANXTDSC (AT91_CAST(AT91_REG *) 	0xFFF78320) // (UDPHS_DMA_2) UDPHS DMA Channel Next Descriptor Address
N// ========== Register definition for UDPHS_DMA_3 peripheral ========== 
N#define AT91C_UDPHS_DMA_3_DMAADDRESS (AT91_CAST(AT91_REG *) 	0xFFF78334) // (UDPHS_DMA_3) UDPHS DMA Channel Address Register
N#define AT91C_UDPHS_DMA_3_DMANXTDSC (AT91_CAST(AT91_REG *) 	0xFFF78330) // (UDPHS_DMA_3) UDPHS DMA Channel Next Descriptor Address
N#define AT91C_UDPHS_DMA_3_DMACONTROL (AT91_CAST(AT91_REG *) 	0xFFF78338) // (UDPHS_DMA_3) UDPHS DMA Channel Control Register
N#define AT91C_UDPHS_DMA_3_DMASTATUS (AT91_CAST(AT91_REG *) 	0xFFF7833C) // (UDPHS_DMA_3) UDPHS DMA Channel Status Register
N// ========== Register definition for UDPHS_DMA_4 peripheral ========== 
N#define AT91C_UDPHS_DMA_4_DMANXTDSC (AT91_CAST(AT91_REG *) 	0xFFF78340) // (UDPHS_DMA_4) UDPHS DMA Channel Next Descriptor Address
N#define AT91C_UDPHS_DMA_4_DMAADDRESS (AT91_CAST(AT91_REG *) 	0xFFF78344) // (UDPHS_DMA_4) UDPHS DMA Channel Address Register
N#define AT91C_UDPHS_DMA_4_DMACONTROL (AT91_CAST(AT91_REG *) 	0xFFF78348) // (UDPHS_DMA_4) UDPHS DMA Channel Control Register
N#define AT91C_UDPHS_DMA_4_DMASTATUS (AT91_CAST(AT91_REG *) 	0xFFF7834C) // (UDPHS_DMA_4) UDPHS DMA Channel Status Register
N// ========== Register definition for UDPHS_DMA_5 peripheral ========== 
N#define AT91C_UDPHS_DMA_5_DMASTATUS (AT91_CAST(AT91_REG *) 	0xFFF7835C) // (UDPHS_DMA_5) UDPHS DMA Channel Status Register
N#define AT91C_UDPHS_DMA_5_DMACONTROL (AT91_CAST(AT91_REG *) 	0xFFF78358) // (UDPHS_DMA_5) UDPHS DMA Channel Control Register
N#define AT91C_UDPHS_DMA_5_DMANXTDSC (AT91_CAST(AT91_REG *) 	0xFFF78350) // (UDPHS_DMA_5) UDPHS DMA Channel Next Descriptor Address
N#define AT91C_UDPHS_DMA_5_DMAADDRESS (AT91_CAST(AT91_REG *) 	0xFFF78354) // (UDPHS_DMA_5) UDPHS DMA Channel Address Register
N// ========== Register definition for UDPHS_DMA_6 peripheral ========== 
N#define AT91C_UDPHS_DMA_6_DMANXTDSC (AT91_CAST(AT91_REG *) 	0xFFF78360) // (UDPHS_DMA_6) UDPHS DMA Channel Next Descriptor Address
N#define AT91C_UDPHS_DMA_6_DMACONTROL (AT91_CAST(AT91_REG *) 	0xFFF78368) // (UDPHS_DMA_6) UDPHS DMA Channel Control Register
N#define AT91C_UDPHS_DMA_6_DMASTATUS (AT91_CAST(AT91_REG *) 	0xFFF7836C) // (UDPHS_DMA_6) UDPHS DMA Channel Status Register
N#define AT91C_UDPHS_DMA_6_DMAADDRESS (AT91_CAST(AT91_REG *) 	0xFFF78364) // (UDPHS_DMA_6) UDPHS DMA Channel Address Register
N// ========== Register definition for UDPHS peripheral ========== 
N#define AT91C_UDPHS_IEN (AT91_CAST(AT91_REG *) 	0xFFF78010) // (UDPHS) UDPHS Interrupt Enable Register
N#define AT91C_UDPHS_TSTSOFCNT (AT91_CAST(AT91_REG *) 	0xFFF780D0) // (UDPHS) UDPHS Test SOF Counter Register
N#define AT91C_UDPHS_IPFEATURES (AT91_CAST(AT91_REG *) 	0xFFF780F8) // (UDPHS) UDPHS Features Register
N#define AT91C_UDPHS_TST (AT91_CAST(AT91_REG *) 	0xFFF780E0) // (UDPHS) UDPHS Test Register
N#define AT91C_UDPHS_FNUM (AT91_CAST(AT91_REG *) 	0xFFF78004) // (UDPHS) UDPHS Frame Number Register
N#define AT91C_UDPHS_TSTCNTB (AT91_CAST(AT91_REG *) 	0xFFF780D8) // (UDPHS) UDPHS Test B Counter Register
N#define AT91C_UDPHS_RIPPADDRSIZE (AT91_CAST(AT91_REG *) 	0xFFF780EC) // (UDPHS) UDPHS PADDRSIZE Register
N#define AT91C_UDPHS_INTSTA (AT91_CAST(AT91_REG *) 	0xFFF78014) // (UDPHS) UDPHS Interrupt Status Register
N#define AT91C_UDPHS_EPTRST (AT91_CAST(AT91_REG *) 	0xFFF7801C) // (UDPHS) UDPHS Endpoints Reset Register
N#define AT91C_UDPHS_TSTCNTA (AT91_CAST(AT91_REG *) 	0xFFF780D4) // (UDPHS) UDPHS Test A Counter Register
N#define AT91C_UDPHS_RIPNAME2 (AT91_CAST(AT91_REG *) 	0xFFF780F4) // (UDPHS) UDPHS Name2 Register
N#define AT91C_UDPHS_RIPNAME1 (AT91_CAST(AT91_REG *) 	0xFFF780F0) // (UDPHS) UDPHS Name1 Register
N#define AT91C_UDPHS_TSTMODREG (AT91_CAST(AT91_REG *) 	0xFFF780DC) // (UDPHS) UDPHS Test Mode Register
N#define AT91C_UDPHS_CLRINT (AT91_CAST(AT91_REG *) 	0xFFF78018) // (UDPHS) UDPHS Clear Interrupt Register
N#define AT91C_UDPHS_IPVERSION (AT91_CAST(AT91_REG *) 	0xFFF780FC) // (UDPHS) UDPHS Version Register
N#define AT91C_UDPHS_CTRL (AT91_CAST(AT91_REG *) 	0xFFF78000) // (UDPHS) UDPHS Control Register
N// ========== Register definition for PDC_AC97C peripheral ========== 
N#define AT91C_AC97C_PTSR (AT91_CAST(AT91_REG *) 	0xFFFAC124) // (PDC_AC97C) PDC Transfer Status Register
N#define AT91C_AC97C_RPR (AT91_CAST(AT91_REG *) 	0xFFFAC100) // (PDC_AC97C) Receive Pointer Register
N#define AT91C_AC97C_RNCR (AT91_CAST(AT91_REG *) 	0xFFFAC114) // (PDC_AC97C) Receive Next Counter Register
N#define AT91C_AC97C_RCR (AT91_CAST(AT91_REG *) 	0xFFFAC104) // (PDC_AC97C) Receive Counter Register
N#define AT91C_AC97C_PTCR (AT91_CAST(AT91_REG *) 	0xFFFAC120) // (PDC_AC97C) PDC Transfer Control Register
N#define AT91C_AC97C_TPR (AT91_CAST(AT91_REG *) 	0xFFFAC108) // (PDC_AC97C) Transmit Pointer Register
N#define AT91C_AC97C_RNPR (AT91_CAST(AT91_REG *) 	0xFFFAC110) // (PDC_AC97C) Receive Next Pointer Register
N#define AT91C_AC97C_TNPR (AT91_CAST(AT91_REG *) 	0xFFFAC118) // (PDC_AC97C) Transmit Next Pointer Register
N#define AT91C_AC97C_TCR (AT91_CAST(AT91_REG *) 	0xFFFAC10C) // (PDC_AC97C) Transmit Counter Register
N#define AT91C_AC97C_TNCR (AT91_CAST(AT91_REG *) 	0xFFFAC11C) // (PDC_AC97C) Transmit Next Counter Register
N// ========== Register definition for AC97C peripheral ========== 
N#define AT91C_AC97C_IER (AT91_CAST(AT91_REG *) 	0xFFFAC054) // (AC97C) Interrupt Enable Register
N#define AT91C_AC97C_COTHR (AT91_CAST(AT91_REG *) 	0xFFFAC044) // (AC97C) COdec Transmit Holding Register
N#define AT91C_AC97C_IDR (AT91_CAST(AT91_REG *) 	0xFFFAC058) // (AC97C) Interrupt Disable Register
N#define AT91C_AC97C_ICA (AT91_CAST(AT91_REG *) 	0xFFFAC010) // (AC97C) Input Channel AssignementRegister
N#define AT91C_AC97C_CATHR (AT91_CAST(AT91_REG *) 	0xFFFAC024) // (AC97C) Channel A Transmit Holding Register
N#define AT91C_AC97C_CBSR (AT91_CAST(AT91_REG *) 	0xFFFAC038) // (AC97C) Channel B Status Register
N#define AT91C_AC97C_CAMR (AT91_CAST(AT91_REG *) 	0xFFFAC02C) // (AC97C) Channel A Mode Register
N#define AT91C_AC97C_SR  (AT91_CAST(AT91_REG *) 	0xFFFAC050) // (AC97C) Status Register
N#define AT91C_AC97C_CBTHR (AT91_CAST(AT91_REG *) 	0xFFFAC034) // (AC97C) Channel B Transmit Holding Register (optional)
N#define AT91C_AC97C_CASR (AT91_CAST(AT91_REG *) 	0xFFFAC028) // (AC97C) Channel A Status Register
N#define AT91C_AC97C_COSR (AT91_CAST(AT91_REG *) 	0xFFFAC048) // (AC97C) CODEC Status Register
N#define AT91C_AC97C_MR  (AT91_CAST(AT91_REG *) 	0xFFFAC008) // (AC97C) Mode Register
N#define AT91C_AC97C_OCA (AT91_CAST(AT91_REG *) 	0xFFFAC014) // (AC97C) Output Channel Assignement Register
N#define AT91C_AC97C_CORHR (AT91_CAST(AT91_REG *) 	0xFFFAC040) // (AC97C) COdec Transmit Holding Register
N#define AT91C_AC97C_CBRHR (AT91_CAST(AT91_REG *) 	0xFFFAC030) // (AC97C) Channel B Receive Holding Register (optional)
N#define AT91C_AC97C_IMR (AT91_CAST(AT91_REG *) 	0xFFFAC05C) // (AC97C) Interrupt Mask Register
N#define AT91C_AC97C_COMR (AT91_CAST(AT91_REG *) 	0xFFFAC04C) // (AC97C) CODEC Mask Status Register
N#define AT91C_AC97C_CARHR (AT91_CAST(AT91_REG *) 	0xFFFAC020) // (AC97C) Channel A Receive Holding Register
N#define AT91C_AC97C_VERSION (AT91_CAST(AT91_REG *) 	0xFFFAC0FC) // (AC97C) Version Register
N#define AT91C_AC97C_CBMR (AT91_CAST(AT91_REG *) 	0xFFFAC03C) // (AC97C) Channel B Mode Register
N// ========== Register definition for LCDC peripheral ========== 
N#define AT91C_LCDC_MVAL (AT91_CAST(AT91_REG *) 	0x00500818) // (LCDC) LCD Mode Toggle Rate Value Register
N#define AT91C_LCDC_PWRCON (AT91_CAST(AT91_REG *) 	0x0050083C) // (LCDC) Power Control Register
N#define AT91C_LCDC_ISR  (AT91_CAST(AT91_REG *) 	0x00500854) // (LCDC) Interrupt Enable Register
N#define AT91C_LCDC_FRMP1 (AT91_CAST(AT91_REG *) 	0x00500008) // (LCDC) DMA Frame Pointer Register 1
N#define AT91C_LCDC_CTRSTVAL (AT91_CAST(AT91_REG *) 	0x00500844) // (LCDC) Contrast Value Register
N#define AT91C_LCDC_ICR  (AT91_CAST(AT91_REG *) 	0x00500858) // (LCDC) Interrupt Clear Register
N#define AT91C_LCDC_TIM1 (AT91_CAST(AT91_REG *) 	0x00500808) // (LCDC) LCD Timing Config 1 Register
N#define AT91C_LCDC_DMACON (AT91_CAST(AT91_REG *) 	0x0050001C) // (LCDC) DMA Control Register
N#define AT91C_LCDC_ITR  (AT91_CAST(AT91_REG *) 	0x00500860) // (LCDC) Interrupts Test Register
N#define AT91C_LCDC_IDR  (AT91_CAST(AT91_REG *) 	0x0050084C) // (LCDC) Interrupt Disable Register
N#define AT91C_LCDC_DP4_7 (AT91_CAST(AT91_REG *) 	0x00500820) // (LCDC) Dithering Pattern DP4_7 Register
N#define AT91C_LCDC_DP5_7 (AT91_CAST(AT91_REG *) 	0x0050082C) // (LCDC) Dithering Pattern DP5_7 Register
N#define AT91C_LCDC_IRR  (AT91_CAST(AT91_REG *) 	0x00500864) // (LCDC) Interrupts Raw Status Register
N#define AT91C_LCDC_DP3_4 (AT91_CAST(AT91_REG *) 	0x00500830) // (LCDC) Dithering Pattern DP3_4 Register
N#define AT91C_LCDC_IMR  (AT91_CAST(AT91_REG *) 	0x00500850) // (LCDC) Interrupt Mask Register
N#define AT91C_LCDC_LCDFRCFG (AT91_CAST(AT91_REG *) 	0x00500810) // (LCDC) LCD Frame Config Register
N#define AT91C_LCDC_CTRSTCON (AT91_CAST(AT91_REG *) 	0x00500840) // (LCDC) Contrast Control Register
N#define AT91C_LCDC_DP1_2 (AT91_CAST(AT91_REG *) 	0x0050081C) // (LCDC) Dithering Pattern DP1_2 Register
N#define AT91C_LCDC_FRMP2 (AT91_CAST(AT91_REG *) 	0x0050000C) // (LCDC) DMA Frame Pointer Register 2
N#define AT91C_LCDC_LCDCON1 (AT91_CAST(AT91_REG *) 	0x00500800) // (LCDC) LCD Control 1 Register
N#define AT91C_LCDC_DP4_5 (AT91_CAST(AT91_REG *) 	0x00500834) // (LCDC) Dithering Pattern DP4_5 Register
N#define AT91C_LCDC_FRMA2 (AT91_CAST(AT91_REG *) 	0x00500014) // (LCDC) DMA Frame Address Register 2
N#define AT91C_LCDC_BA1  (AT91_CAST(AT91_REG *) 	0x00500000) // (LCDC) DMA Base Address Register 1
N#define AT91C_LCDC_DMA2DCFG (AT91_CAST(AT91_REG *) 	0x00500020) // (LCDC) DMA 2D addressing configuration
N#define AT91C_LCDC_LUT_ENTRY (AT91_CAST(AT91_REG *) 	0x00500C00) // (LCDC) LUT Entries Register
N#define AT91C_LCDC_DP6_7 (AT91_CAST(AT91_REG *) 	0x00500838) // (LCDC) Dithering Pattern DP6_7 Register
N#define AT91C_LCDC_FRMCFG (AT91_CAST(AT91_REG *) 	0x00500018) // (LCDC) DMA Frame Configuration Register
N#define AT91C_LCDC_TIM2 (AT91_CAST(AT91_REG *) 	0x0050080C) // (LCDC) LCD Timing Config 2 Register
N#define AT91C_LCDC_DP3_5 (AT91_CAST(AT91_REG *) 	0x00500824) // (LCDC) Dithering Pattern DP3_5 Register
N#define AT91C_LCDC_FRMA1 (AT91_CAST(AT91_REG *) 	0x00500010) // (LCDC) DMA Frame Address Register 1
N#define AT91C_LCDC_IER  (AT91_CAST(AT91_REG *) 	0x00500848) // (LCDC) Interrupt Enable Register
N#define AT91C_LCDC_DP2_3 (AT91_CAST(AT91_REG *) 	0x00500828) // (LCDC) Dithering Pattern DP2_3 Register
N#define AT91C_LCDC_FIFO (AT91_CAST(AT91_REG *) 	0x00500814) // (LCDC) LCD FIFO Register
N#define AT91C_LCDC_BA2  (AT91_CAST(AT91_REG *) 	0x00500004) // (LCDC) DMA Base Address Register 2
N#define AT91C_LCDC_LCDCON2 (AT91_CAST(AT91_REG *) 	0x00500804) // (LCDC) LCD Control 2 Register
N#define AT91C_LCDC_GPR  (AT91_CAST(AT91_REG *) 	0x0050085C) // (LCDC) General Purpose Register
N// ========== Register definition for LCDC_16B_TFT peripheral ========== 
N#define AT91C_TFT_MVAL  (AT91_CAST(AT91_REG *) 	0x00500818) // (LCDC_16B_TFT) LCD Mode Toggle Rate Value Register
N#define AT91C_TFT_PWRCON (AT91_CAST(AT91_REG *) 	0x0050083C) // (LCDC_16B_TFT) Power Control Register
N#define AT91C_TFT_ISR   (AT91_CAST(AT91_REG *) 	0x00500854) // (LCDC_16B_TFT) Interrupt Enable Register
N#define AT91C_TFT_FRMP1 (AT91_CAST(AT91_REG *) 	0x00500008) // (LCDC_16B_TFT) DMA Frame Pointer Register 1
N#define AT91C_TFT_CTRSTVAL (AT91_CAST(AT91_REG *) 	0x00500844) // (LCDC_16B_TFT) Contrast Value Register
N#define AT91C_TFT_ICR   (AT91_CAST(AT91_REG *) 	0x00500858) // (LCDC_16B_TFT) Interrupt Clear Register
N#define AT91C_TFT_TIM1  (AT91_CAST(AT91_REG *) 	0x00500808) // (LCDC_16B_TFT) LCD Timing Config 1 Register
N#define AT91C_TFT_DMACON (AT91_CAST(AT91_REG *) 	0x0050001C) // (LCDC_16B_TFT) DMA Control Register
N#define AT91C_TFT_ITR   (AT91_CAST(AT91_REG *) 	0x00500860) // (LCDC_16B_TFT) Interrupts Test Register
N#define AT91C_TFT_IDR   (AT91_CAST(AT91_REG *) 	0x0050084C) // (LCDC_16B_TFT) Interrupt Disable Register
N#define AT91C_TFT_DP4_7 (AT91_CAST(AT91_REG *) 	0x00500820) // (LCDC_16B_TFT) Dithering Pattern DP4_7 Register
N#define AT91C_TFT_DP5_7 (AT91_CAST(AT91_REG *) 	0x0050082C) // (LCDC_16B_TFT) Dithering Pattern DP5_7 Register
N#define AT91C_TFT_IRR   (AT91_CAST(AT91_REG *) 	0x00500864) // (LCDC_16B_TFT) Interrupts Raw Status Register
N#define AT91C_TFT_DP3_4 (AT91_CAST(AT91_REG *) 	0x00500830) // (LCDC_16B_TFT) Dithering Pattern DP3_4 Register
N#define AT91C_TFT_IMR   (AT91_CAST(AT91_REG *) 	0x00500850) // (LCDC_16B_TFT) Interrupt Mask Register
N#define AT91C_TFT_LCDFRCFG (AT91_CAST(AT91_REG *) 	0x00500810) // (LCDC_16B_TFT) LCD Frame Config Register
N#define AT91C_TFT_CTRSTCON (AT91_CAST(AT91_REG *) 	0x00500840) // (LCDC_16B_TFT) Contrast Control Register
N#define AT91C_TFT_DP1_2 (AT91_CAST(AT91_REG *) 	0x0050081C) // (LCDC_16B_TFT) Dithering Pattern DP1_2 Register
N#define AT91C_TFT_FRMP2 (AT91_CAST(AT91_REG *) 	0x0050000C) // (LCDC_16B_TFT) DMA Frame Pointer Register 2
N#define AT91C_TFT_LCDCON1 (AT91_CAST(AT91_REG *) 	0x00500800) // (LCDC_16B_TFT) LCD Control 1 Register
N#define AT91C_TFT_DP4_5 (AT91_CAST(AT91_REG *) 	0x00500834) // (LCDC_16B_TFT) Dithering Pattern DP4_5 Register
N#define AT91C_TFT_FRMA2 (AT91_CAST(AT91_REG *) 	0x00500014) // (LCDC_16B_TFT) DMA Frame Address Register 2
N#define AT91C_TFT_BA1   (AT91_CAST(AT91_REG *) 	0x00500000) // (LCDC_16B_TFT) DMA Base Address Register 1
N#define AT91C_TFT_DMA2DCFG (AT91_CAST(AT91_REG *) 	0x00500020) // (LCDC_16B_TFT) DMA 2D addressing configuration
N#define AT91C_TFT_LUT_ENTRY (AT91_CAST(AT91_REG *) 	0x00500C00) // (LCDC_16B_TFT) LUT Entries Register
N#define AT91C_TFT_DP6_7 (AT91_CAST(AT91_REG *) 	0x00500838) // (LCDC_16B_TFT) Dithering Pattern DP6_7 Register
N#define AT91C_TFT_FRMCFG (AT91_CAST(AT91_REG *) 	0x00500018) // (LCDC_16B_TFT) DMA Frame Configuration Register
N#define AT91C_TFT_TIM2  (AT91_CAST(AT91_REG *) 	0x0050080C) // (LCDC_16B_TFT) LCD Timing Config 2 Register
N#define AT91C_TFT_DP3_5 (AT91_CAST(AT91_REG *) 	0x00500824) // (LCDC_16B_TFT) Dithering Pattern DP3_5 Register
N#define AT91C_TFT_FRMA1 (AT91_CAST(AT91_REG *) 	0x00500010) // (LCDC_16B_TFT) DMA Frame Address Register 1
N#define AT91C_TFT_IER   (AT91_CAST(AT91_REG *) 	0x00500848) // (LCDC_16B_TFT) Interrupt Enable Register
N#define AT91C_TFT_DP2_3 (AT91_CAST(AT91_REG *) 	0x00500828) // (LCDC_16B_TFT) Dithering Pattern DP2_3 Register
N#define AT91C_TFT_FIFO  (AT91_CAST(AT91_REG *) 	0x00500814) // (LCDC_16B_TFT) LCD FIFO Register
N#define AT91C_TFT_BA2   (AT91_CAST(AT91_REG *) 	0x00500004) // (LCDC_16B_TFT) DMA Base Address Register 2
N#define AT91C_TFT_LCDCON2 (AT91_CAST(AT91_REG *) 	0x00500804) // (LCDC_16B_TFT) LCD Control 2 Register
N#define AT91C_TFT_GPR   (AT91_CAST(AT91_REG *) 	0x0050085C) // (LCDC_16B_TFT) General Purpose Register
N// ========== Register definition for HDMA_CH_0 peripheral ========== 
N#define AT91C_HDMA_CH_0_BDSCR (AT91_CAST(AT91_REG *) 	0xFFFFEC5C) // (HDMA_CH_0) HDMA Reserved
N#define AT91C_HDMA_CH_0_DADDR (AT91_CAST(AT91_REG *) 	0xFFFFEC40) // (HDMA_CH_0) HDMA Channel Destination Address Register
N#define AT91C_HDMA_CH_0_DPIP (AT91_CAST(AT91_REG *) 	0xFFFFEC58) // (HDMA_CH_0) HDMA Channel Destination Picture in Picture Configuration Register
N#define AT91C_HDMA_CH_0_DSCR (AT91_CAST(AT91_REG *) 	0xFFFFEC44) // (HDMA_CH_0) HDMA Channel Descriptor Address Register
N#define AT91C_HDMA_CH_0_CFG (AT91_CAST(AT91_REG *) 	0xFFFFEC50) // (HDMA_CH_0) HDMA Channel Configuration Register
N#define AT91C_HDMA_CH_0_SPIP (AT91_CAST(AT91_REG *) 	0xFFFFEC54) // (HDMA_CH_0) HDMA Channel Source Picture in Picture Configuration Register
N#define AT91C_HDMA_CH_0_CADDR (AT91_CAST(AT91_REG *) 	0xFFFFEC60) // (HDMA_CH_0) HDMA Reserved
N#define AT91C_HDMA_CH_0_CTRLA (AT91_CAST(AT91_REG *) 	0xFFFFEC48) // (HDMA_CH_0) HDMA Channel Control A Register
N#define AT91C_HDMA_CH_0_CTRLB (AT91_CAST(AT91_REG *) 	0xFFFFEC4C) // (HDMA_CH_0) HDMA Channel Control B Register
N#define AT91C_HDMA_CH_0_SADDR (AT91_CAST(AT91_REG *) 	0xFFFFEC3C) // (HDMA_CH_0) HDMA Channel Source Address Register
N// ========== Register definition for HDMA_CH_1 peripheral ========== 
N#define AT91C_HDMA_CH_1_CADDR (AT91_CAST(AT91_REG *) 	0xFFFFEC88) // (HDMA_CH_1) HDMA Reserved
N#define AT91C_HDMA_CH_1_DPIP (AT91_CAST(AT91_REG *) 	0xFFFFEC80) // (HDMA_CH_1) HDMA Channel Destination Picture in Picture Configuration Register
N#define AT91C_HDMA_CH_1_CTRLB (AT91_CAST(AT91_REG *) 	0xFFFFEC74) // (HDMA_CH_1) HDMA Channel Control B Register
N#define AT91C_HDMA_CH_1_SADDR (AT91_CAST(AT91_REG *) 	0xFFFFEC64) // (HDMA_CH_1) HDMA Channel Source Address Register
N#define AT91C_HDMA_CH_1_BDSCR (AT91_CAST(AT91_REG *) 	0xFFFFEC84) // (HDMA_CH_1) HDMA Reserved
N#define AT91C_HDMA_CH_1_CFG (AT91_CAST(AT91_REG *) 	0xFFFFEC78) // (HDMA_CH_1) HDMA Channel Configuration Register
N#define AT91C_HDMA_CH_1_DSCR (AT91_CAST(AT91_REG *) 	0xFFFFEC6C) // (HDMA_CH_1) HDMA Channel Descriptor Address Register
N#define AT91C_HDMA_CH_1_DADDR (AT91_CAST(AT91_REG *) 	0xFFFFEC68) // (HDMA_CH_1) HDMA Channel Destination Address Register
N#define AT91C_HDMA_CH_1_CTRLA (AT91_CAST(AT91_REG *) 	0xFFFFEC70) // (HDMA_CH_1) HDMA Channel Control A Register
N#define AT91C_HDMA_CH_1_SPIP (AT91_CAST(AT91_REG *) 	0xFFFFEC7C) // (HDMA_CH_1) HDMA Channel Source Picture in Picture Configuration Register
N// ========== Register definition for HDMA_CH_2 peripheral ========== 
N#define AT91C_HDMA_CH_2_SADDR (AT91_CAST(AT91_REG *) 	0xFFFFEC8C) // (HDMA_CH_2) HDMA Channel Source Address Register
N#define AT91C_HDMA_CH_2_BDSCR (AT91_CAST(AT91_REG *) 	0xFFFFECAC) // (HDMA_CH_2) HDMA Reserved
N#define AT91C_HDMA_CH_2_DPIP (AT91_CAST(AT91_REG *) 	0xFFFFECA8) // (HDMA_CH_2) HDMA Channel Destination Picture in Picture Configuration Register
N#define AT91C_HDMA_CH_2_SPIP (AT91_CAST(AT91_REG *) 	0xFFFFECA4) // (HDMA_CH_2) HDMA Channel Source Picture in Picture Configuration Register
N#define AT91C_HDMA_CH_2_DADDR (AT91_CAST(AT91_REG *) 	0xFFFFEC90) // (HDMA_CH_2) HDMA Channel Destination Address Register
N#define AT91C_HDMA_CH_2_DSCR (AT91_CAST(AT91_REG *) 	0xFFFFEC94) // (HDMA_CH_2) HDMA Channel Descriptor Address Register
N#define AT91C_HDMA_CH_2_CTRLA (AT91_CAST(AT91_REG *) 	0xFFFFEC98) // (HDMA_CH_2) HDMA Channel Control A Register
N#define AT91C_HDMA_CH_2_CADDR (AT91_CAST(AT91_REG *) 	0xFFFFECB0) // (HDMA_CH_2) HDMA Reserved
N#define AT91C_HDMA_CH_2_CFG (AT91_CAST(AT91_REG *) 	0xFFFFECA0) // (HDMA_CH_2) HDMA Channel Configuration Register
N#define AT91C_HDMA_CH_2_CTRLB (AT91_CAST(AT91_REG *) 	0xFFFFEC9C) // (HDMA_CH_2) HDMA Channel Control B Register
N// ========== Register definition for HDMA_CH_3 peripheral ========== 
N#define AT91C_HDMA_CH_3_SPIP (AT91_CAST(AT91_REG *) 	0xFFFFECCC) // (HDMA_CH_3) HDMA Channel Source Picture in Picture Configuration Register
N#define AT91C_HDMA_CH_3_CTRLA (AT91_CAST(AT91_REG *) 	0xFFFFECC0) // (HDMA_CH_3) HDMA Channel Control A Register
N#define AT91C_HDMA_CH_3_DPIP (AT91_CAST(AT91_REG *) 	0xFFFFECD0) // (HDMA_CH_3) HDMA Channel Destination Picture in Picture Configuration Register
N#define AT91C_HDMA_CH_3_CTRLB (AT91_CAST(AT91_REG *) 	0xFFFFECC4) // (HDMA_CH_3) HDMA Channel Control B Register
N#define AT91C_HDMA_CH_3_BDSCR (AT91_CAST(AT91_REG *) 	0xFFFFECD4) // (HDMA_CH_3) HDMA Reserved
N#define AT91C_HDMA_CH_3_DSCR (AT91_CAST(AT91_REG *) 	0xFFFFECBC) // (HDMA_CH_3) HDMA Channel Descriptor Address Register
N#define AT91C_HDMA_CH_3_CADDR (AT91_CAST(AT91_REG *) 	0xFFFFECD8) // (HDMA_CH_3) HDMA Reserved
N#define AT91C_HDMA_CH_3_CFG (AT91_CAST(AT91_REG *) 	0xFFFFECC8) // (HDMA_CH_3) HDMA Channel Configuration Register
N#define AT91C_HDMA_CH_3_DADDR (AT91_CAST(AT91_REG *) 	0xFFFFECB8) // (HDMA_CH_3) HDMA Channel Destination Address Register
N#define AT91C_HDMA_CH_3_SADDR (AT91_CAST(AT91_REG *) 	0xFFFFECB4) // (HDMA_CH_3) HDMA Channel Source Address Register
N// ========== Register definition for HDMA_CH_4 peripheral ========== 
N#define AT91C_HDMA_CH_4_CFG (AT91_CAST(AT91_REG *) 	0xFFFFECF0) // (HDMA_CH_4) HDMA Channel Configuration Register
N#define AT91C_HDMA_CH_4_BDSCR (AT91_CAST(AT91_REG *) 	0xFFFFECFC) // (HDMA_CH_4) HDMA Reserved
N#define AT91C_HDMA_CH_4_CADDR (AT91_CAST(AT91_REG *) 	0xFFFFED00) // (HDMA_CH_4) HDMA Reserved
N#define AT91C_HDMA_CH_4_DADDR (AT91_CAST(AT91_REG *) 	0xFFFFECE0) // (HDMA_CH_4) HDMA Channel Destination Address Register
N#define AT91C_HDMA_CH_4_CTRLA (AT91_CAST(AT91_REG *) 	0xFFFFECE8) // (HDMA_CH_4) HDMA Channel Control A Register
N#define AT91C_HDMA_CH_4_SADDR (AT91_CAST(AT91_REG *) 	0xFFFFECDC) // (HDMA_CH_4) HDMA Channel Source Address Register
N#define AT91C_HDMA_CH_4_CTRLB (AT91_CAST(AT91_REG *) 	0xFFFFECEC) // (HDMA_CH_4) HDMA Channel Control B Register
N#define AT91C_HDMA_CH_4_DSCR (AT91_CAST(AT91_REG *) 	0xFFFFECE4) // (HDMA_CH_4) HDMA Channel Descriptor Address Register
N#define AT91C_HDMA_CH_4_SPIP (AT91_CAST(AT91_REG *) 	0xFFFFECF4) // (HDMA_CH_4) HDMA Channel Source Picture in Picture Configuration Register
N#define AT91C_HDMA_CH_4_DPIP (AT91_CAST(AT91_REG *) 	0xFFFFECF8) // (HDMA_CH_4) HDMA Channel Destination Picture in Picture Configuration Register
N// ========== Register definition for HDMA_CH_5 peripheral ========== 
N#define AT91C_HDMA_CH_5_CTRLB (AT91_CAST(AT91_REG *) 	0xFFFFED14) // (HDMA_CH_5) HDMA Channel Control B Register
N#define AT91C_HDMA_CH_5_DADDR (AT91_CAST(AT91_REG *) 	0xFFFFED08) // (HDMA_CH_5) HDMA Channel Destination Address Register
N#define AT91C_HDMA_CH_5_SPIP (AT91_CAST(AT91_REG *) 	0xFFFFED1C) // (HDMA_CH_5) HDMA Channel Source Picture in Picture Configuration Register
N#define AT91C_HDMA_CH_5_DSCR (AT91_CAST(AT91_REG *) 	0xFFFFED0C) // (HDMA_CH_5) HDMA Channel Descriptor Address Register
N#define AT91C_HDMA_CH_5_DPIP (AT91_CAST(AT91_REG *) 	0xFFFFED20) // (HDMA_CH_5) HDMA Channel Destination Picture in Picture Configuration Register
N#define AT91C_HDMA_CH_5_CFG (AT91_CAST(AT91_REG *) 	0xFFFFED18) // (HDMA_CH_5) HDMA Channel Configuration Register
N#define AT91C_HDMA_CH_5_CADDR (AT91_CAST(AT91_REG *) 	0xFFFFED28) // (HDMA_CH_5) HDMA Reserved
N#define AT91C_HDMA_CH_5_SADDR (AT91_CAST(AT91_REG *) 	0xFFFFED04) // (HDMA_CH_5) HDMA Channel Source Address Register
N#define AT91C_HDMA_CH_5_BDSCR (AT91_CAST(AT91_REG *) 	0xFFFFED24) // (HDMA_CH_5) HDMA Reserved
N#define AT91C_HDMA_CH_5_CTRLA (AT91_CAST(AT91_REG *) 	0xFFFFED10) // (HDMA_CH_5) HDMA Channel Control A Register
N// ========== Register definition for HDMA_CH_6 peripheral ========== 
N#define AT91C_HDMA_CH_6_SADDR (AT91_CAST(AT91_REG *) 	0xFFFFED2C) // (HDMA_CH_6) HDMA Channel Source Address Register
N#define AT91C_HDMA_CH_6_BDSCR (AT91_CAST(AT91_REG *) 	0xFFFFED4C) // (HDMA_CH_6) HDMA Reserved
N#define AT91C_HDMA_CH_6_CADDR (AT91_CAST(AT91_REG *) 	0xFFFFED50) // (HDMA_CH_6) HDMA Reserved
N#define AT91C_HDMA_CH_6_SPIP (AT91_CAST(AT91_REG *) 	0xFFFFED44) // (HDMA_CH_6) HDMA Channel Source Picture in Picture Configuration Register
N#define AT91C_HDMA_CH_6_CTRLB (AT91_CAST(AT91_REG *) 	0xFFFFED3C) // (HDMA_CH_6) HDMA Channel Control B Register
N#define AT91C_HDMA_CH_6_DSCR (AT91_CAST(AT91_REG *) 	0xFFFFED34) // (HDMA_CH_6) HDMA Channel Descriptor Address Register
N#define AT91C_HDMA_CH_6_CFG (AT91_CAST(AT91_REG *) 	0xFFFFED40) // (HDMA_CH_6) HDMA Channel Configuration Register
N#define AT91C_HDMA_CH_6_DPIP (AT91_CAST(AT91_REG *) 	0xFFFFED48) // (HDMA_CH_6) HDMA Channel Destination Picture in Picture Configuration Register
N#define AT91C_HDMA_CH_6_DADDR (AT91_CAST(AT91_REG *) 	0xFFFFED30) // (HDMA_CH_6) HDMA Channel Destination Address Register
N#define AT91C_HDMA_CH_6_CTRLA (AT91_CAST(AT91_REG *) 	0xFFFFED38) // (HDMA_CH_6) HDMA Channel Control A Register
N// ========== Register definition for HDMA_CH_7 peripheral ========== 
N#define AT91C_HDMA_CH_7_CADDR (AT91_CAST(AT91_REG *) 	0xFFFFED78) // (HDMA_CH_7) HDMA Reserved
N#define AT91C_HDMA_CH_7_CFG (AT91_CAST(AT91_REG *) 	0xFFFFED68) // (HDMA_CH_7) HDMA Channel Configuration Register
N#define AT91C_HDMA_CH_7_DADDR (AT91_CAST(AT91_REG *) 	0xFFFFED58) // (HDMA_CH_7) HDMA Channel Destination Address Register
N#define AT91C_HDMA_CH_7_CTRLB (AT91_CAST(AT91_REG *) 	0xFFFFED64) // (HDMA_CH_7) HDMA Channel Control B Register
N#define AT91C_HDMA_CH_7_DSCR (AT91_CAST(AT91_REG *) 	0xFFFFED5C) // (HDMA_CH_7) HDMA Channel Descriptor Address Register
N#define AT91C_HDMA_CH_7_DPIP (AT91_CAST(AT91_REG *) 	0xFFFFED70) // (HDMA_CH_7) HDMA Channel Destination Picture in Picture Configuration Register
N#define AT91C_HDMA_CH_7_CTRLA (AT91_CAST(AT91_REG *) 	0xFFFFED60) // (HDMA_CH_7) HDMA Channel Control A Register
N#define AT91C_HDMA_CH_7_BDSCR (AT91_CAST(AT91_REG *) 	0xFFFFED74) // (HDMA_CH_7) HDMA Reserved
N#define AT91C_HDMA_CH_7_SPIP (AT91_CAST(AT91_REG *) 	0xFFFFED6C) // (HDMA_CH_7) HDMA Channel Source Picture in Picture Configuration Register
N#define AT91C_HDMA_CH_7_SADDR (AT91_CAST(AT91_REG *) 	0xFFFFED54) // (HDMA_CH_7) HDMA Channel Source Address Register
N// ========== Register definition for HDMA peripheral ========== 
N#define AT91C_HDMA_EBCIDR (AT91_CAST(AT91_REG *) 	0xFFFFEC1C) // (HDMA) HDMA Error, Chained Buffer transfer completed and Buffer transfer completed Interrupt Disable register
N#define AT91C_HDMA_LAST (AT91_CAST(AT91_REG *) 	0xFFFFEC10) // (HDMA) HDMA Software Last Transfer Flag Register
N#define AT91C_HDMA_SREQ (AT91_CAST(AT91_REG *) 	0xFFFFEC08) // (HDMA) HDMA Software Single Request Register
N#define AT91C_HDMA_RSVD0 (AT91_CAST(AT91_REG *) 	0xFFFFEC34) // (HDMA) HDMA Reserved
N#define AT91C_HDMA_EBCIER (AT91_CAST(AT91_REG *) 	0xFFFFEC18) // (HDMA) HDMA Error, Chained Buffer transfer completed and Buffer transfer completed Interrupt Enable register
N#define AT91C_HDMA_GCFG (AT91_CAST(AT91_REG *) 	0xFFFFEC00) // (HDMA) HDMA Global Configuration Register
N#define AT91C_HDMA_CHER (AT91_CAST(AT91_REG *) 	0xFFFFEC28) // (HDMA) HDMA Channel Handler Enable Register
N#define AT91C_HDMA_RSVD1 (AT91_CAST(AT91_REG *) 	0xFFFFEC38) // (HDMA) HDMA Reserved
N#define AT91C_HDMA_CHDR (AT91_CAST(AT91_REG *) 	0xFFFFEC2C) // (HDMA) HDMA Channel Handler Disable Register
N#define AT91C_HDMA_EBCIMR (AT91_CAST(AT91_REG *) 	0xFFFFEC20) // (HDMA) HDMA Error, Chained Buffer transfer completed and Buffer transfer completed Mask Register
N#define AT91C_HDMA_CREQ (AT91_CAST(AT91_REG *) 	0xFFFFEC0C) // (HDMA) HDMA Software Chunk Transfer Request Register
N#define AT91C_HDMA_SYNC (AT91_CAST(AT91_REG *) 	0xFFFFEC14) // (HDMA) HDMA Request Synchronization Register
N#define AT91C_HDMA_EN   (AT91_CAST(AT91_REG *) 	0xFFFFEC04) // (HDMA) HDMA Controller Enable Register
N#define AT91C_HDMA_EBCISR (AT91_CAST(AT91_REG *) 	0xFFFFEC24) // (HDMA) HDMA Error, Chained Buffer transfer completed and Buffer transfer completed Status Register
N#define AT91C_HDMA_CHSR (AT91_CAST(AT91_REG *) 	0xFFFFEC30) // (HDMA) HDMA Channel Handler Status Register
N// ========== Register definition for HECC peripheral ========== 
N#define AT91C_HECC_VR   (AT91_CAST(AT91_REG *) 	0xFFFFE2FC) // (HECC)  ECC Version register
N#define AT91C_HECC_SR   (AT91_CAST(AT91_REG *) 	0xFFFFE208) // (HECC)  ECC Status register
N#define AT91C_HECC_CR   (AT91_CAST(AT91_REG *) 	0xFFFFE200) // (HECC)  ECC reset register
N#define AT91C_HECC_NPR  (AT91_CAST(AT91_REG *) 	0xFFFFE210) // (HECC)  ECC Parity N register
N#define AT91C_HECC_PR   (AT91_CAST(AT91_REG *) 	0xFFFFE20C) // (HECC)  ECC Parity register
N#define AT91C_HECC_MR   (AT91_CAST(AT91_REG *) 	0xFFFFE204) // (HECC)  ECC Page size register
N// ========== Register definition for EMACB peripheral ========== 
N#define AT91C_EMACB_ALE (AT91_CAST(AT91_REG *) 	0xFFFBC054) // (EMACB) Alignment Error Register
N#define AT91C_EMACB_RRE (AT91_CAST(AT91_REG *) 	0xFFFBC06C) // (EMACB) Receive Ressource Error Register
N#define AT91C_EMACB_SA4H (AT91_CAST(AT91_REG *) 	0xFFFBC0B4) // (EMACB) Specific Address 4 Top, Last 2 bytes
N#define AT91C_EMACB_TPQ (AT91_CAST(AT91_REG *) 	0xFFFBC0BC) // (EMACB) Transmit Pause Quantum Register
N#define AT91C_EMACB_RJA (AT91_CAST(AT91_REG *) 	0xFFFBC07C) // (EMACB) Receive Jabbers Register
N#define AT91C_EMACB_SA2H (AT91_CAST(AT91_REG *) 	0xFFFBC0A4) // (EMACB) Specific Address 2 Top, Last 2 bytes
N#define AT91C_EMACB_TPF (AT91_CAST(AT91_REG *) 	0xFFFBC08C) // (EMACB) Transmitted Pause Frames Register
N#define AT91C_EMACB_ROV (AT91_CAST(AT91_REG *) 	0xFFFBC070) // (EMACB) Receive Overrun Errors Register
N#define AT91C_EMACB_SA4L (AT91_CAST(AT91_REG *) 	0xFFFBC0B0) // (EMACB) Specific Address 4 Bottom, First 4 bytes
N#define AT91C_EMACB_MAN (AT91_CAST(AT91_REG *) 	0xFFFBC034) // (EMACB) PHY Maintenance Register
N#define AT91C_EMACB_TID (AT91_CAST(AT91_REG *) 	0xFFFBC0B8) // (EMACB) Type ID Checking Register
N#define AT91C_EMACB_TBQP (AT91_CAST(AT91_REG *) 	0xFFFBC01C) // (EMACB) Transmit Buffer Queue Pointer
N#define AT91C_EMACB_SA3L (AT91_CAST(AT91_REG *) 	0xFFFBC0A8) // (EMACB) Specific Address 3 Bottom, First 4 bytes
N#define AT91C_EMACB_DTF (AT91_CAST(AT91_REG *) 	0xFFFBC058) // (EMACB) Deferred Transmission Frame Register
N#define AT91C_EMACB_PTR (AT91_CAST(AT91_REG *) 	0xFFFBC038) // (EMACB) Pause Time Register
N#define AT91C_EMACB_CSE (AT91_CAST(AT91_REG *) 	0xFFFBC068) // (EMACB) Carrier Sense Error Register
N#define AT91C_EMACB_ECOL (AT91_CAST(AT91_REG *) 	0xFFFBC060) // (EMACB) Excessive Collision Register
N#define AT91C_EMACB_STE (AT91_CAST(AT91_REG *) 	0xFFFBC084) // (EMACB) SQE Test Error Register
N#define AT91C_EMACB_MCF (AT91_CAST(AT91_REG *) 	0xFFFBC048) // (EMACB) Multiple Collision Frame Register
N#define AT91C_EMACB_IER (AT91_CAST(AT91_REG *) 	0xFFFBC028) // (EMACB) Interrupt Enable Register
N#define AT91C_EMACB_ELE (AT91_CAST(AT91_REG *) 	0xFFFBC078) // (EMACB) Excessive Length Errors Register
N#define AT91C_EMACB_USRIO (AT91_CAST(AT91_REG *) 	0xFFFBC0C0) // (EMACB) USER Input/Output Register
N#define AT91C_EMACB_PFR (AT91_CAST(AT91_REG *) 	0xFFFBC03C) // (EMACB) Pause Frames received Register
N#define AT91C_EMACB_FCSE (AT91_CAST(AT91_REG *) 	0xFFFBC050) // (EMACB) Frame Check Sequence Error Register
N#define AT91C_EMACB_SA1L (AT91_CAST(AT91_REG *) 	0xFFFBC098) // (EMACB) Specific Address 1 Bottom, First 4 bytes
N#define AT91C_EMACB_NCR (AT91_CAST(AT91_REG *) 	0xFFFBC000) // (EMACB) Network Control Register
N#define AT91C_EMACB_HRT (AT91_CAST(AT91_REG *) 	0xFFFBC094) // (EMACB) Hash Address Top[63:32]
N#define AT91C_EMACB_NCFGR (AT91_CAST(AT91_REG *) 	0xFFFBC004) // (EMACB) Network Configuration Register
N#define AT91C_EMACB_SCF (AT91_CAST(AT91_REG *) 	0xFFFBC044) // (EMACB) Single Collision Frame Register
N#define AT91C_EMACB_LCOL (AT91_CAST(AT91_REG *) 	0xFFFBC05C) // (EMACB) Late Collision Register
N#define AT91C_EMACB_SA3H (AT91_CAST(AT91_REG *) 	0xFFFBC0AC) // (EMACB) Specific Address 3 Top, Last 2 bytes
N#define AT91C_EMACB_HRB (AT91_CAST(AT91_REG *) 	0xFFFBC090) // (EMACB) Hash Address Bottom[31:0]
N#define AT91C_EMACB_ISR (AT91_CAST(AT91_REG *) 	0xFFFBC024) // (EMACB) Interrupt Status Register
N#define AT91C_EMACB_IMR (AT91_CAST(AT91_REG *) 	0xFFFBC030) // (EMACB) Interrupt Mask Register
N#define AT91C_EMACB_WOL (AT91_CAST(AT91_REG *) 	0xFFFBC0C4) // (EMACB) Wake On LAN Register
N#define AT91C_EMACB_USF (AT91_CAST(AT91_REG *) 	0xFFFBC080) // (EMACB) Undersize Frames Register
N#define AT91C_EMACB_TSR (AT91_CAST(AT91_REG *) 	0xFFFBC014) // (EMACB) Transmit Status Register
N#define AT91C_EMACB_FRO (AT91_CAST(AT91_REG *) 	0xFFFBC04C) // (EMACB) Frames Received OK Register
N#define AT91C_EMACB_IDR (AT91_CAST(AT91_REG *) 	0xFFFBC02C) // (EMACB) Interrupt Disable Register
N#define AT91C_EMACB_SA1H (AT91_CAST(AT91_REG *) 	0xFFFBC09C) // (EMACB) Specific Address 1 Top, Last 2 bytes
N#define AT91C_EMACB_RLE (AT91_CAST(AT91_REG *) 	0xFFFBC088) // (EMACB) Receive Length Field Mismatch Register
N#define AT91C_EMACB_TUND (AT91_CAST(AT91_REG *) 	0xFFFBC064) // (EMACB) Transmit Underrun Error Register
N#define AT91C_EMACB_RSR (AT91_CAST(AT91_REG *) 	0xFFFBC020) // (EMACB) Receive Status Register
N#define AT91C_EMACB_SA2L (AT91_CAST(AT91_REG *) 	0xFFFBC0A0) // (EMACB) Specific Address 2 Bottom, First 4 bytes
N#define AT91C_EMACB_FTO (AT91_CAST(AT91_REG *) 	0xFFFBC040) // (EMACB) Frames Transmitted OK Register
N#define AT91C_EMACB_RSE (AT91_CAST(AT91_REG *) 	0xFFFBC074) // (EMACB) Receive Symbol Errors Register
N#define AT91C_EMACB_NSR (AT91_CAST(AT91_REG *) 	0xFFFBC008) // (EMACB) Network Status Register
N#define AT91C_EMACB_RBQP (AT91_CAST(AT91_REG *) 	0xFFFBC018) // (EMACB) Receive Buffer Queue Pointer
N#define AT91C_EMACB_REV (AT91_CAST(AT91_REG *) 	0xFFFBC0FC) // (EMACB) Revision Register
N// ========== Register definition for ISI peripheral ========== 
N#define AT91C_ISI_DMACHDR (AT91_CAST(AT91_REG *) 	0xFFFB403C) // (ISI) DMA Channel Disable Register
N#define AT91C_ISI_IMR   (AT91_CAST(AT91_REG *) 	0xFFFB4034) // (ISI) Interrupt Mask Register
N#define AT91C_ISI_R2YSET1 (AT91_CAST(AT91_REG *) 	0xFFFB401C) // (ISI) Color Space Conversion RGB to YCrCb Register
N#define AT91C_ISI_PDECF (AT91_CAST(AT91_REG *) 	0xFFFB400C) // (ISI) Preview Decimation Factor Register
N#define AT91C_ISI_CFG2  (AT91_CAST(AT91_REG *) 	0xFFFB4004) // (ISI) Configuration Register 2
N#define AT91C_ISI_DMACCTRL (AT91_CAST(AT91_REG *) 	0xFFFB4054) // (ISI) DMA Codec Control Register
N#define AT91C_ISI_CTRL  (AT91_CAST(AT91_REG *) 	0xFFFB4024) // (ISI) Control Register
N#define AT91C_ISI_Y2RSET0 (AT91_CAST(AT91_REG *) 	0xFFFB4010) // (ISI) Color Space Conversion YCrCb to RGB Register
N#define AT91C_ISI_WPSR  (AT91_CAST(AT91_REG *) 	0xFFFB40E8) // (ISI) Write Protection Status Register
N#define AT91C_ISI_DMACHER (AT91_CAST(AT91_REG *) 	0xFFFB4038) // (ISI) DMA Channel Enable Register
N#define AT91C_ISI_DMACHSR (AT91_CAST(AT91_REG *) 	0xFFFB4040) // (ISI) DMA Channel Status Register
N#define AT91C_ISI_IDR   (AT91_CAST(AT91_REG *) 	0xFFFB4030) // (ISI) Interrupt Disable Register
N#define AT91C_ISI_VER   (AT91_CAST(AT91_REG *) 	0xFFFB40FC) // (ISI) Version Register
N#define AT91C_ISI_Y2RSET1 (AT91_CAST(AT91_REG *) 	0xFFFB4014) // (ISI) Color Space Conversion YCrCb to RGB Register
N#define AT91C_ISI_R2YSET2 (AT91_CAST(AT91_REG *) 	0xFFFB4020) // (ISI) Color Space Conversion RGB to YCrCb Register
N#define AT91C_ISI_SR    (AT91_CAST(AT91_REG *) 	0xFFFB4028) // (ISI) Status Register
N#define AT91C_ISI_DMACDSCR (AT91_CAST(AT91_REG *) 	0xFFFB4058) // (ISI) DMA Codec Descriptor Address Register
N#define AT91C_ISI_IER   (AT91_CAST(AT91_REG *) 	0xFFFB402C) // (ISI) Interrupt Enable Register
N#define AT91C_ISI_WPCR  (AT91_CAST(AT91_REG *) 	0xFFFB40E4) // (ISI) Write Protection Control Register
N#define AT91C_ISI_DMACADDR (AT91_CAST(AT91_REG *) 	0xFFFB4050) // (ISI) DMA Codec Base Address Register
N#define AT91C_ISI_CFG1  (AT91_CAST(AT91_REG *) 	0xFFFB4000) // (ISI) Configuration Register 1
N#define AT91C_ISI_R2YSET0 (AT91_CAST(AT91_REG *) 	0xFFFB4018) // (ISI) Color Space Conversion RGB to YCrCb Register
N#define AT91C_ISI_PSIZE (AT91_CAST(AT91_REG *) 	0xFFFB4008) // (ISI) Preview Size Register
N#define AT91C_ISI_DMAPDSCR (AT91_CAST(AT91_REG *) 	0xFFFB404C) // (ISI) DMA Preview Descriptor Address Register
N#define AT91C_ISI_DMAPADDR (AT91_CAST(AT91_REG *) 	0xFFFB4044) // (ISI) DMA Preview Base Address Register
N#define AT91C_ISI_DMAPCTRL (AT91_CAST(AT91_REG *) 	0xFFFB4048) // (ISI) DMA Preview Control Register
N// ========== Register definition for VDEC peripheral ========== 
N#define AT91C_VDEC_DCR  (AT91_CAST(AT91_REG *) 	0x00900008) // (VDEC) Device Configuration Register
N#define AT91C_VDEC_IDR  (AT91_CAST(AT91_REG *) 	0x00900000) // (VDEC) ID Register
N#define AT91C_VDEC_ISR  (AT91_CAST(AT91_REG *) 	0x00900004) // (VDEC) Interrupt Status Register
N// ========== Register definition for UHPHS_OHCI peripheral ========== 
N#define AT91C_OHCI_HcRhPortStatus (AT91_CAST(AT91_REG *) 	0x00700054) // (UHPHS_OHCI) Root Hub Port Status Register
N#define AT91C_OHCI_HcFmRemaining (AT91_CAST(AT91_REG *) 	0x00700038) // (UHPHS_OHCI) Bit time remaining in the current Frame
N#define AT91C_OHCI_HcInterruptEnable (AT91_CAST(AT91_REG *) 	0x00700010) // (UHPHS_OHCI) Interrupt Enable Register
N#define AT91C_OHCI_HcControl (AT91_CAST(AT91_REG *) 	0x00700004) // (UHPHS_OHCI) Operating modes for the Host Controller
N#define AT91C_OHCI_HcPeriodicStart (AT91_CAST(AT91_REG *) 	0x00700040) // (UHPHS_OHCI) Periodic Start
N#define AT91C_OHCI_HcInterruptStatus (AT91_CAST(AT91_REG *) 	0x0070000C) // (UHPHS_OHCI) Interrupt Status Register
N#define AT91C_OHCI_HcRhDescriptorB (AT91_CAST(AT91_REG *) 	0x0070004C) // (UHPHS_OHCI) Root Hub characteristics B
N#define AT91C_OHCI_HcInterruptDisable (AT91_CAST(AT91_REG *) 	0x00700014) // (UHPHS_OHCI) Interrupt Disable Register
N#define AT91C_OHCI_HcPeriodCurrentED (AT91_CAST(AT91_REG *) 	0x0070001C) // (UHPHS_OHCI) Current Isochronous or Interrupt Endpoint Descriptor
N#define AT91C_OHCI_HcRhDescriptorA (AT91_CAST(AT91_REG *) 	0x00700048) // (UHPHS_OHCI) Root Hub characteristics A
N#define AT91C_OHCI_HcRhStatus (AT91_CAST(AT91_REG *) 	0x00700050) // (UHPHS_OHCI) Root Hub Status register
N#define AT91C_OHCI_HcBulkCurrentED (AT91_CAST(AT91_REG *) 	0x0070002C) // (UHPHS_OHCI) Current endpoint of the Bulk list
N#define AT91C_OHCI_HcControlHeadED (AT91_CAST(AT91_REG *) 	0x00700020) // (UHPHS_OHCI) First Endpoint Descriptor of the Control list
N#define AT91C_OHCI_HcLSThreshold (AT91_CAST(AT91_REG *) 	0x00700044) // (UHPHS_OHCI) LS Threshold
N#define AT91C_OHCI_HcRevision (AT91_CAST(AT91_REG *) 	0x00700000) // (UHPHS_OHCI) Revision
N#define AT91C_OHCI_HcBulkDoneHead (AT91_CAST(AT91_REG *) 	0x00700030) // (UHPHS_OHCI) Last completed transfer descriptor
N#define AT91C_OHCI_HcFmNumber (AT91_CAST(AT91_REG *) 	0x0070003C) // (UHPHS_OHCI) Frame number
N#define AT91C_OHCI_HcFmInterval (AT91_CAST(AT91_REG *) 	0x00700034) // (UHPHS_OHCI) Bit time between 2 consecutive SOFs
N#define AT91C_OHCI_HcBulkHeadED (AT91_CAST(AT91_REG *) 	0x00700028) // (UHPHS_OHCI) First endpoint register of the Bulk list
N#define AT91C_OHCI_HcHCCA (AT91_CAST(AT91_REG *) 	0x00700018) // (UHPHS_OHCI) Pointer to the Host Controller Communication Area
N#define AT91C_OHCI_HcCommandStatus (AT91_CAST(AT91_REG *) 	0x00700008) // (UHPHS_OHCI) Command & status Register
N#define AT91C_OHCI_HcControlCurrentED (AT91_CAST(AT91_REG *) 	0x00700024) // (UHPHS_OHCI) Endpoint Control and Status Register
N// ========== Register definition for UHPHS_EHCI peripheral ========== 
N#define AT91C_EHCI_USBSTS (AT91_CAST(AT91_REG *) 	0x00800014) // (UHPHS_EHCI) 
N#define AT91C_EHCI_INSNREG03 (AT91_CAST(AT91_REG *) 	0x0080009C) // (UHPHS_EHCI) 
N#define AT91C_EHCI_INSNREG00 (AT91_CAST(AT91_REG *) 	0x00800090) // (UHPHS_EHCI) 
N#define AT91C_EHCI_HCSPPORTROUTE (AT91_CAST(AT91_REG *) 	0x0080000C) // (UHPHS_EHCI) 
N#define AT91C_EHCI_FRINDEX (AT91_CAST(AT91_REG *) 	0x0080001C) // (UHPHS_EHCI) 
N#define AT91C_EHCI_CONFIGFLAG (AT91_CAST(AT91_REG *) 	0x00800050) // (UHPHS_EHCI) 
N#define AT91C_EHCI_HCCPARAMS (AT91_CAST(AT91_REG *) 	0x00800008) // (UHPHS_EHCI) 
N#define AT91C_EHCI_USBINTR (AT91_CAST(AT91_REG *) 	0x00800018) // (UHPHS_EHCI) 
N#define AT91C_EHCI_PORTSC (AT91_CAST(AT91_REG *) 	0x00800054) // (UHPHS_EHCI) 
N#define AT91C_EHCI_CTRLDSSEGMENT (AT91_CAST(AT91_REG *) 	0x00800020) // (UHPHS_EHCI) 
N#define AT91C_EHCI_VERSION (AT91_CAST(AT91_REG *) 	0x00800000) // (UHPHS_EHCI) 
N#define AT91C_EHCI_USBCMD (AT91_CAST(AT91_REG *) 	0x00800010) // (UHPHS_EHCI) 
N#define AT91C_EHCI_INSNREG04 (AT91_CAST(AT91_REG *) 	0x008000A0) // (UHPHS_EHCI) 
N#define AT91C_EHCI_PERIODICLISTBASE (AT91_CAST(AT91_REG *) 	0x00800024) // (UHPHS_EHCI) 
N#define AT91C_EHCI_INSNREG01 (AT91_CAST(AT91_REG *) 	0x00800094) // (UHPHS_EHCI) 
N#define AT91C_EHCI_HCSPARAMS (AT91_CAST(AT91_REG *) 	0x00800004) // (UHPHS_EHCI) 
N#define AT91C_EHCI_INSNREG05 (AT91_CAST(AT91_REG *) 	0x008000A4) // (UHPHS_EHCI) 
N#define AT91C_EHCI_ASYNCLISTADDR (AT91_CAST(AT91_REG *) 	0x00800028) // (UHPHS_EHCI) 
N#define AT91C_EHCI_INSNREG02 (AT91_CAST(AT91_REG *) 	0x00800098) // (UHPHS_EHCI) 
N// ========== Register definition for TRNG peripheral ========== 
N#define AT91C_TRNG_IDR  (AT91_CAST(AT91_REG *) 	0xFFFCC014) // (TRNG) Interrupt Disable Register
N#define AT91C_TRNG_IER  (AT91_CAST(AT91_REG *) 	0xFFFCC010) // (TRNG) Interrupt Enable Register
N#define AT91C_TRNG_VERSION (AT91_CAST(AT91_REG *) 	0xFFFCC0FC) // (TRNG) TRNG Version Register
N#define AT91C_TRNG_ISR  (AT91_CAST(AT91_REG *) 	0xFFFCC01C) // (TRNG) Interrupt Status Register
N#define AT91C_TRNG_CR   (AT91_CAST(AT91_REG *) 	0xFFFCC000) // (TRNG) Control Register
N#define AT91C_TRNG_ODATA (AT91_CAST(AT91_REG *) 	0xFFFCC050) // (TRNG) Output Data Register
N#define AT91C_TRNG_IMR  (AT91_CAST(AT91_REG *) 	0xFFFCC018) // (TRNG) Interrupt Mask Register
N
N// *****************************************************************************
N//               PIO DEFINITIONS FOR AT91SAM9M10
N// *****************************************************************************
N#define AT91C_PIO_PA0        (1 <<  0) // Pin Controlled by PA0
N#define AT91C_PA0_MCI0_CK  (AT91C_PIO_PA0) //  
N#define AT91C_PA0_TCLK3    (AT91C_PIO_PA0) //  
N#define AT91C_PIO_PA1        (1 <<  1) // Pin Controlled by PA1
N#define AT91C_PA1_MCI0_CDA (AT91C_PIO_PA1) //  
N#define AT91C_PA1_TIOA3    (AT91C_PIO_PA1) //  
N#define AT91C_PIO_PA10       (1 << 10) // Pin Controlled by PA10
N#define AT91C_PA10_ETX0     (AT91C_PIO_PA10) //  Ethernet MAC Transmit Data 0
N#define AT91C_PIO_PA11       (1 << 11) // Pin Controlled by PA11
N#define AT91C_PA11_ETX1     (AT91C_PIO_PA11) //  Ethernet MAC Transmit Data 1
N#define AT91C_PIO_PA12       (1 << 12) // Pin Controlled by PA12
N#define AT91C_PA12_ERX0     (AT91C_PIO_PA12) //  Ethernet MAC Receive Data 0
N#define AT91C_PIO_PA13       (1 << 13) // Pin Controlled by PA13
N#define AT91C_PA13_ERX1     (AT91C_PIO_PA13) //  Ethernet MAC Receive Data 1
N#define AT91C_PIO_PA14       (1 << 14) // Pin Controlled by PA14
N#define AT91C_PA14_ETXEN    (AT91C_PIO_PA14) //  Ethernet MAC Transmit Enable
N#define AT91C_PIO_PA15       (1 << 15) // Pin Controlled by PA15
N#define AT91C_PA15_ERXDV    (AT91C_PIO_PA15) //  Ethernet MAC Receive Data Valid
N#define AT91C_PIO_PA16       (1 << 16) // Pin Controlled by PA16
N#define AT91C_PA16_ERXER    (AT91C_PIO_PA16) //  Ethernet MAC Receive Error
N#define AT91C_PIO_PA17       (1 << 17) // Pin Controlled by PA17
N#define AT91C_PA17_ETXCK_EREFCK (AT91C_PIO_PA17) //  Ethernet MAC Transmit Clock/Reference Clock
N#define AT91C_PIO_PA18       (1 << 18) // Pin Controlled by PA18
N#define AT91C_PA18_EMDC     (AT91C_PIO_PA18) //  Ethernet MAC Management Data Clock
N#define AT91C_PIO_PA19       (1 << 19) // Pin Controlled by PA19
N#define AT91C_PA19_EMDIO    (AT91C_PIO_PA19) //  Ethernet MAC Management Data Input/Output
N#define AT91C_PIO_PA2        (1 <<  2) // Pin Controlled by PA2
N#define AT91C_PA2_MCI0_DA0 (AT91C_PIO_PA2) //  
N#define AT91C_PA2_TIOB3    (AT91C_PIO_PA2) //  
N#define AT91C_PIO_PA20       (1 << 20) // Pin Controlled by PA20
N#define AT91C_PA20_TWD0     (AT91C_PIO_PA20) //  TWI Two-wire Serial Data
N#define AT91C_PIO_PA21       (1 << 21) // Pin Controlled by PA21
N#define AT91C_PA21_TWCK0    (AT91C_PIO_PA21) //  TWI Two-wire Serial Clock
N#define AT91C_PIO_PA22       (1 << 22) // Pin Controlled by PA22
N#define AT91C_PA22_MCI1_CDA (AT91C_PIO_PA22) //  
N#define AT91C_PA22_SCK3     (AT91C_PIO_PA22) //  
N#define AT91C_PIO_PA23       (1 << 23) // Pin Controlled by PA23
N#define AT91C_PA23_MCI1_DA0 (AT91C_PIO_PA23) //  
N#define AT91C_PA23_RTS3     (AT91C_PIO_PA23) //  
N#define AT91C_PIO_PA24       (1 << 24) // Pin Controlled by PA24
N#define AT91C_PA24_MCI1_DA1 (AT91C_PIO_PA24) //  
N#define AT91C_PA24_CTS3     (AT91C_PIO_PA24) //  
N#define AT91C_PIO_PA25       (1 << 25) // Pin Controlled by PA25
N#define AT91C_PA25_MCI1_DA2 (AT91C_PIO_PA25) //  
N#define AT91C_PA25_PWM3     (AT91C_PIO_PA25) //  
N#define AT91C_PIO_PA26       (1 << 26) // Pin Controlled by PA26
N#define AT91C_PA26_MCI1_DA3 (AT91C_PIO_PA26) //  
N#define AT91C_PA26_TIOB2    (AT91C_PIO_PA26) //  
N#define AT91C_PIO_PA27       (1 << 27) // Pin Controlled by PA27
N#define AT91C_PA27_MCI1_DA4 (AT91C_PIO_PA27) //  
N#define AT91C_PA27_ETXER    (AT91C_PIO_PA27) //  Ethernet MAC Transmikt Coding Error
N#define AT91C_PIO_PA28       (1 << 28) // Pin Controlled by PA28
N#define AT91C_PA28_MCI1_DA5 (AT91C_PIO_PA28) //  
N#define AT91C_PA28_ERXCK    (AT91C_PIO_PA28) //  Ethernet MAC Receive Clock
N#define AT91C_PIO_PA29       (1 << 29) // Pin Controlled by PA29
N#define AT91C_PA29_MCI1_DA6 (AT91C_PIO_PA29) //  
N#define AT91C_PA29_ECRS     (AT91C_PIO_PA29) //  Ethernet MAC Carrier Sense/Carrier Sense and Data Valid
N#define AT91C_PIO_PA3        (1 <<  3) // Pin Controlled by PA3
N#define AT91C_PA3_MCI0_DA1 (AT91C_PIO_PA3) //  
N#define AT91C_PA3_TCLK4    (AT91C_PIO_PA3) //  
N#define AT91C_PIO_PA30       (1 << 30) // Pin Controlled by PA30
N#define AT91C_PA30_MCI1_DA7 (AT91C_PIO_PA30) //  
N#define AT91C_PA30_ECOL     (AT91C_PIO_PA30) //  Ethernet MAC Collision Detected
N#define AT91C_PIO_PA31       (1 << 31) // Pin Controlled by PA31
N#define AT91C_PA31_MCI1_CK  (AT91C_PIO_PA31) //  
N#define AT91C_PA31_PCK0     (AT91C_PIO_PA31) //  
N#define AT91C_PIO_PA4        (1 <<  4) // Pin Controlled by PA4
N#define AT91C_PA4_MCI0_DA2 (AT91C_PIO_PA4) //  
N#define AT91C_PA4_TIOA4    (AT91C_PIO_PA4) //  
N#define AT91C_PIO_PA5        (1 <<  5) // Pin Controlled by PA5
N#define AT91C_PA5_MCI0_DA3 (AT91C_PIO_PA5) //  
N#define AT91C_PA5_TIOB4    (AT91C_PIO_PA5) //  
N#define AT91C_PIO_PA6        (1 <<  6) // Pin Controlled by PA6
N#define AT91C_PA6_MCI0_DA4 (AT91C_PIO_PA6) //  
N#define AT91C_PA6_ETX2     (AT91C_PIO_PA6) //  Ethernet MAC Transmit Data 2
N#define AT91C_PIO_PA7        (1 <<  7) // Pin Controlled by PA7
N#define AT91C_PA7_MCI0_DA5 (AT91C_PIO_PA7) //  
N#define AT91C_PA7_ETX3     (AT91C_PIO_PA7) //  Ethernet MAC Transmit Data 3
N#define AT91C_PIO_PA8        (1 <<  8) // Pin Controlled by PA8
N#define AT91C_PA8_MCI0_DA6 (AT91C_PIO_PA8) //  
N#define AT91C_PA8_ERX2     (AT91C_PIO_PA8) //  Ethernet MAC Receive Data 2
N#define AT91C_PIO_PA9        (1 <<  9) // Pin Controlled by PA9
N#define AT91C_PA9_MCI0_DA7 (AT91C_PIO_PA9) //  
N#define AT91C_PA9_ERX3     (AT91C_PIO_PA9) //  Ethernet MAC Receive Data 3
N#define AT91C_PIO_PB0        (1 <<  0) // Pin Controlled by PB0
N#define AT91C_PB0_SPI0_MISO (AT91C_PIO_PB0) //  SPI 0 Master In Slave
N#define AT91C_PIO_PB1        (1 <<  1) // Pin Controlled by PB1
N#define AT91C_PB1_SPI0_MOSI (AT91C_PIO_PB1) //  SPI 0 Master Out Slave
N#define AT91C_PIO_PB10       (1 << 10) // Pin Controlled by PB10
N#define AT91C_PB10_TWD1     (AT91C_PIO_PB10) //  
N#define AT91C_PB10_ISI_D10  (AT91C_PIO_PB10) //  
N#define AT91C_PIO_PB11       (1 << 11) // Pin Controlled by PB11
N#define AT91C_PB11_TWCK1    (AT91C_PIO_PB11) //  
N#define AT91C_PB11_ISI_D11  (AT91C_PIO_PB11) //  
N#define AT91C_PIO_PB12       (1 << 12) // Pin Controlled by PB12
N#define AT91C_PB12_DRXD     (AT91C_PIO_PB12) //  
N#define AT91C_PIO_PB13       (1 << 13) // Pin Controlled by PB13
N#define AT91C_PB13_DTXD     (AT91C_PIO_PB13) //  
N#define AT91C_PIO_PB14       (1 << 14) // Pin Controlled by PB14
N#define AT91C_PB14_SPI1_MISO (AT91C_PIO_PB14) //  
N#define AT91C_PIO_PB15       (1 << 15) // Pin Controlled by PB15
N#define AT91C_PB15_SPI1_MOSI (AT91C_PIO_PB15) //  
N#define AT91C_PB15_CTS0     (AT91C_PIO_PB15) //  
N#define AT91C_PIO_PB16       (1 << 16) // Pin Controlled by PB16
N#define AT91C_PB16_SPI1_SPCK (AT91C_PIO_PB16) //  
N#define AT91C_PB16_SCK0     (AT91C_PIO_PB16) //  
N#define AT91C_PIO_PB17       (1 << 17) // Pin Controlled by PB17
N#define AT91C_PB17_SPI1_NPCS0 (AT91C_PIO_PB17) //  
N#define AT91C_PB17_RTS0     (AT91C_PIO_PB17) //  
N#define AT91C_PIO_PB18       (1 << 18) // Pin Controlled by PB18
N#define AT91C_PB18_RXD0     (AT91C_PIO_PB18) //  
N#define AT91C_PB18_SPI0_NPCS1 (AT91C_PIO_PB18) //  
N#define AT91C_PIO_PB19       (1 << 19) // Pin Controlled by PB19
N#define AT91C_PB19_TXD0     (AT91C_PIO_PB19) //  
N#define AT91C_PB19_SPI0_NPCS2 (AT91C_PIO_PB19) //  
N#define AT91C_PIO_PB2        (1 <<  2) // Pin Controlled by PB2
N#define AT91C_PB2_SPI0_SPCK (AT91C_PIO_PB2) //  SPI 0 Serial Clock
N#define AT91C_PIO_PB20       (1 << 20) // Pin Controlled by PB20
N#define AT91C_PB20_ISI_D0   (AT91C_PIO_PB20) //  
N#define AT91C_PIO_PB21       (1 << 21) // Pin Controlled by PB21
N#define AT91C_PB21_ISI_D1   (AT91C_PIO_PB21) //  
N#define AT91C_PIO_PB22       (1 << 22) // Pin Controlled by PB22
N#define AT91C_PB22_ISI_D2   (AT91C_PIO_PB22) //  
N#define AT91C_PIO_PB23       (1 << 23) // Pin Controlled by PB23
N#define AT91C_PB23_ISI_D3   (AT91C_PIO_PB23) //  
N#define AT91C_PIO_PB24       (1 << 24) // Pin Controlled by PB24
N#define AT91C_PB24_ISI_D4   (AT91C_PIO_PB24) //  
N#define AT91C_PIO_PB25       (1 << 25) // Pin Controlled by PB25
N#define AT91C_PB25_ISI_D5   (AT91C_PIO_PB25) //  
N#define AT91C_PIO_PB26       (1 << 26) // Pin Controlled by PB26
N#define AT91C_PB26_ISI_D6   (AT91C_PIO_PB26) //  
N#define AT91C_PIO_PB27       (1 << 27) // Pin Controlled by PB27
N#define AT91C_PB27_ISI_D7   (AT91C_PIO_PB27) //  
N#define AT91C_PIO_PB28       (1 << 28) // Pin Controlled by PB28
N#define AT91C_PB28_ISI_PCK  (AT91C_PIO_PB28) //  
N#define AT91C_PIO_PB29       (1 << 29) // Pin Controlled by PB29
N#define AT91C_PB29_ISI_VSYNC (AT91C_PIO_PB29) //  
N#define AT91C_PIO_PB3        (1 <<  3) // Pin Controlled by PB3
N#define AT91C_PB3_SPI0_NPCS0 (AT91C_PIO_PB3) //  SPI 0 Peripheral Chip Select 0
N#define AT91C_PIO_PB30       (1 << 30) // Pin Controlled by PB30
N#define AT91C_PB30_ISI_HSYNC (AT91C_PIO_PB30) //  
N#define AT91C_PIO_PB31       (1 << 31) // Pin Controlled by PB31
N#define AT91C_PB31_         (AT91C_PIO_PB31) //  
N#define AT91C_PB31_PCK1     (AT91C_PIO_PB31) //  
N#define AT91C_PIO_PB4        (1 <<  4) // Pin Controlled by PB4
N#define AT91C_PB4_TXD1     (AT91C_PIO_PB4) //  USART 1 Transmit Data
N#define AT91C_PIO_PB5        (1 <<  5) // Pin Controlled by PB5
N#define AT91C_PB5_RXD1     (AT91C_PIO_PB5) //  USART 1 Receive Data
N#define AT91C_PIO_PB6        (1 <<  6) // Pin Controlled by PB6
N#define AT91C_PB6_TXD2     (AT91C_PIO_PB6) //  USART 2 Transmit Data
N#define AT91C_PIO_PB7        (1 <<  7) // Pin Controlled by PB7
N#define AT91C_PB7_RXD2     (AT91C_PIO_PB7) //  USART 2 Receive Data
N#define AT91C_PIO_PB8        (1 <<  8) // Pin Controlled by PB8
N#define AT91C_PB8_TXD3     (AT91C_PIO_PB8) //  USART 3 Transmit Data
N#define AT91C_PB8_ISI_D8   (AT91C_PIO_PB8) //  
N#define AT91C_PIO_PB9        (1 <<  9) // Pin Controlled by PB9
N#define AT91C_PB9_RXD3     (AT91C_PIO_PB9) //  USART 3 Receive Data
N#define AT91C_PB9_ISI_D9   (AT91C_PIO_PB9) //  
N#define AT91C_PIO_PC0        (1 <<  0) // Pin Controlled by PC0
N#define AT91C_PC0_DQM2     (AT91C_PIO_PC0) //  DQM2
N#define AT91C_PIO_PC1        (1 <<  1) // Pin Controlled by PC1
N#define AT91C_PC1_DQM3     (AT91C_PIO_PC1) //  DQM3
N#define AT91C_PIO_PC10       (1 << 10) // Pin Controlled by PC10
N#define AT91C_PC10_NCS4_CFCS0 (AT91C_PIO_PC10) //  
N#define AT91C_PC10_TCLK2    (AT91C_PIO_PC10) //  
N#define AT91C_PIO_PC11       (1 << 11) // Pin Controlled by PC11
N#define AT91C_PC11_NCS5_CFCS1 (AT91C_PIO_PC11) //  
N#define AT91C_PC11_CTS2     (AT91C_PIO_PC11) //  
N#define AT91C_PIO_PC12       (1 << 12) // Pin Controlled by PC12
N#define AT91C_PC12_A25_CFRNW (AT91C_PIO_PC12) //  
N#define AT91C_PIO_PC13       (1 << 13) // Pin Controlled by PC13
N#define AT91C_PC13_NCS2     (AT91C_PIO_PC13) //  
N#define AT91C_PIO_PC14       (1 << 14) // Pin Controlled by PC14
N#define AT91C_PC14_NCS3_NANDCS (AT91C_PIO_PC14) //  
N#define AT91C_PIO_PC15       (1 << 15) // Pin Controlled by PC15
N#define AT91C_PC15_NWAIT    (AT91C_PIO_PC15) //  
N#define AT91C_PIO_PC16       (1 << 16) // Pin Controlled by PC16
N#define AT91C_PC16_D16      (AT91C_PIO_PC16) //  
N#define AT91C_PIO_PC17       (1 << 17) // Pin Controlled by PC17
N#define AT91C_PC17_D17      (AT91C_PIO_PC17) //  
N#define AT91C_PIO_PC18       (1 << 18) // Pin Controlled by PC18
N#define AT91C_PC18_D18      (AT91C_PIO_PC18) //  
N#define AT91C_PIO_PC19       (1 << 19) // Pin Controlled by PC19
N#define AT91C_PC19_D19      (AT91C_PIO_PC19) //  
N#define AT91C_PIO_PC2        (1 <<  2) // Pin Controlled by PC2
N#define AT91C_PC2_A19      (AT91C_PIO_PC2) //  
N#define AT91C_PIO_PC20       (1 << 20) // Pin Controlled by PC20
N#define AT91C_PC20_D20      (AT91C_PIO_PC20) //  
N#define AT91C_PIO_PC21       (1 << 21) // Pin Controlled by PC21
N#define AT91C_PC21_D21      (AT91C_PIO_PC21) //  
N#define AT91C_PIO_PC22       (1 << 22) // Pin Controlled by PC22
N#define AT91C_PC22_D22      (AT91C_PIO_PC22) //  
N#define AT91C_PIO_PC23       (1 << 23) // Pin Controlled by PC23
N#define AT91C_PC23_D23      (AT91C_PIO_PC23) //  
N#define AT91C_PIO_PC24       (1 << 24) // Pin Controlled by PC24
N#define AT91C_PC24_D24      (AT91C_PIO_PC24) //  
N#define AT91C_PIO_PC25       (1 << 25) // Pin Controlled by PC25
N#define AT91C_PC25_D25      (AT91C_PIO_PC25) //  
N#define AT91C_PIO_PC26       (1 << 26) // Pin Controlled by PC26
N#define AT91C_PC26_D26      (AT91C_PIO_PC26) //  
N#define AT91C_PIO_PC27       (1 << 27) // Pin Controlled by PC27
N#define AT91C_PC27_D27      (AT91C_PIO_PC27) //  
N#define AT91C_PIO_PC28       (1 << 28) // Pin Controlled by PC28
N#define AT91C_PC28_D28      (AT91C_PIO_PC28) //  
N#define AT91C_PIO_PC29       (1 << 29) // Pin Controlled by PC29
N#define AT91C_PC29_D29      (AT91C_PIO_PC29) //  
N#define AT91C_PIO_PC3        (1 <<  3) // Pin Controlled by PC3
N#define AT91C_PC3_A20      (AT91C_PIO_PC3) //  
N#define AT91C_PIO_PC30       (1 << 30) // Pin Controlled by PC30
N#define AT91C_PC30_D30      (AT91C_PIO_PC30) //  
N#define AT91C_PIO_PC31       (1 << 31) // Pin Controlled by PC31
N#define AT91C_PC31_D31      (AT91C_PIO_PC31) //  
N#define AT91C_PIO_PC4        (1 <<  4) // Pin Controlled by PC4
N#define AT91C_PC4_A21_NANDALE (AT91C_PIO_PC4) //  
N#define AT91C_PIO_PC5        (1 <<  5) // Pin Controlled by PC5
N#define AT91C_PC5_A22_NANDCLE (AT91C_PIO_PC5) //  
N#define AT91C_PIO_PC6        (1 <<  6) // Pin Controlled by PC6
N#define AT91C_PC6_A23      (AT91C_PIO_PC6) //  
N#define AT91C_PIO_PC7        (1 <<  7) // Pin Controlled by PC7
N#define AT91C_PC7_A24      (AT91C_PIO_PC7) //  
N#define AT91C_PIO_PC8        (1 <<  8) // Pin Controlled by PC8
N#define AT91C_PC8_CFCE1    (AT91C_PIO_PC8) //  
N#define AT91C_PIO_PC9        (1 <<  9) // Pin Controlled by PC9
N#define AT91C_PC9_CFCE2    (AT91C_PIO_PC9) //  
N#define AT91C_PC9_RTS2     (AT91C_PIO_PC9) //  
N#define AT91C_PIO_PD0        (1 <<  0) // Pin Controlled by PD0
N#define AT91C_PD0_TK0      (AT91C_PIO_PD0) //  
N#define AT91C_PD0_PWM3     (AT91C_PIO_PD0) //  
N#define AT91C_PIO_PD1        (1 <<  1) // Pin Controlled by PD1
N#define AT91C_PD1_TF0      (AT91C_PIO_PD1) //  
N#define AT91C_PIO_PD10       (1 << 10) // Pin Controlled by PD10
N#define AT91C_PD10_TD1      (AT91C_PIO_PD10) //  
N#define AT91C_PIO_PD11       (1 << 11) // Pin Controlled by PD11
N#define AT91C_PD11_RD1      (AT91C_PIO_PD11) //  
N#define AT91C_PIO_PD12       (1 << 12) // Pin Controlled by PD12
N#define AT91C_PD12_TK1      (AT91C_PIO_PD12) //  
N#define AT91C_PD12_PCK0     (AT91C_PIO_PD12) //  
N#define AT91C_PIO_PD13       (1 << 13) // Pin Controlled by PD13
N#define AT91C_PD13_RK1      (AT91C_PIO_PD13) //  
N#define AT91C_PIO_PD14       (1 << 14) // Pin Controlled by PD14
N#define AT91C_PD14_TF1      (AT91C_PIO_PD14) //  
N#define AT91C_PIO_PD15       (1 << 15) // Pin Controlled by PD15
N#define AT91C_PD15_RF1      (AT91C_PIO_PD15) //  
N#define AT91C_PIO_PD16       (1 << 16) // Pin Controlled by PD16
N#define AT91C_PD16_RTS1     (AT91C_PIO_PD16) //  
N#define AT91C_PIO_PD17       (1 << 17) // Pin Controlled by PD17
N#define AT91C_PD17_CTS1     (AT91C_PIO_PD17) //  
N#define AT91C_PIO_PD18       (1 << 18) // Pin Controlled by PD18
N#define AT91C_PD18_SPI1_NPCS2 (AT91C_PIO_PD18) //  
N#define AT91C_PD18_IRQ      (AT91C_PIO_PD18) //  
N#define AT91C_PIO_PD19       (1 << 19) // Pin Controlled by PD19
N#define AT91C_PD19_SPI1_NPCS3 (AT91C_PIO_PD19) //  
N#define AT91C_PD19_FIQ      (AT91C_PIO_PD19) //  
N#define AT91C_PIO_PD2        (1 <<  2) // Pin Controlled by PD2
N#define AT91C_PD2_TD0      (AT91C_PIO_PD2) //  
N#define AT91C_PIO_PD20       (1 << 20) // Pin Controlled by PD20
N#define AT91C_PD20_TIOA0    (AT91C_PIO_PD20) //  
N#define AT91C_PIO_PD21       (1 << 21) // Pin Controlled by PD21
N#define AT91C_PD21_TIOA1    (AT91C_PIO_PD21) //  
N#define AT91C_PIO_PD22       (1 << 22) // Pin Controlled by PD22
N#define AT91C_PD22_TIOA2    (AT91C_PIO_PD22) //  
N#define AT91C_PIO_PD23       (1 << 23) // Pin Controlled by PD23
N#define AT91C_PD23_TCLK0    (AT91C_PIO_PD23) //  
N#define AT91C_PIO_PD24       (1 << 24) // Pin Controlled by PD24
N#define AT91C_PD24_SPI0_NPCS1 (AT91C_PIO_PD24) //  
N#define AT91C_PD24_PWM0     (AT91C_PIO_PD24) //  
N#define AT91C_PIO_PD25       (1 << 25) // Pin Controlled by PD25
N#define AT91C_PD25_SPI0_NPCS2 (AT91C_PIO_PD25) //  
N#define AT91C_PD25_PWM1     (AT91C_PIO_PD25) //  
N#define AT91C_PIO_PD26       (1 << 26) // Pin Controlled by PD26
N#define AT91C_PD26_PCK0     (AT91C_PIO_PD26) //  
N#define AT91C_PD26_PWM2     (AT91C_PIO_PD26) //  
N#define AT91C_PIO_PD27       (1 << 27) // Pin Controlled by PD27
N#define AT91C_PD27_PCK1     (AT91C_PIO_PD27) //  
N#define AT91C_PD27_SPI0_NPCS3 (AT91C_PIO_PD27) //  
N#define AT91C_PIO_PD28       (1 << 28) // Pin Controlled by PD28
N#define AT91C_PD28_TSADTRG  (AT91C_PIO_PD28) //  
N#define AT91C_PD28_SPI1_NPCS1 (AT91C_PIO_PD28) //  
N#define AT91C_PIO_PD29       (1 << 29) // Pin Controlled by PD29
N#define AT91C_PD29_TCLK1    (AT91C_PIO_PD29) //  
N#define AT91C_PD29_SCK1     (AT91C_PIO_PD29) //  
N#define AT91C_PIO_PD3        (1 <<  3) // Pin Controlled by PD3
N#define AT91C_PD3_RD0      (AT91C_PIO_PD3) //  
N#define AT91C_PIO_PD30       (1 << 30) // Pin Controlled by PD30
N#define AT91C_PD30_TIOB0    (AT91C_PIO_PD30) //  
N#define AT91C_PD30_SCK2     (AT91C_PIO_PD30) //  
N#define AT91C_PIO_PD31       (1 << 31) // Pin Controlled by PD31
N#define AT91C_PD31_TIOB1    (AT91C_PIO_PD31) //  
N#define AT91C_PD31_PWM1     (AT91C_PIO_PD31) //  
N#define AT91C_PIO_PD4        (1 <<  4) // Pin Controlled by PD4
N#define AT91C_PD4_RK0      (AT91C_PIO_PD4) //  
N#define AT91C_PIO_PD5        (1 <<  5) // Pin Controlled by PD5
N#define AT91C_PD5_RF0      (AT91C_PIO_PD5) //  
N#define AT91C_PIO_PD6        (1 <<  6) // Pin Controlled by PD6
N#define AT91C_PD6_AC97RX   (AT91C_PIO_PD6) //  
N#define AT91C_PIO_PD7        (1 <<  7) // Pin Controlled by PD7
N#define AT91C_PD7_AC97TX   (AT91C_PIO_PD7) //  
N#define AT91C_PD7_TIOA5    (AT91C_PIO_PD7) //  
N#define AT91C_PIO_PD8        (1 <<  8) // Pin Controlled by PD8
N#define AT91C_PD8_AC97FS   (AT91C_PIO_PD8) //  
N#define AT91C_PD8_TIOB5    (AT91C_PIO_PD8) //  
N#define AT91C_PIO_PD9        (1 <<  9) // Pin Controlled by PD9
N#define AT91C_PD9_AC97CK   (AT91C_PIO_PD9) //  
N#define AT91C_PD9_TCLK5    (AT91C_PIO_PD9) //  
N#define AT91C_PIO_PE0        (1 <<  0) // Pin Controlled by PE0
N#define AT91C_PE0_LCDPWR   (AT91C_PIO_PE0) //  
N#define AT91C_PE0_PCK0     (AT91C_PIO_PE0) //  
N#define AT91C_PIO_PE1        (1 <<  1) // Pin Controlled by PE1
N#define AT91C_PE1_LCDMOD   (AT91C_PIO_PE1) //  
N#define AT91C_PIO_PE10       (1 << 10) // Pin Controlled by PE10
N#define AT91C_PE10_LCDD3    (AT91C_PIO_PE10) //  
N#define AT91C_PE10_LCDD5    (AT91C_PIO_PE10) //  
N#define AT91C_PIO_PE11       (1 << 11) // Pin Controlled by PE11
N#define AT91C_PE11_LCDD4    (AT91C_PIO_PE11) //  
N#define AT91C_PE11_LCDD6    (AT91C_PIO_PE11) //  
N#define AT91C_PIO_PE12       (1 << 12) // Pin Controlled by PE12
N#define AT91C_PE12_LCDD5    (AT91C_PIO_PE12) //  
N#define AT91C_PE12_LCDD7    (AT91C_PIO_PE12) //  
N#define AT91C_PIO_PE13       (1 << 13) // Pin Controlled by PE13
N#define AT91C_PE13_LCDD6    (AT91C_PIO_PE13) //  
N#define AT91C_PE13_LCDD10   (AT91C_PIO_PE13) //  
N#define AT91C_PIO_PE14       (1 << 14) // Pin Controlled by PE14
N#define AT91C_PE14_LCDD7    (AT91C_PIO_PE14) //  
N#define AT91C_PE14_LCDD11   (AT91C_PIO_PE14) //  
N#define AT91C_PIO_PE15       (1 << 15) // Pin Controlled by PE15
N#define AT91C_PE15_LCDD8    (AT91C_PIO_PE15) //  
N#define AT91C_PE15_LCDD12   (AT91C_PIO_PE15) //  
N#define AT91C_PIO_PE16       (1 << 16) // Pin Controlled by PE16
N#define AT91C_PE16_LCDD9    (AT91C_PIO_PE16) //  
N#define AT91C_PE16_LCDD13   (AT91C_PIO_PE16) //  
N#define AT91C_PIO_PE17       (1 << 17) // Pin Controlled by PE17
N#define AT91C_PE17_LCDD10   (AT91C_PIO_PE17) //  
N#define AT91C_PE17_LCDD14   (AT91C_PIO_PE17) //  
N#define AT91C_PIO_PE18       (1 << 18) // Pin Controlled by PE18
N#define AT91C_PE18_LCDD11   (AT91C_PIO_PE18) //  
N#define AT91C_PE18_LCDD15   (AT91C_PIO_PE18) //  
N#define AT91C_PIO_PE19       (1 << 19) // Pin Controlled by PE19
N#define AT91C_PE19_LCDD12   (AT91C_PIO_PE19) //  
N#define AT91C_PE19_LCDD18   (AT91C_PIO_PE19) //  
N#define AT91C_PIO_PE2        (1 <<  2) // Pin Controlled by PE2
N#define AT91C_PE2_LCDCC    (AT91C_PIO_PE2) //  
N#define AT91C_PIO_PE20       (1 << 20) // Pin Controlled by PE20
N#define AT91C_PE20_LCDD13   (AT91C_PIO_PE20) //  
N#define AT91C_PE20_LCDD19   (AT91C_PIO_PE20) //  
N#define AT91C_PIO_PE21       (1 << 21) // Pin Controlled by PE21
N#define AT91C_PE21_LCDD14   (AT91C_PIO_PE21) //  
N#define AT91C_PE21_LCDD20   (AT91C_PIO_PE21) //  
N#define AT91C_PIO_PE22       (1 << 22) // Pin Controlled by PE22
N#define AT91C_PE22_LCDD15   (AT91C_PIO_PE22) //  
N#define AT91C_PE22_LCDD21   (AT91C_PIO_PE22) //  
N#define AT91C_PIO_PE23       (1 << 23) // Pin Controlled by PE23
N#define AT91C_PE23_LCDD16   (AT91C_PIO_PE23) //  
N#define AT91C_PE23_LCDD22   (AT91C_PIO_PE23) //  
N#define AT91C_PIO_PE24       (1 << 24) // Pin Controlled by PE24
N#define AT91C_PE24_LCDD17   (AT91C_PIO_PE24) //  
N#define AT91C_PE24_LCDD23   (AT91C_PIO_PE24) //  
N#define AT91C_PIO_PE25       (1 << 25) // Pin Controlled by PE25
N#define AT91C_PE25_LCDD18   (AT91C_PIO_PE25) //  
N#define AT91C_PIO_PE26       (1 << 26) // Pin Controlled by PE26
N#define AT91C_PE26_LCDD19   (AT91C_PIO_PE26) //  
N#define AT91C_PIO_PE27       (1 << 27) // Pin Controlled by PE27
N#define AT91C_PE27_LCDD20   (AT91C_PIO_PE27) //  
N#define AT91C_PIO_PE28       (1 << 28) // Pin Controlled by PE28
N#define AT91C_PE28_LCDD21   (AT91C_PIO_PE28) //  
N#define AT91C_PIO_PE29       (1 << 29) // Pin Controlled by PE29
N#define AT91C_PE29_LCDD22   (AT91C_PIO_PE29) //  
N#define AT91C_PIO_PE3        (1 <<  3) // Pin Controlled by PE3
N#define AT91C_PE3_LCDVSYNC (AT91C_PIO_PE3) //  
N#define AT91C_PIO_PE30       (1 << 30) // Pin Controlled by PE30
N#define AT91C_PE30_LCDD23   (AT91C_PIO_PE30) //  
N#define AT91C_PIO_PE31       (1 << 31) // Pin Controlled by PE31
N#define AT91C_PE31_PWM2     (AT91C_PIO_PE31) //  
N#define AT91C_PE31_PCK1     (AT91C_PIO_PE31) //  
N#define AT91C_PIO_PE4        (1 <<  4) // Pin Controlled by PE4
N#define AT91C_PE4_LCDHSYNC (AT91C_PIO_PE4) //  
N#define AT91C_PIO_PE5        (1 <<  5) // Pin Controlled by PE5
N#define AT91C_PE5_LCDDOTCK (AT91C_PIO_PE5) //  
N#define AT91C_PIO_PE6        (1 <<  6) // Pin Controlled by PE6
N#define AT91C_PE6_LCDDEN   (AT91C_PIO_PE6) //  
N#define AT91C_PIO_PE7        (1 <<  7) // Pin Controlled by PE7
N#define AT91C_PE7_LCDD0    (AT91C_PIO_PE7) //  
N#define AT91C_PE7_LCDD2    (AT91C_PIO_PE7) //  
N#define AT91C_PIO_PE8        (1 <<  8) // Pin Controlled by PE8
N#define AT91C_PE8_LCDD1    (AT91C_PIO_PE8) //  
N#define AT91C_PE8_LCDD3    (AT91C_PIO_PE8) //  
N#define AT91C_PIO_PE9        (1 <<  9) // Pin Controlled by PE9
N#define AT91C_PE9_LCDD2    (AT91C_PIO_PE9) //  
N#define AT91C_PE9_LCDD4    (AT91C_PIO_PE9) //  
N
N// *****************************************************************************
N//               PERIPHERAL ID DEFINITIONS FOR AT91SAM9M10
N// *****************************************************************************
N#define AT91C_ID_FIQ    ( 0) // Advanced Interrupt Controller (FIQ)
N#define AT91C_ID_SYS    ( 1) // System Controller
N#define AT91C_ID_PIOA   ( 2) // Parallel IO Controller A
N#define AT91C_ID_PIOB   ( 3) // Parallel IO Controller B
N#define AT91C_ID_PIOC   ( 4) // Parallel IO Controller C
N#define AT91C_ID_PIOD_E ( 5) // Parallel IO Controller D and E
N#define AT91C_ID_TRNG   ( 6) // True Random Number Generator
N#define AT91C_ID_US0    ( 7) // USART 0
N#define AT91C_ID_US1    ( 8) // USART 1
N#define AT91C_ID_US2    ( 9) // USART 2
N#define AT91C_ID_US3    (10) // USART 2
N#define AT91C_ID_MCI0   (11) // Multimedia Card Interface 0
N#define AT91C_ID_TWI0   (12) // TWI 0
N#define AT91C_ID_TWI1   (13) // TWI 1
N#define AT91C_ID_SPI0   (14) // Serial Peripheral Interface
N#define AT91C_ID_SPI1   (15) // Serial Peripheral Interface
N#define AT91C_ID_SSC0   (16) // Serial Synchronous Controller 0
N#define AT91C_ID_SSC1   (17) // Serial Synchronous Controller 1
N#define AT91C_ID_TC     (18) // Timer Counter 0, 1, 2, 3, 4, 5
N#define AT91C_ID_PWMC   (19) // Pulse Width Modulation Controller
N#define AT91C_ID_TSADC  (20) // Touch Screen Controller
N#define AT91C_ID_HDMA   (21) // HDMA
N#define AT91C_ID_UHPHS  (22) // USB Host High Speed
N#define AT91C_ID_LCDC   (23) // LCD Controller
N#define AT91C_ID_AC97C  (24) // AC97 Controller
N#define AT91C_ID_EMAC   (25) // Ethernet MAC
N#define AT91C_ID_ISI    (26) // Image Sensor Interface
N#define AT91C_ID_UDPHS  (27) // USB Device HS
N#define AT91C_ID_MCI1   (29) // Multimedia Card Interface 1
N#define AT91C_ID_VDEC   (30) // Video Decoder
N#define AT91C_ID_IRQ0   (31) // Advanced Interrupt Controller (IRQ0)
N#define AT91C_ALL_INT   (0xEFFFFFFF) // ALL VALID INTERRUPTS
N
N// *****************************************************************************
N//               BASE ADDRESS DEFINITIONS FOR AT91SAM9M10
N// *****************************************************************************
N#define AT91C_BASE_SFR       (AT91_CAST(AT91PS_SFR) 	0xFFF74000) // (SFR) Base Address
N#define AT91C_BASE_SYS       (AT91_CAST(AT91PS_SYS) 	0xFFFFC000) // (SYS) Base Address
N#define AT91C_BASE_EBI       (AT91_CAST(AT91PS_EBI) 	0xFFFFE200) // (EBI) Base Address
N#define AT91C_BASE_DDR2CP1   (AT91_CAST(AT91PS_HDDRSDRC2) 	0xFFFFE400) // (DDR2CP1) Base Address
N#define AT91C_BASE_DDR2C     (AT91_CAST(AT91PS_HDDRSDRC2) 	0xFFFFE600) // (DDR2C) Base Address
N#define AT91C_BASE_SMC       (AT91_CAST(AT91PS_SMC) 	0xFFFFE800) // (SMC) Base Address
N#define AT91C_BASE_MATRIX    (AT91_CAST(AT91PS_MATRIX) 	0xFFFFEA00) // (MATRIX) Base Address
N#define AT91C_BASE_CCFG      (AT91_CAST(AT91PS_CCFG) 	0xFFFFEB10) // (CCFG) Base Address
N#define AT91C_BASE_AIC       (AT91_CAST(AT91PS_AIC) 	0xFFFFF000) // (AIC) Base Address
N#define AT91C_BASE_PDC_DBGU  (AT91_CAST(AT91PS_PDC) 	0xFFFFEF00) // (PDC_DBGU) Base Address
N#define AT91C_BASE_DBGU      (AT91_CAST(AT91PS_DBGU) 	0xFFFFEE00) // (DBGU) Base Address
N#define AT91C_BASE_PIOA      (AT91_CAST(AT91PS_PIO) 	0xFFFFF200) // (PIOA) Base Address
N#define AT91C_BASE_PIOB      (AT91_CAST(AT91PS_PIO) 	0xFFFFF400) // (PIOB) Base Address
N#define AT91C_BASE_PIOC      (AT91_CAST(AT91PS_PIO) 	0xFFFFF600) // (PIOC) Base Address
N#define AT91C_BASE_PIOD      (AT91_CAST(AT91PS_PIO) 	0xFFFFF800) // (PIOD) Base Address
N#define AT91C_BASE_PIOE      (AT91_CAST(AT91PS_PIO) 	0xFFFFFA00) // (PIOE) Base Address
N#define AT91C_BASE_PMC       (AT91_CAST(AT91PS_PMC) 	0xFFFFFC00) // (PMC) Base Address
N#define AT91C_BASE_CKGR      (AT91_CAST(AT91PS_CKGR) 	0xFFFFFC1C) // (CKGR) Base Address
N#define AT91C_BASE_RSTC      (AT91_CAST(AT91PS_RSTC) 	0xFFFFFD00) // (RSTC) Base Address
N#define AT91C_BASE_SHDWC     (AT91_CAST(AT91PS_SHDWC) 	0xFFFFFD10) // (SHDWC) Base Address
N#define AT91C_BASE_RTTC      (AT91_CAST(AT91PS_RTTC) 	0xFFFFFD20) // (RTTC) Base Address
N#define AT91C_BASE_PITC      (AT91_CAST(AT91PS_PITC) 	0xFFFFFD30) // (PITC) Base Address
N#define AT91C_BASE_WDTC      (AT91_CAST(AT91PS_WDTC) 	0xFFFFFD40) // (WDTC) Base Address
N#define AT91C_BASE_RTC       (AT91_CAST(AT91PS_RTC) 	0xFFFFFDB0) // (RTC) Base Address
N#define AT91C_BASE_TC0       (AT91_CAST(AT91PS_TC) 	0xFFF7C000) // (TC0) Base Address
N#define AT91C_BASE_TC1       (AT91_CAST(AT91PS_TC) 	0xFFF7C040) // (TC1) Base Address
N#define AT91C_BASE_TC2       (AT91_CAST(AT91PS_TC) 	0xFFF7C080) // (TC2) Base Address
N#define AT91C_BASE_TC3       (AT91_CAST(AT91PS_TC) 	0xFFFD4000) // (TC3) Base Address
N#define AT91C_BASE_TC4       (AT91_CAST(AT91PS_TC) 	0xFFFD4040) // (TC4) Base Address
N#define AT91C_BASE_TC5       (AT91_CAST(AT91PS_TC) 	0xFFFD4080) // (TC5) Base Address
N#define AT91C_BASE_TCB0      (AT91_CAST(AT91PS_TCB) 	0xFFF7C000) // (TCB0) Base Address
N#define AT91C_BASE_TCB1      (AT91_CAST(AT91PS_TCB) 	0xFFFD4000) // (TCB1) Base Address
N#define AT91C_BASE_MCI0      (AT91_CAST(AT91PS_MCI) 	0xFFF80000) // (MCI0) Base Address
N#define AT91C_BASE_MCI1      (AT91_CAST(AT91PS_MCI) 	0xFFFD0000) // (MCI1) Base Address
N#define AT91C_BASE_TWI0      (AT91_CAST(AT91PS_TWI) 	0xFFF84000) // (TWI0) Base Address
N#define AT91C_BASE_TWI1      (AT91_CAST(AT91PS_TWI) 	0xFFF88000) // (TWI1) Base Address
N#define AT91C_BASE_PDC_US0   (AT91_CAST(AT91PS_PDC) 	0xFFF8C100) // (PDC_US0) Base Address
N#define AT91C_BASE_US0       (AT91_CAST(AT91PS_USART) 	0xFFF8C000) // (US0) Base Address
N#define AT91C_BASE_PDC_US1   (AT91_CAST(AT91PS_PDC) 	0xFFF90100) // (PDC_US1) Base Address
N#define AT91C_BASE_US1       (AT91_CAST(AT91PS_USART) 	0xFFF90000) // (US1) Base Address
N#define AT91C_BASE_PDC_US2   (AT91_CAST(AT91PS_PDC) 	0xFFF94100) // (PDC_US2) Base Address
N#define AT91C_BASE_US2       (AT91_CAST(AT91PS_USART) 	0xFFF94000) // (US2) Base Address
N#define AT91C_BASE_PDC_US3   (AT91_CAST(AT91PS_PDC) 	0xFFF98100) // (PDC_US3) Base Address
N#define AT91C_BASE_US3       (AT91_CAST(AT91PS_USART) 	0xFFF98000) // (US3) Base Address
N#define AT91C_BASE_PDC_SSC0  (AT91_CAST(AT91PS_PDC) 	0xFFF9C100) // (PDC_SSC0) Base Address
N#define AT91C_BASE_SSC0      (AT91_CAST(AT91PS_SSC) 	0xFFF9C000) // (SSC0) Base Address
N#define AT91C_BASE_PDC_SSC1  (AT91_CAST(AT91PS_PDC) 	0xFFFA0100) // (PDC_SSC1) Base Address
N#define AT91C_BASE_SSC1      (AT91_CAST(AT91PS_SSC) 	0xFFFA0000) // (SSC1) Base Address
N#define AT91C_BASE_PWMC_CH0  (AT91_CAST(AT91PS_PWMC_CH) 	0xFFFB8200) // (PWMC_CH0) Base Address
N#define AT91C_BASE_PWMC_CH1  (AT91_CAST(AT91PS_PWMC_CH) 	0xFFFB8220) // (PWMC_CH1) Base Address
N#define AT91C_BASE_PWMC_CH2  (AT91_CAST(AT91PS_PWMC_CH) 	0xFFFB8240) // (PWMC_CH2) Base Address
N#define AT91C_BASE_PWMC_CH3  (AT91_CAST(AT91PS_PWMC_CH) 	0xFFFB8260) // (PWMC_CH3) Base Address
N#define AT91C_BASE_PWMC      (AT91_CAST(AT91PS_PWMC) 	0xFFFB8000) // (PWMC) Base Address
N#define AT91C_BASE_PDC_SPI0  (AT91_CAST(AT91PS_PDC) 	0xFFFA4100) // (PDC_SPI0) Base Address
N#define AT91C_BASE_PDC_SPI1  (AT91_CAST(AT91PS_PDC) 	0xFFFA8100) // (PDC_SPI1) Base Address
N#define AT91C_BASE_SPI0      (AT91_CAST(AT91PS_SPI) 	0xFFFA4000) // (SPI0) Base Address
N#define AT91C_BASE_SPI1      (AT91_CAST(AT91PS_SPI) 	0xFFFA8000) // (SPI1) Base Address
N#define AT91C_BASE_PDC_TSADC (AT91_CAST(AT91PS_PDC) 	0xFFFB0100) // (PDC_TSADC) Base Address
N#define AT91C_BASE_TSADC     (AT91_CAST(AT91PS_TSADC) 	0xFFFB0000) // (TSADC) Base Address
N#define AT91C_BASE_UDPHS_EPTFIFO (AT91_CAST(AT91PS_UDPHS_EPTFIFO) 	0x00600000) // (UDPHS_EPTFIFO) Base Address
N#define AT91C_BASE_UDPHS_EPT_0 (AT91_CAST(AT91PS_UDPHS_EPT) 	0xFFF78100) // (UDPHS_EPT_0) Base Address
N#define AT91C_BASE_UDPHS_EPT_1 (AT91_CAST(AT91PS_UDPHS_EPT) 	0xFFF78120) // (UDPHS_EPT_1) Base Address
N#define AT91C_BASE_UDPHS_EPT_2 (AT91_CAST(AT91PS_UDPHS_EPT) 	0xFFF78140) // (UDPHS_EPT_2) Base Address
N#define AT91C_BASE_UDPHS_EPT_3 (AT91_CAST(AT91PS_UDPHS_EPT) 	0xFFF78160) // (UDPHS_EPT_3) Base Address
N#define AT91C_BASE_UDPHS_EPT_4 (AT91_CAST(AT91PS_UDPHS_EPT) 	0xFFF78180) // (UDPHS_EPT_4) Base Address
N#define AT91C_BASE_UDPHS_EPT_5 (AT91_CAST(AT91PS_UDPHS_EPT) 	0xFFF781A0) // (UDPHS_EPT_5) Base Address
N#define AT91C_BASE_UDPHS_EPT_6 (AT91_CAST(AT91PS_UDPHS_EPT) 	0xFFF781C0) // (UDPHS_EPT_6) Base Address
N#define AT91C_BASE_UDPHS_DMA_1 (AT91_CAST(AT91PS_UDPHS_DMA) 	0xFFF78310) // (UDPHS_DMA_1) Base Address
N#define AT91C_BASE_UDPHS_DMA_2 (AT91_CAST(AT91PS_UDPHS_DMA) 	0xFFF78320) // (UDPHS_DMA_2) Base Address
N#define AT91C_BASE_UDPHS_DMA_3 (AT91_CAST(AT91PS_UDPHS_DMA) 	0xFFF78330) // (UDPHS_DMA_3) Base Address
N#define AT91C_BASE_UDPHS_DMA_4 (AT91_CAST(AT91PS_UDPHS_DMA) 	0xFFF78340) // (UDPHS_DMA_4) Base Address
N#define AT91C_BASE_UDPHS_DMA_5 (AT91_CAST(AT91PS_UDPHS_DMA) 	0xFFF78350) // (UDPHS_DMA_5) Base Address
N#define AT91C_BASE_UDPHS_DMA_6 (AT91_CAST(AT91PS_UDPHS_DMA) 	0xFFF78360) // (UDPHS_DMA_6) Base Address
N#define AT91C_BASE_UDPHS     (AT91_CAST(AT91PS_UDPHS) 	0xFFF78000) // (UDPHS) Base Address
N#define AT91C_BASE_PDC_AC97C (AT91_CAST(AT91PS_PDC) 	0xFFFAC100) // (PDC_AC97C) Base Address
N#define AT91C_BASE_AC97C     (AT91_CAST(AT91PS_AC97C) 	0xFFFAC000) // (AC97C) Base Address
N#define AT91C_BASE_LCDC      (AT91_CAST(AT91PS_LCDC) 	0x00500000) // (LCDC) Base Address
N#define AT91C_BASE_LCDC_16B_TFT (AT91_CAST(AT91PS_LCDC) 	0x00500000) // (LCDC_16B_TFT) Base Address
N#define AT91C_BASE_HDMA_CH_0 (AT91_CAST(AT91PS_HDMA_CH) 	0xFFFFEC3C) // (HDMA_CH_0) Base Address
N#define AT91C_BASE_HDMA_CH_1 (AT91_CAST(AT91PS_HDMA_CH) 	0xFFFFEC64) // (HDMA_CH_1) Base Address
N#define AT91C_BASE_HDMA_CH_2 (AT91_CAST(AT91PS_HDMA_CH) 	0xFFFFEC8C) // (HDMA_CH_2) Base Address
N#define AT91C_BASE_HDMA_CH_3 (AT91_CAST(AT91PS_HDMA_CH) 	0xFFFFECB4) // (HDMA_CH_3) Base Address
N#define AT91C_BASE_HDMA_CH_4 (AT91_CAST(AT91PS_HDMA_CH) 	0xFFFFECDC) // (HDMA_CH_4) Base Address
N#define AT91C_BASE_HDMA_CH_5 (AT91_CAST(AT91PS_HDMA_CH) 	0xFFFFED04) // (HDMA_CH_5) Base Address
N#define AT91C_BASE_HDMA_CH_6 (AT91_CAST(AT91PS_HDMA_CH) 	0xFFFFED2C) // (HDMA_CH_6) Base Address
N#define AT91C_BASE_HDMA_CH_7 (AT91_CAST(AT91PS_HDMA_CH) 	0xFFFFED54) // (HDMA_CH_7) Base Address
N#define AT91C_BASE_HDMA      (AT91_CAST(AT91PS_HDMA) 	0xFFFFEC00) // (HDMA) Base Address
N#define AT91C_BASE_HECC      (AT91_CAST(AT91PS_ECC) 	0xFFFFE200) // (HECC) Base Address
N#define AT91C_BASE_EMACB     (AT91_CAST(AT91PS_EMAC) 	0xFFFBC000) // (EMACB) Base Address
N#define AT91C_BASE_ISI       (AT91_CAST(AT91PS_ISI) 	0xFFFB4000) // (ISI) Base Address
N#define AT91C_BASE_VDEC      (AT91_CAST(AT91PS_VDEC) 	0x00900000) // (VDEC) Base Address
N#define AT91C_BASE_UHPHS_OHCI (AT91_CAST(AT91PS_UHPHS_OHCI) 	0x00700000) // (UHPHS_OHCI) Base Address
N#define AT91C_BASE_UHPHS_EHCI (AT91_CAST(AT91PS_UHPHS_EHCI) 	0x00800000) // (UHPHS_EHCI) Base Address
N#define AT91C_BASE_TRNG      (AT91_CAST(AT91PS_TRNG) 	0xFFFCC000) // (TRNG) Base Address
N
N// *****************************************************************************
N//               MEMORY MAPPING DEFINITIONS FOR AT91SAM9M10
N// *****************************************************************************
N// ITCM
N#define AT91C_ITCM 	 (0x00100000) // Maximum ITCM Area base address
N#define AT91C_ITCM_SIZE	 (0x00008000) // Maximum ITCM Area size in byte (32 Kbytes)
N// DTCM
N#define AT91C_DTCM 	 (0x00200000) // Maximum DTCM Area base address
N#define AT91C_DTCM_SIZE	 (0x00010000) // Maximum DTCM Area size in byte (64 Kbytes)
N// IRAM
N#define AT91C_IRAM 	 (0x00300000) // Maximum Internal SRAM base address
N#define AT91C_IRAM_SIZE	 (0x00010000) // Maximum Internal SRAM size in byte (64 Kbytes)
N// IRAM_MIN
N#define AT91C_IRAM_MIN	 (0x00300000) // Minimum Internal RAM base address
N#define AT91C_IRAM_MIN_SIZE	 (0x00004000) // Minimum Internal RAM size in byte (16 Kbytes)
N// IROM
N#define AT91C_IROM 	 (0x00400000) // Internal ROM base address
N#define AT91C_IROM_SIZE	 (0x00010000) // Internal ROM size in byte (64 Kbytes)
N// EBI_CS0
N#define AT91C_EBI_CS0	 (0x10000000) // EBI Chip Select 0 base address
N#define AT91C_EBI_CS0_SIZE	 (0x10000000) // EBI Chip Select 0 size in byte (262144 Kbytes)
N// EBI_CS1
N#define AT91C_EBI_CS1	 (0x20000000) // EBI Chip Select 1 base address
N#define AT91C_EBI_CS1_SIZE	 (0x10000000) // EBI Chip Select 1 size in byte (262144 Kbytes)
N// EBI_SDRAM
N#define AT91C_EBI_SDRAM	 (0x20000000) // SDRAM on EBI Chip Select 1 base address
N#define AT91C_EBI_SDRAM_SIZE	 (0x10000000) // SDRAM on EBI Chip Select 1 size in byte (262144 Kbytes)
N// EBI_SDRAM_16BIT
N#define AT91C_EBI_SDRAM_16BIT	 (0x20000000) // SDRAM on EBI Chip Select 1 base address
N#define AT91C_EBI_SDRAM_16BIT_SIZE	 (0x02000000) // SDRAM on EBI Chip Select 1 size in byte (32768 Kbytes)
N// EBI_SDRAM_32BIT
N#define AT91C_EBI_SDRAM_32BIT	 (0x20000000) // SDRAM on EBI Chip Select 1 base address
N#define AT91C_EBI_SDRAM_32BIT_SIZE	 (0x04000000) // SDRAM on EBI Chip Select 1 size in byte (65536 Kbytes)
N// EBI_CS2
N#define AT91C_EBI_CS2	 (0x30000000) // EBI Chip Select 2 base address
N#define AT91C_EBI_CS2_SIZE	 (0x10000000) // EBI Chip Select 2 size in byte (262144 Kbytes)
N// EBI_CS3
N#define AT91C_EBI_CS3	 (0x40000000) // EBI Chip Select 3 base address
N#define AT91C_EBI_CS3_SIZE	 (0x10000000) // EBI Chip Select 3 size in byte (262144 Kbytes)
N// EBI_SM
N#define AT91C_EBI_SM	 (0x40000000) // NANDFLASH on EBI Chip Select 3 base address
N#define AT91C_EBI_SM_SIZE	 (0x10000000) // NANDFLASH on EBI Chip Select 3 size in byte (262144 Kbytes)
N// EBI_CS4
N#define AT91C_EBI_CS4	 (0x50000000) // EBI Chip Select 4 base address
N#define AT91C_EBI_CS4_SIZE	 (0x10000000) // EBI Chip Select 4 size in byte (262144 Kbytes)
N// EBI_CF0
N#define AT91C_EBI_CF0	 (0x50000000) // CompactFlash 0 on EBI Chip Select 4 base address
N#define AT91C_EBI_CF0_SIZE	 (0x10000000) // CompactFlash 0 on EBI Chip Select 4 size in byte (262144 Kbytes)
N// EBI_CS5
N#define AT91C_EBI_CS5	 (0x60000000) // EBI Chip Select 5 base address
N#define AT91C_EBI_CS5_SIZE	 (0x10000000) // EBI Chip Select 5 size in byte (262144 Kbytes)
N// EBI_CF1
N#define AT91C_EBI_CF1	 (0x60000000) // CompactFlash 1 on EBIChip Select 5 base address
N#define AT91C_EBI_CF1_SIZE	 (0x10000000) // CompactFlash 1 on EBIChip Select 5 size in byte (262144 Kbytes)
N// DDR2
N#define AT91C_DDR2 	 (0x70000000) // DDR2/LPDDR space base address
N#define AT91C_DDR2_SIZE	 (0x10000000) // DDR2/LPDDR space size in byte (262144 Kbytes)
N
N#endif
L 70 ".\atmel\board.h" 2
N
N
N//------------------------------------------------------------------------------
N//         Definitions
N//------------------------------------------------------------------------------
N
N//------------------------------------------------------------------------------
N/// \page "SAM9M10-EK - Board Description"
N/// This page lists several definition related to the board description.
N///
N/// !Definitions
N/// - BOARD_NAME
N
N/// Name of the board.
N#define BOARD_NAME              "AT91SAM9M10-EK"
N/// Board definition.
N#define at91sam9m10ek
N//------------------------------------------------------------------------------
N
N//------------------------------------------------------------------------------
N/// \page "SAM9M10-EK - Operating frequencies"
N/// This page lists several definition related to the board operating frequency
N/// (when using the initialization done by board_lowlevel.c).
N///
N/// !Definitions
N/// - BOARD_MAINOSC
N/// - BOARD_MCK
N
N/// Frequency of the board main oscillator.
N#define BOARD_MAINOSC           12000000
N
N/// Master clock frequency (when using board_lowlevel.c).
N// ((12MHz / DIVA / PLLADIV2 / MDIV) * (MULA+1)
N#define BOARD_MCK               ((unsigned long)((BOARD_MAINOSC / 3 / 2 / 3) * 200 )) // 133MHz
N//#define BOARD_MCK               ((unsigned long)((BOARD_MAINOSC / 3 / 2 / 4) * 200 )) // 100MHz
N
N//------------------------------------------------------------------------------
N
N//------------------------------------------------------------------------------
N/// \page "SAM9M10-EK - USB device"
N///
N/// !Constants
N/// - BOARD_USB_BMATTRIBUTES
N
N/// USB attributes configuration descriptor (bus or self powered, remote wakeup)
N//#define BOARD_USB_BMATTRIBUTES USBConfigurationDescriptor_SELFPOWERED_RWAKEUP
N#define BOARD_USB_BMATTRIBUTES   USBConfigurationDescriptor_SELFPOWERED_NORWAKEUP
N//------------------------------------------------------------------------------
N
N//------------------------------------------------------------------------------
N/// \page "SAM9M10-EK - PIO definitions"
N/// This pages lists all the pio definitions contained in board.h. The constants
N/// are named using the following convention: PIN_* for a constant which defines
N/// a single Pin instance (but may include several PIOs sharing the same
N/// controller), and PINS_* for a list of Pin instances.
N///
N/// !DBGU
N/// - PINS_DBGU
N///
N/// !LEDs
N/// - PIN_LED_0
N/// - PIN_LED_1
N/// - PINS_LEDS
N/// - LED_POWER
N/// - LED_DS1
N///
N/// !Push buttons
N/// - PIN_PUSHBUTTON_1
N/// - PIN_PUSHBUTTON_2
N/// - PINS_PUSHBUTTONS
N/// - PUSHBUTTON_BP1
N/// - PUSHBUTTON_BP2
N/// - JOYSTICK_LEFT
N/// - JOYSTICK_RIGHT
N///
N/// !Joystick buttons
N/// - PIN_JOYSTICK_UP
N/// - PIN_JOYSTICK_DOWN
N/// - PIN_JOYSTICK_LEFT
N/// - PIN_JOYSTICK_RIGHT
N/// - PIN_JOYSTICK_LCLIC, PIN_JOYSTICK_PUSH
N/// - PINS_JOYSTICK_MOVE, PINS_JOYSTICK_CLIC, PINS_JOYSTICK
N/// - JOYSTICK_UP
N/// - JOYSTICK_DOWN
N/// - JOYSTICK_LEFT
N/// - JOYSTICK_RIGHT
N/// - JOYSTICK_LCLIC, JOYSTICK_PUSH
N///
N/// !USART0
N/// - PIN_USART0_RXD
N/// - PIN_USART0_TXD
N///
N/// !SPI0
N/// - PIN_SPI0_MISO
N/// - PIN_SPI0_MOSI
N/// - PIN_SPI0_SPCK
N/// - PINS_SPI0
N/// - PIN_SPI0_NPCS0
N/// - PIN_SPI0_NPCS1
N///
N/// !SSC
N/// - PINS_SSC_TX
N///
N/// !USB
N/// - PIN_USB_VBUS
N///
N/// !MCI
N/// - PINS_MCI
N///
N/// !PWM
N/// - PIN_PWMC_PWM1
N/// - PIN_PWMC_PWM3
N/// - PIN_PWM_LED0
N/// - PIN_PWM_LED1
N/// - CHANNEL_PWM_LED0
N/// - CHANNEL_PWM_LED1
N///
N/// !TWI
N/// - PINS_TWI0
N///
N/// !TSADC
N/// - PINS_TSADCC
N
N/// List of all DBGU pin definitions.
N#define PINS_DBGU  {(1<<12) | (1<<13), AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT}
N
N/// LED #0 pin definition.
N#define PIN_LED_0   {1 << 0, AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_OUTPUT_1, PIO_DEFAULT}
N/// LED #1 pin definition.
N#define PIN_LED_1   {1 << 31, AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_OUTPUT_1, PIO_DEFAULT}
N/// List of all LED definitions.
N#define PINS_LEDS   PIN_LED_0, PIN_LED_1
N/// Power LED index.
N#define LED_POWER       0
N/// DS1 LED index.
N#define LED_DS1         1
N
N/// Push button #1 pin definition.
N#define PIN_PUSHBUTTON_1  {1 << 6, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_PULLUP}
N/// Pusb button #2 pin definition.
N#define PIN_PUSHBUTTON_2  {1 << 7, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_PULLUP}
N/// List of all pushbutton pin definitions.
N#define PINS_PUSHBUTTONS  PIN_PUSHBUTTON_1, PIN_PUSHBUTTON_2
N/// Push button #1 index.
N#define PUSHBUTTON_BP1   0
N/// Push button #2 index.
N#define PUSHBUTTON_BP2   1
N
N// Joystick definition.
N/// Joystick UP.
N#define PIN_JOYSTICK_UP    {1 << 16, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_PULLUP}
N/// Joystick DOWN.
N#define PIN_JOYSTICK_DOWN  {1 << 17, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_PULLUP}
N/// Joystick LEFT.
N#define PIN_JOYSTICK_LEFT  {1 << 14, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_PULLUP}
N/// Joystick RIGHT.
N#define PIN_JOYSTICK_RIGHT {1 << 15, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_PULLUP}
N/// Joystick LEFT clic.
N#define PIN_JOYSTICK_LCLIC {1 << 18, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_PULLUP}
N/// Joystick PUSH button.
N#define PIN_JOYSTICK_PUSH  PIN_JOYSTICK_LCLIC
N/// List of all Joystick click definitions
N#define PINS_JOYSTICK_CLIC   PIN_JOYSTICK_LCLIC
N/// List of all Joystick movement direction definitions
N#define PINS_JOYSTICK_MOVE  PIN_JOYSTICK_UP, PIN_JOYSTICK_DOWN, \
N                            PIN_JOYSTICK_LEFT, PIN_JOYSTICK_RIGHT
X#define PINS_JOYSTICK_MOVE  PIN_JOYSTICK_UP, PIN_JOYSTICK_DOWN,                             PIN_JOYSTICK_LEFT, PIN_JOYSTICK_RIGHT
N/// List of all Joystick definitions
N#define PINS_JOYSTICK  PINS_JOYSTICK_MOVE, \
N                       PINS_JOYSTICK_CLIC
X#define PINS_JOYSTICK  PINS_JOYSTICK_MOVE,                        PINS_JOYSTICK_CLIC
N/// Joystick UP index.
N#define JOYSTICK_UP         0
N/// Joystick DOWN index.
N#define JOYSTICK_DOWN       1
N/// Joystick LEFT index.
N#define JOYSTICK_LEFT       2
N/// Joystick RIGHT index.
N#define JOYSTICK_RIGHT      3
N/// Joystick LEFT CLICK index.
N#define JOYSTICK_LCLIC      4
N/// Joystick PUSH button index.
N#define JOYSTICK_PUSH       4
N
N/// USART0 TXD pin definition.
N#define PIN_USART0_TXD  {1 << 19, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT}
N/// USART0 RXD pin definition.
N#define PIN_USART0_RXD  {1 << 18, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT}
N/// USART0 RTS pin definition.
N#define PIN_USART0_RTS  {1 << 17, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_B, PIO_DEFAULT}
N/// USART0 CTS pin definition.
N#define PIN_USART0_CTS  {1 << 15, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_B, PIO_DEFAULT}
N/// USART0 SCK pin definition.
N#define PIN_USART0_SCK  {1 << 16, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_B, PIO_DEFAULT}
N/// USART1 TXD pin definition.
N#define PIN_USART1_TXD  {1 <<  4, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT}
N/// USART1 RXD pin definition.
N#define PIN_USART1_RXD  {1 <<  5, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT}
N/// USART1 RTS pin definition.
N#define PIN_USART1_RTS  {1 << 16, AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_PERIPH_B, PIO_DEFAULT}
N/// USART1 CTS pin definition.
N#define PIN_USART1_CTS  {1 << 17, AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_PERIPH_B, PIO_DEFAULT}
N/// USART1 SCK pin definition.
N#define PIN_USART1_SCK  {1 << 29, AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_PERIPH_B, PIO_DEFAULT}
N
N/// SPI0 MISO pin definition.
N#define PIN_SPI0_MISO  {1 << 0, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_A, PIO_PULLUP}
N/// SPI0 MOSI pin definition.
N#define PIN_SPI0_MOSI  {1 << 1, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT}
N/// SPI0 SPCK pin definition.
N#define PIN_SPI0_SPCK  {1 << 2, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT}
N/// List of SPI0 pin definitions (MISO, MOSI & SPCK).
N#define PINS_SPI0      PIN_SPI0_MISO, PIN_SPI0_MOSI, PIN_SPI0_SPCK
N/// SPI0 chip select 0 pin definition.
N#define PIN_SPI0_NPCS0 {1 << 3, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT}
N
N/// SSC transmitter pins definition.
N#define PINS_SSC_TX { (1 << 0) | (1 << 1) | (1 << 2), \
N                      AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_PERIPH_A, PIO_DEFAULT}
X#define PINS_SSC_TX { (1 << 0) | (1 << 1) | (1 << 2),                       AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_PERIPH_A, PIO_DEFAULT}
N
N/// USB VBus monitoring pin definition.
N#define PIN_USB_VBUS    {1 << 19, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_DEFAULT}
N
N/// USB VBus supply pin definition (SP2526A-2, active LOW, default to OFF).
N#define PIN_USB_POWER_ENA {1 << 1, AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_OUTPUT_1, PIO_DEFAULT}
N#define PIN_USB_POWER_ENB {1 << 3, AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_OUTPUT_1, PIO_DEFAULT}
N
N/// List of MCI pins definitions.
N#define PINS_MCI0 \
N    {(0x3EUL <<  0), AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_A, PIO_PULLUP}, \
N    {(0x1UL <<  0), AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT}
X#define PINS_MCI0     {(0x3EUL <<  0), AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_A, PIO_PULLUP},     {(0x1UL <<  0), AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT}
N#define PINS_MCI1 \
N    {(0x1FUL << 22), AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_A, PIO_PULLUP}, \
N    {(0x1UL <<  31), AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT}
X#define PINS_MCI1     {(0x1FUL << 22), AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_A, PIO_PULLUP},     {(0x1UL <<  31), AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT}
N#define PIN_MCI0_DAT0 \
N    {AT91C_PIO_PA2, AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_A, PIO_PULLUP}
X#define PIN_MCI0_DAT0     {AT91C_PIO_PA2, AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_A, PIO_PULLUP}
N#define PIN_MCI1_DAT1 \
N    {AT91C_PIO_PA23, AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_A, PIO_PULLUP}
X#define PIN_MCI1_DAT1     {AT91C_PIO_PA23, AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_A, PIO_PULLUP}
N#define PINS_MCI0_CD \
N    {AT91C_PIO_PD10, AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_INPUT, PIO_PULLUP}
X#define PINS_MCI0_CD     {AT91C_PIO_PD10, AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_INPUT, PIO_PULLUP}
N#define PINS_MCI1_CD \
N    {AT91C_PIO_PD11, AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_INPUT, PIO_PULLUP}
X#define PINS_MCI1_CD     {AT91C_PIO_PD11, AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_INPUT, PIO_PULLUP}
N#define PINS_MCI1_WP \
N    {AT91C_PIO_PD29, AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_INPUT, PIO_PULLUP}
X#define PINS_MCI1_WP     {AT91C_PIO_PD29, AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_INPUT, PIO_PULLUP}
N
N/*
N#define PINS_MCI  \
N    {0x0000003B, AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_B, PIO_PULLUP}, \
N    {1 << 8, AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT}
X
N*/
N
N/// PWMC PWM0 pin definition.
N#define PIN_PWMC_PWM0  {1 << 24, AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_PERIPH_B, PIO_DEFAULT}
N/// PWMC PWM1 pin definition.
N#define PIN_PWMC_PWM1  {1 << 31, AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_PERIPH_B, PIO_DEFAULT}
N/// PWMC PWM2 pin definition.
N#define PIN_PWMC_PWM2  {1 << 26, AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_PERIPH_B, PIO_DEFAULT}
N/// PWMC PWM2 pin definition.
N#define PIN_PWMC_PWM3  {1 <<  0, AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_PERIPH_B, PIO_DEFAULT}
N
N/// PWM pin definition for LED0
N#define PIN_PWM_LED0 PIN_PWMC_PWM3
N/// PWM pin definition for LED1
N#define PIN_PWM_LED1 PIN_PWMC_PWM1
N/// PWM channel for LED0
N#define CHANNEL_PWM_LED0 3
N/// PWM channel for LED1
N#define CHANNEL_PWM_LED1 1
N
N/// TWI  version 3xx
N#define TWI_V3XX
N/// TWI pins definition.
N#define PINS_TWI0  {(1<<20) | (1<<21), AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT}
N
N/// TSADCC pins definition.
N#define PINS_TSADCC {(1 << 20)|(1 << 21)|(1 << 22)|(1 << 23),\
N                     AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_PERIPH_A, PIO_DEFAULT}
X#define PINS_TSADCC {(1 << 20)|(1 << 21)|(1 << 22)|(1 << 23),                     AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_PERIPH_A, PIO_DEFAULT}
N
N/// PCK0: PA31.B, PD12.B, PE0.B
N//#define PIN_PCK0    {1 << 12, AT91C_BASE_PIOA, AT91C_ID_PIOABCD, PIO_PERIPH_B, PIO_DEFAULT}
N/// PCK1: PB31.B, PE31.B, 
N#define PIN_PCK1    {1 << 31, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_B, PIO_DEFAULT}
N
N/// PIN used for reset the smartcard
N#define PIN_ISO7816_RSTMC       {1 << 7, AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_OUTPUT_0, PIO_DEFAULT}
N
N/// Pins used for connect the smartcard
N#define PINS_ISO7816            PIN_USART0_TXD, PIN_USART0_SCK, PIN_ISO7816_RSTMC
N
N/// IRDA SD pin
N#define PIN_IRDA_SD {0x1 << 8, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_OUTPUT_1, PIO_DEFAULT}
N
N//------------------------------------------------------------------------------
N
N//------------------------------------------------------------------------------
N/// \page "SAM9M10-EK - External components"
N/// This page lists the definitions related to external on-board components
N/// located in the board.h file for the AT91SAM9M10-EK.
N///
N/// !AT45 Dataflash Card (A)
N/// - BOARD_AT45_A_SPI_BASE
N/// - BOARD_AT45_A_SPI_ID
N/// - BOARD_AT45_A_SPI_PINS
N/// - BOARD_AT45_A_SPI
N/// - BOARD_AT45_A_NPCS
N/// - BOARD_AT45_A_NPCS_PIN
N///
N/// !AT45 Dataflash (B)
N/// - BOARD_AT45_B_SPI_BASE
N/// - BOARD_AT45_B_SPI_ID
N/// - BOARD_AT45_B_SPI_PINS
N/// - BOARD_AT45_B_SPI
N/// - BOARD_AT45_B_NPCS
N/// - BOARD_AT45_B_NPCS_PIN
N///
N/// !LCD
N/// - PINS_LCD
N/// - BOARD_LCD_WIDTH
N/// - BOARD_LCD_HEIGHT
N/// - BOARD_LCD_BPP
N/// - BOARD_LCD_IFWIDTH
N/// - BOARD_LCD_FRAMESIZE_PIXELS
N/// - BOARD_LCD_FRAMESIZE
N/// - BOARD_LCD_FRAMERATE
N/// - BOARD_LCD_PIXELCLOCK
N/// - BOARD_LCD_DISPLAYTYPE
N/// - BOARD_LCD_POLARITY_INVVD
N/// - BOARD_LCD_POLARITY_INVFRAME
N/// - BOARD_LCD_POLARITY_INVLINE
N/// - BOARD_LCD_POLARITY_INVCLK
N/// - BOARD_LCD_POLARITY_INVDVAL
N/// - BOARD_LCD_CLOCKMODE
N/// - BOARD_LCD_TIMING_VFP
N/// - BOARD_LCD_TIMING_VBP
N/// - BOARD_LCD_TIMING_VPW
N/// - BOARD_LCD_TIMING_VHDLY
N/// - BOARD_LCD_TIMING_HFP
N/// - BOARD_LCD_TIMING_HBP
N/// - BOARD_LCD_TIMING_HPW
N///
N/// !LCD
N/// - PINS_LCD
N/// - BOARD_LCD_WIDTH
N/// - BOARD_LCD_HEIGHT
N/// - BOARD_LCD_BPP
N/// - BOARD_LCD_IFWIDTH
N/// - BOARD_LCD_FRAMESIZE_PIXELS
N/// - BOARD_LCD_FRAMESIZE
N/// - BOARD_LCD_FRAMERATE
N/// - BOARD_LCD_PIXELCLOCK
N/// - BOARD_LCD_DISPLAYTYPE
N/// - BOARD_LCD_POLARITY_INVVD
N/// - BOARD_LCD_POLARITY_INVFRAME
N/// - BOARD_LCD_POLARITY_INVLINE
N/// - BOARD_LCD_POLARITY_INVCLK
N/// - BOARD_LCD_POLARITY_INVDVAL
N/// - BOARD_LCD_CLOCKMODE
N/// - BOARD_LCD_TIMING_VFP
N/// - BOARD_LCD_TIMING_VBP
N/// - BOARD_LCD_TIMING_VPW
N/// - BOARD_LCD_TIMING_VHDLY
N/// - BOARD_LCD_TIMING_HFP
N/// - BOARD_LCD_TIMING_HBP
N/// - BOARD_LCD_TIMING_HPW
N/// 
N/// !Touchscreen
N/// - BOARD_TOUCHSCREEN_ADCCLK
N/// - BOARD_TOUCHSCREEN_STARTUP
N/// - BOARD_TOUCHSCREEN_SHTIM
N/// - BOARD_TOUCHSCREEN_DEBOUNCE
N/// 
N/// !SD Card
N/// - BOARD_SD_MCI_BASE
N/// - BOARD_SD_MCI_ID
N/// - BOARD_SD_PINS
N/// - BOARD_SD_SLOT
N/// - BOARD_SD_BOOT_MCISLOT
N///
N/// !AC97
N/// - PINS_AC97
N///
N/// !ISI
N/// - BOARD_ISI_PIO_CNTRL1
N/// - BOARD_ISI_PIO_CNTRL2
N/// - BOARD_ISI_TWCK
N/// - BOARD_ISI_TWD
N/// - BOARD_ISI_MCK
N/// - BOARD_ISI_VSYNC
N/// - BOARD_ISI_HSYNC
N/// - BOARD_ISI_PCK
N/// - BOARD_ISI_PINS_DATA
N
N/// Base address of SPI peripheral connected to the dataflash.
N#define BOARD_AT45_A_SPI_BASE         AT91C_BASE_SPI0
N/// Identifier of SPI peripheral connected to the dataflash.
N#define BOARD_AT45_A_SPI_ID           AT91C_ID_SPI0
N/// Pins of the SPI peripheral connected to the dataflash.
N#define BOARD_AT45_A_SPI_PINS         PINS_SPI0
N/// Dataflash SPI number.
N#define BOARD_AT45_A_SPI              0
N/// Chip select connected to the dataflash.
N#define BOARD_AT45_A_NPCS             0
N/// Chip select pin connected to the dataflash.
N#define BOARD_AT45_A_NPCS_PIN         PIN_SPI0_NPCS0
N
N
N/// Base address of SPI peripheral connected to the serialflash.
N#define BOARD_AT26_A_SPI_BASE         AT91C_BASE_SPI0
N/// Identifier of SPI peripheral connected to the dataflash.
N#define BOARD_AT26_A_SPI_ID           AT91C_ID_SPI0
N/// Pins of the SPI peripheral connected to the dataflash.
N#define BOARD_AT26_A_SPI_PINS         PINS_SPI0
N/// Dataflahs SPI number.
N#define BOARD_AT26_A_SPI              0
N/// Chip select connected to the dataflash.
N#define BOARD_AT26_A_NPCS             0
N/// Chip select pin connected to the dataflash.
N#define BOARD_AT26_A_NPCS_PIN         PIN_SPI0_NPCS0
N
N/// LCD pin list.
N#define PINS_LCD    \
N    {0x7FFFFFFD, AT91C_BASE_PIOE, AT91C_ID_PIOD_E, PIO_PERIPH_A, PIO_DEFAULT}
X#define PINS_LCD        {0x7FFFFFFD, AT91C_BASE_PIOE, AT91C_ID_PIOD_E, PIO_PERIPH_A, PIO_DEFAULT}
N
N/// LCD enable & disable pin list
N#define BOARD_LCD_ENABLE     {0x05, AT91C_BASE_PIOE, AT91C_ID_PIOD_E, PIO_OUTPUT_1, PIO_DEFAULT},\
N                             {0x40, AT91C_BASE_PIOE, AT91C_ID_PIOD_E, PIO_PERIPH_A, PIO_DEFAULT}
X#define BOARD_LCD_ENABLE     {0x05, AT91C_BASE_PIOE, AT91C_ID_PIOD_E, PIO_OUTPUT_1, PIO_DEFAULT},                             {0x40, AT91C_BASE_PIOE, AT91C_ID_PIOD_E, PIO_PERIPH_A, PIO_DEFAULT}
N#define BOARD_LCD_DISABLE    {0x45, AT91C_BASE_PIOE, AT91C_ID_PIOD_E, PIO_OUTPUT_0, PIO_DEFAULT}
N
N/// TV enable & disable pin list
N#define BOARD_TV_ENABLE      {0x40, AT91C_BASE_PIOE, AT91C_ID_PIOD_E, PIO_PERIPH_A, PIO_DEFAULT}
N#define BOARD_TV_DISABLE     {0x40, AT91C_BASE_PIOE, AT91C_ID_PIOD_E, PIO_OUTPUT_0, PIO_DEFAULT}
N
N/// Board is wired in RGB 565.
N#define BOARD_LCD_BGR565
N/// LCD pixel clock is not divide by two
N#define LCDC_PIXELCLOCK_DOUBLE
N/// Display width in pixels.
N#define BOARD_LCD_WIDTH             480
N/// Display height in pixels.
N#define BOARD_LCD_HEIGHT            272
N/// Display resolution in bits per pixel (bpp).
N#define BOARD_LCD_BPP               AT91C_LCDC_PIXELSIZE_TWENTYFOURBITSPERPIXEL
N/// Display interface width in bits.
N#define BOARD_LCD_IFWIDTH           24
N/// Frame size in pixels (height * width * bpp).
N#define BOARD_LCD_FRAMESIZE_PIXELS  (BOARD_LCD_WIDTH * BOARD_LCD_HEIGHT * 24)
N/// Frame size in words (height * width * bpp / 32)
N#define BOARD_LCD_FRAMESIZE         (BOARD_LCD_FRAMESIZE_PIXELS / 32)
N/// Frame rate in Hz.
N#define BOARD_LCD_FRAMERATE         60
N/// Pixel clock rate in Hz (frameSize * frameRate / interfaceWidth).
N#define BOARD_LCD_PIXELCLOCK        (BOARD_LCD_FRAMESIZE_PIXELS * BOARD_LCD_FRAMERATE / BOARD_LCD_IFWIDTH)
N/// LCD display type.
N#define BOARD_LCD_DISPLAYTYPE       AT91C_LCDC_DISTYPE_TFT
N/// LCDC polarity.
N#define BOARD_LCD_POLARITY_INVVD    AT91C_LCDC_INVVD_NORMALPOL
N/// LCDVSYNC polarity.
N#define BOARD_LCD_POLARITY_INVFRAME AT91C_LCDC_INVFRAME_INVERTEDPOL
N/// LCDHSYNC polarity.
N#define BOARD_LCD_POLARITY_INVLINE  AT91C_LCDC_INVLINE_INVERTEDPOL
N/// LCDDOTCLK polarity.
N#define BOARD_LCD_POLARITY_INVCLK   AT91C_LCDC_INVCLK_NORMALPOL
N/// LCDDEN polarity.
N#define BOARD_LCD_POLARITY_INVDVAL  AT91C_LCDC_INVDVAL_NORMALPOL
N/// Pixel clock mode.
N#define BOARD_LCD_CLOCKMODE         AT91C_LCDC_CLKMOD_ALWAYSACTIVE
N/// Vertical front porch in number of lines.
N#define BOARD_LCD_TIMING_VFP        4
N/// Vertical back porch in number of lines.
N#define BOARD_LCD_TIMING_VBP        4
N/// Vertical pulse width in LCDDOTCLK cycles.
N#define BOARD_LCD_TIMING_VPW        4
N/// Number of cycles between VSYNC edge and HSYNC rising edge.
N#define BOARD_LCD_TIMING_VHDLY      2
N/// Horizontal front porch in LCDDOTCLK cycles.
N#define BOARD_LCD_TIMING_HFP        5
N/// Horizontal back porch in LCDDOTCLK cycles.
N#define BOARD_LCD_TIMING_HBP        5
N/// Horizontal pulse width in LCDDOTCLK cycles.
N#define BOARD_LCD_TIMING_HPW        5
N/// Touchscreen ADC clock frequency to use.
N#define BOARD_TOUCHSCREEN_ADCCLK    300000 // 8MHz max
N/// Touchscreen ADC startup time in seconds.
N#define BOARD_TOUCHSCREEN_STARTUP   40
N/// Touchscreen ADC track and hold time in nanoseconds.
N#define BOARD_TOUCHSCREEN_SHTIM     2000    // min 1s at 8MHz
N/// Touchscreen pen debounce time in nanoseconds.
N#define BOARD_TOUCHSCREEN_DEBOUNCE  10000000
N
N/// Base address of the MCI peripheral connected to the SD card.
N#define BOARD_SD_MCI_BASE           AT91C_BASE_MCI0
N#if defined(ORIGIN_SD_PORT_MCI1)
X#if 0L
S#undef BOARD_SD_MCI_BASE
S#define BOARD_SD_MCI_BASE           AT91C_BASE_MCI1
N#endif
N#define BOARD_SD_MCI1_BASE           AT91C_BASE_MCI1
N/// Dma channel number the mci is using
N#define BOARD_MCI_DMA_CHANNEL       0
N/// Peripheral identifier of the MCI connected to the SD card.
N#define BOARD_SD_MCI_ID             AT91C_ID_MCI0
N#if defined(ORIGIN_SD_PORT_MCI1)
X#if 0L
S#undef BOARD_SD_MCI_ID
S#define BOARD_SD_MCI_ID             AT91C_ID_MCI1
N#endif
N#define BOARD_SD_MCI1_ID             AT91C_ID_MCI1
N/// MCI pins that shall be configured to access the SD card.
N#define BOARD_SD_PINS               PINS_MCI0
N#define BOARD_SD_DAT0               PIN_MCI0_DAT0
N#if defined(ORIGIN_SD_PORT_MCI1)
X#if 0L
S#undef BOARD_SD_PINS
S#define BOARD_SD_PINS               PINS_MCI1
S#undef BOARD_SD_DAT0
S#define BOARD_SD_DAT0               PIN_MCI1_DAT0
N#endif
N#define BOARD_SD_MCI1_PINS          PINS_MCI1
N/// MCI slot to which the SD card is connected to.
N#define BOARD_SD_SLOT               MCI_SD_SLOTA
N#if defined(ORIGIN_SD_PORT_MCI1)
X#if 0L
S#undef BOARD_SD_SLOT
S#define BOARD_SD_SLOT               MCI_SD_SLOTA  // MCI1 using MCI1's slotA
N#endif
N#define BOARD_SD_MCI1_SLOT          MCI_SD_SLOTA  // MCI1 using MCI1's slotA
N/// SD card write protection pin definition.
N//#define BOARD_SD_PIN_WP             PINS_MCI1_WP
N/// SD card detection pin definition.
N#define BOARD_SD_PIN_CD             PINS_MCI0_CD
N#if defined(ORIGIN_SD_PORT_MCI1)
X#if 0L
S#undef BOARD_SD_PIN_CD
S#define BOARD_SD_PIN_CD             PINS_MCI1_CD
N#endif
N#define BOARD_SD_MCI1_PIN_CD             PINS_MCI1_CD
N/// MCI0 DMA hardware handshaking ID
N#define DMA_HW_SRC_REQ_ID_MCI0      AT91C_HDMA_SRC_PER_0
N#define DMA_HW_DEST_REQ_ID_MCI0     AT91C_HDMA_DST_PER_0
N/// MCI1 DMA hardware handshaking ID
N#define DMA_HW_SRC_REQ_ID_MCI1      AT91C_HDMA_SRC_PER_13
N#define DMA_HW_DEST_REQ_ID_MCI1     AT91C_HDMA_DST_PER_13
N/// SD DMA hardware handshaking ID
N#define BOARD_SD_DMA_HW_SRC_REQ_ID      DMA_HW_SRC_REQ_ID_MCI0
N#define BOARD_SD_DMA_HW_DEST_REQ_ID     DMA_HW_DEST_REQ_ID_MCI0
N#if defined(ORIGIN_SD_PORT_MCI1)
X#if 0L
S#undef BOARD_SD_DMA_HW_SRC_REQ_ID
S#define BOARD_SD_DMA_HW_SRC_REQ_ID      DMA_HW_SRC_REQ_ID_MCI1
S#undef BOARD_SD_DMA_HW_DEST_REQ_ID
S#define BOARD_SD_DMA_HW_DEST_REQ_ID     DMA_HW_DEST_REQ_ID_MCI1
N#endif
N/// SD boot slot
N#define BOARD_SD_BOOT_MCISLOT    0
N
N/// PHY address
N#define BOARD_EMAC_PHY_ADDR         0
N/// PHY Component
N#define BOARD_EMAC_PHY_COMP_DM9161  1
N/// Board EMAC power control - ALWAYS ON
N#define BOARD_EMAC_POWER_ALWAYS_ON
N/// Board EMAC work mode - RMII/MII ( 1 / 0 )
N#define BOARD_EMAC_MODE_RMII        1
N
N/// The PIN list of PIO for EMAC
N#define BOARD_EMAC_PINS     {  (1<<27)|(1<<28)|(1<<29)|(1<<30)\
N                              |(1<< 6)|(1<< 7)|(1<< 8)|(1<< 9),\
N                              AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_B, PIO_DEFAULT}, \
N                            {  (1<<10)|(1<<11)|(1<<12)|(1<<13)|(1<<14)|(1<<15)\
N                              |(1<<16)|(1<<17)|(1<<18)|(1<<19),\
N                              AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT}
X#define BOARD_EMAC_PINS     {  (1<<27)|(1<<28)|(1<<29)|(1<<30)                              |(1<< 6)|(1<< 7)|(1<< 8)|(1<< 9),                              AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_B, PIO_DEFAULT},                             {  (1<<10)|(1<<11)|(1<<12)|(1<<13)|(1<<14)|(1<<15)                              |(1<<16)|(1<<17)|(1<<18)|(1<<19),                              AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT}
N/// The power up reset latch PIO for PHY
N#define BOARD_EMAC_PIN_TEST   {(1<<15), AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_OUTPUT_0, PIO_DEFAULT}//RX_DV
N#define BOARD_EMAC_PIN_RMII   {(1<<30), AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_OUTPUT_1, PIO_DEFAULT}//COL
N// We force the address
N//(1<<12) RXD0/PHY address 0, (1<<13) RXD1/PHY address 1, (1<<8) RXD2/PHY address 2,
N//(1<<9) RXD3/PHY address 3, (1<<29) CRS/PHY address 4
N#define BOARD_EMAC_PINS_PHYAD {(1<<12)|(1<<13)|(1<<8)|(1<<9)|(1<<29),\
N                               AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_OUTPUT_1, PIO_DEFAULT}
X#define BOARD_EMAC_PINS_PHYAD {(1<<12)|(1<<13)|(1<<8)|(1<<9)|(1<<29),                               AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_OUTPUT_1, PIO_DEFAULT}
N#define BOARD_EMAC_PIN_10BT   {(1<<28), AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_OUTPUT_0, PIO_DEFAULT}//RX_CLK
N#define BOARD_EMAC_PIN_RPTR   {(1<<16), AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_OUTPUT_0, PIO_DEFAULT}//RX_ER/RXD4
N/// The PIN Configure list for EMAC on power up reset (RMII)
N#define BOARD_EMAC_RST_PINS BOARD_EMAC_PINS_PHYAD, \
N                            BOARD_EMAC_PIN_TEST, BOARD_EMAC_PIN_RMII, \
N                            BOARD_EMAC_PIN_10BT, BOARD_EMAC_PIN_RPTR
X#define BOARD_EMAC_RST_PINS BOARD_EMAC_PINS_PHYAD,                             BOARD_EMAC_PIN_TEST, BOARD_EMAC_PIN_RMII,                             BOARD_EMAC_PIN_10BT, BOARD_EMAC_PIN_RPTR
N
N/// The runtime pin configure list for EMAC
N#define BOARD_EMAC_RUN_PINS BOARD_EMAC_PINS
N
N/// AC97 pins definition.
N#define PINS_AC97   {(1<<6)|(1<<7)|(1<<8)|(1<<9),\
N                     AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_PERIPH_A, PIO_DEFAULT}
X#define PINS_AC97   {(1<<6)|(1<<7)|(1<<8)|(1<<9),                     AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_PERIPH_A, PIO_DEFAULT}
N
N/// ISI
N#define BOARD_ISI_V200
N#define BOARD_CAPTOR_OV2640
N#define BOARD_ISI_PIO_CTRL1 {(1<<12), AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_OUTPUT_0, PIO_DEFAULT}
N#define BOARD_ISI_PIO_CTRL2 {(1<<13), AT91C_BASE_PIOD, AT91C_ID_PIOD_E, PIO_OUTPUT_0, PIO_DEFAULT}
N#define BOARD_ISI_TWCK      {(1<<21), AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT}
N#define BOARD_ISI_TWD       {(1<<20), AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_PERIPH_A, PIO_DEFAULT}
N// PCK1 use instead of ISI_MCK
N#define BOARD_ISI_MCK       {(1<<31), AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_B, PIO_DEFAULT}
N#define BOARD_ISI_VSYNC     {(1<<29), AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT}
N#define BOARD_ISI_HSYNC     {(1<<30), AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT}
N#define BOARD_ISI_PCK       {(1<<28), AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT}
N#define BOARD_ISI_PINS_DATA {(1<<20)|(1<<21)|(1<<22)|(1<<23)|(1<<24)|(1<<25)|(1<<26)|(1<<27),\
N                             AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT},\
N                            {(1<<8)|(1<<9)|(1<<10)|(1<<11),\
N                             AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_B, PIO_DEFAULT}
X#define BOARD_ISI_PINS_DATA {(1<<20)|(1<<21)|(1<<22)|(1<<23)|(1<<24)|(1<<25)|(1<<26)|(1<<27),                             AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_A, PIO_DEFAULT},                            {(1<<8)|(1<<9)|(1<<10)|(1<<11),                             AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_PERIPH_B, PIO_DEFAULT}
N//------------------------------------------------------------------------------
N
N//------------------------------------------------------------------------------
N/// \page "SAM9M10-EK - Memories"
N/// This page lists definitions related to external on-board memories.
N///
N/// !DDRAM
N/// - BOARD_DDRAM_SIZE
N/// - PINS_DDRAM
N/// - BOARD_DDRAM_BUSWIDTH
N/// - BOARD_SDRAM_BUSWIDTH
N///
N/// !Nandflash
N/// - PINS_NANDFLASH
N/// - BOARD_NF_EBI_COMMAND_ADDR
N/// - BOARD_NF_EBI_ADDRESS_ADDR
N/// - BOARD_NF_EBI_DATA_ADDR
N/// - BOARD_NF_CE_PIN
N/// - BOARD_NF_RB_PIN
N///
N/// !NorFlash
N/// - BOARD_NORFLASH_ADDR
N/// - BOARD_NORFLASH_DFT_BUS_SIZE
N
N/// Board DDRAM size
N#define BOARD_DDRAM_SIZE        (128*1024*1024)  // 128 MB
N/// List of all SDRAM pins definitions.
N#define PINS_DDRAM              {0xFFFF0000, AT91C_BASE_PIOC, AT91C_ID_PIOC, PIO_PERIPH_A, PIO_DEFAULT}
N/// DDRAM bus width.
N#define BOARD_DDRAM_BUSWIDTH    16
N/// SDRAM bus width.
N#define BOARD_SDRAM_BUSWIDTH    32
N
N/// Nandflash controller peripheral pins definition.
N#define PINS_NANDFLASH          BOARD_NF_CE_PIN, BOARD_NF_RB_PIN
N/// Nandflash chip enable pin definition.
N#define BOARD_NF_CE_PIN         {1 << 14, AT91C_BASE_PIOC, AT91C_ID_PIOC, PIO_OUTPUT_1, PIO_DEFAULT}
N/// Nandflash ready/busy pin definition.
N#define BOARD_NF_RB_PIN         {1 << 8, AT91C_BASE_PIOC, AT91C_ID_PIOC, PIO_INPUT, PIO_PULLUP}
N/// Address for transferring command bytes to the nandflash.
N#define BOARD_NF_COMMAND_ADDR   0x40400000
N/// Address for transferring address bytes to the nandflash.
N#define BOARD_NF_ADDRESS_ADDR   0x40200000
N/// Address for transferring data bytes to the nandflash.
N#define BOARD_NF_DATA_ADDR      0x40000000
N
N/// Address for transferring command bytes to the norflash.
N#define BOARD_NORFLASH_ADDR     0x10000000
N/// Default NOR bus size after power up reset
N#define BOARD_NORFLASH_DFT_BUS_SIZE 16
N//------------------------------------------------------------------------------
N
N//------------------------------------------------------------------------------
N/// \page "SAM9M10-EK- Individual chip definition"
N/// This page lists the definitions related to different chip's definition
N/// located in the board.h file for the SAM9M10-EK.
N#define BOARD_RTC_ID                AT91C_ID_SYS
N
N/// Twi eeprom
N#define BOARD_ID_TWI_EEPROM         AT91C_ID_TWI0
N#define BOARD_BASE_TWI_EEPROM       AT91C_BASE_TWI0
N#define BOARD_PINS_TWI_EEPROM       PINS_TWI0
N
N/// USART
N#define BOARD_PIN_USART_RXD        PIN_USART1_RXD
N#define BOARD_PIN_USART_TXD        PIN_USART1_TXD
N#define BOARD_PIN_USART_CTS        PIN_USART1_CTS
N#define BOARD_PIN_USART_RTS        PIN_USART1_RTS
N#define BOARD_USART_BASE           AT91C_BASE_US1
N#define BOARD_ID_USART             AT91C_ID_US1
N//------------------------------------------------------------------------------
N
N#endif //#ifndef BOARD_H
N
L 207 "atmel\sdmmc_mci.h" 2
N
N
N#include <mci_hs.h>
L 1 ".\atmel\mci_hs.h" 1
N/* ----------------------------------------------------------------------------
N *         ATMEL Microcontroller Software Support
N * ----------------------------------------------------------------------------
N * Copyright (c) 2008, Atmel Corporation
N *
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N * - Redistributions of source code must retain the above copyright notice,
N * this list of conditions and the disclaimer below.
N *
N * Atmel's name may not be used to endorse or promote products derived from
N * this software without specific prior written permission.
N *
N * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
N * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
N * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
N * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
N * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
N * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
N * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
N * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * ----------------------------------------------------------------------------
N */
N
N//------------------------------------------------------------------------------
N/// \page "mci"
N///
N/// !Purpose
N///  
N/// mci-interface driver
N///
N/// !Usage
N///
N/// -# MCI_Init: Initializes a MCI driver instance and the underlying peripheral.
N/// -# MCI_SetSpeed : Configure the  MCI CLKDIV in the MCI_MR register.
N/// -# MCI_SendCommand: Starts a MCI  transfer.
N/// -# MCI_Handler : Interrupt handler which is called by ISR handler.
N/// -# MCI_SetBusWidth : Configure the  MCI SDCBUS in the MCI_SDCR register.
N//------------------------------------------------------------------------------
N
N
N#ifndef MCI_HS_H
N#define MCI_HS_H
N
N//------------------------------------------------------------------------------
N//         Compile Options
N//------------------------------------------------------------------------------
N
N/// MCI using DMA?
N#define MCI_DMA_ENABLE          1
N
N/// MCI BUSY Check Fix
N#define MCI_BUSY_CHECK_FIX      0
N
N/// MCI support SDIO
N#define MCI_SDIO_ENABLE         0
N
N//------------------------------------------------------------------------------
N//         Headers
N//------------------------------------------------------------------------------
N
N#include <board.h>
N#if MCI_BUSY_CHECK_FIX
X#if 0
S#include <pio/pio.h>
N#endif
N
N//------------------------------------------------------------------------------
N//         Constants
N//------------------------------------------------------------------------------
N
N/// Transfer is pending.
N#define MCI_STATUS_PENDING      1
N/// Transfer has been aborted because an error occured.
N#define MCI_STATUS_ERROR        2
N/// Card did not answer command.
N#define MCI_STATUS_NORESPONSE   3
N
N/// MCI driver is currently in use.
N#define MCI_ERROR_LOCK    1
N
N/// MCI configuration with 1-bit data bus on slot A (for MMC cards).
N#define MCI_MMC_SLOTA           (AT91C_MCI_SCDSEL_SLOTA | AT91C_MCI_SCDBUS_1BIT)
N/// MCI configuration with 4-bit data bus on slot A (for SD cards).
N#define MCI_SD_SLOTA            (AT91C_MCI_SCDSEL_SLOTA | AT91C_MCI_SCDBUS_4BITS)
N#ifdef AT91C_MCI_SCDBUS_8BITS
N/// MCI configuration with 1-bit data bus on slot A (for MMC cards).
N#define MCI_MMC4_SLOTA          (AT91C_MCI_SCDSEL_SLOTA | AT91C_MCI_SCDBUS_8BITS)
N#endif
N#ifdef AT91C_MCI_SCDSEL_SLOTB
N/// MCI configuration with 1-bit data bus on slot B (for MMC cards).
N#define MCI_MMC_SLOTB           (AT91C_MCI_SCDSEL_SLOTB | AT91C_MCI_SCDBUS_1BIT)
N/// MCI configuration with 4-bit data bus on slot B (for SD cards).
N#define MCI_SD_SLOTB            (AT91C_MCI_SCDSEL_SLOTB | AT91C_MCI_SCDBUS_4BITS)
N#ifdef AT91C_MCI_SCDBUS_8BITS
N/// MCI configuration with 1-bit data bus on slot A (for MMC cards).
N#define MCI_MMC4_SLOTB          (AT91C_MCI_SCDSEL_SLOTB | AT91C_MCI_SCDBUS_8BITS)
N#endif
N#else
S#define MCI_MMC_SLOTB           MCI_MMC_SLOTA
S#define MCI_SD_SLOTB            MCI_SD_SLOTA
N#endif
N
N/// Start new data transfer
N#define MCI_NEW_TRANSFER        0
N/// Continue data transfer
N#define MCI_CONTINUE_TRANSFER   1
N/// Stop data transfer
N#define MCI_STOP_TRANSFER       2
N
N/// MCI SD Bus Width 1-bit
N#define MCI_SDCBUS_1BIT (0 << 7)
N/// MCI SD Bus Width 4-bit
N#define MCI_SDCBUS_4BIT (1 << 7)
N/// MCI SD Bus Width 8-bit
N#define MCI_SDCBUS_8BIT (3 << 6)
N
N/// The MCI Clock Speed after initialize (400K)
N#define MCI_INITIAL_SPEED       400000
N
N#define MCI_INTERRUPT_MODE 0
N#define MCI_POLLING_MODE   1
N
N//------------------------------------------------------------------------------
N//         Types
N//------------------------------------------------------------------------------
N
N/// MCI end-of-transfer callback function.
Ntypedef void (*MciCallback)(unsigned char status, void *pCommand);
N
N//------------------------------------------------------------------------------
N/// MCI Transfer Request prepared by the application upper layer. This structure
N/// is sent to the MCI_SendCommand function to start the transfer. At the end of
N/// the transfer, the callback is invoked by the interrupt handler.
N//------------------------------------------------------------------------------
Ntypedef struct _MciCmd {
N
N    /// Command code.
N    unsigned int cmd;
N    /// Command argument.
N    unsigned int arg;
N    /// Data buffer, with MCI_DMA_ENABLE defined 1, the buffer can be
N    /// 1, 2 or 4 bytes aligned. It has to be 4 byte aligned if no DMA.
N    unsigned char *pData;
N    /// Size of data block in bytes.
N    unsigned short blockSize;
N    /// Number of blocks to be transfered
N    unsigned short nbBlock;
N    /// Response buffer.
N    unsigned int  *pResp;
N    /// Optional user-provided callback function.
N    MciCallback callback;
N    /// Optional argument to the callback function.
N    void *pArg;
N    /// SD card response type.
N    unsigned char  resType;
N    /// Indicate if there is data transfer
N    unsigned char dataTran;
N    /// Indicate if continue to transfer data
N    unsigned char tranType;
N    /// Indicates if the command is a read operation.
N    unsigned char isRead;
N
N    /// Command status.
N    volatile int status;
N} MciCmd;
N
N//------------------------------------------------------------------------------
N/// MCI driver structure. Holds the internal state of the MCI driver and
N/// prevents parallel access to a MCI peripheral.
N//------------------------------------------------------------------------------
Ntypedef struct {
N
N#if MCI_BUSY_CHECK_FIX
X#if 0
S    /// MCI DAT0 Pin (Assign it to enable PIO mode DAT0 check)
S    /// The pin is configured as peripheral
S    const Pin *pPinDAT0;
N#endif
N    /// Pointer to a MCI peripheral.
N    AT91S_MCI *pMciHw;
N    /// Pointer to currently executing command.
N    MciCmd *pCommand;
N    /// MCI peripheral identifier.
N    unsigned char mciId;
N    /// MCI HW mode
N    unsigned char mciMode;
N    /// Mutex.
N    volatile char semaphore;
N    /// interrupt or polling mode
N    unsigned int bPolling;    
N} Mci;
N
N//------------------------------------------------------------------------------
N//         Global functions
N//------------------------------------------------------------------------------
N
Nextern void MCI_Init(
N    Mci *pMci,
N    AT91PS_MCI pMciHw,
N    unsigned char mciId,
N    unsigned int mode,
N    unsigned int bPolling);
N    
Nextern unsigned int MCI_GetSpeed(Mci *pMci, unsigned int *mciDiv);
N
Nextern unsigned int MCI_SetSpeed(Mci *pMci,
N                                 unsigned int mciSpeed,          
N                                 unsigned int mciLimit,
N                                 unsigned int mck);
N
Nextern unsigned char MCI_SendCommand(Mci *pMci, MciCmd *pMciCmd);
N
Nextern void MCI_Handler(Mci *pMci);
N
Nextern unsigned char MCI_IsTxComplete(Mci *pMci);
N
Nextern unsigned char MCI_CheckBusy(Mci *pMci);
N
Nextern void MCI_Close(Mci *pMci);
N
Nextern void MCI_EnableHsMode(Mci * pMci, unsigned char hsEnable);
N
Nextern void MCI_SetBusWidth(Mci *pMci, unsigned char busWidth);
N
Nextern unsigned int MCI_FifoTransfer(Mci * pMci, MciCmd * pCommand);
N
N#if MCI_BUSY_CHECK_FIX
X#if 0
Sextern void MCI_SetBusyFix(Mci *pMci, const Pin * pDAT0);
N#endif
N
N#endif //#ifndef MCI_HS_H
N
L 210 "atmel\sdmmc_mci.h" 2
N
N
N//------------------------------------------------------------------------------
N//         Constants
N//------------------------------------------------------------------------------
N
N
N/// There was an error with the SD driver.
N#define SD_ERROR_DRIVER          1
N/// The SD card did not answer the command.
N#define SD_ERROR_NORESPONSE      2
N/// The SD card did not answer the command.
N#define SD_ERROR_NOT_INITIALIZED 3
N/// The SD card is busy
N#define SD_ERROR_BUSY            4
N/// The operation is not supported
N#define SD_ERROR_NOT_SUPPORT     5
N
N/// Card types
N#define CARD_TYPE_bmHC           (1 << 0)       /// Bit for High-Capacity(Density)
N#define CARD_TYPE_bmSDMMC        (0x3 << 1)     /// Bit mask for SD/MMC
N#define CARD_TYPE_bmSD           (0x1 << 1)     /// Bit for SD
N#define CARD_TYPE_bmMMC          (0x2 << 1)     /// Bit for MMC
N#define CARD_TYPE_bmSDIO         (1 << 3)       /// Bit for SDIO
N
N/// Card can not identified
N#define CARD_UNKNOWN    (0)
N/// SD Card (0x2)
N#define CARD_SD         (CARD_TYPE_bmSD)
N/// SD High Capacity Card (0x3)
N#define CARD_SDHC       (CARD_TYPE_bmSD|CARD_TYPE_bmHC)
N/// MMC Card (0x4)
N#define CARD_MMC        (CARD_TYPE_bmMMC)
N/// MMC High-Density Card (0x5)
N#define CARD_MMCHD      (CARD_TYPE_bmMMC|CARD_TYPE_bmHC)
N/// SDIO only card (0x8)
N#define CARD_SDIO       (CARD_TYPE_bmSDIO)
N/// SDIO Combo, with SD embedded (0xA)
N#define CARD_SDCOMBO    (CARD_TYPE_bmSDIO|CARD_SD)
N/// SDIO Combo, with SDHC embedded (0xB)
N#define CARD_SDHCCOMBO  (CARD_TYPE_bmSDIO|CARD_SDHC)
N
N/// SD card block size in bytes.
N#define SD_BLOCK_SIZE           512
N/// SD card block size binary shift value
N#define SD_BLOCK_SIZE_BIT       9
N
N//- MMC Card Command Types
N/// Broadcast commands (bc), no response
N#define MMC_CCT_BC             0
N/// Broadcase commands with response (bcr)
N#define MMC_CCT_BCR            1
N/// Addressed commands (ac), no data transfer on DAT lines
N#define MMC_CCT_AC             2
N/// Addressed data transfer commands (adtc), data transfer on DAT lines
N#define MMC_CCT_ADTC           3
N
N//- MMC Card Command Classes (CCC)
N/// Class 0: basic
N#define MMC_CCC_BASIC               0
N/// Class 1: stream read
N#define MMC_CCC_STREAM_READ         1
N/// Class 2: block read
N#define MMC_CCC_BLOCK_READ          2
N/// Class 3: stream write
N#define MMC_CCC_STREAM_WRITE        3
N/// Class 4: block write
N#define MMC_CCC_BLOCK_WRITE         4
N/// Class 5: erase
N#define MMC_CCC_ERASE               5
N/// Class 6: write protection
N#define MMC_CCC_WRITE_PROTECTION    6
N/// Class 7: lock card
N#define MMC_CCC_LOCK_CARD           7
N/// Class 8: application specific
N#define MMC_CCC_APP_SPEC            8
N/// Class 9: I/O mode
N#define MMC_CCC_IO_MODE             9
N
N//- MMC/SD Card Command Response Type
N/// R1 (normal response command), 48bits
N#define MMC_RESP_R1                 1
N#define SD_RESP_R1                  MMC_RESP_R1
N/// R1b: busy signal transmitted on the data line DAT0
N#define MMC_RESP_R1b                1
N#define SD_RESP_R1b                 MMC_RESP_R1b
N/// R2: 136bits, CID, CSD register
N#define MMC_RESP_R2                 2
N#define SD_RESP_R2                  MMC_RESP_R2
N/// R3: 48bits, OCR
N#define MMC_RESP_R3                 3
N#define SD_RESP_R3                  MMC_RESP_R3
N/// R4 (Fast I/O), 48bits
N#define MMC_RESP_R4                 4
N/// R5 (Interrupt request), 48bits
N#define MMC_RESP_R5                 5
N/// R6 (Published RCA response), 48bits
N#define SD_RESP_R6                  6
N/// R7 (Card interface condition), 48bits
N#define SD_RESP_R7                  7
N
N//- MMC Card CMD6 access mode
N#define MMC_SWITCH_CMDSET           0
N#define MMC_SWITCH_SETBITS          1
N#define MMC_SWITCH_CLRBITS          2
N#define MMC_SWITCH_WRITE            3
N
N//-MMC Boot partition enable
N/// Boot partition 1 enabled for boot
N#define MMC_BOOT_PART_1             1
N/// Boot partition 2 enabled for boot
N#define MMC_BOOT_PART_2             2
N/// User area enabled for boot
N#define MMC_BOOT_PART_USER          7
N
N//-MMC Boot partition access
N/// R/W boot partition 1
N#define MMC_BOOT_ACC_PART1          1
N/// R/W boot partition 2
N#define MMC_BOOT_ACC_PART2          2
N
N//------------------------------------------------------------------------------
N//         Macros
N//------------------------------------------------------------------------------
N
N// CID register access macros (128 bits, 4 * 32 bits).
N#define SD_CID(pSd, bitfield, bits)   (  (pSd->cid[3-(bitfield)/32] >> ((bitfield)%32)) & ((1 << (bits)) - 1))
N#define SD_CID_MID(pSd)               SD_CID(pSd, 120, 8)      ///< Manufacturer ID  
N#define SD_CID_BGA(pSd)               SD_CID(pSd, 112, 2)      ///< Card/BGA(eMMC)
N#define SD_CID_CBS(pSd)               SD_CID(pSd, 112, 2)      ///< Card/BGA(eMMC)
N#define SD_CID_OID_BYTE_1(pSd)        SD_CID(pSd, 112, 8)      ///< OEM/Application ID byte 1
N#define SD_CID_OID_BYTE_0(pSd)        SD_CID(pSd, 104, 8)      ///< OEM/Application ID byte 0
N#define SD_CID_PNM_BYTE_4(pSd)        SD_CID(pSd,  96, 8)      ///< Product revision byte 4
N#define SD_CID_PNM_BYTE_3(pSd)        SD_CID(pSd,  88, 8)      ///< Product revision byte 3
N#define SD_CID_PNM_BYTE_2(pSd)        SD_CID(pSd,  80, 8)      ///< Product revision byte 2
N#define SD_CID_PNM_BYTE_1(pSd)        SD_CID(pSd,  72, 8)      ///< Product revision byte 1
N#define SD_CID_PNM_BYTE_0(pSd)        SD_CID(pSd,  64, 8)      ///< Product revision byte 0
N#define SD_CID_PRV_1(pSd)             SD_CID(pSd,  24, 8)      ///< Product serial number 1
N#define SD_CID_PRV_2(pSd)             SD_CID(pSd,  32,24)      ///< Product serial number 2
N#define SD_CID_MDT_YEAR(pSd)          (SD_CID(pSd, 12, 8))+2000///< Manufacturing date year
N#define SD_CID_MDT_MONTH(pSd)         SD_CID(pSd,   8, 4)      ///< Manufacturing date month
N#define SD_CID_CRC(pSd)               SD_CID(pSd,   1, 7)      ///< CRC7 checksum
N
N// CSD register access macros (128 bits, 4 * 32 bits).
N#define SD_CSD(pSd, bitfield, bits)   ((((pSd)->csd)[3-(bitfield)/32] >> ((bitfield)%32)) & ((1 << (bits)) - 1))
N#define SD_CSD_STRUCTURE(pSd)          SD_CSD(pSd, 126, 2) ///< CSD structure 00b  Version 1.0 01b version 2.0 High Cap
N#define SD_CSD_SPEC_VERS(pSd)          SD_CSD(pSd, 122, 4) ///< System Specification Version Number
N#define SD_CSD_TAAC(pSd)               SD_CSD(pSd, 112, 8) ///< Data read-access-time-1
N#define SD_CSD_NSAC(pSd)               SD_CSD(pSd, 104, 8) ///< Data read access-time-2 in CLK cycles
N#define SD_CSD_TRAN_SPEED(pSd)         SD_CSD(pSd, 96,  8) ///< Max. data transfer rate
N#define SD_CSD_CCC(pSd)                SD_CSD(pSd, 84, 12) ///< Card command class
N#define SD_CSD_READ_BL_LEN(pSd)        SD_CSD(pSd, 80,  4) ///< Max. read data block length
N#define SD_CSD_READ_BL_PARTIAL(pSd)    SD_CSD(pSd, 79,  1) ///< Bartial blocks for read allowed
N#define SD_CSD_WRITE_BLK_MISALIGN(pSd) SD_CSD(pSd, 78,  1) ///< Write block misalignment
N#define SD_CSD_READ_BLK_MISALIGN(pSd)  SD_CSD(pSd, 77,  1) ///< Read block misalignment
N#define SD_CSD_DSR_IMP(pSd)            SD_CSD(pSd, 76,  1) ///< DSP implemented
N#define SD_CSD_C_SIZE(pSd)             ((SD_CSD(pSd, 72,  2) << 10) + \
N                                        (SD_CSD(pSd, 64,  8) << 2)  + \
N                                        SD_CSD(pSd, 62,  2)) ///< Device size
X#define SD_CSD_C_SIZE(pSd)             ((SD_CSD(pSd, 72,  2) << 10) +                                         (SD_CSD(pSd, 64,  8) << 2)  +                                         SD_CSD(pSd, 62,  2)) 
N#define SD_CSD_C_SIZE_HC(pSd)          ((SD_CSD(pSd, 64,  6) << 16) + \
N                                        (SD_CSD(pSd, 56,  8) << 8)  + \
N                                        SD_CSD(pSd, 48,  8)) ///< Device size v2.0 High Capacity
X#define SD_CSD_C_SIZE_HC(pSd)          ((SD_CSD(pSd, 64,  6) << 16) +                                         (SD_CSD(pSd, 56,  8) << 8)  +                                         SD_CSD(pSd, 48,  8)) 
N#define SD_CSD_VDD_R_CURR_MIN(pSd)     SD_CSD(pSd, 59,  3) ///< Max. read current @VDD min
N#define SD_CSD_VDD_R_CURR_MAX(pSd)     SD_CSD(pSd, 56,  3) ///< Max. read current @VDD max
N#define SD_CSD_VDD_W_CURR_MIN(pSd)     SD_CSD(pSd, 53,  3) ///< Max. write current @VDD min
N#define SD_CSD_VDD_W_CURR_MAX(pSd)     SD_CSD(pSd, 50,  3) ///< Max. write current @VDD max
N#define SD_CSD_C_SIZE_MULT(pSd)        SD_CSD(pSd, 47,  3) ///< Device size multiplier
N#define SD_CSD_ERASE_BLK_EN(pSd)       SD_CSD(pSd, 46,  1) ///< Erase single block enable
N#define MMC_CSD_ERASE_BLK_EN(pSd)      SD_CSD(pSd, 46,  1) ///< Erase single block enable
N#define MMC_CSD_ERASE_GRP_SIZE(pSd)    SD_CSD(pSd, 42,  4) ///< Erase group size
N#define SD_CSD_ERASE_GRP_MULT(pSd)     SD_CSD(pSd, 37,  4) ///< Erase group size multiplier
N#define SD_CSD_SECTOR_SIZE(pSd)        ((SD_CSD(pSd, 40,  6) << 1) + SD_CSD(pSd, 39,  1)) ///< Erase sector size
N#define SD_CSD_WP_GRP_SIZE(pSd)        SD_CSD(pSd, 32,  7) ///< Write protect group size
N#define SD_CSD_WP_GRP_ENABLE(pSd)      SD_CSD(pSd, 31,  1) ///< write protect group enable
N#define SD_CSD_R2W_FACTOR(pSd)         SD_CSD(pSd, 26,  3) ///< Write speed factor
N#define SD_CSD_WRITE_BL_LEN(pSd)       ((SD_CSD(pSd, 24,  2) << 2) + SD_CSD(pSd, 22,  2)) ///< Max write block length
N#define SD_CSD_WRITE_BL_PARTIAL(pSd)   SD_CSD(pSd, 21,  1) ///< Partial blocks for write allowed
N#define SD_CSD_CONTENT_PROT_APP(pSd)   SD_CSD(pSd, 16,  1) ///< File format group
N#define SD_CSD_FILE_FORMAT_GRP(pSd)    SD_CSD(pSd, 15,  1) ///< File format group
N#define SD_CSD_COPY(pSd)               SD_CSD(pSd, 14,  1) ///< Copy flag (OTP)
N#define SD_CSD_PERM_WRITE_PROTECT(pSd) SD_CSD(pSd, 13,  1) ///< Permanent write protect
N#define SD_CSD_TMP_WRITE_PROTECT(pSd)  SD_CSD(pSd, 12,  1) ///< Temporary write protection
N#define SD_CSD_FILE_FORMAT(pSd)        SD_CSD(pSd, 10,  2) ///< File format
N#define SD_CSD_ECC(pSd)                SD_CSD(pSd,  8,  2) ///< CRC
N#define SD_CSD_CRC(pSd)                SD_CSD(pSd,  1,  7) ///< CRC
N#define SD_CSD_MULT(pSd)               (1 << (SD_CSD_C_SIZE_MULT(pSd) + 2))
N#define SD_CSD_BLOCKNR(pSd)            ((SD_CSD_C_SIZE(pSd) + 1) * SD_CSD_MULT(pSd))
N#define SD_CSD_BLOCKNR_HC(pSd)         ((SD_CSD_C_SIZE_HC(pSd) + 1) * 1024)
N#define SD_CSD_BLOCK_LEN(pSd)          (1 << SD_CSD_READ_BL_LEN(pSd))
N#define SD_CSD_TOTAL_SIZE(pSd)         (SD_CSD_BLOCKNR(pSd) * SD_CSD_BLOCK_LEN(pSd))
N#define SD_CSD_TOTAL_SIZE_HC(pSd)      ((SD_CSD_C_SIZE_HC(pSd) + 1) * 512* 1024)
N#define SD_TOTAL_SIZE(pSd)             ((pSd)->totalSize)
N#define SD_TOTAL_BLOCK(pSd)            ((pSd)->blockNr)
N
N// SCR register access macros (64 bits, 2 * 32 bits, 8 * 8 bits).
N#define SD_EXT_OFFSET_SD_SCR                0   // DW
N#define SD_SCR(pSd, bitfield, bits) \
N    ( ((char*)(pSd)->extData)[7 - ((bitfield)/8)] >> ((bitfield)%8) \
N                                                  & ((1 << (bits)) - 1) \
N    )
X#define SD_SCR(pSd, bitfield, bits)     ( ((char*)(pSd)->extData)[7 - ((bitfield)/8)] >> ((bitfield)%8)                                                   & ((1 << (bits)) - 1)     )
N#define SD_SCR_SCR_STRUCTURE(pSd)           SD_SCR(pSd, 60, 4)
N#define     SD_SCR_SCR_STRUCTURE_1_0        0
N#define SD_SCR_SD_SPEC(pSd)                 SD_SCR(pSd, 56, 4)
N#define     SD_SCR_SD_SPEC_1_0_01           0
N#define     SD_SCR_SD_SPEC_1_10             1
N#define     SD_SCR_SD_SPEC_2_00             2
N#define SD_SCR_DATA_STAT_AFTER_ERASE(pSd)   SD_SCR(pSd, 55, 1)
N#define SD_SCR_SD_SECURITY(pSd)             SD_SCR(pSd, 52, 3)
N#define     SD_SCR_SD_SECURITY_NO           0
N#define     SD_SCR_SD_SECURITY_NOTUSED      1
N#define     SD_SCR_SD_SECURITY_1_01         2
N#define     SD_SCR_SD_SECURITY_2_00         3
N#define SD_SCR_SD_BUS_WIDTHS(pSd)           SD_SCR(pSd, 48, 4)
N#define     SD_SCR_SD_BUS_WIDTH_1BITS       (1 << 0)
N#define     SD_SCR_SD_BUS_WIDTH_4BITS       (1 << 2)
N
N// SD Status access macros (512 bits, 16 * 32 bits, 64 * 8 bits).
N#define SD_EXT_OFFSET_SD_STAT               2   // DW
N#define SD_STAT(pSd, bitfield, bits) \
N    ( ((char*)&(pSd)->extData[2])[63 - ((bitfield)/8)] >> ((bitfield)%8) \
N                                                  & ((1 << (bits)) - 1) \
N    )
X#define SD_STAT(pSd, bitfield, bits)     ( ((char*)&(pSd)->extData[2])[63 - ((bitfield)/8)] >> ((bitfield)%8)                                                   & ((1 << (bits)) - 1)     )
N/// Bus width, 00: default, 10:4-bit
N#define SD_STAT_DAT_BUS_WIDTH(pSd)           SD_STAT(pSd, 510, 2)
N#define     SD_STAT_DATA_BUS_WIDTH_1BIT      0x0
N#define     SD_STAT_DATA_BUS_WIDTH_4BIT      0x2
N/// Secured Mode
N#define SD_STAT_SECURED_MODE(pSd)            SD_STAT(pSd, 509, 1)
N/// SD Memory Cards as defined in 1.01~2.00
N#define SD_STAT_SD_CARD_TYPE(pSd)           (SD_STAT(pSd, 480, 8) \
N                                           + (SD_STAT(pSd, 488, 8) << 8) )
X#define SD_STAT_SD_CARD_TYPE(pSd)           (SD_STAT(pSd, 480, 8)                                            + (SD_STAT(pSd, 488, 8) << 8) )
N/// STD: ThisSize*Multi*BlockLen, HC: Size in bytes
N#define SD_STAT_SIZE_OF_PROTECTED_AREA(pSd) (SD_STAT(pSd, 448, 8) \
N                                           + (SD_STAT(pSd, 456, 8) <<  8) \
N                                           + (SD_STAT(pSd, 464, 8) << 16) \
N                                           + (SD_STAT(pSd, 472, 8) << 24) )
X#define SD_STAT_SIZE_OF_PROTECTED_AREA(pSd) (SD_STAT(pSd, 448, 8)                                            + (SD_STAT(pSd, 456, 8) <<  8)                                            + (SD_STAT(pSd, 464, 8) << 16)                                            + (SD_STAT(pSd, 472, 8) << 24) )
N/// Speed Class, value can be calculated by Pw/2
N#define SD_STAT_SPEED_CLASS(pSd)             SD_STAT(pSd, 440, 8)
N#define     SD_STAT_SPEED_CLASS_0            0
N#define     SD_STAT_SPEED_CLASS_2            1  // >= 2MB/s 
N#define     SD_STAT_SPEED_CLASS_4            2  // >= 4MB/s
N#define     SD_STAT_SPEED_CLASS_6            3  // >= 6MB/s
N/// 8-bit, by 1MB/s step.
N#define SD_STAT_PERFORMANCE_MOVE(pSd)        SD_STAT(pSd, 432, 8)
N/// AU Size, in power of 2 from 16KB
N#define SD_STAT_AU_SIZE(pSd)                 SD_STAT(pSd, 428, 4)
N#define     SD_STAT_AU_SIZE_16K              1
N#define     SD_STAT_AU_SIZE_32K              2
N#define     SD_STAT_AU_SIZE_64K              3
N#define     SD_STAT_AU_SIZE_128K             4
N#define     SD_STAT_AU_SIZE_256K             5
N#define     SD_STAT_AU_SIZE_512K             6
N#define     SD_STAT_AU_SIZE_1M               7
N#define     SD_STAT_AU_SIZE_2M               8
N#define     SD_STAT_AU_SIZE_4M               9
N/// 16-bit, number of AUs erased.
N#define SD_STAT_ERASE_SIZE(pSd)             (SD_STAT(pSd, 408, 8) \
N                                          + (SD_STAT(pSd, 416, 8) << 8) )
X#define SD_STAT_ERASE_SIZE(pSd)             (SD_STAT(pSd, 408, 8)                                           + (SD_STAT(pSd, 416, 8) << 8) )
N#define SD_STAT_ERASE_TIMEOUT(pSd)           SD_STAT(pSd, 402, 6)
N#define SD_STAT_ERASE_OFFSET(pSd)            SD_STAT(pSd, 400, 2)
N
N// SD Switch Status access macros (512 bits, 16 * 32 bits, 64 * 8 bits).
N#define SD_SW_STAT(p, bitfield, bits) \
N    ( ((char*)(p))[63 - ((bitfield)/8)] >> ((bitfield)%8) \
N                                                  & ((1 << (bits)) - 1) \
N    )
X#define SD_SW_STAT(p, bitfield, bits)     ( ((char*)(p))[63 - ((bitfield)/8)] >> ((bitfield)%8)                                                   & ((1 << (bits)) - 1)     )
N#define SD_SW_STAT_MAX_CURRENT_CONSUMPTION(p)   ( SD_SW_STAT(p, 496, 8) \
N                                               + (SD_SW_STAT(p, 504, 8) << 8) )
X#define SD_SW_STAT_MAX_CURRENT_CONSUMPTION(p)   ( SD_SW_STAT(p, 496, 8)                                                + (SD_SW_STAT(p, 504, 8) << 8) )
N#define SD_SW_STAT_FUN_GRP6_INFO(p)             ( SD_SW_STAT(p, 480, 8) \
N                                               + (SD_SW_STAT(p, 488, 8) << 8) )
X#define SD_SW_STAT_FUN_GRP6_INFO(p)             ( SD_SW_STAT(p, 480, 8)                                                + (SD_SW_STAT(p, 488, 8) << 8) )
N#define SD_SW_STAT_FUN_GRP5_INFO(p)             ( SD_SW_STAT(p, 464, 8) \
N                                               + (SD_SW_STAT(p, 472, 8) << 8) )
X#define SD_SW_STAT_FUN_GRP5_INFO(p)             ( SD_SW_STAT(p, 464, 8)                                                + (SD_SW_STAT(p, 472, 8) << 8) )
N#define SD_SW_STAT_FUN_GRP4_INFO(p)             ( SD_SW_STAT(p, 448, 8) \
N                                               + (SD_SW_STAT(p, 456, 8) << 8) )
X#define SD_SW_STAT_FUN_GRP4_INFO(p)             ( SD_SW_STAT(p, 448, 8)                                                + (SD_SW_STAT(p, 456, 8) << 8) )
N#define SD_SW_STAT_FUN_GRP3_INFO(p)             ( SD_SW_STAT(p, 432, 8) \
N                                               + (SD_SW_STAT(p, 440, 8) << 8) )
X#define SD_SW_STAT_FUN_GRP3_INFO(p)             ( SD_SW_STAT(p, 432, 8)                                                + (SD_SW_STAT(p, 440, 8) << 8) )
N#define SD_SW_STAT_FUN_GRP2_INFO(p)             ( SD_SW_STAT(p, 416, 8) \
N                                               + (SD_SW_STAT(p, 424, 8) << 8) )
X#define SD_SW_STAT_FUN_GRP2_INFO(p)             ( SD_SW_STAT(p, 416, 8)                                                + (SD_SW_STAT(p, 424, 8) << 8) )
N#define SD_SW_STAT_FUN_GRP1_INFO(p)             ( SD_SW_STAT(p, 400, 8) \
N                                               + (SD_SW_STAT(p, 408, 8) << 8) )
X#define SD_SW_STAT_FUN_GRP1_INFO(p)             ( SD_SW_STAT(p, 400, 8)                                                + (SD_SW_STAT(p, 408, 8) << 8) )
N#define SD_SW_STAT_FUN_GRP6_RC(p)                SD_SW_STAT(p, 396, 4)
N#define SD_SW_STAT_FUN_GRP5_RC(p)                SD_SW_STAT(p, 392, 4)
N#define SD_SW_STAT_FUN_GRP4_RC(p)                SD_SW_STAT(p, 388, 4)
N#define SD_SW_STAT_FUN_GRP3_RC(p)                SD_SW_STAT(p, 384, 4)
N#define SD_SW_STAT_FUN_GRP2_RC(p)                SD_SW_STAT(p, 380, 4)
N#define SD_SW_STAT_FUN_GRP1_RC(p)                SD_SW_STAT(p, 376, 4)
N#define     SD_SW_STAT_FUN_GRP_RC_ERROR         0xF
N#define SD_SW_STAT_DATA_STRUCT_VER(p)            SD_SW_STAT(p, 368, 8)
N#define SD_SW_STAT_FUN_GRP6_BUSY(p)             ( SD_SW_STAT(p, 352, 8) \
N                                               + (SD_SW_STAT(p, 360, 8) << 8) )
X#define SD_SW_STAT_FUN_GRP6_BUSY(p)             ( SD_SW_STAT(p, 352, 8)                                                + (SD_SW_STAT(p, 360, 8) << 8) )
N#define SD_SW_STAT_FUN_GRP5_BUSY(p)             ( SD_SW_STAT(p, 336, 8) \
N                                               + (SD_SW_STAT(p, 344, 8) << 8) )
X#define SD_SW_STAT_FUN_GRP5_BUSY(p)             ( SD_SW_STAT(p, 336, 8)                                                + (SD_SW_STAT(p, 344, 8) << 8) )
N#define SD_SW_STAT_FUN_GRP4_BUSY(p)             ( SD_SW_STAT(p, 320, 8) \
N                                               + (SD_SW_STAT(p, 328, 8) << 8) )
X#define SD_SW_STAT_FUN_GRP4_BUSY(p)             ( SD_SW_STAT(p, 320, 8)                                                + (SD_SW_STAT(p, 328, 8) << 8) )
N#define SD_SW_STAT_FUN_GRP3_BUSY(p)             ( SD_SW_STAT(p, 304, 8) \
N                                               + (SD_SW_STAT(p, 312, 8) << 8) )
X#define SD_SW_STAT_FUN_GRP3_BUSY(p)             ( SD_SW_STAT(p, 304, 8)                                                + (SD_SW_STAT(p, 312, 8) << 8) )
N#define SD_SW_STAT_FUN_GRP2_BUSY(p)             ( SD_SW_STAT(p, 288, 8) \
N                                               + (SD_SW_STAT(p, 296, 8) << 8) )
X#define SD_SW_STAT_FUN_GRP2_BUSY(p)             ( SD_SW_STAT(p, 288, 8)                                                + (SD_SW_STAT(p, 296, 8) << 8) )
N#define SD_SW_STAT_FUN_GRP1_BUSY(p)             ( SD_SW_STAT(p, 272, 8) \
N                                               + (SD_SW_STAT(p, 280, 8) << 8) )
X#define SD_SW_STAT_FUN_GRP1_BUSY(p)             ( SD_SW_STAT(p, 272, 8)                                                + (SD_SW_STAT(p, 280, 8) << 8) )
N#define SD_SW_STAT_FUN_GRP_FUN_BUSY(funNdx)     (1 << (funNdx))
N
N// EXT_CSD register definition.
N#define SD_EXTCSD_S_CMD_SET_INDEX              504   // Below belongs to Properties Segment
N#define SD_EXTCSD_BOOT_INFO_INDEX              228
N#define SD_EXTCSD_BOOT_SIZE_MULTI_INDEX        226
N#define SD_EXTCSD_ACC_SIZE_INDEX               225
N#define SD_EXTCSD_HC_ERASE_GRP_SIZE_INDEX      224
N#define SD_EXTCSD_ERASE_TIMEOUT_MULT_INDEX     223
N#define SD_EXTCSD_REL_WR_SEC_C_INDEX           222
N#define SD_EXTCSD_HC_WP_GRP_SIZE_INDEX         221
N#define SD_EXTCSD_S_C_VCC_INDEX                220
N#define SD_EXTCSD_S_C_VCCQ_INDEX               219
N#define SD_EXTCSD_S_A_TIMEOUT_INDEX            217
N#define SD_EXTCSD_SEC_COUNT_INDEX              212
N#define SD_EXTCSD_MIN_PERF_W_8_52_INDEX        210
N#define SD_EXTCSD_MIN_PERF_R_8_52_INDEX        209
N#define SD_EXTCSD_MIN_PERF_W_8_26_4_52_INDEX   208
N#define SD_EXTCSD_MIN_PERF_R_8_26_4_52_INDEX   207
N#define SD_EXTCSD_MIN_PERF_W_4_26_INDEX        206
N#define SD_EXTCSD_MIN_PERF_R_4_26_INDEX        205
N#define SD_EXTCSD_PWR_CL_26_360_INDEX          203
N#define SD_EXTCSD_PWR_CL_52_360_INDEX          202
N#define SD_EXTCSD_PWR_CL_26_195_INDEX          201
N#define SD_EXTCSD_PWR_CL_52_195_INDEX          200
N#define SD_EXTCSD_CARD_TYPE_INDEX              196
N#define SD_EXTCSD_CSD_STRUCTURE_INDEX          194
N#define SD_EXTCSD_EXT_CSD_REV_INDEX            192
N
N#define SD_EXTCSD_CMD_SET_INDEX                191  //Below belongs to Mode Segment
N#define SD_EXTCSD_CMD_SET_REV_INDEX            189
N#define SD_EXTCSD_POWER_CLASS_INDEX            187
N#define SD_EXTCSD_HS_TIMING_INDEX              185
N#define SD_EXTCSD_BUS_WIDTH_INDEX              183
N#define SD_EXTCSD_ERASED_MEM_CONT_INDEX        181
N#define SD_EXTCSD_BOOT_CONFIG_INDEX            179
N#define SD_EXTCSD_BOOT_BUS_WIDTH_INDEX         177
N#define SD_EXTCSD_ERASE_GROUP_DEF_INDEX        175
N
N// Ext_CSD register access marco
N#define MMC_EXTCSD_U8(pSd, bytefield) \
N    ( ((unsigned char*)((pSd)->extData))[(bytefield)] )
X#define MMC_EXTCSD_U8(pSd, bytefield)     ( ((unsigned char*)((pSd)->extData))[(bytefield)] )
N#define MMC_EXTCSD_U16(pSd, bytefield) \
N    ( (((unsigned char*)((pSd)->extData))[(bytefield)    ] << 0) + \
N      (((unsigned char*)((pSd)->extData))[(bytefield) + 1] << 8) )
X#define MMC_EXTCSD_U16(pSd, bytefield)     ( (((unsigned char*)((pSd)->extData))[(bytefield)    ] << 0) +       (((unsigned char*)((pSd)->extData))[(bytefield) + 1] << 8) )
N#define MMC_EXTCSD_U32(pSd, bytefield) \
N    ( (((unsigned char*)((pSd)->extData))[(bytefield)     ] <<  0) + \
N      (((unsigned char*)((pSd)->extData))[(bytefield) +  1] <<  8) + \
N      (((unsigned char*)((pSd)->extData))[(bytefield) +  2] << 16) + \
N      (((unsigned char*)((pSd)->extData))[(bytefield) + 24] << 24) )
X#define MMC_EXTCSD_U32(pSd, bytefield)     ( (((unsigned char*)((pSd)->extData))[(bytefield)     ] <<  0) +       (((unsigned char*)((pSd)->extData))[(bytefield) +  1] <<  8) +       (((unsigned char*)((pSd)->extData))[(bytefield) +  2] << 16) +       (((unsigned char*)((pSd)->extData))[(bytefield) + 24] << 24) )
N#define MMC_EXTCSD(pSd) ((unsigned char*)((pSd)->extData))
N#define SD_EXTCSD_S_CMD_SET(pSd)               (MMC_EXTCSD(pSd)[SD_EXTCSD_S_CMD_SET_INDEX]) // Supported Command Sets
N#define SD_EXTCSD_BOOT_INFO(pSd)               (MMC_EXTCSD(pSd)[SD_EXTCSD_BOOT_INFO_INDEX]) // Boot information
N#define SD_EXTCSD_BOOT_SIZE_MULTI(pSd)         (MMC_EXTCSD(pSd)[SD_EXTCSD_BOOT_SIZE_MULTI_INDEX]) // Boot partition size
N#define SD_EXTCSD_ACC_SIZE(pSd)                (MMC_EXTCSD(pSd)[SD_EXTCSD_ACC_SIZE_INDEX]) // Access size
N#define SD_EXTCSD_HC_ERASE_GRP_SIZE(pSd)       (MMC_EXTCSD(pSd)[SD_EXTCSD_HC_ERASE_GRP_SIZE_INDEX]) // High-capacity erase unit size
N#define SD_EXTCSD_ERASE_TIMEOUT_MULT(pSd)      (MMC_EXTCSD(pSd)[SD_EXTCSD_ERASE_TIMEOUT_MULT_INDEX]) // High-capacity erase timeout
N#define SD_EXTCSD_REL_WR_SEC_C(pSd)            (MMC_EXTCSD(pSd)[SD_EXTCSD_REL_WR_SEC_C_INDEX]) // Reliable write sector count
N#define SD_EXTCSD_HC_WP_GRP_SIZE(pSd)          (MMC_EXTCSD(pSd)[SD_EXTCSD_HC_WP_GRP_SIZE_INDEX]) // High-capacity write protect group size
N#define SD_EXTCSD_S_C_VCC(pSd)                 (MMC_EXTCSD(pSd)[SD_EXTCSD_S_C_VCC_INDEX]) // Sleep current(VCC)
N#define SD_EXTCSD_S_C_VCCQ(pSd)                (MMC_EXTCSD(pSd)[SD_EXTCSD_S_C_VCCQ_INDEX]) // Sleep current(VCCQ)
N#define SD_EXTCSD_S_A_TIMEOUT(pSd)             (MMC_EXTCSD(pSd)[SD_EXTCSD_S_A_TIMEOUT_INDEX]) // Sleep/awake timeout
N#define SD_EXTCSD_SEC_COUNT(pSd)               ((MMC_EXTCSD(pSd)[SD_EXTCSD_SEC_COUNT_INDEX]) + \
N                                                (MMC_EXTCSD(pSd)[SD_EXTCSD_SEC_COUNT_INDEX+1] << 8 ) + \
N                                                (MMC_EXTCSD(pSd)[SD_EXTCSD_SEC_COUNT_INDEX+2] << 16 ) + \
N                                                (MMC_EXTCSD(pSd)[SD_EXTCSD_SEC_COUNT_INDEX+3] << 24 )) //Sector Count
X#define SD_EXTCSD_SEC_COUNT(pSd)               ((MMC_EXTCSD(pSd)[SD_EXTCSD_SEC_COUNT_INDEX]) +                                                 (MMC_EXTCSD(pSd)[SD_EXTCSD_SEC_COUNT_INDEX+1] << 8 ) +                                                 (MMC_EXTCSD(pSd)[SD_EXTCSD_SEC_COUNT_INDEX+2] << 16 ) +                                                 (MMC_EXTCSD(pSd)[SD_EXTCSD_SEC_COUNT_INDEX+3] << 24 )) 
N#define SD_EXTCSD_MIN_PERF_W_8_52(pSd)         (MMC_EXTCSD(pSd)[SD_EXTCSD_MIN_PERF_W_8_52_INDEX]) // Minimum Write Performance for 8bit at 52MHz
N#define SD_EXTCSD_MIN_PERF_R_8_52(pSd)         (MMC_EXTCSD(pSd)[SD_EXTCSD_MIN_PERF_R_8_52_INDEX]) // Minimum Read Performance for 8bit at 52MHz
N#define SD_EXTCSD_MIN_PERF_W_8_26_4_52(pSd)    (MMC_EXTCSD(pSd)[SD_EXTCSD_MIN_PERF_W_8_26_4_52_INDEX]) // Minimum Write Performance for 8bit at 26MHz, for 4bit at 52MHz
N#define SD_EXTCSD_MIN_PERF_R_8_26_4_52(pSd)    (MMC_EXTCSD(pSd)[SD_EXTCSD_MIN_PERF_R_8_26_4_52_INDEX]) // Minimum Read Performance for 8bit at 26MHz, for 4bit at 52MHz
N#define SD_EXTCSD_MIN_PERF_W_4_26(pSd)         (MMC_EXTCSD(pSd)[SD_EXTCSD_MIN_PERF_W_4_26_INDEX]) // Minimum Write Performance for 4bit at 26MHz
N#define SD_EXTCSD_MIN_PERF_R_4_26(pSd)         (MMC_EXTCSD(pSd)[SD_EXTCSD_MIN_PERF_R_4_26_INDEX]) // Minimum Read Performance for 4bit at 26MHz
N#define SD_EXTCSD_PWR_CL_26_360(pSd)           (MMC_EXTCSD(pSd)[SD_EXTCSD_PWR_CL_26_360_INDEX]) // Power class for 26MHz at 3.6v
N#define SD_EXTCSD_PWR_CL_52_360(pSd)           (MMC_EXTCSD(pSd)[SD_EXTCSD_PWR_CL_52_360_INDEX]) // Power class for 52MHz at 3.6v
N#define SD_EXTCSD_PWR_CL_26_195(pSd)           (MMC_EXTCSD(pSd)[SD_EXTCSD_PWR_CL_26_195_INDEX]) // Power class for 26MHz at 1.95v
N#define SD_EXTCSD_PWR_CL_52_195(pSd)           (MMC_EXTCSD(pSd)[SD_EXTCSD_PWR_CL_52_195_INDEX]) // Power class for 52MHz at 1.95v
N#define SD_EXTCSD_CARD_TYPE(pSd)               (MMC_EXTCSD(pSd)[SD_EXTCSD_CARD_TYPE_INDEX]) // Card type
N#define SD_EXTCSD_CSD_STRUCTURE(pSd)           (MMC_EXTCSD(pSd)[SD_EXTCSD_CSD_STRUCTURE_INDEX]) // CSD structure version
N#define SD_EXTCSD_EXT_CSD_REV(pSd)             (MMC_EXTCSD(pSd)[SD_EXTCSD_EXT_CSD_REV_INDEX]) // Extended CSD structure version
N#define SD_EXTCSD_CMD_SET(pSd)                 (MMC_EXTCSD(pSd)[SD_EXTCSD_CMD_SET_INDEX]) // Command set
N#define SD_EXTCSD_CMD_SET_REV(pSd)             (MMC_EXTCSD(pSd)[SD_EXTCSD_CMD_SET_REV_INDEX]) // Command set revision
N#define SD_EXTCSD_POWER_CLASS(pSd)             (MMC_EXTCSD(pSd)[SD_EXTCSD_POWER_CLASS_INDEX]) // Power class
N#define SD_EXTCSD_HS_TIMING(pSd)               (MMC_EXTCSD(pSd)[SD_EXTCSD_HS_TIMING_INDEX]) // High-speed interface timing
N#define SD_EXTCSD_BUS_WIDTH(pSd)               (MMC_EXTCSD(pSd)[SD_EXTCSD_BUS_WIDTH_INDEX]) // Bus width mode
N#define SD_EXTCSD_ERASED_MEM_CONT(pSd)         (MMC_EXTCSD(pSd)[SD_EXTCSD_ERASED_MEM_CONT_INDEX]) // Erased memory content
N#define SD_EXTCSD_BOOT_CONFIG(pSd)             (MMC_EXTCSD(pSd)[SD_EXTCSD_BOOT_CONFIG_INDEX]) // Boot configuration
N#define SD_EXTCSD_BOOT_BUS_WIDTH(pSd)          (MMC_EXTCSD(pSd)[SD_EXTCSD_BOOT_BUS_WIDTH_INDEX]) // Boot bus width
N#define SD_EXTCSD_ERASE_GROUP_DEF(pSd)         (MMC_EXTCSD(pSd)[SD_EXTCSD_ERASE_GROUP_DEF_INDEX]) // High-density erase group definition
N
N// EXTCSD total size and block number
N#define SD_EXTCSD_TOTAL_SIZE(pSd)              (SD_EXTCSD_SEC_COUNT(pSd)*512)
N#define SD_EXTCSD_BLOCKNR(pSd)                 (SD_EXTCSD_SEC_COUNT(pSd))
N
N// Bus width Byte
N#define SD_EXTCSD_BUS_WIDTH_1BIT               (0x0UL)
N#define SD_EXTCSD_BUS_WIDTH_4BIT               (0x1UL)
N#define SD_EXTCSD_BUS_WIDTH_8BIT               (0x2UL)
N
N// High speed mode
N#define SD_EXTCSD_HS_TIMING_ENABLE             (0x1UL)
N#define SD_EXTCSD_HS_TIMING_DISABLE            (0x0UL)
N
N// Boot config
N#define SD_EXTCSD_BOOT_PARTITION_ACCESS        (0x7UL) // boot partition access
N#define SD_EXTCSD_BOOT_PART_NO_ACCESS          (0x0UL)
N#define SD_EXTCSD_BOOT_PART_RW_PART1           (0x1UL)
N#define SD_EXTCSD_BOOT_PART_RW_PART2           (0x2UL)
N#define SD_EXTCSD_BOOT_PARTITION_ENABLE        (0x7UL << 3) // boot partition enable
N#define SD_EXTCSD_BOOT_PART_DISABLE            (0x0UL << 3)
N#define SD_EXTCSD_BOOT_PART_ENABLE_PART1       (0x1UL << 3)
N#define SD_EXTCSD_BOOT_PART_ENABLE_PART2       (0x2UL << 3)
N#define SD_EXTCSD_BOOT_PART_ENABLE_USER        (0x7UL << 3)
N#define SD_EXTCSD_BOOT_PARTITION_ACK           (0x1UL << 7) // boot acknowledge
N#define SD_EXTCSD_BOOT_PART_NOACK              (0x0UL << 7)
N#define SD_EXTCSD_BOOT_PART_ACK                (0x1UL << 7)
N
N// Boot bus width
N#define SD_EXTCSD_BOOT_BUS_WIDTH_BIT           (0x3UL) // boot bus width
N#define SD_EXTCSD_BOOT_BUS_1BIT                (0x0UL)
N#define SD_EXTCSD_BOOT_BUS_4BIT                (0x1UL)
N#define SD_EXTCSD_BOOT_BUS_8BIT                (0x2UL)
N#define SD_EXTCSD_RESET_BOOT_BUS_WIDTH_BIT     (0x1UL << 2) // boot bus width
N#define SD_EXTCSD_RESET_BOOT_BUS               (0x0UL << 2)
N#define SD_EXTCSD_RETAIN_BOOT_BUS              (0x1UL << 2)
N
N// Mode Switch Arguments for CMD6
N#define MMC_CMD6_ARG_ACCESS
N#define MMC_CMD6_ARG_INDEX
N#define MMC_CMD6_ARG_VALUE
N#define MMC_CMD6_ARG_CMDSET
N
N// SDIO functions
N#define SDIO_CIA            0   /// SDIO Function 0 (CIA)
N#define SDIO_FN0            0   /// SDIO Function 0
N#define SDIO_FN1            1   /// SDIO Function 1
N#define SDIO_FN2            2   /// SDIO Function 2
N#define SDIO_FN3            3   /// SDIO Function 3
N#define SDIO_FN4            4   /// SDIO Function 4
N#define SDIO_FN5            5   /// SDIO Function 5
N#define SDIO_FN6            6   /// SDIO Function 6
N#define SDIO_FN7            7   /// SDIO Function 7
N
N// SDIO Card Common Control Registers (CCCR)
N#define SDIO_CCCR_REG       0x00    /// CCCR/SDIO revision (RO)
N#define  SDIO_CCCR          (0xFUL << 0)/// CCCR Format Version number
N#define  SDIO_CCCR_1_00     (0x0UL << 0)/// CCCR/FBR Version 1.00
N#define  SDIO_CCCR_1_10     (0x1UL << 0)/// CCCR/FBR Version 1.10
N#define  SDIO_CCCR_1_20     (0x2UL << 0)/// CCCR/FBR Version 1.20
N#define  SDIO_SDIO          (0xFUL << 4)/// SDIO Specification
N#define  SDIO_SDIO_1_00     (0x0UL << 4)/// SDIO Specification 1.00
N#define  SDIO_SDIO_1_10     (0x1UL << 4)/// SDIO Specification 1.10
N#define  SDIO_SDIO_1_20     (0x2UL << 4)/// SDIO Specification 1.20(unreleased)
N#define  SDIO_SDIO_2_00     (0x3UL << 4)/// SDIO Specification Version 2.00
N#define SDIO_SD_REV_REG     0x01    /// SD Specification Revision (RO)
N#define  SDIO_SD            (0xFUL << 0)/// SD Physical Specification
N#define  SDIO_SD_1_01       (0x0UL << 0)/// SD 1.01 (Mar 2000)
N#define  SDIO_SD_1_10       (0x1UL << 0)/// SD 1.10 (Oct 2004)
N#define  SDIO_SD_2_00       (0x2UL << 0)/// SD 2.00 (May 2006)
N#define SDIO_IOE_REG        0x02    /// I/O Enable (R/W)
N#define  SDIO_IOE           0xFEUL      /// Enable/Disable Function
N#define  SDIO_IOE_FN1       (0x1UL << 1)/// Function 1 Enable/Disable
N#define  SDIO_IOE_FN2       (0x1UL << 2)/// Function 2 Enable/Disable
N#define  SDIO_IOE_FN3       (0x1UL << 3)/// Function 3 Enable/Disable
N#define  SDIO_IOE_FN4       (0x1UL << 4)/// Function 4 Enable/Disable
N#define  SDIO_IOE_FN5       (0x1UL << 5)/// Function 5 Enable/Disable
N#define  SDIO_IOE_FN6       (0x1UL << 6)/// Function 6 Enable/Disable
N#define  SDIO_IOE_FN7       (0x1UL << 7)/// Function 7 Enable/Disable
N#define SDIO_IOR_REG        0x03    /// I/O Ready (RO)
N#define  SDIO_IOR           0xFEUL      /// I/O Function Ready
N#define  SDIO_IOR_FN1       (0x1UL << 1)/// Function 1 ready
N#define  SDIO_IOR_FN2       (0x1UL << 2)/// Function 2 ready
N#define  SDIO_IOR_FN3       (0x1UL << 3)/// Function 3 ready
N#define  SDIO_IOR_FN4       (0x1UL << 4)/// Function 4 ready
N#define  SDIO_IOR_FN5       (0x1UL << 5)/// Function 5 ready
N#define  SDIO_IOR_FN6       (0x1UL << 6)/// Function 6 ready
N#define  SDIO_IOR_FN7       (0x1UL << 7)/// Function 7 ready
N#define SDIO_IEN_REG        0x04    /// Int Enable
N#define  SDIO_IENM          0x01UL      /// Int Enable Master (R/W)
N#define  SDIO_IEN           0xFEUL      /// Int Enable for function (R/W)
N#define  SDIO_IEN_FN1       (0x1UL << 1)/// Function 1 Int Enable
N#define  SDIO_IEN_FN2       (0x1UL << 2)/// Function 2 Int Enable
N#define  SDIO_IEN_FN3       (0x1UL << 3)/// Function 3 Int Enable
N#define  SDIO_IEN_FN4       (0x1UL << 4)/// Function 4 Int Enable
N#define  SDIO_IEN_FN5       (0x1UL << 5)/// Function 5 Int Enable
N#define  SDIO_IEN_FN6       (0x1UL << 6)/// Function 6 Int Enable
N#define  SDIO_IEN_FN7       (0x1UL << 7)/// Function 7 Int Enable
N#define SDIO_INT_REG        0x05    /// Int Pending
N#define  SDIO_INT           0xFE      /// Int Pending for functions (RO)
N#define  SDIO_INT_FN1       (0x1UL << 1)/// Function 1 Int pending
N#define  SDIO_INT_FN2       (0x1UL << 2)/// Function 2 Int pending
N#define  SDIO_INT_FN3       (0x1UL << 3)/// Function 3 Int pending
N#define  SDIO_INT_FN4       (0x1UL << 4)/// Function 4 Int pending
N#define  SDIO_INT_FN5       (0x1UL << 5)/// Function 5 Int pending
N#define  SDIO_INT_FN6       (0x1UL << 6)/// Function 6 Int pending
N#define  SDIO_INT_FN7       (0x1UL << 7)/// Function 7 Int pending
N#define SDIO_IOA_REG        0x06    /// I/O Abort
N#define  SDIO_AS            (0x7UL << 0)/// Abort Select In Order (WO)
N#define  SDIO_AS_FN1        (0x1UL << 0)/// Abort function 1 IO
N#define  SDIO_AS_FN2        (0x2UL << 0)/// Abort function 2 IO
N#define  SDIO_AS_FN3        (0x3UL << 0)/// Abort function 3 IO
N#define  SDIO_AS_FN4        (0x4UL << 0)/// Abort function 4 IO
N#define  SDIO_AS_FN5        (0x5UL << 0)/// Abort function 5 IO
N#define  SDIO_AS_FN6        (0x6UL << 0)/// Abort function 6 IO
N#define  SDIO_AS_FN7        (0x7UL << 0)/// Abort function 7 IO
N#define  SDIO_RES           (0x1UL << 3)/// IO CARD RESET (WO)
N#define SDIO_BUS_CTRL_REG   0x07    /// Bus Interface Control
N#define  SDIO_BUSWIDTH      (0x3UL << 0)/// Data bus width (R/W)
N#define  SDIO_BUSWIDTH_1B   (0x0UL << 0)/// 1-bit data bus
N#define  SDIO_BUSWIDTH_4B   (0x2UL << 0)/// 4-bit data bus
N#define  SDIO_ECSI          (0x1UL << 5)/// Enable Continuous SPI interrupt (R/W)
N#define  SDIO_SCSI          (0x1UL << 6)/// Support Continuous SPI interrupt (RO)
N#define  SDIO_CD            (0x1UL << 7)/// Connect(0)/Disconnect(1) pull-up on CD/DAT[3] (R/W)
N#define SDIO_CAP_REG        0x08    /// Card Capability
N#define  SDIO_SDC           (0x1UL << 0)/// Support Direct Commands during data transfer (RO)
N#define  SDIO_SMB           (0x1UL << 1)/// Support Multi-Block (RO)
N#define  SDIO_SRW           (0x1UL << 2)/// Support Read Wait (RO)
N#define  SDIO_SBS           (0x1UL << 3)/// Support Suspend/Resume (RO)
N#define  SDIO_S4MI          (0x1UL << 4)/// Support interrupt between blocks of data in 4-bit SD mode (RO)
N#define  SDIO_E4MI          (0x1UL << 5)/// Enable interrupt between blocks of data in 4-bit SD mode (R/W)
N#define  SDIO_LSC           (0x1UL << 6)/// Low-Speed Card (RO)
N#define  SDIO_4BLS          (0x1UL << 7)/// 4-bit support for Low-Speed Card (RO)
N#define SDIO_CIS_PTR_REG    0x09    /// Pointer to CIS (3B, LSB first)
N#define SDIO_BUS_SUSP_REG   0x0C    /// Bus Suspend
N#define  SDIO_BS            (0x1UL << 0)/// Bus Status (transfer on DAT[x] lines) (RO)
N#define  SDIO_BR            (0x1UL << 1)/// Bus Release Request/Status (R/W)
N#define SDIO_FUN_SEL_REG    0x0D    /// Function select
N#define  SDIO_DF            (0x1UL << 7)/// Resume Data Flag (RO)
N#define  SDIO_FS            (0xFUL << 0)/// Select Function (R/W)
N#define  SDIO_FS_CIA        (0x0UL << 0)/// Select CIA (function 0)
N#define  SDIO_FS_FN1        (0x1UL << 0)/// Select Function 1
N#define  SDIO_FS_FN2        (0x2UL << 0)/// Select Function 2
N#define  SDIO_FS_FN3        (0x3UL << 0)/// Select Function 3
N#define  SDIO_FS_FN4        (0x4UL << 0)/// Select Function 4
N#define  SDIO_FS_FN5        (0x5UL << 0)/// Select Function 5
N#define  SDIO_FS_FN6        (0x6UL << 0)/// Select Function 6
N#define  SDIO_FS_FN7        (0x7UL << 0)/// Select Function 7
N#define  SDIO_FS_MEM        (0x8UL << 0)/// Select memory in combo card
N#define SDIO_EXEC_REG       0x0E    /// Exec Flags (RO)
N#define  SDIO_EXM           (0x1UL << 0)/// Executing status of memory
N#define  SDIO_EX            (0xFEUL)    /// Executing status of functions
N#define  SDIO_EX_FN1        (0x1UL << 1)/// Executing status of function 1
N#define  SDIO_EX_FN2        (0x1UL << 2)/// Executing status of function 2
N#define  SDIO_EX_FN3        (0x1UL << 3)/// Executing status of function 3
N#define  SDIO_EX_FN4        (0x1UL << 4)/// Executing status of function 4
N#define  SDIO_EX_FN5        (0x1UL << 5)/// Executing status of function 5
N#define  SDIO_EX_FN6        (0x1UL << 6)/// Executing status of function 6
N#define  SDIO_EX_FN7        (0x1UL << 7)/// Executing status of function 7
N#define SDIO_READY_REG      0x0F    /// Ready Flags (RO)
N#define  SDIO_RFM           (0x1UL << 0)/// Ready Flag for memory
N#define  SDIO_RF            (0xFEUL)    /// Ready Flag for functions
N#define  SDIO_RF_FN1        (0x1UL << 1)/// Ready Flag for function 1
N#define  SDIO_RF_FN2        (0x1UL << 2)/// Ready Flag for function 2
N#define  SDIO_RF_FN3        (0x1UL << 3)/// Ready Flag for function 3
N#define  SDIO_RF_FN4        (0x1UL << 4)/// Ready Flag for function 4
N#define  SDIO_RF_FN5        (0x1UL << 5)/// Ready Flag for function 5
N#define  SDIO_RF_FN6        (0x1UL << 6)/// Ready Flag for function 6
N#define  SDIO_RF_FN7        (0x1UL << 7)/// Ready Flag for function 7
N#define SDIO_FN0_BLKSIZ_REG 0x10    /// FN0 Block Size (2B, LSB first) (R/W)
N#define SDIO_POWER_REG      0x12    /// Power Control
N#define  SDIO_SMPC          (0x1UL << 0)/// Support Master Power Control (RO)
N#define  SDIO_EMPC          (0x1UL << 1)/// Enable Master Power Control (R/W)
N#define SDIO_HS_REG         0x13    /// High-Speed
N#define  SDIO_SHS           (0x1UL << 0)/// Support High-Speed (RO)
N#define  SDIO_EHS           (0x1UL << 1)/// Enable High-Speed (R/W)
N
N// SDIO Function Basic Registers (FBR)
N#define SDIO_FBR_ADDR(fn, x)    (0x100*(fn) + (x))
N#define SDIO_FBR_CSA_IF         0x0     /// CSA and function interface code (RO)
N#define  SDIO_IFC               (0xFUL << 0)/// Standard SDIO Fun Interface Code
N#define  SDIO_IFC_NO_IF         (0x0UL << 0)/// No SDIO standard interface
N#define  SDIO_IFC_UART          (0x1UL << 0)/// UART
N#define  SDIO_IFC_TA_BT         (0x2UL << 0)/// Type-A Bluetooth
N#define  SDIO_IFC_TB_BT         (0x3UL << 0)/// Type-B Bluetooth
N#define  SDIO_IFC_GPS           (0x4UL << 0)/// GPS
N#define  SDIO_IFC_CAMERA        (0x5UL << 0)/// Camera
N#define  SDIO_IFC_PHS           (0x6UL << 0)/// PHS
N#define  SDIO_IFC_WLAN          (0x7UL << 0)/// WLAN
N#define  SDIO_IFC_ATA           (0x8UL << 0)/// Embedded SDIO-ATA
N#define  SDIO_IFC_EXT           (0xFUL << 0)/// Check EXT interface code
N#define  SDIO_SCSA              (0x1UL << 6)/// Function supports Code Storage Area (CSA)
N#define  SDIO_FBR_CSA           (0x1UL << 7)/// Function CSA enable
N#define SDIO_FBR_EXT_IF         0x1     /// Extended function interface code (RO)
N#define SDIO_FBR_PWR            0x2     /// function power control
N#define  SDIO_SPS               (0x1UL << 0)/// function support power selection (RO)
N#define  SDIO_EPS               (0x1UL << 1)/// Low Current Mode/High Current Mode (R/W)
N#define SDIO_FBR_CIS_PTR        0x9     /// Address pointer to function CIS (3B, LSB first) (RO)
N#define SDIO_FBR_CSA_PTR        0xC     /// Address pointer to CSA (3B, LSB first) (R/W)
N#define SDIO_FBR_CSA_DATA       0xF     /// Read/Write fifo to CSA (R/W)
N#define SDIO_FBR_BLK_SIZ        0x10    /// Block size (2B, LSB first) (R/W)
N
N// SDIO Card Metaformat
N#define CISTPL_NULL     0x00    /// Null tuple (PCMCIA 3.1.9)
N#define CISTPL_DEVICE   0x01    /// Device tuple (PCMCIA 3.2.2)
N#define CISTPL_CHECKSUM 0x10    /// Checksum control (PCMCIA 3.1.1)
N#define CISTPL_VERS_1   0x15    /// Level 1 version (PCMCIA 3.2.10)
N#define CISTPL_ALTSTR   0x16    /// Alternate Language String (PCMCIA 3.2.1)
N#define CISTPL_MANFID   0x20    /// Manufacturer Identification String (PCMCIA 3.2.9)
N#define CISTPL_FUNCID   0x21    /// Function Identification (PCMCIA 3.2.7)
N#define CISTPL_FUNCE    0x22    /// Function Extensions (PCMCIA 3.2.6)
N#define CISTPL_SDIO_STD 0x91    /// Additional information for SDIO (PCMCIA 6.1.2)
N#define CISTPL_SDIO_EXT 0x92    /// Reserved for future SDIO (PCMCIA 6.1.3)
N#define CISTPL_END      0xFF    /// The End-of-chain Tuple (PCMCIA 3.1.2)
N
N//------------------------------------------------------------------------------
N//         Types
N//------------------------------------------------------------------------------
N
Ntypedef MciCallback SdCallback;
Ntypedef MciCmd      SdCmd;
Ntypedef Mci         SdDriver;
N
N//------------------------------------------------------------------------------
N/// Sdcard driver structure. It holds the current command being processed and
N/// the SD card address.
N//------------------------------------------------------------------------------
Ntypedef struct _SdCard {
N
N    /// Pointer to the underlying MCI driver.
N    SdDriver *pSdDriver;
N    /// Current MCI command being processed.
N    SdCmd command;
N    /// Card IDentification (CID register)   
N    unsigned int cid[4];    
N    /// Card-specific data (CSD register)   
N    unsigned int csd[4];
N    /// SD SCR(64 bit), Status(512 bit) or MMC EXT_CSD(512 bytes) register
N    unsigned int extData[512 / 4];
N    /// Previous access block number.
N    unsigned int preBlock;
N    /// Card total size
N    unsigned int totalSize;
N    /// Card block number
N    unsigned int blockNr;
N    /// Card option command support list
N    unsigned int optCmdBitMap;
N    /// Card CSD TRANS_SPEED
N    unsigned int transSpeed;
N    /// SD card current address.
N    unsigned short cardAddress;
N    /// Card type
N    unsigned char cardType;
N    /// Card access mode
N    unsigned char mode;
N    /// State after sd command complete
N    unsigned char state;
N} SdCard;
N
Ntypedef struct _MmcCmd6Arg {
N
N    /// Access
N    unsigned char access;
N    /// Index
N    unsigned char index;
N    /// Value
N    unsigned char value;
N    /// Cmd Set
N    unsigned char cmdSet;
N} MmcCmd6Arg;
N
Ntypedef struct _SdCmd6Arg {
N    unsigned int accessMode:4,  /// [ 3: 0] function group 1, access mode
N                 command:4,     /// [ 7: 4] function group 2, command system
N                 reserveFG3:4,  /// [11: 8] function group 3, 0xF or 0x0
N                 reserveFG4:4,  /// [15:12] function group 4, 0xF or 0x0
N                 reserveFG5:4,  /// [19:16] function group 5, 0xF or 0x0
N                 reserveFG6:4,  /// [23:20] function group 6, 0xF or 0x0
N                 reserved:7,    /// [30:24] reserved 0
N                 mode:1;        /// [31   ] Mode, 0: Check, 1: Switch
N} SdCmd6Arg;
N
N/// General header struct for Tuple
Ntypedef struct _CisTplHeader {
N    unsigned char tpl_code;         /// Tuple code
N    unsigned char tpl_link;         /// Link to next tuple
N} CisTplHeader;
N
N/// 
Ntypedef struct _CisTpl_ManfID {
N    unsigned char tpl_code;         /// CISTPL_MANFID (20H)
N    unsigned char tpl_link;         /// Link to next tuple (at least 4)
N    unsigned char tplmid_manf[2];   /// SDIO Card manufacturer code
N    unsigned char tplmid_card[2];   /// manufacturer information (Part Nb, Rev.)
N} CisTpl_ManfID;
N
N/// Function Identification Tuple
Ntypedef struct _CisTpl_FuncID {
N    unsigned char tpl_code;         /// CISTPL_FUNCID (0x21)
N    unsigned char tpl_link;         /// Link to next tuple (0x02)
N    unsigned char tplfid_function;  /// Card function code (0x0C)
N    unsigned char tplfid_sysinit;   /// System initialization bit mask (0x00)
N} CisTpl_FuncID;
N
N/// Function Extenstion Tuple
Ntypedef struct _CisTpl_FuncE {
N    unsigned char tpl_code;         /// CISTPL_FUNCE (0x22)
N    unsigned char tpl_link;         /// Link to next tuple
N    unsigned char tplfe_type;       /// Type of extended data
N    unsigned char tplfe_data[1];    /// Function information
N} CisTpl_FuncE;
N
N/// Tuple for Function 0 (common)
Ntypedef struct _CisTpl_Func0 {
N    unsigned char tpl_code;         /// CISTPL_FUNCE (0x22)
N    unsigned char tpl_link;         /// Link to next tuple (0x04)
N    unsigned char tplfe_type;       /// Type of extended data (0x00)
N    unsigned char tplfe_fn0_blk_size[2];/// Max block size and byte count
N    unsigned char tple_max_tran_speed;  /// Indicates the max transfer rate
N} CisTpl_Func0;
N
N/// Tuple for Function 1-7
Ntypedef struct _CisTpl_FuncN {
N    unsigned char tpl_code;         /// CISTPL_FUNCE (0x22)
N    unsigned char tpl_link;         /// Link to next tuple (0x2A)
N    unsigned char tplfe_type;       /// Type of extended data (0x01)
N    unsigned char tplfe_function_info;/// Bits significant information
N    unsigned char tplfe_std_io_rev; /// Version level of App Spec. for STD SDIO
N    unsigned char tplfe_card_psn[4];/// Product Serial Number
N    unsigned char tplfe_csa_size[4];/// Size of the CSA space
N    unsigned char tplfe_csa_property;/// Flags identifying properties of CSA
N    unsigned char tplfe_max_blk_size[2];/// Max block size and byte count
N    unsigned char tplfe_ocr[4]; /// OCR value (SD Spec.)
N    unsigned char tplfe_op_min_pwr; /// Min current in mA
N    unsigned char tplfe_op_avg_pwr; /// Avg current in mA
N    unsigned char tplfe_op_max_pwr; /// Max(peak) current in mA
N    unsigned char tplfe_sb_min_pwr; /// Min standby current in mA
N    unsigned char tplfe_sb_avg_pwr; /// Avg standby current in mA
N    unsigned char tplfe_sb_max_pwr; /// Max standby current in mA
N    unsigned char tplfe_min_bw[2];  /// Min data transfer bandwidth, in KB/s
N    unsigned char tplfe_opt_bw[2];  /// Optimum data transfer bandwidth, in KB/s
N    unsigned char tplfe_enable_timeout_val[2];/// Time out IOEx->IORx, in 10ms
N    unsigned char tplfe_sp_avg_pwr_3_3_v[2];/// same as tplfe_op_avg_pwr
N    unsigned char tplfe_sp_max_pwr_3_3_v[2];/// same as tplfe_op_max_pwr
N    unsigned char tplfe_hg_avg_pwr_3_3_v[2];/// Higher Current Mode avg current in mA
N    unsigned char tplfe_hg_max_pwr_3_3_v[2];/// Higher Current Mode peak current in mA
N    unsigned char tplfe_lp_avg_pwr_3_3_v[2];/// Lower Current Mode avg current in mA
N    unsigned char tplfe_lp_max_pwr_3_3_v[2];/// Lower Current Mode avg current in mA
N} CisTpl_FuncN;
N
N//------------------------------------------------------------------------------
N//         Global functions
N//------------------------------------------------------------------------------
N
Nextern unsigned char SD_Init(SdCard *pSd,
N                             SdDriver *pSdDriver);
N
Nextern unsigned char SDIO_ReadDirect(SdCard * pSd,
N                                     unsigned char funNb,
N                                     unsigned int address,
N                                     unsigned char * pBytes,
N                                     unsigned int size);
Nextern unsigned char SDIO_WriteDirect(SdCard * pSd,
N                                      unsigned char funNb,
N                                      unsigned int address,
N                                      unsigned char byte);
Nextern unsigned char SDIO_ReadBytes(SdCard * pSd,
N                                    unsigned char funNb,
N                                    unsigned int address,
N                                    unsigned char isFixedAddr,
N                                    unsigned char * pBytes,
N                                    unsigned int size);
Nextern unsigned char SDIO_WriteBytes(SdCard * pSd,
N                                     unsigned char funNb,
N                                     unsigned int address,
N                                     unsigned char isFixedAddr,
N                                     unsigned char * pBytes,
N                                     unsigned int size);
N
Nextern unsigned char SD_Read(SdCard        *pSd,
N                             unsigned int   address,
N                             void          *pData,
N                             unsigned short length,
N                             SdCallback     pCallback,
N                             void          *pArgs);
N
Nextern unsigned char SD_Write(SdCard        *pSd,
N                              unsigned int   address,
N                              void          *pData,
N                              unsigned short length,
N                              SdCallback     pCallback,
N                              void          *pArgs);
N
Nextern unsigned char SD_ReadBlock(
N    SdCard *pSd,
N    unsigned int address,
N    unsigned short nbBlocks,
N    unsigned char *pData);
N
Nextern unsigned char SD_WriteBlock(
N    SdCard *pSd,
N    unsigned int address,
N    unsigned short nbBlocks,
N    const unsigned char *pData);
N
Nextern unsigned char SD_Stop(SdCard *pSd, SdDriver *pSdDriver);
N
Nextern unsigned char SD_HighSpeedMode(SdCard *pSd,
N                                      unsigned char cardHsMode);
N
Nextern unsigned char MMC_SetupBootMode(SdCard * pSd,
N                                       unsigned char resetBus,
N                                       unsigned char busWidth,
N                                       unsigned char bootPart,
N                                       unsigned char accPart,
N                                       unsigned char bootAck);
N
Nextern unsigned char MMC_BootInit(SdCard * pSd);
Nextern unsigned char MMC_BootRead(SdCard * pSd,
N                                  unsigned int nbBlocks,
N                                  unsigned char * pData);
Nextern unsigned char MMC_BootStop(SdCard * pSd);
N
Nextern unsigned int MMC_GetTotalSizeKB(SdCard *pSd);
N
Nextern void SDIO_DisplayCardInformation(SdCard *pSd);
N
Nextern void SD_DisplayRegisterCID(SdCard *pSd);
N
Nextern void SD_DisplayRegisterCSD(SdCard *pSd);
N
Nextern void SD_DisplayRegisterECSD(SdCard * pSd);
N
Nextern void SD_DisplayRegisterSCR(SdCard * pSd);
N
Nextern void SD_DisplaySdStatus(SdCard * pSd);
N
N#endif //#ifndef SDCARD_H
N
L 35 "atmel\sdmmc_mci.c" 2
N#include "trace.h"
L 1 ".\trace.h" 1
N/*
N *------------------------------------------------------------------------------
N *
N *------------------------------------------------------------------------------
N */
N
N#ifndef __TRACE_H__
N#define __TRACE_H__
N
N#include "shell.h"
L 1 ".\shell.h" 1
N/*
N *------------------------------------------------------------------------------
N *
N *------------------------------------------------------------------------------
N */
N
N#ifndef __SHELL_H__
N#define __SHELL_H__
N
N#include "def.h"
L 1 ".\def.h" 1
N/*
N *------------------------------------------------------------------------------
N *
N *------------------------------------------------------------------------------
N */
N
N#ifndef __DEF_H__
N#define __DEF_H__
N
Ntypedef float F32;
Ntypedef unsigned int U32;
Ntypedef int S32;
Ntypedef unsigned short U16;
Ntypedef short int S16;
Ntypedef unsigned char U8;
Ntypedef char S8;
N
Ntypedef enum { FALSE = 0, TRUE } BOOL;
N
N#endif /* __DEF_H__ */
L 11 ".\shell.h" 2
N
N#define SHELL_INF(...)		{ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N#define SHELL_DATA(...)		{ShellPrintf(__VA_ARGS__);}
N#define SHELL_EMPTY()		{ShellPrintf("\n\r");}
N#define SHELL_BNNER()		{ShellPrintf("==========================================\n\r");}
N
Nvoid ShellAllClear(void);
N
NU32 ShellPrintf(const char* format,...);
Nvoid ShellSendString(S8 *pt);
Nvoid ShellGetString(S8 *string);
NS32 ShellGetIntNum(void);
N
Nvoid ShellPutByte(S8 c);
NS8 ShellGetByte(void);
NS8 ShellGetKey(void);
N
N#endif /* __SHELL_H__ */
L 11 ".\trace.h" 2
N
N#define DEBUG_ENABLE		0
N
N#if (DEBUG_ENABLE == 1)
X#if (0 == 1)
S#define TRACE_DEBUG(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;34mD: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
S#define TRACE_DEBUG_WP(...)		{ShellPrintf(__VA_ARGS__);}
S#define DEBUG_MSG(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;34mD: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
S#define DEBUG_MSG_WP(...)	{ShellPutByte(0x1B); ShellPrintf("[1;1;34mD: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__);}
S
S#define ASSERT(condition, ...)  { \
S    if (!(condition)) { \
S        ShellPrintf("ASSERT: "); \
S        ShellPrintf(__VA_ARGS__); \
S        while (1); \
S    } \
S}
X#define ASSERT(condition, ...)  {     if (!(condition)) {         ShellPrintf("ASSERT: ");         ShellPrintf(__VA_ARGS__);         while (1);     } }
S#define SANITY_ERROR            "Sanity check failed at %s:%d\n\r"
S
S/// Performs the same duty as the ASSERT() macro, except a default error
S/// message is output if the condition is false.
S/// \param condition  Condition to verify.
S#define SANITY_CHECK(condition) ASSERT(condition, SANITY_ERROR, __FILE__, __LINE__)
S		
S
N#else
N#define TRACE_DEBUG(...)		{ }
N#define TRACE_DEBUG_WP(...)		{ShellPrintf(__VA_ARGS__);}
N#define DEBUG_MSG(...)		{ }
N#define DEBUG_MSG_WP(...)	{ }
N#define ASSERT(...)
N#define SANITY_CHECK(...)
N#endif
N
N
N#define PRINT_F(...)		{ShellPrintf(__VA_ARGS__);}
N#define TRACE_MSG(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N#define TRACE_FIN(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;32mF: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N#define TRACE_WRN(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N#define TRACE_ERR(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N
N
N
N#define TRACE_ERROR(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N#define TRACE_INFO(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N#define TRACE_WARNING(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N#define TRACE_ERROR_WP(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__);}
N#define TRACE_INFO_WP(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__);}
N#define TRACE_WARNING_WP(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__);}
N
N#endif /* __TRACE_H__ */
L 36 "atmel\sdmmc_mci.c" 2
N#include "dbgu.h"
L 1 ".\dbgu.h" 1
N/*
N *------------------------------------------------------------------------------
N *
N *------------------------------------------------------------------------------
N */
N
N#ifndef __DBGU_H__
N#define __DBGU_H__
N
N// -------- DBGU_CR : (USART Offset: 0x0)  Control Register -------- 
N#define DBGU_RSTRX		(0x1 <<  2) // (USART) Reset Receiver
N#define DBGU_RSTTX		(0x1 <<  3) // (USART) Reset Transmitter
N#define DBGU_RXEN		(0x1 <<  4) // (USART) Receiver Enable
N#define DBGU_RXDIS		(0x1 <<  5) // (USART) Receiver Disable
N#define DBGU_TXEN		(0x1 <<  6) // (USART) Transmitter Enable
N#define DBGU_TXDIS		(0x1 <<  7) // (USART) Transmitter Disable
N#define DBGU_RSTSTA		(0x1 <<  8) // (USART) Reset Status Bits
N
N// -------- DBGU_IER : (USART Offset: 0x8)  Interrupt Enable Register -------- 
N#define DBGU_RXRDY		(0x1 <<  0) // (USART) RXRDY Interrupt
N#define DBGU_TXRDY		(0x1 <<  1) // (USART) TXRDY Interrupt
N#define DBGU_ENDRX		(0x1 <<  3) // (USART) End of Receive Transfer Interrupt
N#define DBGU_ENDTX		(0x1 <<  4) // (USART) End of Transmit Interrupt
N#define DBGU_OVRE		(0x1 <<  5) // (USART) Overrun Interrupt
N#define DBGU_FRAME		(0x1 <<  6) // (USART) Framing Error Interrupt
N#define DBGU_PARE		(0x1 <<  7) // (USART) Parity Error Interrupt
N#define DBGU_TXEMPTY	(0x1 <<  9) // (USART) TXEMPTY Interrupt
N#define DBGU_TXBUFE		(0x1 << 11) // (USART) TXBUFE Interrupt
N#define DBGU_RXBUFF		(0x1 << 12) // (USART) RXBUFF Interrupt
N#define DBGU_COMMTX		(0x1 << 30) // (USART) Clear To Send Input Change Flag
N#define DBGU_COMMRX		(0x1 << 31) // (USART) Manchester Error Interrupt
N
N//void DBGU_TxEN(void);
N//void DBGU_TxDIS(void);
N//void DBGU_RxEN(void);
N//void DBGU_RxDIS(void);
N
Nvoid DBGU_PutByte(S8 c);
NS8 DBGU_GetByte(void);
NS8 DBGU_GetKey(void);
N
N#endif /* __DBGU_H__ */
L 37 "atmel\sdmmc_mci.c" 2
N
N//#include "pio.h"
N
N#include <string.h>
L 1 "C:\Keil\ARM\RV31\INC\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 137748 $
N * Checkin $Date: 2008-09-11 17:34:24 +0100 (Thu, 11 Sep 2008) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
L 41 "atmel\sdmmc_mci.c" 2
N
N//------------------------------------------------------------------------------
N//         Global variables
N//------------------------------------------------------------------------------
N
N#if defined(MCI2_INTERFACE)
X#if 1L
Nunsigned char gSdmmcAutoHsEnable = 1;
N#else
Sunsigned char gSdmmcAutoHsEnable = 0;
N#endif
N
N//------------------------------------------------------------------------------
N//         Local constants
N//------------------------------------------------------------------------------
N
N//#define SINGLE_READ
N//#define SINGLE_WRITE
N
N// Timeout wait loop
N#define TO_LOOP             0x10000
N
N// SD card operation states
N#define SD_STATE_IDLE        0
N#define SD_STATE_INIT        1
N#define SD_STATE_READY       2
N#define SD_STATE_READ     0x10
N#define SD_STATE_RD_RDY   0x11
N#define SD_STATE_RD_BSY   0x12
N#define SD_STATE_WRITE    0x20
N#define SD_STATE_WR_RDY   0x21
N#define SD_STATE_WR_BSY   0x22
N#define SD_STATE_BOOT     0x30
N
N// Delay between sending MMC commands
N#define MMC_DELAY     0x4FF
N
N#define SD_ADDRESS(pSd, address) \
N    ( ((pSd)->totalSize == 0xFFFFFFFF) ? \
N                            (address):((address) << SD_BLOCK_SIZE_BIT) )
X#define SD_ADDRESS(pSd, address)     ( ((pSd)->totalSize == 0xFFFFFFFF) ?                             (address):((address) << SD_BLOCK_SIZE_BIT) )
N
N//-----------------------------------------------------------------------------
N/// MMC/SD in SPI mode reports R1 status always, and R2 for SEND_STATUS
N/// R1 is the low order byte; R2 is the next highest byte, when present.
N//-----------------------------------------------------------------------------
N#define R1_SPI_IDLE             (1 << 0)
N#define R1_SPI_ERASE_RESET      (1 << 1)
N#define R1_SPI_ILLEGAL_COMMAND  (1 << 2)
N#define R1_SPI_COM_CRC          (1 << 3)
N#define R1_SPI_ERASE_SEQ        (1 << 4)
N#define R1_SPI_ADDRESS          (1 << 5)
N#define R1_SPI_PARAMETER        (1 << 6)
N// R1 bit 7 is always zero
N#define R2_SPI_CARD_LOCKED      (1 << 0)
N#define R2_SPI_WP_ERASE_SKIP    (1 << 1)
N#define R2_SPI_LOCK_UNLOCK_FAIL R2_SPI_WP_ERASE_SKIP
N#define R2_SPI_ERROR            (1 << 2)
N#define R2_SPI_CC_ERROR         (1 << 3)
N#define R2_SPI_CARD_ECC_ERROR   (1 << 4)
N#define R2_SPI_WP_VIOLATION     (1 << 5)
N#define R2_SPI_ERASE_PARAM      (1 << 6)
N#define R2_SPI_OUT_OF_RANGE     (1 << 7)
N#define R2_SPI_CSD_OVERWRITE    R2_SPI_OUT_OF_RANGE
N
N// Status register constants
N#define STATUS_APP_CMD          (1UL << 5)
N#define STATUS_SWITCH_ERROR     (1UL << 7)
N#define STATUS_READY_FOR_DATA   (1UL << 8)
N#define STATUS_IDLE             (0UL << 9)
N#define STATUS_READY            (1UL << 9)
N#define STATUS_IDENT            (2UL << 9)
N#define STATUS_STBY             (3UL << 9)
N#define STATUS_TRAN             (4UL << 9)
N#define STATUS_DATA             (5UL << 9)
N#define STATUS_RCV              (6UL << 9)
N#define STATUS_PRG              (7UL << 9)
N#define STATUS_DIS              (8UL << 9)
N#define STATUS_STATE          (0xFUL << 9)
N#define STATUS_ERASE_RESET       (1UL << 13)
N#define STATUS_WP_ERASE_SKIP     (1UL << 15)
N#define STATUS_CIDCSD_OVERWRITE  (1UL << 16)
N#define STATUS_OVERRUN           (1UL << 17)
N#define STATUS_UNERRUN           (1UL << 18)
N#define STATUS_ERROR             (1UL << 19)
N#define STATUS_CC_ERROR          (1UL << 20)
N#define STATUS_CARD_ECC_FAILED   (1UL << 21)
N#define STATUS_ILLEGAL_COMMAND   (1UL << 22)
N#define STATUS_COM_CRC_ERROR     (1UL << 23)
N#define STATUS_UN_LOCK_FAILED    (1UL << 24)
N#define STATUS_CARD_IS_LOCKED    (1UL << 25)
N#define STATUS_WP_VIOLATION      (1UL << 26)
N#define STATUS_ERASE_PARAM       (1UL << 27)
N#define STATUS_ERASE_SEQ_ERROR   (1UL << 28)
N#define STATUS_BLOCK_LEN_ERROR   (1UL << 29)
N#define STATUS_ADDRESS_MISALIGN  (1UL << 30)
N#define STATUS_ADDR_OUT_OR_RANGE (1UL << 31)
N
N#define STATUS_STOP ( STATUS_CARD_IS_LOCKED \
N                        | STATUS_COM_CRC_ERROR \
N                        | STATUS_ILLEGAL_COMMAND \
N                        | STATUS_CC_ERROR \
N                        | STATUS_ERROR \
N                        | STATUS_STATE \
N                        | STATUS_READY_FOR_DATA )
X#define STATUS_STOP ( STATUS_CARD_IS_LOCKED                         | STATUS_COM_CRC_ERROR                         | STATUS_ILLEGAL_COMMAND                         | STATUS_CC_ERROR                         | STATUS_ERROR                         | STATUS_STATE                         | STATUS_READY_FOR_DATA )
N
N#define STATUS_WRITE ( STATUS_ADDR_OUT_OR_RANGE \
N                        | STATUS_ADDRESS_MISALIGN \
N                        | STATUS_BLOCK_LEN_ERROR \
N                        | STATUS_WP_VIOLATION \
N                        | STATUS_CARD_IS_LOCKED \
N                        | STATUS_COM_CRC_ERROR \
N                        | STATUS_ILLEGAL_COMMAND \
N                        | STATUS_CC_ERROR \
N                        | STATUS_ERROR \
N                        | STATUS_ERASE_RESET \
N                        | STATUS_STATE \
N                        | STATUS_READY_FOR_DATA )
X#define STATUS_WRITE ( STATUS_ADDR_OUT_OR_RANGE                         | STATUS_ADDRESS_MISALIGN                         | STATUS_BLOCK_LEN_ERROR                         | STATUS_WP_VIOLATION                         | STATUS_CARD_IS_LOCKED                         | STATUS_COM_CRC_ERROR                         | STATUS_ILLEGAL_COMMAND                         | STATUS_CC_ERROR                         | STATUS_ERROR                         | STATUS_ERASE_RESET                         | STATUS_STATE                         | STATUS_READY_FOR_DATA )
N
N#define STATUS_READ  ( STATUS_ADDR_OUT_OR_RANGE \
N                        | STATUS_ADDRESS_MISALIGN \
N                        | STATUS_BLOCK_LEN_ERROR \
N                        | STATUS_CARD_IS_LOCKED \
N                        | STATUS_COM_CRC_ERROR \
N                        | STATUS_ILLEGAL_COMMAND \
N                        | STATUS_CARD_ECC_FAILED \
N                        | STATUS_CC_ERROR \
N                        | STATUS_ERROR \
N                        | STATUS_ERASE_RESET \
N                        | STATUS_STATE \
N                        | STATUS_READY_FOR_DATA )
X#define STATUS_READ  ( STATUS_ADDR_OUT_OR_RANGE                         | STATUS_ADDRESS_MISALIGN                         | STATUS_BLOCK_LEN_ERROR                         | STATUS_CARD_IS_LOCKED                         | STATUS_COM_CRC_ERROR                         | STATUS_ILLEGAL_COMMAND                         | STATUS_CARD_ECC_FAILED                         | STATUS_CC_ERROR                         | STATUS_ERROR                         | STATUS_ERASE_RESET                         | STATUS_STATE                         | STATUS_READY_FOR_DATA )
N
N#define STATUS_SD_SWITCH ( STATUS_ADDR_OUT_OR_RANGE \
N                            | STATUS_CARD_IS_LOCKED \
N                            | STATUS_COM_CRC_ERROR \
N                            | STATUS_ILLEGAL_COMMAND \
N                            | STATUS_CARD_ECC_FAILED \
N                            | STATUS_CC_ERROR \
N                            | STATUS_ERROR \
N                            | STATUS_UNERRUN \
N                            | STATUS_OVERRUN \
N                            | STATUS_STATE)
X#define STATUS_SD_SWITCH ( STATUS_ADDR_OUT_OR_RANGE                             | STATUS_CARD_IS_LOCKED                             | STATUS_COM_CRC_ERROR                             | STATUS_ILLEGAL_COMMAND                             | STATUS_CARD_ECC_FAILED                             | STATUS_CC_ERROR                             | STATUS_ERROR                             | STATUS_UNERRUN                             | STATUS_OVERRUN                             | STATUS_STATE)
N
N#define STATUS_MMC_SWITCH ( STATUS_CARD_IS_LOCKED \
N                            | STATUS_COM_CRC_ERROR \
N                            | STATUS_ILLEGAL_COMMAND \
N                            | STATUS_CC_ERROR \
N                            | STATUS_ERROR \
N                            | STATUS_ERASE_RESET \
N                            | STATUS_STATE \
N                            | STATUS_READY_FOR_DATA \
N                            | STATUS_SWITCH_ERROR )
X#define STATUS_MMC_SWITCH ( STATUS_CARD_IS_LOCKED                             | STATUS_COM_CRC_ERROR                             | STATUS_ILLEGAL_COMMAND                             | STATUS_CC_ERROR                             | STATUS_ERROR                             | STATUS_ERASE_RESET                             | STATUS_STATE                             | STATUS_READY_FOR_DATA                             | STATUS_SWITCH_ERROR )
N
N//                            | (0x3UL << 12) /* IO_CURRENT_STATE */
N#define STATUS_SDIO_CMD52 ( (1UL << 15) /* COM_CRC_ERROR */ \
N                            | (1UL << 14) /* ILLEGAL_COMMAND */ \
N                            | (1UL << 11) /* ERRIR */ \
N                            | (1UL <<  9) /* FUNCTION_NUMBER */ \
N                            | (1UL <<  8) /* OUT_OF_RANGE */)
X#define STATUS_SDIO_CMD52 ( (1UL << 15)                               | (1UL << 14)                               | (1UL << 11)                               | (1UL <<  9)                               | (1UL <<  8)  )
N
N//-----------------------------------------------------------------------------
N/// OCR Register
N//-----------------------------------------------------------------------------
N#define AT91C_VDD_16_17          (1UL << 4)
N#define AT91C_VDD_17_18          (1UL << 5)
N#define AT91C_VDD_18_19          (1UL << 6)
N#define AT91C_VDD_19_20          (1UL << 7)
N#define AT91C_VDD_20_21          (1UL << 8)
N#define AT91C_VDD_21_22          (1UL << 9)
N#define AT91C_VDD_22_23          (1UL << 10)
N#define AT91C_VDD_23_24          (1UL << 11)
N#define AT91C_VDD_24_25          (1UL << 12)
N#define AT91C_VDD_25_26          (1UL << 13)
N#define AT91C_VDD_26_27          (1UL << 14)
N#define AT91C_VDD_27_28          (1UL << 15)
N#define AT91C_VDD_28_29          (1UL << 16)
N#define AT91C_VDD_29_30          (1UL << 17)
N#define AT91C_VDD_30_31          (1UL << 18)
N#define AT91C_VDD_31_32          (1UL << 19)
N#define AT91C_VDD_32_33          (1UL << 20)
N#define AT91C_VDD_33_34          (1UL << 21)
N#define AT91C_VDD_34_35          (1UL << 22)
N#define AT91C_VDD_35_36          (1UL << 23)
N#define AT91C_SDIO_MP            (1UL << 27)
N#define AT91C_SDIO_NF            (7UL << 28)
N#define AT91C_MMC_OCR_BIT2930    (3UL << 29)
N#define AT91C_CARD_POWER_UP_BUSY (1UL << 31)
N
N#define AT91C_MMC_HOST_VOLTAGE_RANGE     (AT91C_VDD_27_28 +\
N                                          AT91C_VDD_28_29 +\
N                                          AT91C_VDD_29_30 +\
N                                          AT91C_VDD_30_31 +\
N                                          AT91C_VDD_31_32 +\
N                                          AT91C_VDD_32_33)
X#define AT91C_MMC_HOST_VOLTAGE_RANGE     (AT91C_VDD_27_28 +                                          AT91C_VDD_28_29 +                                          AT91C_VDD_29_30 +                                          AT91C_VDD_30_31 +                                          AT91C_VDD_31_32 +                                          AT91C_VDD_32_33)
N
N// MMC OCR response for Bit 29, 30
N#define AT91C_MMC_NORM_DENSITY   (0x0UL << 29)
N#define AT91C_MMC_HIGH_DENSITY   (0x2UL << 29)
N
N#define AT91C_CCS    (1 << 30)
N
N// MCI_CMD Register Value
N#define AT91C_POWER_ON_INIT      (0 | AT91C_MCI_TRCMD_NO    \
N                                    | AT91C_MCI_SPCMD_INIT  \
N                                    | AT91C_MCI_OPDCMD)
X#define AT91C_POWER_ON_INIT      (0 | AT91C_MCI_TRCMD_NO                                        | AT91C_MCI_SPCMD_INIT                                      | AT91C_MCI_OPDCMD)
N
N//-----------------------------------------------------------------------------
N/// eMMC CMD6
N//-----------------------------------------------------------------------------
N#define AT91C_EMMC_CMD6ARG_ACCESS_BITS        (0x3UL << 24)
N#define AT91C_EMMC_CMD6ARG_ACCESS_SHIFT       (24)
N// change command sets
N#define AT91C_EMMC_CMD6ARG_ACCESS_CMDSETS     (0x0UL << 24)
N// set bits in the value field
N#define AT91C_EMMC_CMD6ARG_ACCESS_SETBITS     (0x1UL << 24)
N// clear bits in the value field
N#define AT91C_EMMC_CMD6ARG_ACCESS_CLRBITS     (0x2UL << 24)
N// the value field is written into the pointed byte
N#define AT91C_EMMC_CMD6ARG_ACCESS_WRBYTES     (0x3UL << 24) 
N#define AT91C_EMMC_CMD6ARG_INDEX_BITS         (0xffUL << 16)
N#define AT91C_EMMC_CMD6ARG_INDEX_SHIFT        (16)
N#define AT91C_EMMC_CMD6ARG_VALUE_BITS         (0xffUL << 8)
N#define AT91C_EMMC_CMD6ARG_VALUE_SHIFT        (8)
N#define AT91C_EMMC_CMD6ARG_CMDSET_BITS        (0x7UL << 0)
N#define AT91C_EMMC_CMD6ARG_CMDSET_SHIFT       (0)
N
N//-----------------------------------------------------------------------------
N// Command Classes
N//-----------------------------------------------------------------------------
N//
N// Class 0, 2, 4, 5, 7 and 8 are mandatory and shall be supported by
N// all SD Memory Cards.
N//
N// Basic Commands (class 0)
N//
N// Cmd0 MCI + SPI
N#define   AT91C_GO_IDLE_STATE_CMD     (0 | AT91C_MCI_TRCMD_NO \
N                                         | AT91C_MCI_SPCMD_NONE )
X#define   AT91C_GO_IDLE_STATE_CMD     (0 | AT91C_MCI_TRCMD_NO                                          | AT91C_MCI_SPCMD_NONE )
N// Cmd1 SPI
N#define   AT91C_MMC_SEND_OP_COND_CMD  (1 | AT91C_MCI_TRCMD_NO \
N                                         | AT91C_MCI_SPCMD_NONE \
N                                         | AT91C_MCI_RSPTYP_48 \
N                                         | AT91C_MCI_OPDCMD)
X#define   AT91C_MMC_SEND_OP_COND_CMD  (1 | AT91C_MCI_TRCMD_NO                                          | AT91C_MCI_SPCMD_NONE                                          | AT91C_MCI_RSPTYP_48                                          | AT91C_MCI_OPDCMD)
N// Cmd2 MCI
N#define   AT91C_ALL_SEND_CID_CMD      (2 | AT91C_MCI_TRCMD_NO \
N                                         | AT91C_MCI_SPCMD_NONE \
N                                         | AT91C_MCI_OPDCMD \
N                                         | AT91C_MCI_RSPTYP_136 )
X#define   AT91C_ALL_SEND_CID_CMD      (2 | AT91C_MCI_TRCMD_NO                                          | AT91C_MCI_SPCMD_NONE                                          | AT91C_MCI_OPDCMD                                          | AT91C_MCI_RSPTYP_136 )
N// Cmd3 MCI
N#define   AT91C_SET_RELATIVE_ADDR_CMD (3 | AT91C_MCI_TRCMD_NO \
N                                         | AT91C_MCI_SPCMD_NONE \
N                                         | AT91C_MCI_RSPTYP_48 \
N                                         | AT91C_MCI_OPDCMD \
N                                         | AT91C_MCI_MAXLAT )
X#define   AT91C_SET_RELATIVE_ADDR_CMD (3 | AT91C_MCI_TRCMD_NO                                          | AT91C_MCI_SPCMD_NONE                                          | AT91C_MCI_RSPTYP_48                                          | AT91C_MCI_OPDCMD                                          | AT91C_MCI_MAXLAT )
N// Cmd4 MCI
N#define AT91C_SET_DSR_CMD             (4 | AT91C_MCI_TRCMD_NO \
N                                         | AT91C_MCI_SPCMD_NONE \
N                                         | AT91C_MCI_RSPTYP_NO \
N                                         | AT91C_MCI_MAXLAT )
X#define AT91C_SET_DSR_CMD             (4 | AT91C_MCI_TRCMD_NO                                          | AT91C_MCI_SPCMD_NONE                                          | AT91C_MCI_RSPTYP_NO                                          | AT91C_MCI_MAXLAT )
N// Cmd5 MCI
N#define AT91C_IO_SEND_OP_COND_CMD     (5 | AT91C_MCI_TRCMD_NO \
N                                         | AT91C_MCI_SPCMD_NONE \
N                                         | AT91C_MCI_RSPTYP_48 \
N                                         | AT91C_MCI_OPDCMD )
X#define AT91C_IO_SEND_OP_COND_CMD     (5 | AT91C_MCI_TRCMD_NO                                          | AT91C_MCI_SPCMD_NONE                                          | AT91C_MCI_RSPTYP_48                                          | AT91C_MCI_OPDCMD )
N// Cmd6 SD/MMC
N#if defined(MCI2_INTERFACE)
X#if 1L
N#define AT91C_MMC_SWITCH_CMD          (6 | AT91C_MCI_TRCMD_NO \
N                                         | AT91C_MCI_SPCMD_NONE \
N                                         | AT91C_MCI_RSPTYP_R1B \
N                                         | AT91C_MCI_MAXLAT )
X#define AT91C_MMC_SWITCH_CMD          (6 | AT91C_MCI_TRCMD_NO                                          | AT91C_MCI_SPCMD_NONE                                          | AT91C_MCI_RSPTYP_R1B                                          | AT91C_MCI_MAXLAT )
N#else
S#define AT91C_MMC_SWITCH_CMD          (6 | AT91C_MCI_TRCMD_NO \
S                                         | AT91C_MCI_SPCMD_NONE \
S                                         | AT91C_MCI_RSPTYP_48 \
S                                         | AT91C_MCI_MAXLAT )
X#define AT91C_MMC_SWITCH_CMD          (6 | AT91C_MCI_TRCMD_NO                                          | AT91C_MCI_SPCMD_NONE                                          | AT91C_MCI_RSPTYP_48                                          | AT91C_MCI_MAXLAT )
N#endif
N#define AT91C_SD_SWITCH_CMD           (6 | AT91C_MCI_TRCMD_START \
N                                         | AT91C_MCI_TRTYP_BLOCK \
N                                         | AT91C_MCI_TRDIR_READ \
N                                         | AT91C_MCI_SPCMD_NONE \
N                                         | AT91C_MCI_RSPTYP_48 \
N                                         | AT91C_MCI_MAXLAT )
X#define AT91C_SD_SWITCH_CMD           (6 | AT91C_MCI_TRCMD_START                                          | AT91C_MCI_TRTYP_BLOCK                                          | AT91C_MCI_TRDIR_READ                                          | AT91C_MCI_SPCMD_NONE                                          | AT91C_MCI_RSPTYP_48                                          | AT91C_MCI_MAXLAT )
N// cmd7 MCI
N#define   AT91C_SEL_DESEL_CARD_CMD    (7 | AT91C_MCI_TRCMD_NO \
N                                         | AT91C_MCI_SPCMD_NONE \
N                                         | AT91C_MCI_RSPTYP_48 \
N                                         | AT91C_MCI_MAXLAT )
X#define   AT91C_SEL_DESEL_CARD_CMD    (7 | AT91C_MCI_TRCMD_NO                                          | AT91C_MCI_SPCMD_NONE                                          | AT91C_MCI_RSPTYP_48                                          | AT91C_MCI_MAXLAT )
N#define   AT91C_SEL_CARD_CMD          (7 | AT91C_MCI_TRCMD_NO \
N                                         | AT91C_MCI_SPCMD_NONE \
N                                         | AT91C_MCI_RSPTYP_48 \
N                                         | AT91C_MCI_MAXLAT )
X#define   AT91C_SEL_CARD_CMD          (7 | AT91C_MCI_TRCMD_NO                                          | AT91C_MCI_SPCMD_NONE                                          | AT91C_MCI_RSPTYP_48                                          | AT91C_MCI_MAXLAT )
N#define   AT91C_DESEL_CARD_CMD        (7 | AT91C_MCI_TRCMD_NO \
N                                         | AT91C_MCI_SPCMD_NONE \
N                                         | AT91C_MCI_RSPTYP_NO \
N                                         | AT91C_MCI_MAXLAT )
X#define   AT91C_DESEL_CARD_CMD        (7 | AT91C_MCI_TRCMD_NO                                          | AT91C_MCI_SPCMD_NONE                                          | AT91C_MCI_RSPTYP_NO                                          | AT91C_MCI_MAXLAT )
N// Cmd8 MCI + SPI
N#define   AT91C_SEND_IF_COND          (8  | AT91C_MCI_TRCMD_NO \
N                                          | AT91C_MCI_SPCMD_NONE \
N                                          | AT91C_MCI_RSPTYP_48 \
N                                          | AT91C_MCI_MAXLAT )
X#define   AT91C_SEND_IF_COND          (8  | AT91C_MCI_TRCMD_NO                                           | AT91C_MCI_SPCMD_NONE                                           | AT91C_MCI_RSPTYP_48                                           | AT91C_MCI_MAXLAT )
N// Cmd9 MCI + SPI
N#define   AT91C_SEND_CSD_CMD          (9  | AT91C_MCI_TRCMD_NO \
N                                          | AT91C_MCI_SPCMD_NONE \
N                                          | AT91C_MCI_RSPTYP_136 \
N                                          | AT91C_MCI_MAXLAT )
X#define   AT91C_SEND_CSD_CMD          (9  | AT91C_MCI_TRCMD_NO                                           | AT91C_MCI_SPCMD_NONE                                           | AT91C_MCI_RSPTYP_136                                           | AT91C_MCI_MAXLAT )
N// Cmd10 MCI + SPI
N#define   AT91C_SEND_CID_CMD          (10 | AT91C_MCI_TRCMD_NO \
N                                          | AT91C_MCI_SPCMD_NONE \
N                                          | AT91C_MCI_RSPTYP_136 \
N                                          | AT91C_MCI_MAXLAT )
X#define   AT91C_SEND_CID_CMD          (10 | AT91C_MCI_TRCMD_NO                                           | AT91C_MCI_SPCMD_NONE                                           | AT91C_MCI_RSPTYP_136                                           | AT91C_MCI_MAXLAT )
N// Cmd12 MCI + SPI
N#if defined(MCI2_INTERFACE)
X#if 1L
N#define   AT91C_STOP_TRANSMISSION_CMD (12 | AT91C_MCI_TRCMD_STOP \
N                                          | AT91C_MCI_SPCMD_NONE \
N                                          | AT91C_MCI_RSPTYP_R1B \
N                                          | AT91C_MCI_MAXLAT )
X#define   AT91C_STOP_TRANSMISSION_CMD (12 | AT91C_MCI_TRCMD_STOP                                           | AT91C_MCI_SPCMD_NONE                                           | AT91C_MCI_RSPTYP_R1B                                           | AT91C_MCI_MAXLAT )
N#else
S#define   AT91C_STOP_TRANSMISSION_CMD (12 | AT91C_MCI_TRCMD_STOP \
S                                          | AT91C_MCI_SPCMD_NONE \
S                                          | AT91C_MCI_RSPTYP_48 \
S                                          | AT91C_MCI_MAXLAT )
X#define   AT91C_STOP_TRANSMISSION_CMD (12 | AT91C_MCI_TRCMD_STOP                                           | AT91C_MCI_SPCMD_NONE                                           | AT91C_MCI_RSPTYP_48                                           | AT91C_MCI_MAXLAT )
N#endif
N// Cmd13 MCI + SPI
N#define   AT91C_SEND_STATUS_CMD       (13 | AT91C_MCI_TRCMD_NO \
N                                          | AT91C_MCI_SPCMD_NONE \
N                                          | AT91C_MCI_RSPTYP_48 \
N                                          | AT91C_MCI_MAXLAT )
X#define   AT91C_SEND_STATUS_CMD       (13 | AT91C_MCI_TRCMD_NO                                           | AT91C_MCI_SPCMD_NONE                                           | AT91C_MCI_RSPTYP_48                                           | AT91C_MCI_MAXLAT )
N// Cmd15 MCI
N#define AT91C_GO_INACTIVE_STATE_CMD   (15 | AT91C_MCI_RSPTYP_NO )
N
N// Cmd58 SPI
N#define   AT91C_READ_OCR_CMD          (58 | AT91C_MCI_RSPTYP_48 \
N                                          | AT91C_MCI_SPCMD_NONE \
N                                          | AT91C_MCI_MAXLAT )
X#define   AT91C_READ_OCR_CMD          (58 | AT91C_MCI_RSPTYP_48                                           | AT91C_MCI_SPCMD_NONE                                           | AT91C_MCI_MAXLAT )
N// Cmd59 SPI
N#define   AT91C_CRC_ON_OFF_CMD        (59 | AT91C_MCI_RSPTYP_48 \
N                                          | AT91C_MCI_SPCMD_NONE \
N                                          | AT91C_MCI_MAXLAT )
X#define   AT91C_CRC_ON_OFF_CMD        (59 | AT91C_MCI_RSPTYP_48                                           | AT91C_MCI_SPCMD_NONE                                           | AT91C_MCI_MAXLAT )
N
N//*------------------------------------------------
N//* Class 2 commands: Block oriented Read commands
N//*------------------------------------------------
N
N// Cmd8 for MMC
N#define AT91C_SEND_EXT_CSD_CMD          (8 | AT91C_MCI_SPCMD_NONE \
N                                           | AT91C_MCI_OPDCMD_PUSHPULL \
N                                           | AT91C_MCI_RSPTYP_48 \
N                                           | AT91C_MCI_TRCMD_START \
N                                           | AT91C_MCI_TRTYP_BLOCK \
N                                           | AT91C_MCI_TRDIR \
N                                           | AT91C_MCI_MAXLAT)
X#define AT91C_SEND_EXT_CSD_CMD          (8 | AT91C_MCI_SPCMD_NONE                                            | AT91C_MCI_OPDCMD_PUSHPULL                                            | AT91C_MCI_RSPTYP_48                                            | AT91C_MCI_TRCMD_START                                            | AT91C_MCI_TRTYP_BLOCK                                            | AT91C_MCI_TRDIR                                            | AT91C_MCI_MAXLAT)
N
N// Cmd16
N#define AT91C_SET_BLOCKLEN_CMD          (16 | AT91C_MCI_TRCMD_NO \
N                                            | AT91C_MCI_SPCMD_NONE \
N                                            | AT91C_MCI_RSPTYP_48 \
N                                            | AT91C_MCI_MAXLAT )
X#define AT91C_SET_BLOCKLEN_CMD          (16 | AT91C_MCI_TRCMD_NO                                             | AT91C_MCI_SPCMD_NONE                                             | AT91C_MCI_RSPTYP_48                                             | AT91C_MCI_MAXLAT )
N// Cmd17
N#define AT91C_READ_SINGLE_BLOCK_CMD     (17 | AT91C_MCI_SPCMD_NONE \
N                                            | AT91C_MCI_RSPTYP_48 \
N                                            | AT91C_MCI_TRCMD_START \
N                                            | AT91C_MCI_TRTYP_BLOCK \
N                                            | AT91C_MCI_TRDIR \
N                                            | AT91C_MCI_MAXLAT)
X#define AT91C_READ_SINGLE_BLOCK_CMD     (17 | AT91C_MCI_SPCMD_NONE                                             | AT91C_MCI_RSPTYP_48                                             | AT91C_MCI_TRCMD_START                                             | AT91C_MCI_TRTYP_BLOCK                                             | AT91C_MCI_TRDIR                                             | AT91C_MCI_MAXLAT)
N// Cmd18
N#define AT91C_READ_MULTIPLE_BLOCK_CMD   (18 | AT91C_MCI_SPCMD_NONE \
N                                            | AT91C_MCI_RSPTYP_48 \
N                                            | AT91C_MCI_TRCMD_START \
N                                            | AT91C_MCI_TRTYP_MULTIPLE \
N                                            | AT91C_MCI_TRDIR \
N                                            | AT91C_MCI_MAXLAT)
X#define AT91C_READ_MULTIPLE_BLOCK_CMD   (18 | AT91C_MCI_SPCMD_NONE                                             | AT91C_MCI_RSPTYP_48                                             | AT91C_MCI_TRCMD_START                                             | AT91C_MCI_TRTYP_MULTIPLE                                             | AT91C_MCI_TRDIR                                             | AT91C_MCI_MAXLAT)
N
N//*------------------------------------------------
N//* Class 4 commands: Block oriented write commands
N//*------------------------------------------------
N// Cmd24
N#define AT91C_WRITE_BLOCK_CMD           (24 | AT91C_MCI_SPCMD_NONE \
N                                            | AT91C_MCI_RSPTYP_48 \
N                                            | AT91C_MCI_TRCMD_START \
N                                            | (AT91C_MCI_TRTYP_BLOCK \
N                                                & ~(AT91C_MCI_TRDIR)) \
N                                            | AT91C_MCI_MAXLAT)
X#define AT91C_WRITE_BLOCK_CMD           (24 | AT91C_MCI_SPCMD_NONE                                             | AT91C_MCI_RSPTYP_48                                             | AT91C_MCI_TRCMD_START                                             | (AT91C_MCI_TRTYP_BLOCK                                                 & ~(AT91C_MCI_TRDIR))                                             | AT91C_MCI_MAXLAT)
N// Cmd25
N#define AT91C_WRITE_MULTIPLE_BLOCK_CMD  (25 | AT91C_MCI_SPCMD_NONE \
N                                            | AT91C_MCI_RSPTYP_48 \
N                                            | AT91C_MCI_TRCMD_START \
N                                            | (AT91C_MCI_TRTYP_MULTIPLE \
N                                                & ~(AT91C_MCI_TRDIR)) \
N                                            | AT91C_MCI_MAXLAT)
X#define AT91C_WRITE_MULTIPLE_BLOCK_CMD  (25 | AT91C_MCI_SPCMD_NONE                                             | AT91C_MCI_RSPTYP_48                                             | AT91C_MCI_TRCMD_START                                             | (AT91C_MCI_TRTYP_MULTIPLE                                                 & ~(AT91C_MCI_TRDIR))                                             | AT91C_MCI_MAXLAT)
N// Cmd27
N#define AT91C_PROGRAM_CSD_CMD           (27 | AT91C_MCI_RSPTYP_48 )
N
N//*----------------------------------------
N//* Class 5 commands: Erase commands
N//*----------------------------------------
N// Cmd32
N//#define AT91C_TAG_SECTOR_START_CMD          (32 | AT91C_MCI_SPCMD_NONE  | AT91C_MCI_RSPTYP_48   | AT91C_MCI_TRCMD_NO    | AT91C_MCI_MAXLAT)
N// Cmd33
N//#define AT91C_TAG_SECTOR_END_CMD            (33 | AT91C_MCI_SPCMD_NONE  | AT91C_MCI_RSPTYP_48   | AT91C_MCI_TRCMD_NO    | AT91C_MCI_MAXLAT)
N// Cmd38
N//#define AT91C_ERASE_CMD                     (38 | AT91C_MCI_SPCMD_NONE  | AT91C_MCI_RSPTYP_48   | AT91C_MCI_TRCMD_NO    | AT91C_MCI_MAXLAT )
N
N//*----------------------------------------
N//* Class 7 commands: Lock commands
N//*----------------------------------------
N// Cmd42
N//#define AT91C_LOCK_UNLOCK           (42 | AT91C_MCI_SPCMD_NONE  | AT91C_MCI_RSPTYP_48   | AT91C_MCI_TRCMD_NO    | AT91C_MCI_MAXLAT) // not tested
N
N//*-----------------------------------------------
N// Class 8 commands: Application specific commands
N//*-----------------------------------------------
N// Cmd55
N#define AT91C_APP_CMD               (55 | AT91C_MCI_SPCMD_NONE \
N                                        | AT91C_MCI_RSPTYP_48 \
N                                        | AT91C_MCI_TRCMD_NO \
N                                        | AT91C_MCI_MAXLAT)
X#define AT91C_APP_CMD               (55 | AT91C_MCI_SPCMD_NONE                                         | AT91C_MCI_RSPTYP_48                                         | AT91C_MCI_TRCMD_NO                                         | AT91C_MCI_MAXLAT)
N// cmd 56
N//#define AT91C_GEN_CMD               (56 | AT91C_MCI_SPCMD_NONE  | AT91C_MCI_RSPTYP_48   | AT91C_MCI_TRCMD_NO | AT91C_MCI_MAXLAT)    // not tested
N// ACMD6
N#define AT91C_SD_SET_BUS_WIDTH_CMD          (6  | AT91C_MCI_SPCMD_NONE \
N                                                | AT91C_MCI_RSPTYP_48 \
N                                                | AT91C_MCI_TRCMD_NO \
N                                                | AT91C_MCI_MAXLAT)
X#define AT91C_SD_SET_BUS_WIDTH_CMD          (6  | AT91C_MCI_SPCMD_NONE                                                 | AT91C_MCI_RSPTYP_48                                                 | AT91C_MCI_TRCMD_NO                                                 | AT91C_MCI_MAXLAT)
N// ACMD13
N#define AT91C_SD_STATUS_CMD                 (13 | AT91C_MCI_SPCMD_NONE \
N                                                | AT91C_MCI_RSPTYP_48 \
N                                                | AT91C_MCI_TRCMD_START \
N                                                | AT91C_MCI_TRTYP_BLOCK \
N                                                | AT91C_MCI_TRDIR_READ \
N                                                | AT91C_MCI_MAXLAT)
X#define AT91C_SD_STATUS_CMD                 (13 | AT91C_MCI_SPCMD_NONE                                                 | AT91C_MCI_RSPTYP_48                                                 | AT91C_MCI_TRCMD_START                                                 | AT91C_MCI_TRTYP_BLOCK                                                 | AT91C_MCI_TRDIR_READ                                                 | AT91C_MCI_MAXLAT)
N// ACMD22
N//#define AT91C_SD_SEND_NUM_WR_BLOCKS_CMD     (22 | AT91C_MCI_SPCMD_NONE  | AT91C_MCI_RSPTYP_48   | AT91C_MCI_TRCMD_NO    | AT91C_MCI_MAXLAT)
N// ACMD23
N//#define AT91C_SD_SET_WR_BLK_ERASE_COUNT_CMD (23 | AT91C_MCI_SPCMD_NONE  | AT91C_MCI_RSPTYP_48   | AT91C_MCI_TRCMD_NO    | AT91C_MCI_MAXLAT)
N// ACMD41
N#define AT91C_SD_APP_OP_COND_CMD            (41 | AT91C_MCI_SPCMD_NONE \
N                                                | AT91C_MCI_RSPTYP_48 \
N                                                | AT91C_MCI_TRCMD_NO )
X#define AT91C_SD_APP_OP_COND_CMD            (41 | AT91C_MCI_SPCMD_NONE                                                 | AT91C_MCI_RSPTYP_48                                                 | AT91C_MCI_TRCMD_NO )
N// ACMD42
N//#define AT91C_SD_SET_CLR_CARD_DETECT_CMD    (42 | AT91C_MCI_SPCMD_NONE  | AT91C_MCI_RSPTYP_48   | AT91C_MCI_TRCMD_NO    | AT91C_MCI_MAXLAT)
N// ACMD51
N#define AT91C_SD_SEND_SCR_CMD               (51 | AT91C_MCI_SPCMD_NONE \
N                                                | AT91C_MCI_RSPTYP_48 \
N                                                | AT91C_MCI_TRCMD_START \
N                                                | AT91C_MCI_TRDIR_READ \
N                                                | AT91C_MCI_TRTYP_BLOCK \
N                                                | AT91C_MCI_MAXLAT)
X#define AT91C_SD_SEND_SCR_CMD               (51 | AT91C_MCI_SPCMD_NONE                                                 | AT91C_MCI_RSPTYP_48                                                 | AT91C_MCI_TRCMD_START                                                 | AT91C_MCI_TRDIR_READ                                                 | AT91C_MCI_TRTYP_BLOCK                                                 | AT91C_MCI_MAXLAT)
N
N// SDIO commands
N// CMD5, R4
N#define AT91C_SDIO_SEND_OP_COND (5 | AT91C_MCI_TRCMD_NO \
N                                   | AT91C_MCI_SPCMD_NONE \
N                                   | AT91C_MCI_RSPTYP_48 \
N                                   | AT91C_MCI_OPDCMD)
X#define AT91C_SDIO_SEND_OP_COND (5 | AT91C_MCI_TRCMD_NO                                    | AT91C_MCI_SPCMD_NONE                                    | AT91C_MCI_RSPTYP_48                                    | AT91C_MCI_OPDCMD)
N
N// CMD52, R5
N#define AT91C_SDIO_IO_RW_DIRECT (52| AT91C_MCI_TRCMD_NO \
N                                   | AT91C_MCI_SPCMD_NONE \
N                                   | AT91C_MCI_RSPTYP_48 \
N                                   | AT91C_MCI_MAXLAT )
X#define AT91C_SDIO_IO_RW_DIRECT (52| AT91C_MCI_TRCMD_NO                                    | AT91C_MCI_SPCMD_NONE                                    | AT91C_MCI_RSPTYP_48                                    | AT91C_MCI_MAXLAT )
N
N// CMD53, R5
N#define AT91C_SDIO_IO_RW_EXTENDED (53 | AT91C_MCI_SPCMD_NONE \
N                                      | AT91C_MCI_RSPTYP_48 \
N                                      | AT91C_MCI_TRCMD_START \
N                                      | AT91C_MCI_MAXLAT)
X#define AT91C_SDIO_IO_RW_EXTENDED (53 | AT91C_MCI_SPCMD_NONE                                       | AT91C_MCI_RSPTYP_48                                       | AT91C_MCI_TRCMD_START                                       | AT91C_MCI_MAXLAT)
N
N#ifdef AT91C_MCI_SPCMD_BOOTREQ
S// BOOTREQ
S#define AT91C_BOOTREQ           (AT91C_MCI_SPCMD_BOOTREQ \
S                                    | AT91C_MCI_TRDIR_READ \
S                                    | AT91C_MCI_TRCMD_START \
S                                    | AT91C_MCI_MAXLAT)
X#define AT91C_BOOTREQ           (AT91C_MCI_SPCMD_BOOTREQ                                     | AT91C_MCI_TRDIR_READ                                     | AT91C_MCI_TRCMD_START                                     | AT91C_MCI_MAXLAT)
S// BOOTEND
S#define AT91C_BOOTEND           (AT91C_MCI_SPCMD_BOOTEND \
S                                    | AT91C_MCI_OPDCMD_PUSHPULL)
X#define AT91C_BOOTEND           (AT91C_MCI_SPCMD_BOOTEND                                     | AT91C_MCI_OPDCMD_PUSHPULL)
N#endif
N// Optional commands
N#define SD_ACMD6_SUPPORT        (1UL << 0)
N#define SD_ACMD13_SUPPORT       (1UL << 1)
N#define SD_ACMD41_SUPPORT       (1UL << 2)
N#define SD_ACMD51_SUPPORT       (1UL << 3)
N
N#define SD_CMD16_SUPPORT        (1UL << 8)
N
N//------------------------------------------------------------------------------
N//         Local functions
N//------------------------------------------------------------------------------
N
N//------------------------------------------------------------------------------
N/// DecodeR1
N/// \param R1  
N//------------------------------------------------------------------------------
Nvoid DecodeR1(unsigned char R1)
N{
N    if( (R1 & R1_SPI_IDLE)==R1_SPI_IDLE) {
X    if( (R1 & (1 << 0))==(1 << 0)) {
N        TRACE_DEBUG("R1_SPI_IDLE\n\r");
X        { };
N    }
N    if( (R1 & R1_SPI_ERASE_RESET)==R1_SPI_ERASE_RESET) {
X    if( (R1 & (1 << 1))==(1 << 1)) {
N        TRACE_DEBUG("R1_SPI_ERASE_RESET\n\r");
X        { };
N    }
N    if( (R1 & R1_SPI_ILLEGAL_COMMAND)==R1_SPI_ILLEGAL_COMMAND) {
X    if( (R1 & (1 << 2))==(1 << 2)) {
N        TRACE_DEBUG("R1_SPI_ILLEGAL_COMMAND\n\r");
X        { };
N    }
N    if( (R1 & R1_SPI_COM_CRC)==R1_SPI_COM_CRC) {
X    if( (R1 & (1 << 3))==(1 << 3)) {
N        TRACE_DEBUG("R1_SPI_COM_CRC\n\r");
X        { };
N    }
N    if( (R1 & R1_SPI_ERASE_SEQ)==R1_SPI_ERASE_SEQ) {
X    if( (R1 & (1 << 4))==(1 << 4)) {
N        TRACE_DEBUG("R1_SPI_ERASE_SEQ\n\r");
X        { };
N    }
N    if( (R1 & R1_SPI_ADDRESS)==R1_SPI_ADDRESS) {
X    if( (R1 & (1 << 5))==(1 << 5)) {
N        TRACE_DEBUG("R1_SPI_ADDRESS\n\r");
X        { };
N    }
N    if( (R1 & R1_SPI_PARAMETER)==R1_SPI_PARAMETER) {
X    if( (R1 & (1 << 6))==(1 << 6)) {
N        TRACE_DEBUG("R1_SPI_PARAMETER\n\r");
X        { };
N    }
N}
N
N//------------------------------------------------------------------------------
N/// DecodeR2
N/// \param R2  
N//------------------------------------------------------------------------------
Nvoid DecodeR2(unsigned char R2)
N{
N    if( (R2 & R2_SPI_CARD_LOCKED)==R2_SPI_CARD_LOCKED) {
X    if( (R2 & (1 << 0))==(1 << 0)) {
N        TRACE_DEBUG("R2_SPI_CARD_LOCKED\n\r");
X        { };
N    }
N    if( (R2 & R2_SPI_WP_ERASE_SKIP)==R2_SPI_WP_ERASE_SKIP) {
X    if( (R2 & (1 << 1))==(1 << 1)) {
N        TRACE_DEBUG("R2_SPI_WP_ERASE_SKIP/R2_SPI_LOCK_UNLOCK_FAIL\n\r");
X        { };
N    }
N    if( (R2 & R2_SPI_ERROR)==R2_SPI_ERROR) {
X    if( (R2 & (1 << 2))==(1 << 2)) {
N        TRACE_DEBUG("R2_SPI_ERROR\n\r");
X        { };
N    }
N    if( (R2 & R2_SPI_CC_ERROR)==R2_SPI_CC_ERROR) {
X    if( (R2 & (1 << 3))==(1 << 3)) {
N        TRACE_DEBUG("R2_SPI_CC_ERROR\n\r");
X        { };
N    }
N    if( (R2 & R2_SPI_CARD_ECC_ERROR)==R2_SPI_CARD_ECC_ERROR) {
X    if( (R2 & (1 << 4))==(1 << 4)) {
N        TRACE_DEBUG("R2_SPI_CARD_ECC_ERROR\n\r");
X        { };
N    }
N    if( (R2 & R2_SPI_WP_VIOLATION)==R2_SPI_WP_VIOLATION) {
X    if( (R2 & (1 << 5))==(1 << 5)) {
N        TRACE_DEBUG("R2_SPI_WP_VIOLATION\n\r");
X        { };
N    }
N    if( (R2 & R2_SPI_ERASE_PARAM)==R2_SPI_ERASE_PARAM) {
X    if( (R2 & (1 << 6))==(1 << 6)) {
N        TRACE_DEBUG("R2_SPI_ERASE_PARAM\n\r");
X        { };
N    }
N    if( (R2 & R2_SPI_OUT_OF_RANGE)==R2_SPI_OUT_OF_RANGE) {
X    if( (R2 & (1 << 7))==(1 << 7)) {
N        TRACE_DEBUG("R2_SPI_OUT_OF_RANGE/R2_SPI_CSD_OVERWRITE\n\r");
X        { };
N    }
N}
N
N//------------------------------------------------------------------------------
N/// Get Trans Speed Value (Kbit/s)
N/// \param tranSpeed The TRAN_SPEED value from SD(IO)/MMC enum information.
N/// \param unitList  Transfer rate units (Kbit/s), 4 units listed.
N/// \param nbUnits   Transfer rate units list size.
N/// \param codeList  Time value codes list, 16 codes listed.
N//------------------------------------------------------------------------------
Nstatic unsigned int MmcGetTranSpeed(unsigned int tranSpeed,
N                            const unsigned int* unitList, unsigned int nbUnits,
N                            const unsigned int* codeList)
N{
N    unsigned int unit, value;
N    unit = tranSpeed & 0x7;
N    if (unit < nbUnits) unit = unitList[unit];
N    else                return 0;
N    value = (tranSpeed >> 3) & 0xF;
N    if (value < 16)   value = codeList[value];
N    else                return 0;
N    return (unit * value);
N}
N
N//------------------------------------------------------------------------------
N/// Get Trans Speed Value
N/// \param pSd    
N//------------------------------------------------------------------------------
Nvoid GetTransSpeedValue(SdCard *pSd)
N{
N    // CSD register, TRANS_SPEED bit
N    const unsigned int units[4] = {10, 100, 1000, 10000 }; // *Kbit/s 
N    const unsigned int values_emmc[16] = {0, 10, 12, 13, 15, 20,
N                                          26, 30, 35, 40, 45, 52,
N                                          55, 60, 70, 80};
N    const unsigned int values_sdmmc[16] = {0, 10, 12, 13, 15, 20,
N                                           25, 30, 35, 40, 45, 50,
N                                           55, 60, 70, 80};
N  #if 0
S    unsigned int unit, value;
S    unit = (SD_CSD_TRAN_SPEED(pSd) & 0x7);
S    if(unit < 4)    unit  = units[unit];
S    else            return;
S    value = (SD_CSD_TRAN_SPEED(pSd) >> 3) & 0xF;
S    if (value < 16) {
S        if (pSd->cardType >= CARD_MMC && SD_CID_BGA(pSd) == 1) {
S            value = values_emmc[value];
S        }
S        else
S            value = values_sdmmc[value];
S    }
S    else            return;
S    pSd->transSpeed = (unit * value);
N  #else
N    pSd->transSpeed = MmcGetTranSpeed(SD_CSD_TRAN_SPEED(pSd),
X    pSd->transSpeed = MmcGetTranSpeed(((((pSd)->csd)[3-(96)/32] >> ((96)%32)) & ((1 << (8)) - 1)),
N                                      units, 4,
N                                      (pSd->cardType >= CARD_MMC
X                                      (pSd->cardType >= ((0x2 << 1))
N                                       && SD_CID_BGA(pSd) == 1) ?
X                                       && ( (pSd->cid[3-(112)/32] >> ((112)%32)) & ((1 << (2)) - 1)) == 1) ?
N                                       values_emmc : values_sdmmc);
N  #endif
N    if (pSd->cardType >= CARD_MMC && SD_EXTCSD_HS_TIMING(pSd)) {
X    if (pSd->cardType >= ((0x2 << 1)) && (((unsigned char*)((pSd)->extData))[185])) {
N        pSd->transSpeed *= 2;
N    }
N    DEBUG_MSG("-I- SD/MMC TRANS SPEED %d KBit/s", pSd->transSpeed);
X    { };
N    pSd->transSpeed *= 1000;  
N}
N
N#if 1
N//------------------------------------------------------------------------------
N/// Reset the SdCmd
N//------------------------------------------------------------------------------
Nstatic void ResetCommand(SdCmd *pCommand)
N{
N  #if 0
S    unsigned char* p = (unsigned char*)pCommand;
S    unsigned int   l = sizeof(SdCmd);
S    while(l --) *p++ = 0;
N  #else
N    pCommand->cmd       = 0;
N    pCommand->arg       = 0;
N    pCommand->pData     = 0;
N    pCommand->blockSize = 0;
N    pCommand->nbBlock   = 0;
N    pCommand->pResp     = 0;
N    pCommand->callback  = 0;
N    pCommand->pArg      = 0;
N    pCommand->resType   = 0;
N    pCommand->dataTran  = 0;
N    pCommand->tranType  = 0;
N    pCommand->isRead    = 0;
N    pCommand->status    = 0;
N  #endif
N}
N#else
S// GNU halt on memset now
S# define ResetCommand(pCommand) memset(pCommand, 0, sizeof(SdCmd))
N#endif
N
N//------------------------------------------------------------------------------
N/// Delay some loop
N//------------------------------------------------------------------------------
Nstatic void Delay(volatile unsigned int loop)
N{
N    for(;loop > 0; loop --);
N}
N
N//------------------------------------------------------------------------------
N/// Sends the current SD card driver command to the card.
N/// Returns 0 if successful; Otherwise, returns the transfer status code or
N/// SD_ERROR_DRIVER if there was a problem with the SD transfer.
N/// \param pSd  Pointer to a SdCard driver instance.
N//------------------------------------------------------------------------------
Nstatic unsigned char SendCommand(SdCard *pSd)
N{
N    SdCmd *pCommand = &(pSd->command);
N    SdDriver *pSdDriver = pSd->pSdDriver;
N    unsigned char error;
N
N    // Send command
N    error = MCI_SendCommand((Mci *)pSdDriver, (MciCmd *)pCommand);
N    if (error) {
N        TRACE_ERROR("MCI SendCommand: Failed to send command (%d)\n\r", error);
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("MCI SendCommand: Failed to send command (%d)\n\r", error); ShellPrintf("\n\r");};
N        return SD_ERROR_DRIVER;
X        return 1;
N    }
N
N    // Wait for command to complete (if no callback defined)
N    if (pCommand->callback == 0) {
N        while (!MCI_IsTxComplete((Mci *)pSdDriver));
N    }
N
N    // Check for using fifo to transfer data
N  #if !defined(MCI_DMA_ENABLE) && defined(MCI2_INTERFACE)
X  #if !1L && 1L
S    if (pCommand->dataTran && pCommand->nbBlock) {
S        MCI_FifoTransfer((Mci *)pSdDriver, (MciCmd *)pCommand);
S    }
N  #endif
N
N    return pCommand->status;
N}
N
N//------------------------------------------------------------------------------
N/// Initialization delay: The maximum of 1 msec, 74 clock cycles and supply ramp
N/// up time.
N/// Returns the command transfer result (see SendCommand).
N/// \param pSd  Pointer to a SdCard driver instance.
N//------------------------------------------------------------------------------
Nstatic unsigned char Pon(SdCard *pSd)
N{
N    SdCmd *pCommand = &(pSd->command);
N    unsigned int response;
N    unsigned char error;
N
N    ResetCommand(pCommand);
N    // Fill command information
N    pCommand->cmd = AT91C_POWER_ON_INIT;
X    pCommand->cmd = (0 | (0x0 << 16) | (0x1 << 8) | (0x1 << 11));
N    pCommand->pResp = &response;
N
N    // Send command
N
N    error =  SendCommand(pSd);
N    return error;
N}
N
N#if defined(MCI2_INTERFACE) && defined(AT91C_MCI_SPCMD_BOOTREQ)
X#if 1L && 0L
S//------------------------------------------------------------------------------
S/// Initialization delay: The maximum of 1 msec, 74 clock cycles and supply ramp
S/// up time, CMD keeps low so that the device run in boot mode.
S/// Returns the command transfer result (see SendCommand).
S/// \param pSd  Pointer to a SdCard driver instance.
S//------------------------------------------------------------------------------
Sstatic unsigned char PonBoot(SdCard *pSd)
S{
S    SdCmd *pCommand = &(pSd->command);
S    unsigned int response;
S    unsigned char error;
S
S    ResetCommand(pCommand);
S    // Fill command information
S    pCommand->cmd = AT91C_POWER_ON_INIT;
S    pCommand->pResp = &response;
S
S    // Send command
S    error =  SendCommand(pSd);
S    return error;
S}
N#endif
N
N//------------------------------------------------------------------------------
N/// Resets all cards to idle state
N/// \param pSd  Pointer to a SdCard driver instance.
N/// \param arg  Argument used.
N/// \return the command transfer result (see SendCommand).
N//------------------------------------------------------------------------------
Nstatic unsigned char Cmd0(SdCard *pSd, unsigned int arg)
N{
N    SdCmd *pCommand = &(pSd->command);
N    unsigned int response;
N    unsigned char error;
N
N    TRACE_DEBUG("Cmd0()\n\r");
X    { };
N    ResetCommand(pCommand);
N    // Fill command information
N    pCommand->cmd = AT91C_GO_IDLE_STATE_CMD;
X    pCommand->cmd = (0 | (0x0 << 16) | (0x0 << 8) );
N    pCommand->arg = arg;
N    pCommand->pResp = &response;
N
N    // send command
N    error =  SendCommand(pSd);
N    return error;
N}
N
N//------------------------------------------------------------------------------
N/// MMC send operation condition command.
N/// Sends host capacity support information and activates the card's
N/// initialization process.
N/// Returns the command transfer result (see SendCommand).
N/// \param pSd  Pointer to a SdCard driver instance.
N/// \param hdSupport  Indicate whether the host support high density MMC.
N/// \param pHdSupport  Indicate whether the card is a high density MMC.
N//------------------------------------------------------------------------------
Nstatic unsigned char Cmd1(SdCard *pSd,
N                          unsigned char hdSupport,
N                          unsigned char *pHdSupport)
N{
N    SdCmd *pCommand = &(pSd->command);
N    unsigned char error;
N    unsigned int response;
N
N    TRACE_DEBUG("Cmd1()\n\r");
X    { };
N    ResetCommand(pCommand);
N    // Fill command information
N    pCommand->cmd = AT91C_MMC_SEND_OP_COND_CMD;
X    pCommand->cmd = (1 | (0x0 << 16) | (0x0 << 8) | (0x1 << 6) | (0x1 << 11));
N    pCommand->arg = AT91C_MMC_HOST_VOLTAGE_RANGE;
X    pCommand->arg = ((1UL << 15) + (1UL << 16) + (1UL << 17) + (1UL << 18) + (1UL << 19) + (1UL << 20));
N    if(hdSupport) {
N        pCommand->arg |= AT91C_MMC_HIGH_DENSITY;
X        pCommand->arg |= (0x2UL << 29);
N    }
N    else {
N        pCommand->arg |= AT91C_MMC_NORM_DENSITY;
X        pCommand->arg |= (0x0UL << 29);
N    }
N    pCommand->resType = 3;
N    pCommand->pResp = &response;
N
N    // send command
N    *pHdSupport = 0; 
N    error = SendCommand(pSd);
N    if (error) {
N        return error;
N    }
N    if ((response & AT91C_CARD_POWER_UP_BUSY) == AT91C_CARD_POWER_UP_BUSY) {        if((response & AT91C_MMC_OCR_BIT2930) == AT91C_MMC_HIGH_DENSITY) {
X    if ((response & (1UL << 31)) == (1UL << 31)) {        if((response & (3UL << 29)) == (0x2UL << 29)) {
N            *pHdSupport = 1;
N        }
N        return 0;
N    }
N    else {
N        return SD_ERROR_DRIVER;
X        return 1;
N    }
N}
N
N//------------------------------------------------------------------------------
N/// Asks any card to send the CID numbers
N/// on the CMD line (any card that is
N/// connected to the host will respond)
N/// Returns the command transfer result (see SendCommand).
N/// \param pSd  Pointer to a SD card driver instance.
N/// \param pCid  Buffer for storing the CID numbers.
N//------------------------------------------------------------------------------
Nstatic unsigned char Cmd2(SdCard *pSd)
N{
N    SdCmd *pCommand = &(pSd->command);
N
N    TRACE_DEBUG("Cmd2()\n\r");
X    { };
N    ResetCommand(pCommand);
N    // Fill the command information
N    pCommand->cmd = AT91C_ALL_SEND_CID_CMD;
X    pCommand->cmd = (2 | (0x0 << 16) | (0x0 << 8) | (0x1 << 11) | (0x2 << 6) );
N    pCommand->resType = 2;
N    pCommand->pResp = pSd->cid;
N
N    // Send the command
N    return SendCommand(pSd);
N}
N
N//------------------------------------------------------------------------------
N/// Ask the card to publish a new relative address (RCA)
N/// Returns the command transfer result (see SendCommand).
N/// \param pSd  Pointer to a SD card driver instance.
N//------------------------------------------------------------------------------
Nstatic unsigned char Cmd3(SdCard *pSd)
N{
N    SdCmd *pCommand = &(pSd->command);
N    unsigned int cardAddress;
N    unsigned char error;
N
N    TRACE_DEBUG("Cmd3()\n\r");
X    { };
N    ResetCommand(pCommand);
N    // Fill command information
N    pCommand->cmd = AT91C_SET_RELATIVE_ADDR_CMD;
X    pCommand->cmd = (3 | (0x0 << 16) | (0x0 << 8) | (0x1 << 6) | (0x1 << 11) | (0x1 << 12) );
N
N    // Assign relative address to MMC card
N    if ((pSd->cardType == CARD_MMC) || (pSd->cardType == CARD_MMCHD)) {
X    if ((pSd->cardType == ((0x2 << 1))) || (pSd->cardType == ((0x2 << 1)|(1 << 0)))) {
N        pCommand->arg = (0x1 << 16);
N    }
N    pCommand->resType = 1;
N    pCommand->pResp = &cardAddress;
N
N    // Send command
N    error = SendCommand(pSd);
N    if (error) {
N        return error;
N    }
N
N    // Save card address in driver
N    if ( (pSd->cardType == CARD_SD)
X    if ( (pSd->cardType == ((0x1 << 1)))
N        || (pSd->cardType == CARD_SDHC)) {
X        || (pSd->cardType == ((0x1 << 1)|(1 << 0)))) {
N        pSd->cardAddress = (cardAddress >> 16) & 0xFFFF;
N    }
N    else if (pSd->cardType >= CARD_SDIO) {
X    else if (pSd->cardType >= ((1 << 3))) {
N        pSd->cardAddress = (cardAddress >> 16) & 0xFFFF;
N    }
N    else {
N        // Default MMC RCA is 0x0001
N        pSd->cardAddress = 1;
N    }
N
N    return 0;
N}
N
N#if MCI_SDIO_ENABLE
X#if 0
S//------------------------------------------------------------------------------
S/// SDIO send operation condition command.
S/// Sends host capacity support information and activates the card's
S/// initialization process.
S/// Returns the command transfer result (see SendCommand).
S/// \param pSd  Pointer to a SdCard driver instance.
S/// \param pIo  Pointer to data send as well as response buffer.
S//------------------------------------------------------------------------------
Sstatic unsigned char Cmd5(SdCard *pSd,
S                          unsigned int *pIo)
S{
S    SdCmd *pCommand = &(pSd->command);
S    unsigned char error;
S
S    TRACE_DEBUG("Cmd5()\n\r");
S    ResetCommand(pCommand);
S    // Fill command information
S    pCommand->cmd = AT91C_IO_SEND_OP_COND_CMD;
S    pCommand->arg = *pIo;
S    pCommand->resType = 4;
S    pCommand->pResp = pIo;
S
S    // send command
S    error = SendCommand(pSd);
S    return error;
S}
N#endif
N
N//------------------------------------------------------------------------------
N/// Command toggles a card between the
N/// stand-by and transfer states or between
N/// the programming and disconnect states.
N/// Returns the command transfer result (see SendCommand).
N/// \param pSd  Pointer to a SD card driver instance.
N/// \param address  Relative Card Address (0 deselects all).
N//------------------------------------------------------------------------------
Nstatic unsigned char Cmd7(SdCard *pSd, unsigned int address)
N{
N    SdCmd *pCommand = &(pSd->command);
N
N    TRACE_DEBUG("Cmd7()\n\r");
X    { };
N    ResetCommand(pCommand);
N    // Fill command information
N    pCommand->cmd = AT91C_SEL_DESEL_CARD_CMD;
X    pCommand->cmd = (7 | (0x0 << 16) | (0x0 << 8) | (0x1 << 6) | (0x1 << 12) );
N    pCommand->arg = address << 16;
N    pCommand->resType = 1;
N
N    // Send command
N    return SendCommand(pSd);
N}
N
N//------------------------------------------------------------------------------
N/// Switches the mode of operation of the selected card (SD/MMC) or
N/// modifies the EXT_CSD registers (for MMC only).
N/// CMD6 is valid under the "trans" state.
N/// \return The command transfer result (see SendCommand).
N/// \param  pSd         Pointer to a SD/MMC card driver instance.
N/// \param  pSwitchArg  Pointer to a MmcCmd6Arg instance.
N/// \param  pStatus     Pointer to where the 512bit status is returned.
N/// \param  pResp       Pointer to where the response is returned.
N//------------------------------------------------------------------------------
Nstatic unsigned char Cmd6(SdCard *pSd,
N                          const void * pSwitchArg,
N                          unsigned int  * pStatus,
N                          unsigned int  * pResp)
N{
N    SdCmd *pCommand = &(pSd->command);
N    unsigned int  response;
N    unsigned char error;
N    SdCmd6Arg  * pSdSwitch;
N    MmcCmd6Arg * pMmcSwitch;
N
N    SANITY_CHECK(pSd);
X    ;
N    SANITY_CHECK(pSwitchArg);
X    ;
N
N    TRACE_DEBUG("CMD6()\n\r");
X    { };
N
N    ResetCommand(pCommand);
N
N    if (pSd->cardType >= CARD_MMC) {
X    if (pSd->cardType >= ((0x2 << 1))) {
N        pMmcSwitch = (MmcCmd6Arg*)pSwitchArg;
N        // R1b response
N        pCommand->cmd = AT91C_MMC_SWITCH_CMD;
X        pCommand->cmd = (6 | (0x0 << 16) | (0x0 << 8) | (0x3 << 6) | (0x1 << 12) );
N        pCommand->resType = 1;
N        pCommand->arg =   (pMmcSwitch->access << 24)
N                        | (pMmcSwitch->index  << 16)
N                        | (pMmcSwitch->value  <<  8)
N                        | (pMmcSwitch->cmdSet <<  0);
N    }
N    else if (pSd->cardType >= CARD_SD) {
X    else if (pSd->cardType >= ((0x1 << 1))) {
N
N        pSdSwitch = (SdCmd6Arg*)pSwitchArg;
N        // R1 response & 512 bits of status on DAT
N        pCommand->cmd = AT91C_SD_SWITCH_CMD;
X        pCommand->cmd = (6 | (0x1 << 16) | (0x0 << 19) | (0x1 << 18) | (0x0 << 8) | (0x1 << 6) | (0x1 << 12) );
N        pCommand->resType = 1;
N        pCommand->arg =   (pSdSwitch->mode << 31)
N                        | (pSdSwitch->reserved << 30)
N                        | (pSdSwitch->reserveFG6 << 20)
N                        | (pSdSwitch->reserveFG5 << 16)
N                        | (pSdSwitch->reserveFG4 << 12)
N                        | (pSdSwitch->reserveFG3 <<  8)
N                        | (pSdSwitch->command << 4)
N                        | (pSdSwitch->accessMode << 0);
N        if (pStatus) {
N            pCommand->blockSize = 512 / 8;
N            pCommand->nbBlock = 1;
N            pCommand->pData = (unsigned char*)pStatus;
N
N            pCommand->dataTran = 1;
N            pCommand->isRead = 1;
N            pCommand->tranType = MCI_NEW_TRANSFER;
X            pCommand->tranType = 0;
N        }
N    }
N    pCommand->pResp = &response;
N
N    DEBUG_MSG("CMD6(%d) arg 0x%X\n\r", pSd->cardType, pCommand->arg);
X    { };
N
N    error = SendCommand(pSd);
N
N    if (error)
N        return error;
N    else if (pResp)
N        *pResp = response;
N
N    return 0;
N}
N
N//------------------------------------------------------------------------------
N/// SD:  Sends SD Memory Card interface condition, which includes host supply
N///      voltage information and asks the card whether card supports voltage.
N///      Should be performed at initialization time to detect the card type.
N/// MMC: SEND_EXT_CSD, to get EXT_CSD register as a block of data.
N///      Valid under "trans" state.
N/// \param pSd   Pointer to a SD card driver instance.
N/// \param sdCmd For SD Memory Card interface condition 
N/// \param arg   Expected supply voltage(SD) or 512 byte buffer pointer (MMC).
N/// \return 0 if successful;
N///         otherwise returns SD_ERROR_NORESPONSE if the card did not answer
N///         the command, or SD_ERROR_DRIVER.
N//------------------------------------------------------------------------------
Nstatic unsigned char Cmd8(SdCard *pSd,
N                          unsigned char sdCmd,
N                          void* arg)
N{
N    SdCmd *pCommand = &(pSd->command);
N    unsigned int response;
N    unsigned char error;
N    unsigned char supplyVoltage = (unsigned char)((unsigned int)arg);
N
N    TRACE_DEBUG("Cmd8()\n\r");
X    { };
N    ResetCommand(pCommand);
N
N    if (sdCmd) {
N
N        // Fill command information
N        pCommand->cmd = AT91C_SEND_IF_COND;
X        pCommand->cmd = (8 | (0x0 << 16) | (0x0 << 8) | (0x1 << 6) | (0x1 << 12) );
N        pCommand->arg = (supplyVoltage << 8) | (0xAA);
N        pCommand->resType = 7;
N
N        TRACE_DEBUG("supplyVoltage: 0x%x\n\r", supplyVoltage);
X        { };
N    }
N    else {
N
N        pCommand->cmd = AT91C_SEND_EXT_CSD_CMD;
X        pCommand->cmd = (8 | (0x0 << 8) | (0x0 << 11) | (0x1 << 6) | (0x1 << 16) | (0x0 << 19) | (0x1 << 18) | (0x1 << 12));
N        pCommand->resType = 1;
N
N        pCommand->blockSize = SD_BLOCK_SIZE;
X        pCommand->blockSize = 512;
N        pCommand->nbBlock = 512 / SD_BLOCK_SIZE;
X        pCommand->nbBlock = 512 / 512;
N        pCommand->pData = arg;
N
N        pCommand->dataTran = 1;
N        pCommand->isRead = 1;
N        pCommand->tranType = MCI_NEW_TRANSFER;
X        pCommand->tranType = 0;
N    }
N    pCommand->pResp = &response;
N
N    // Send command
N    error = SendCommand(pSd);
N
N    if (sdCmd) {
N
N        // Check result
N        if (error == MCI_STATUS_NORESPONSE) {
X        if (error == 3) {
N
N            return SD_ERROR_NORESPONSE;
X            return 2;
N        }
N        // SD_R7
N        // Bit 0 - 7: check pattern (echo-back)
N        // Bit 8 -11: voltage accepted
N        else if (!error &&
N                ((response & 0x00000FFF) == ((supplyVoltage << 8) | 0xAA))) {
N            return 0;
N        }
N        else {
N            return SD_ERROR_DRIVER;
X            return 1;
N        }
N    }
N
N    return error;
N}
N
N//------------------------------------------------------------------------------
N/// Addressed card sends its card-specific
N/// data (CSD) on the CMD line.
N/// Returns the command transfer result (see SendCommand).
N/// \param pSd  Pointer to a SD card driver instance.
N//------------------------------------------------------------------------------
Nstatic unsigned char Cmd9(SdCard *pSd)
N{
N    SdCmd *pCommand = &(pSd->command);
N    unsigned char error;
N
N    TRACE_DEBUG("Cmd9()\n\r");
X    { };
N    ResetCommand(pCommand);
N    // Fill command information
N    pCommand->cmd = AT91C_SEND_CSD_CMD;
X    pCommand->cmd = (9 | (0x0 << 16) | (0x0 << 8) | (0x2 << 6) | (0x1 << 12) );
N    pCommand->arg = pSd->cardAddress << 16;
N    pCommand->resType = 2;
N    pCommand->pResp = pSd->csd;
N
N    // Send command
N    error = SendCommand(pSd);
N    return error;
N}
N
N//------------------------------------------------------------------------------
N/// Forces the card to stop transmission
N/// \param pSd      Pointer to a SD card driver instance.
N/// \param stopRead Stop reading stream/writing stream.
N/// \param pStatus  Pointer to a status variable.
N//------------------------------------------------------------------------------
Nstatic unsigned char Cmd12(SdCard *pSd,
N                           unsigned char stopRead,
N                           unsigned int *pStatus)
N{
N    SdCmd *pCommand = &(pSd->command);
N    unsigned char error;
N    unsigned int response;
N
N    TRACE_DEBUG("Cmd12()\n\r");
X    { };
N    ResetCommand(pCommand);
N    // Fill command information
N    pCommand->cmd = AT91C_STOP_TRANSMISSION_CMD;
X    pCommand->cmd = (12 | (0x2 << 16) | (0x0 << 8) | (0x3 << 6) | (0x1 << 12) );
N    pCommand->isRead = stopRead;
N    pCommand->tranType = MCI_STOP_TRANSFER;
X    pCommand->tranType = 2;
N    pCommand->resType = 1;
N    pCommand->pResp = &response;
N
N    // Send command
N    error = SendCommand(pSd);
N    if (pStatus) *pStatus = response;
N    return error;
N}
N
N//------------------------------------------------------------------------------
N/// Addressed card sends its status register.
N/// Returns the command transfer result (see SendCommand).
N/// \param pSd  Pointer to a SD card driver instance.
N/// \param pStatus  Pointer to a status variable.
N//------------------------------------------------------------------------------
Nstatic unsigned char Cmd13(SdCard *pSd, unsigned int *pStatus)
N{
N    SdCmd *pCommand = &(pSd->command);
N    unsigned char error;
N
N    TRACE_DEBUG("Cmd13()\n\r");
X    { };
N    ResetCommand(pCommand);
N    // Fill command information
N    pCommand->cmd = AT91C_SEND_STATUS_CMD;
X    pCommand->cmd = (13 | (0x0 << 16) | (0x0 << 8) | (0x1 << 6) | (0x1 << 12) );
N    pCommand->arg = pSd->cardAddress << 16;
N    pCommand->resType = 1;
N    pCommand->pResp = pStatus;
N
N    // Send command
N    error = SendCommand(pSd);
N
N    return error;
N}
N
N//------------------------------------------------------------------------------
N/// In the case of a Standard Capacity SD Memory Card, this command sets the
N/// block length (in bytes) for all following block commands
N/// (read, write, lock).
N/// Default block length is fixed to 512 Bytes.
N/// Set length is valid for memory access commands only if partial block read
N/// operation are allowed in CSD.
N/// In the case of a High Capacity SD Memory Card, block length set by CMD16
N/// command does not affect the memory read and write commands. Always 512
N/// Bytes fixed block length is used. This command is effective for LOCK_UNLOCK
N/// command. In both cases, if block length is set larger than 512Bytes, the
N/// card sets the BLOCK_LEN_ERROR bit.
N/// \param pSd  Pointer to a SD card driver instance.
N/// \param blockLength  Block length in bytes.
N//------------------------------------------------------------------------------
Nstatic unsigned char Cmd16(SdCard *pSd, unsigned short blockLength)
N{
N    SdCmd *pCommand = &(pSd->command);
N    unsigned char error;
N    unsigned int response;
N
N    TRACE_DEBUG("Cmd16()\n\r");
X    { };
N    ResetCommand(pCommand);
N    // Fill command information
N    pCommand->cmd = AT91C_SET_BLOCKLEN_CMD;
X    pCommand->cmd = (16 | (0x0 << 16) | (0x0 << 8) | (0x1 << 6) | (0x1 << 12) );
N    pCommand->arg = blockLength;
N    pCommand->resType = 1;
N    pCommand->pResp = &response;
N
N    // Send command
N    error = SendCommand(pSd);
N
N    return error;
N}
N
N#ifdef SINGLE_READ
Sstatic unsigned char Cmd17(SdCard *pSd,
S                           unsigned char  *pData,
S                           unsigned int   address,
S                           unsigned int   *pStatus)
S{
S    SdCmd *pCommand = &(pSd->command);
S    unsigned char error;
S    unsigned int response;
S
S    TRACE_DEBUG("Cmd17()\n\r");
S    ResetCommand(pCommand);
S    // Fill command information
S    pCommand->cmd = AT91C_READ_SINGLE_BLOCK_CMD;
S    pCommand->arg = address;
S    pCommand->resType = 1;
S    pCommand->pResp = &response;
S
S    pCommand->blockSize = SD_BLOCK_SIZE;
S    pCommand->nbBlock = 1;
S    pCommand->pData = pData;
S
S    pCommand->dataTran = 1;
S    pCommand->isRead = 1;
S    pCommand->tranType = MCI_NEW_TRANSFER;
S
S    // Send command
S    error = SendCommand(pSd);
S
S    if (pStatus) *pStatus = response;
S    return error;
S}
N#endif
N
N//------------------------------------------------------------------------------
N/// Continously transfers datablocks from card to host until interrupted by a
N/// STOP_TRANSMISSION command.
N/// \param pSd        Pointer to a SD card driver instance.
N/// \param blockSize  Block size (shall be set to 512 in case of high capacity).
N/// \param pData      Pointer to the DW aligned buffer to be filled.
N/// \param address    SD card address.
N//------------------------------------------------------------------------------
Nstatic unsigned char Cmd18(SdCard *pSd,
N                           unsigned short nbBlock,
N                           unsigned char *pData,
N                           unsigned int address,
N                           unsigned int *pStatus)
N{
N    SdCmd *pCommand = &(pSd->command);
N    unsigned char error;
N    unsigned int response;
N
N    TRACE_DEBUG("Cmd18()\n\r");
X    { };
N    ResetCommand(pCommand);
N    // Fill command information
N    pCommand->cmd = AT91C_READ_MULTIPLE_BLOCK_CMD;
X    pCommand->cmd = (18 | (0x0 << 8) | (0x1 << 6) | (0x1 << 16) | (0x1 << 19) | (0x1 << 18) | (0x1 << 12));
N    pCommand->arg = address;
N    pCommand->resType = 1;
N    pCommand->pResp = &response;
N
N    pCommand->blockSize = SD_BLOCK_SIZE;
X    pCommand->blockSize = 512;
N    pCommand->nbBlock = nbBlock;
N    pCommand->pData = pData;
N
N    pCommand->dataTran = 1;
N    pCommand->isRead = 1;
N    pCommand->tranType = MCI_NEW_TRANSFER;
X    pCommand->tranType = 0;
N
N    // Send command
N    error = SendCommand(pSd);
N
N    if (pStatus) *pStatus = response;
N
N    return error;
N}
N#ifdef SINGLE_WRITE
Sstatic unsigned char Cmd24(SdCard *pSd,
S                           unsigned char  *pData,
S                           unsigned int   address,
S                           unsigned int   *pStatus)
S{
S    SdCmd *pCommand = &(pSd->command);
S    unsigned char error;
S    unsigned int response;
S
S    TRACE_DEBUG("Cmd24()\n\r");
S    ResetCommand(pCommand);
S    // Fill command information
S    pCommand->cmd = AT91C_WRITE_BLOCK_CMD;
S    pCommand->arg = address;
S    pCommand->resType = 1;
S    pCommand->pResp = &response;
S
S    pCommand->blockSize = SD_BLOCK_SIZE;
S    pCommand->nbBlock = 1;
S    pCommand->pData = pData;
S
S    pCommand->dataTran = 1;
S    pCommand->isRead = 0;
S    pCommand->tranType = MCI_NEW_TRANSFER;
S
S    // Send command
S    error = SendCommand(pSd);
S
S    if (pStatus) *pStatus = response;
S    return error;
S}
N#endif
N//------------------------------------------------------------------------------
N/// Write block command
N/// \param pSd  Pointer to a SD card driver instance.
N/// \param blockSize  Block size (shall be set to 512 in case of high capacity).
N/// \param pData  Pointer to the DW aligned buffer to be filled.
N/// \param address  SD card address.
N//------------------------------------------------------------------------------
Nstatic unsigned char Cmd25(SdCard *pSd,
N                           unsigned short nbBlock,
N                           unsigned char *pData,
N                           unsigned int address,
N                           unsigned int *pStatus)
N{
N    SdCmd *pCommand = &(pSd->command);
N    unsigned char error;
N    unsigned int response;
N
N    TRACE_DEBUG("Cmd25()\n\r");
X    { };
N    ResetCommand(pCommand);
N    // Fill command information
N    pCommand->cmd = AT91C_WRITE_MULTIPLE_BLOCK_CMD;
X    pCommand->cmd = (25 | (0x0 << 8) | (0x1 << 6) | (0x1 << 16) | ((0x1 << 19) & ~((0x1 << 18))) | (0x1 << 12));
N    pCommand->arg = address;
N    pCommand->resType = 1;
N    pCommand->pResp = &response;
N
N    pCommand->blockSize = SD_BLOCK_SIZE;
X    pCommand->blockSize = 512;
N    pCommand->nbBlock = nbBlock;
N    pCommand->pData = pData;
N
N    pCommand->dataTran = 1;
N    pCommand->tranType = MCI_NEW_TRANSFER;
X    pCommand->tranType = 0;
N
N    // Send command
N    error = SendCommand(pSd);
N    if (pStatus) *pStatus = response;
N
N    return error;
N}
N
N#if MCI_SDIO_ENABLE
X#if 0
S//------------------------------------------------------------------------------
S/// SDIO R/W Byte Direct, response R5
S/// \param pSd Pointer to SdCard instance.
S/// \param func Number of function.
S/// \param rw   The direction of IO operation, 1 for write.
S/// \param raw  Read after write
S/// \param addr The register address to access.
S/// \param pIoData Pointer to fill written data and response.
S//------------------------------------------------------------------------------
Sstatic unsigned char Cmd52(SdCard *pSd,
S                           unsigned char func,
S                           unsigned char rw,
S                           unsigned char raw,
S                           unsigned int addr,
S                           unsigned int *pIoData)
S{
S    SdCmd *pCommand = &(pSd->command);
S    unsigned char error;
S    unsigned int response;
S    unsigned char byte = 0;
S
S    TRACE_DEBUG("Cmd52()\n\r");
S    ResetCommand(pCommand);
S    // Fill command information
S    pCommand->cmd = AT91C_SDIO_IO_RW_DIRECT;
S    // - argument
S    if (pIoData) byte = *pIoData;
S    pCommand->arg = byte
S                   | (addr << 9)    // register address 25: 9
S                   | (raw  << 27)   // ReadAfterWrite   27
S                   | (func << 28)   // FunctionNumber   30:28
S                   | (rw << 31);    // R/W              31
S    pCommand->resType = 5;
S    pCommand->pResp = &response;
S    // Send command
S    error = SendCommand(pSd);
S    if (pIoData) *pIoData = response;
S    return error;
S}
S
S//------------------------------------------------------------------------------
S/// SDIO R/W Extended, response R5
S/// \param pSd Pointer to SdCard instance.
S/// \param func Number of function.
S/// \param rw   The direction of IO operation, 1 for write.
S/// \param blockMode  R/O on a block basis
S/// \param incAddress R/W to incrementing address (1) or fixed address (0)
S/// \param addr The register address to access.
S/// \param pIoData Pointer to fill written data and response.
S/// \param size    Data size base on bytes or blocks depending on blockMode
S/// \param pResp   Pointer to response buffer
S//------------------------------------------------------------------------------
Sstatic unsigned char Cmd53(SdCard *pSd,
S                           unsigned char func,
S                           unsigned char rw,
S                           unsigned char blockMode,
S                           unsigned char incAddress,
S                           unsigned int  addr,
S                           unsigned char *pIoData,
S                           unsigned short size,
S                           unsigned int *pResp)
S{
S    SdCmd *pCommand = &(pSd->command);
S    unsigned char error;
S
S    TRACE_DEBUG("Cmd53()\n\r");
S    ResetCommand(pCommand);
S    // Fill command information
S    pCommand->cmd = AT91C_SDIO_IO_RW_EXTENDED;
S    // - argument
S    pCommand->arg = size
S                   | (addr << 9)        // register address 25: 9
S                   | (incAddress << 26) // OP Code          26
S                   | (blockMode << 27)  // ReadAfterWrite   27
S                   | (func << 28)       // FunctionNumber   30:28
S                   | (rw << 31);        // R/W              31
S    pCommand->resType = 5;
S    pCommand->pResp   = pResp;
S    
S    // - Write...
S    if (rw) {}
S    else {
S        pCommand->cmd |= AT91C_MCI_TRDIR_READ;
S        pCommand->isRead = 1;
S    }
S    // - Block...
S    if (blockMode) {
S        pCommand->cmd |= AT91C_MCI_TRTYP_SDIO_BLOCK
S                       | AT91C_MCI_TRCMD_START;
S        pCommand->blockSize = SD_BLOCK_SIZE;
S    }
S    else {
S        pCommand->cmd |= AT91C_MCI_TRTYP_SDIO_BYTE
S                       | AT91C_MCI_TRCMD_START;
S        pCommand->blockSize = 1;
S    }
S    pCommand->nbBlock  = size;
S    pCommand->pData    = pIoData;
S    pCommand->dataTran = 1;
S    pCommand->tranType = MCI_NEW_TRANSFER;
S
S    // Send command
S    error = SendCommand(pSd);
S    return error;
S}
N#endif
N
N//------------------------------------------------------------------------------
N/// Initialization delay: The maximum of 1 msec, 74 clock cycles and supply
N/// ramp up time.
N/// Returns the command transfer result (see SendCommand).
N/// \param pSd  Pointer to a SD card driver instance.
N//------------------------------------------------------------------------------
Nstatic unsigned char Cmd55(SdCard *pSd)
N{
N    SdCmd *pCommand = &(pSd->command);
N    unsigned char error;
N    unsigned int response;
N
N    TRACE_DEBUG("Cmd55()\n\r");
X    { };
N    ResetCommand(pCommand);
N    // Fill command information
N    pCommand->cmd = AT91C_APP_CMD;
X    pCommand->cmd = (55 | (0x0 << 8) | (0x1 << 6) | (0x0 << 16) | (0x1 << 12));
N    pCommand->arg = (pSd->cardAddress << 16);
N    pCommand->resType = 1;
N    pCommand->pResp = &response;
N
N    // Send command
N    error = SendCommand(pSd);
N
N    return error;
N}
N
N/*
N//------------------------------------------------------------------------------
N/// SPI Mode, Reads the OCR register of a card
N/// Returns the command transfer result (see SendCommand).
N/// \param pSd  Pointer to a SD card driver instance.
N/// \param pOcr   OCR value of the card
N//------------------------------------------------------------------------------
Nstatic unsigned char Cmd58(SdCard *pSd, unsigned int *pOcr)
N{
N    SdCmd *pCommand = &(pSd->command);
N    unsigned char error;
N    unsigned int response[2];
N
N    TRACE_DEBUG("Cmd58()\n\r");
N    ResetCommand(pCommand);
N    // Fill command information
N    pCommand->cmd = AT91C_READ_OCR_CMD;
N    pCommand->resType = 3;
N    pCommand->pResp = &response[0];
N
N    // Send command
N    error = SendCommand(pSd);
N    return error;
N}
N
N//------------------------------------------------------------------------------
N/// SPI Mode, Set CRC option of a card
N/// Returns the command transfer result (see SendCommand).
N/// \param pSd  Pointer to a SD card driver instance.
N/// \param option  CRC option, 1 to turn on, 0 to trun off
N//------------------------------------------------------------------------------
Nstatic unsigned char Cmd59(SdCard *pSd, unsigned char option)
N{
N    SdCmd *pCommand = &(pSd->command);
N    unsigned char error;
N    unsigned int response;
N
N    TRACE_DEBUG("Cmd59()\n\r");
N    ResetCommand(pCommand);
N    // Fill command information
N    pCommand->cmd = AT91C_CRC_ON_OFF_CMD;
N    pCommand->arg = (option & 0x1);
N    pCommand->resType = 1;
N    pCommand->pResp = &response;
N
N    // Send command
N    error = SendCommand(pSd);
N
N    return error;
N}
N*/
N
N//------------------------------------------------------------------------------
N/// Defines the data bus width (00=1bit or 10=4 bits bus) to be used for data
N/// transfer.
N/// The allowed data bus widths are given in SCR register.
N/// \param pSd  Pointer to a SD card driver instance.
N/// \param busWidth  Bus width in bits.
N/// \return the command transfer result (see SendCommand).
N//------------------------------------------------------------------------------
Nstatic unsigned char Acmd6(SdCard *pSd, unsigned char busWidth)
N{
N    SdCmd *pCommand = &(pSd->command);
N    unsigned char error;
N    unsigned int response;
N
N    TRACE_DEBUG("Acmd6()\n\r");
X    { };
N
N    error = Cmd55(pSd);
N    if (error) {
N        TRACE_ERROR("Acmd6.Cmd55: %d\n\r", error);
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("Acmd6.Cmd55: %d\n\r", error); ShellPrintf("\n\r");};
N        return error;
N    }
N
N    ResetCommand(pCommand);
N    // Fill command information
N    pCommand->cmd = AT91C_SD_SET_BUS_WIDTH_CMD;
X    pCommand->cmd = (6 | (0x0 << 8) | (0x1 << 6) | (0x0 << 16) | (0x1 << 12));
N    pCommand->arg = (busWidth == 4) ? SD_STAT_DATA_BUS_WIDTH_4BIT :
X    pCommand->arg = (busWidth == 4) ? 0x2 :
N                                      SD_STAT_DATA_BUS_WIDTH_1BIT;
X                                      0x0;
N    pCommand->resType = 1;
N    pCommand->pResp = &response;
N
N    // Send command
N    return SendCommand(pSd);
N}
N
N//------------------------------------------------------------------------------
N/// The SD Status contains status bits that are related to the SD memory Card
N/// proprietary features and may be used for future application-specific usage.
N/// Can be sent to a card only in 'tran_state'.
N//------------------------------------------------------------------------------
Nstatic unsigned char Acmd13(SdCard *pSd, unsigned int * pSdSTAT)
N{
N    SdCmd *pCommand = &(pSd->command);
N    unsigned char error;
N    unsigned int response[1];
N
N    TRACE_DEBUG("Acmd13()\n\r");
X    { };
N
N    error = Cmd55(pSd);
N    if (error) {
N        TRACE_ERROR("Acmd13.Cmd55: %d\n\r", error);
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("Acmd13.Cmd55: %d\n\r", error); ShellPrintf("\n\r");};
N        return error;
N    }
N
N    ResetCommand(pCommand);
N    // Fill command information
N    pCommand->cmd = AT91C_SD_STATUS_CMD;
X    pCommand->cmd = (13 | (0x0 << 8) | (0x1 << 6) | (0x1 << 16) | (0x0 << 19) | (0x1 << 18) | (0x1 << 12));
N    pCommand->resType = 1;
N    pCommand->pResp = response;
N
N    pCommand->blockSize = 512 / 8;
N    pCommand->nbBlock = 1;
N    pCommand->pData = (unsigned char*)pSdSTAT;
N
N    pCommand->dataTran = 1;
N    pCommand->isRead = 1;
N    pCommand->tranType = MCI_NEW_TRANSFER;
X    pCommand->tranType = 0;
N
N    // Send command
N    error = SendCommand(pSd);
N
N    return error;
N}
N
N//------------------------------------------------------------------------------
N/// Asks to all cards to send their operations conditions.
N/// Returns the command transfer result (see SendCommand).
N/// \param pSd  Pointer to a SD card driver instance.
N/// \param hcs  Shall be true if Host support High capacity.
N/// \param pCCS  Set the pointed flag to 1 if hcs != 0 and SD OCR CCS flag is set.
N//------------------------------------------------------------------------------
Nstatic unsigned char Acmd41(SdCard *pSd, unsigned char hcs, unsigned char *pCCS)
N{
N    SdCmd *pCommand = &(pSd->command);
N    unsigned char error;
N    unsigned int  response;
N
N    do {
N        error = Cmd55(pSd);
N        if (error) {
N            return error;
N        }
N
N        ResetCommand(pCommand);
N        // Fill command information
N        pCommand->cmd = AT91C_SD_APP_OP_COND_CMD;
X        pCommand->cmd = (41 | (0x0 << 8) | (0x1 << 6) | (0x0 << 16) );
N        pCommand->arg = AT91C_MMC_HOST_VOLTAGE_RANGE;
X        pCommand->arg = ((1UL << 15) + (1UL << 16) + (1UL << 17) + (1UL << 18) + (1UL << 19) + (1UL << 20));
N        if (hcs) {
N            pCommand->arg |= AT91C_CCS;
X            pCommand->arg |= (1 << 30);
N        }
N
N        pCommand->resType = 3;
N        pCommand->pResp = &response;
N
N        // Send command
N        TRACE_DEBUG("Acmd41()\n\r");
X        { };
N        error = SendCommand(pSd);
N        if (error) {
N            return error;
N        }
N        *pCCS  = ((response & AT91C_CCS) != 0);
X        *pCCS  = ((response & (1 << 30)) != 0);
N    }
N    while ((response & AT91C_CARD_POWER_UP_BUSY) != AT91C_CARD_POWER_UP_BUSY);
X    while ((response & (1UL << 31)) != (1UL << 31));
N
N    return 0;
N}
N
N//------------------------------------------------------------------------------
N/// SD Card Configuration Register (SCR) provides information on the SD Memory
N/// Card's special features that were configured into the given card. The size
N/// of SCR register is 64 bits.
N//------------------------------------------------------------------------------
Nstatic unsigned char Acmd51(SdCard *pSd, unsigned int * pSCR)
N{
N    SdCmd *pCommand = &(pSd->command);
N    unsigned char error;
N    unsigned int response[1];
N
N    TRACE_DEBUG("Acmd51()\n\r");
X    { };
N
N    error = Cmd55(pSd);
N    if (error) {
N        TRACE_ERROR("Acmd51.Cmd55: %d\n\r", error);
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("Acmd51.Cmd55: %d\n\r", error); ShellPrintf("\n\r");};
N        return error;
N    }
N
N    ResetCommand(pCommand);
N    // Fill command information
N    pCommand->cmd = AT91C_SD_SEND_SCR_CMD;
X    pCommand->cmd = (51 | (0x0 << 8) | (0x1 << 6) | (0x1 << 16) | (0x1 << 18) | (0x0 << 19) | (0x1 << 12));
N    pCommand->resType = 1;
N    pCommand->pResp = response;
N
N    pCommand->blockSize = 64 / 8;
N    pCommand->nbBlock = 1;
N    pCommand->pData = (unsigned char*)pSCR;
N
N    pCommand->dataTran = 1;
N    pCommand->isRead = 1;
N    pCommand->tranType = MCI_NEW_TRANSFER;
X    pCommand->tranType = 0;
N
N    // Send command
N    error = SendCommand(pSd);
N
N    //if (!error) Int2MsbFirstStream((unsigned char*)pSCR, 8 / 4);
N
N    return error;
N}
N
N#if defined(MCI2_INTERFACE) && defined(AT91C_MCI_SPCMD_BOOTREQ)
X#if 1L && 0L
S//------------------------------------------------------------------------------
S/// Terminate boot stream.
S/// \param pSd      Pointer to SdCard instance.
S//------------------------------------------------------------------------------
Sstatic unsigned char BootEnd(SdCard *pSd)
S{
S    SdCmd * pCommand = &(pSd->command);
S
S    TRACE_DEBUG("BootEnd()\n\r");
S    ResetCommand(pCommand);
S
S    // Send boot end
S    pCommand->cmd = AT91C_BOOTEND;
S
S    return SendCommand(pSd);
S}
S
S//------------------------------------------------------------------------------
S/// In boot operation mode, the processor can read boot data from the slave,
S/// by keeping the CMD line low after power-on before issuing CMD1.
S/// BootEnd() must be invoked after the boot request done.
S/// \param pSd      Pointer to SdCard instance.
S/// \param pBuffer  The buffer holding received data.
S/// \param length   The buffer length.
S//------------------------------------------------------------------------------
Sstatic unsigned char BootREQ(SdCard *pSd,
S                             unsigned char* pBuffer,
S                             unsigned int   nbBlocks,
S                             unsigned char  ackEnable)
S{
S    SdCmd * pCommand = &(pSd->command);
S    unsigned char error;
S
S    TRACE_DEBUG("BootREQ()\n\r");
S    ResetCommand(pCommand);
S
S    // Send boot request
S    pCommand->cmd = ackEnable ? (AT91C_BOOTREQ | AT91C_MCI_BOOTACK)
S                              :  AT91C_BOOTREQ;
S    pCommand->blockSize = SD_BLOCK_SIZE;
S    pCommand->nbBlock   = nbBlocks;
S    pCommand->pData     = pBuffer;
S    pCommand->isRead    = 1;
S    pCommand->tranType = MCI_NEW_TRANSFER;
S
S    error = SendCommand(pSd);
S    if (error) {
S        TRACE_ERROR("BootOperation.BootReq: %d\n\r", error);
S        return error;
S    }
S    return error;
S}
N#endif
N
N//------------------------------------------------------------------------------
N/// Continue to transfer datablocks from card to host until interrupted by a
N/// STOP_TRANSMISSION command.
N/// \param pSd  Pointer to a SD card driver instance.
N/// \param blockSize  Block size (shall be set to 512 in case of high capacity).
N/// \param pData  Pointer to the application buffer to be filled.
N/// \param address  SD card address.
N//------------------------------------------------------------------------------
Nstatic unsigned char ContinuousRead(SdCard *pSd,
N                                    unsigned short nbBlock,
N                                    unsigned char *pData,
N                                    SdCallback     pCb,
N                                    void          *pArg)
N{
N    SdCmd *pCommand = &(pSd->command);
N
N    TRACE_DEBUG_WP(".");
X    {ShellPrintf(".");};
N    ResetCommand(pCommand);
N    // Fill command information
N    pCommand->blockSize = SD_BLOCK_SIZE;
X    pCommand->blockSize = 512;
N    pCommand->nbBlock   = nbBlock;
N    pCommand->pData     = pData;
N
N    pCommand->dataTran = 1;
N    pCommand->tranType = MCI_CONTINUE_TRANSFER;
X    pCommand->tranType = 1;
N    pCommand->isRead = 1;
N    
N    pCommand->callback = pCb;
N    pCommand->pArg     = pArg;
N
N    // Send command
N    return SendCommand(pSd);
N}
N
N//------------------------------------------------------------------------------
N/// Continue to transfer datablocks from host to card until interrupted by a
N/// STOP_TRANSMISSION command.
N/// \param pSd  Pointer to a SD card driver instance.
N/// \param blockSize  Block size (shall be set to 512 in case of high capacity).
N/// \param pData  Pointer to the application buffer to be filled.
N//------------------------------------------------------------------------------
Nstatic unsigned char ContinuousWrite(SdCard *pSd,
N                                     unsigned short nbBlock,
N                                     const unsigned char *pData,
N                                     SdCallback     pCb,
N                                     void          *pArg)
N{
N    SdCmd *pCommand = &(pSd->command);
N
N    TRACE_DEBUG("Write()\n\r");
X    { };
N    ResetCommand(pCommand);
N    // Fill command information
N    pCommand->blockSize = SD_BLOCK_SIZE;
X    pCommand->blockSize = 512;
N    pCommand->nbBlock   = nbBlock;
N    pCommand->pData     = (unsigned char*)pData;
N
N    pCommand->dataTran = 1;
N    pCommand->tranType = MCI_CONTINUE_TRANSFER;
X    pCommand->tranType = 1;
N    
N    pCommand->callback = pCb;
N    pCommand->pArg     = pArg;
N
N    // Send command
N    return SendCommand(pSd);
N}
N
N//------------------------------------------------------------------------------
N/// Try SW Reset several times (CMD0 with ARG 0)
N/// \param pSd      Pointer to a SD card driver instance.
N/// \param retry    Retry times.
N/// \return 0 or MCI error code.
N//------------------------------------------------------------------------------
Nstatic unsigned char SwReset(SdCard *pSd, unsigned int retry)
N{
N    unsigned int i;
N    unsigned char error = 0;
N
N    for (i = 0; i < retry; i ++) {
N        error = Cmd0(pSd, 0);
N        if (error != MCI_STATUS_NORESPONSE)
X        if (error != 3)
N            break;
N    }
N    return error;
N}
N/*
N//------------------------------------------------------------------------------
N/// Re-init card to trans state.
N//------------------------------------------------------------------------------
Nstatic unsigned char ReInit(SdCard *pSd)
N{
N    #if 0
N    unsigned char error;
N    error = SwReset(pSd, 1);
N    if (error) {
N        TRACE_ERROR("ReInit.Cmd0: %d\n\r", error);
N        return error;
N    }
N    error = Cmd1(pSd);
N    if (error) {
N        TRACE_ERROR("ReInit.Cmd1: %d\n\r", error);
N        return error;
N    }
N    error = Cmd2(pSd);
N    if (error) {
N        TRACE_ERROR("ReInit.Cmd2: %d\n\r", error);
N        return error;
N    }
N    error = Cmd3(pSd);
N    if (error) {
N        TRACE_ERROR("ReInit.Cmd3: %d\n\r", error);
N        return error;
N    }
N    error = Cmd7(pSd, pSd->cardAddress);
N    if (error) {
N        TRACE_ERROR("ReInit.Cmd7: %d\n\r", error);
N        return error;
N    }
N    #endif
N    return 0;
N}
N*/
N//------------------------------------------------------------------------------
N/// Move SD card to transfer state.
N//------------------------------------------------------------------------------
Nstatic unsigned char MoveToTranState(SdCard * pSd)
N{
N    unsigned char error;
N    unsigned int  status;
N
N    // Quit transfer state
N    if((pSd->state == SD_STATE_READ)
X    if((pSd->state == 0x10)
N    || (pSd->state == SD_STATE_WRITE)) {
X    || (pSd->state == 0x20)) {
N
N        error = Cmd12(pSd,
N                      (pSd->state == SD_STATE_READ),
X                      (pSd->state == 0x10),
N                      &status);
N        if (error) {
N            TRACE_ERROR("MvToTran.Cmd12: %d\n\r", error);
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("MvToTran.Cmd12: %d\n\r", error); ShellPrintf("\n\r");};
N            return error;
N        }
N    }
N
N    // Put device into tran state
N    error = Cmd13(pSd, &status);
N    if (error) {
N        TRACE_ERROR("MvToTran.Cmd13: %d\n\r", error);
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("MvToTran.Cmd13: %d\n\r", error); ShellPrintf("\n\r");};
N        return error;
N    }
N    if ((status & STATUS_STATE) == STATUS_STBY) {
X    if ((status & (0xFUL << 9)) == (3UL << 9)) {
N        error = Cmd7(pSd, pSd->cardAddress);
N        if (error) {
N            TRACE_ERROR("MvToTran.Cmd7: %d\n\r", error);
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("MvToTran.Cmd7: %d\n\r", error); ShellPrintf("\n\r");};
N            return error;
N        }
N    }
N
N    return 0;
N}
N
N#if defined(SINGLE_READ) || defined(SINGLE_WRITE)
X#if 0L || 0L
Sstatic unsigned char PerformSingleTransfer(SdCard *pSd,
S                                           unsigned int address,
S                                           unsigned char *pData,
S                                           unsigned char isRead)
S{
S    unsigned int status;
S    unsigned char error = 0;
S
S    /* Reset transfer state if previous in multi- mode */
S    if(    (pSd->state == SD_STATE_READ)
S        || (pSd->state == SD_STATE_WRITE)) {
S        /* Stop transfer */
S        error = Cmd12(pSd, (pSd->state == SD_STATE_READ), &status);
S        if (error) {
S            TRACE_ERROR("SingleTx.Cmd12: st%x, er%d\n\r", pSd->state, error);
S        }
S        pSd->state = SD_STATE_READY;
S        pSd->preBlock = 0xFFFFFFFF;
S    }
S
S#ifdef SINGLE_READ
S    if(isRead) {
S        // Wait for card to be ready for data transfers
S        do {
S            error = Cmd13(pSd, &status);
S            if (error) {
S                TRACE_ERROR("SingleTx.RD.Cmd13: %d\n\r", error);
S                return error;
S            }
S            if(  ((status & STATUS_STATE) == STATUS_IDLE)
S               ||((status & STATUS_STATE) == STATUS_READY)
S               ||((status & STATUS_STATE) == STATUS_IDENT)) {
S                TRACE_ERROR("SingleTx.mode\n\r");
S                return SD_ERROR_NOT_INITIALIZED;
S            }
S            // If the card is in sending data state or in receivce data state
S            if (  ((status & STATUS_STATE) == STATUS_RCV)
S                ||((status & STATUS_STATE) == STATUS_DATA) ){
S
S                TRACE_DEBUG("SingleTx.state = 0x%X\n\r", (status & STATUS_STATE) >> 9);
S            }
S        }
S        while (    ((status & STATUS_READY_FOR_DATA) == 0)
S                || ((status & STATUS_STATE) != STATUS_TRAN) );
S        ASSERT((status & STATUS_STATE) == STATUS_TRAN,
S                "SD Card can't be configured in transfer state 0x%X\n\r",
S                (status & STATUS_STATE)>>9);
S        // Read data
S        // Move to Sending data state
S        error = Cmd17(pSd, pData, SD_ADDRESS(pSd,address), &status);
S        if (error) {
S            TRACE_ERROR("SingleTx.Cmd17: %d\n\r", error);
S            return error;
S        }
S        if (status & ~(STATUS_READY_FOR_DATA | STATUS_STATE)) {
S            TRACE_ERROR("CMD17.stat: %x\n\r",
S                status & ~(STATUS_READY_FOR_DATA | STATUS_STATE));
S            return SD_ERROR_DRIVER;
S        }
S        return error;
S    }
S#endif
S#ifdef SINGLE_WRITE
S    // Write
S    {
S        // Wait for card to be ready for data transfers
S        do {
S            error = Cmd13(pSd, &status);
S            if (error) {
S                TRACE_ERROR("SingleTx.WR.Cmd13: %d\n\r", error);
S                return error;
S            }
S        }
S        while ((status & STATUS_READY_FOR_DATA) == 0);
S        // Move to Sending data state
S        error = Cmd24(pSd, pData, SD_ADDRESS(pSd,address), &status);
S        if (error) {
S            TRACE_DEBUG("SingleTx.Cmd25: %d\n\r", error);
S            return error;
S        }
S        if (status & (STATUS_WRITE & ~(STATUS_READY_FOR_DATA | STATUS_STATE))) {
S            TRACE_ERROR("CMD24(0x%x).stat: %x\n\r",
S                SD_ADDRESS(pSd,address), 
S                status & (STATUS_WRITE
S                            & ~(STATUS_READY_FOR_DATA | STATUS_STATE)));
S            return SD_ERROR_DRIVER;
S        }
S    }
S    return error;
S#endif
S}
N#endif
N
N//------------------------------------------------------------------------------
N/// Move SD card to transfer state. The buffer size must be at
N/// least 512 byte long. This function checks the SD card status register and
N/// address the card if required before sending the transfer command.
N/// Returns 0 if successful; otherwise returns an code describing the error.
N/// \param pSd      Pointer to a SD card driver instance.
N/// \param address  Address of the block to transfer.
N/// \param nbBlocks Number of blocks to be transfer, 0 for infinite transfer.
N/// \param pData    Data buffer whose size is at least the block size.
N/// \param isRead   1 for read data and 0 for write data.
N//------------------------------------------------------------------------------
Nstatic unsigned char MoveToTransferState(SdCard *pSd,
N                                         unsigned int address,
N                                         unsigned short nbBlocks,
N                                         unsigned char *pData,
N                                         unsigned char isRead)
N{
N    unsigned int status;
N    unsigned char error;
N
N    if(    (pSd->state == SD_STATE_READ)
X    if(    (pSd->state == 0x10)
N        || (pSd->state == SD_STATE_WRITE)) {
X        || (pSd->state == 0x20)) {
N#if 1//!defined(MCI2_INTERFACE)
N        if (pSd->state == SD_STATE_WRITE) {
X        if (pSd->state == 0x20) {
N            DBGU_PutByte(0);
N            DBGU_PutByte(0);
N            DBGU_PutByte(0);
N            DBGU_PutByte(0);
N        }
N#endif
N        // RW MULTI with length
N        error = Cmd12(pSd,
N                      (pSd->state == SD_STATE_READ),
X                      (pSd->state == 0x10),
N                      &status);
N        if (error) {
N            TRACE_ERROR("MTTranState.Cmd12: st%x, er%d\n\r", pSd->state, error);
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("MTTranState.Cmd12: st%x, er%d\n\r", pSd->state, error); ShellPrintf("\n\r");};
N            return error;
N        }
N#if !defined(MCI2_INTERFACE)
X#if !1L
S        // RW MULTI Infinite
S        if (pSd->state == SD_STATE_WRITE) {
S            while(MCI_CheckBusy((Mci *)pSd->pSdDriver) != 0);
S        }
N#endif
N    }
N
N    if(isRead) {
N        // Wait for card to be ready for data transfers
N        do {
N            error = Cmd13(pSd, &status);
N            if (error) {
N                TRACE_ERROR("MTTranState.RD.Cmd13: %d\n\r", error);
X                {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("MTTranState.RD.Cmd13: %d\n\r", error); ShellPrintf("\n\r");};
N                return error;
N            }
N            if(  ((status & STATUS_STATE) == STATUS_IDLE)
X            if(  ((status & (0xFUL << 9)) == (0UL << 9))
N               ||((status & STATUS_STATE) == STATUS_READY)
X               ||((status & (0xFUL << 9)) == (1UL << 9))
N               ||((status & STATUS_STATE) == STATUS_IDENT)) {
X               ||((status & (0xFUL << 9)) == (2UL << 9))) {
N                TRACE_ERROR("Pb Card Identification mode\n\r");
X                {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("Pb Card Identification mode\n\r"); ShellPrintf("\n\r");};
N                return SD_ERROR_NOT_INITIALIZED;
X                return 3;
N            }
N            // If the card is in sending data state or in receivce data state
N            if (  ((status & STATUS_STATE) == STATUS_RCV)
X            if (  ((status & (0xFUL << 9)) == (6UL << 9))
N                ||((status & STATUS_STATE) == STATUS_DATA) ){
X                ||((status & (0xFUL << 9)) == (5UL << 9)) ){
N
N                TRACE_DEBUG("state = 0x%X\n\r", (status & STATUS_STATE) >> 9);
X                { };
N            }
N        }
N        while (    ((status & STATUS_READY_FOR_DATA) == 0)
X        while (    ((status & (1UL << 8)) == 0)
N                || ((status & STATUS_STATE) != STATUS_TRAN) );
X                || ((status & (0xFUL << 9)) != (4UL << 9)) );
N        ASSERT((status & STATUS_STATE) == STATUS_TRAN,
N                "SD Card can't be configured in transfer state 0x%X\n\r",
N                (status & STATUS_STATE)>>9);
X        ;
N        // Read data
N        // Move to Sending data state
N        error = Cmd18(pSd, nbBlocks, pData, SD_ADDRESS(pSd,address), &status);
X        error = Cmd18(pSd, nbBlocks, pData, ( ((pSd)->totalSize == 0xFFFFFFFF) ? (address):((address) << 9) ), &status);
N        if (error) {
N            TRACE_ERROR("MTTranState.Cmd18: %d\n\r", error);
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("MTTranState.Cmd18: %d\n\r", error); ShellPrintf("\n\r");};
N            return error;
N        }
N        if (status & ~(STATUS_READY_FOR_DATA | STATUS_STATE)) {
X        if (status & ~((1UL << 8) | (0xFUL << 9))) {
N            TRACE_ERROR("CMD18.stat: %x\n\r",
N                status & ~(STATUS_READY_FOR_DATA | STATUS_STATE));
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("CMD18.stat: %x\n\r", status & ~((1UL << 8) | (0xFUL << 9))); ShellPrintf("\n\r");};
N            return SD_ERROR_DRIVER;
X            return 1;
N        }
N    }
N    else {
N        // Wait for card to be ready for data transfers
N        do {
N            error = Cmd13(pSd, &status);
N            if (error) {
N                TRACE_ERROR("MoveToTransferState.WR.Cmd13: %d\n\r", error);
X                {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("MoveToTransferState.WR.Cmd13: %d\n\r", error); ShellPrintf("\n\r");};
N                return error;
N            }
N        }
N        while ((status & STATUS_READY_FOR_DATA) == 0);
X        while ((status & (1UL << 8)) == 0);
N        // Move to Sending data state
N        error = Cmd25(pSd, nbBlocks, pData, SD_ADDRESS(pSd,address), &status);
X        error = Cmd25(pSd, nbBlocks, pData, ( ((pSd)->totalSize == 0xFFFFFFFF) ? (address):((address) << 9) ), &status);
N        if (error) {
N            TRACE_DEBUG("MoveToTransferState.Cmd25: %d\n\r", error);
X            { };
N            return error;
N        }
N        if (status & (STATUS_WRITE & ~(STATUS_READY_FOR_DATA | STATUS_STATE))) {
X        if (status & (( (1UL << 31) | (1UL << 30) | (1UL << 29) | (1UL << 26) | (1UL << 25) | (1UL << 23) | (1UL << 22) | (1UL << 20) | (1UL << 19) | (1UL << 13) | (0xFUL << 9) | (1UL << 8) ) & ~((1UL << 8) | (0xFUL << 9)))) {
N            TRACE_ERROR("CMD25(0x%x, %d).stat: %x\n\r",
N                SD_ADDRESS(pSd,address), nbBlocks,
N                status & (STATUS_WRITE
N                            & ~(STATUS_READY_FOR_DATA | STATUS_STATE)));
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("CMD25(0x%x, %d).stat: %x\n\r", ( ((pSd)->totalSize == 0xFFFFFFFF) ? (address):((address) << 9) ), nbBlocks, status & (( (1UL << 31) | (1UL << 30) | (1UL << 29) | (1UL << 26) | (1UL << 25) | (1UL << 23) | (1UL << 22) | (1UL << 20) | (1UL << 19) | (1UL << 13) | (0xFUL << 9) | (1UL << 8) ) & ~((1UL << 8) | (0xFUL << 9)))); ShellPrintf("\n\r");};
N            return SD_ERROR_DRIVER;
X            return 1;
N        }
N    }
N
N    if (!error) pSd->preBlock = address + (nbBlocks-1);
N    return error;
N}
N
N//------------------------------------------------------------------------------
N/// Switch the bus width of card
N//------------------------------------------------------------------------------
N
N//------------------------------------------------------------------------------
N/// Switch the HS mode of card
N/// \param pSd      Pointer to SdCard instance.
N/// \param hsEnable 1 to enable, 0 to disable.
N//------------------------------------------------------------------------------
Nstatic unsigned char SdMmcSwitchHsMode(SdCard *pSd, unsigned char hsEnable)
N{
N    unsigned int status;
N    unsigned char error = SD_ERROR_DRIVER;
X    unsigned char error = 1;
N    if (pSd->mode == hsEnable)
N        return 0;
N    if (pSd->cardType >= CARD_MMC) {
X    if (pSd->cardType >= ((0x2 << 1))) {
N        MmcCmd6Arg cmd6Arg;
N        cmd6Arg.access = 0x3;
N        cmd6Arg.index  = SD_EXTCSD_HS_TIMING_INDEX;
X        cmd6Arg.index  = 185;
N        cmd6Arg.value  = hsEnable ? SD_EXTCSD_HS_TIMING_ENABLE
X        cmd6Arg.value  = hsEnable ? (0x1UL)
N                                  : SD_EXTCSD_HS_TIMING_DISABLE;
X                                  : (0x0UL);
N        cmd6Arg.cmdSet = 0;
N        error = Cmd6(pSd, &cmd6Arg, 0, &status);
N        if (error) {
N            TRACE_ERROR("MMC SwitchHs.Cmd6: %d\n\r", error);
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("MMC SwitchHs.Cmd6: %d\n\r", error); ShellPrintf("\n\r");};
N        }
N        else if (status & STATUS_SWITCH_ERROR) {
X        else if (status & (1UL << 7)) {
N            TRACE_WARNING("MMC HS SW Fail\n\r");
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("MMC HS SW Fail\n\r"); ShellPrintf("\n\r");};
N            error = SD_ERROR_DRIVER;
X            error = 1;
N        }
N        else {
N            TRACE_WARNING_WP("-I- MMC HS %d\n\r", hsEnable);
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("-I- MMC HS %d\n\r", hsEnable);};
N            pSd->mode = hsEnable;
N        }
N    }
N    else if (pSd->cardType >= CARD_SD) {
X    else if (pSd->cardType >= ((0x1 << 1))) {
N        SdCmd6Arg cmd6Arg;
N        unsigned int switchStatus[512/32];
N        cmd6Arg.mode = 1;
N        cmd6Arg.reserved = 0;
N        cmd6Arg.reserveFG6 = 0xF;
N        cmd6Arg.reserveFG5 = 0xF;
N        cmd6Arg.reserveFG4 = 0xF;
N        cmd6Arg.reserveFG3 = 0xF;
N        cmd6Arg.command = 0;
N        cmd6Arg.accessMode = 1;
N        error = Cmd6(pSd,
N                     &cmd6Arg,
N                     switchStatus,
N                     &status);
N      #if 0
S        unsigned int i;
S        printf("SD Switch status:");
S        for(i = 0; i < 512 / 8; i ++) {
S            if ((i % 8) == 0) printf("\n\r[%3d]", i);
S            printf(" %02x", ((char*)switchStatus)[i]);
S        }
S        printf("\n\r");
S        printf(" _FG1_INFO %x\n\r",
S            SD_SW_STAT_FUN_GRP1_INFO(switchStatus));
S        printf(" _FG1_RC   %x\n\r",
S            SD_SW_STAT_FUN_GRP1_RC(switchStatus));
S        printf(" _FG1_BUSY %x\n\r",
S            SD_SW_STAT_FUN_GRP1_BUSY(switchStatus));
S        printf(" _FG1_DS_V %x\n\r",
S            SD_SW_STAT_DATA_STRUCT_VER(switchStatus));
N      #endif
N        if (error) {
N            TRACE_ERROR("SD SwitchHs.Cmd6: %d\n\r", error);
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SD SwitchHs.Cmd6: %d\n\r", error); ShellPrintf("\n\r");};
N        }
N        else if (status & STATUS_SWITCH_ERROR) {
X        else if (status & (1UL << 7)) {
N            TRACE_WARNING("SD HS SW Fail\n\r");
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SD HS SW Fail\n\r"); ShellPrintf("\n\r");};
N            error = SD_ERROR_DRIVER;
X            error = 1;
N        }
N        else if (SD_SW_STAT_FUN_GRP1_RC(switchStatus)
X        else if (( ((char*)(switchStatus))[63 - ((376)/8)] >> ((376)%8) & ((1 << (4)) - 1) )
N                        == SD_SW_STAT_FUN_GRP_RC_ERROR) {
X                        == 0xF) {
N            TRACE_ERROR_WP("-I- SD HS Not Supported\n\r");
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("-I- SD HS Not Supported\n\r");};
N            error = SD_ERROR_DRIVER;
X            error = 1;
N        }
N        else if (SD_SW_STAT_FUN_GRP1_BUSY(switchStatus)) {
X        else if (( ( ((char*)(switchStatus))[63 - ((272)/8)] >> ((272)%8) & ((1 << (8)) - 1) ) + (( ((char*)(switchStatus))[63 - ((280)/8)] >> ((280)%8) & ((1 << (8)) - 1) ) << 8) )) {
N            TRACE_WARNING("SD HS Busy\n\r");
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SD HS Busy\n\r"); ShellPrintf("\n\r");};
N            error = SD_ERROR_DRIVER;
X            error = 1;
N        }
N        else {
N            TRACE_WARNING_WP("-I- SD HS %d\n\r", hsEnable);
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("-I- SD HS %d\n\r", hsEnable);};
N            pSd->mode = hsEnable;
N        }
N    }
N
N    return error;
N}
N
N#if defined(MCI2_INTERFACE) && defined(AT91C_MCI_SPCMD_BOOTREQ)
X#if 1L && 0L
S//------------------------------------------------------------------------------
S/// Process a list of SWITCH command
S/// \param  pSd      Pointer to SdCard instance.
S/// \param  pArgList Argument list.
S/// \param  listSize Number of arguments listed.
S/// \return 0, or error code and argument index.
S//------------------------------------------------------------------------------
Sstatic unsigned short MmcSwitchSettings(SdCard *pSd,
S                                       const MmcCmd6Arg * pArgList,
S                                       unsigned int listSize,
S                                       unsigned int * pErrSta)
S{
S    unsigned int i, status;
S    unsigned char error;
S
S    SANITY_CHECK(pSd);
S    SANITY_CHECK(pArgList);
S
S    for (i = 0; i < listSize; i ++) {
S        error = Cmd6(pSd, &pArgList[i], 0, &status);
S        if (pErrSta) *pErrSta = status;
S        if (error) {
S            return (error | (i << 8));
S        }
S        if (status & ~(STATUS_STATE | STATUS_READY_FOR_DATA)) {
S            TRACE_WARNING("Error in SWITCH.%d, 0x%x\n\r",
S                          pArgList[i].index, status);
S        }
S        else {
S            TRACE_INFO("SWITCH.%d: 0x%x\n\r",
S                       pArgList[i].index, status);
S        }
S    }
S    return 0;
S}
N#endif
N
N//------------------------------------------------------------------------------
N/// Switch card state between STBY and TRAN
N/// \param pSd      Pointer to a SD card driver instance.
N/// \param address  Card address to TRAN, 0 to STBY
N/// \param check    Whether to check the state
N//------------------------------------------------------------------------------
Nstatic unsigned char MmcSelectCard(SdCard *pSd,
N                                   unsigned short address,
N                                   unsigned char check)
N{
N    unsigned char error;
N    unsigned int  status;
N    unsigned int  targetState = address ? STATUS_TRAN : STATUS_STBY;
X    unsigned int  targetState = address ? (4UL << 9) : (3UL << 9);
N    unsigned int  srcState    = address ? STATUS_STBY : STATUS_TRAN;
X    unsigned int  srcState    = address ? (3UL << 9) : (4UL << 9);
N    if (pSd->cardType == CARD_SDIO) check = 0;
X    if (pSd->cardType == ((1 << 3))) check = 0;
N
N    // At this stage the Initialization and identification process is achieved
N    // The SD card is supposed to be in Stand-by State
N    while(check) {
N        error = Cmd13(pSd, &status);
N        if (error) {
N            TRACE_ERROR("MmcSelectCard.Cmd13 (%d)\n\r", error);
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("MmcSelectCard.Cmd13 (%d)\n\r", error); ShellPrintf("\n\r");};
N            return error;
N        }
N        if ((status & STATUS_READY_FOR_DATA)) {
X        if ((status & (1UL << 8))) {
N            unsigned int currState = status & STATUS_STATE;
X            unsigned int currState = status & (0xFUL << 9);
N            if (currState == targetState) return 0;
N            if (currState != srcState) {
N                TRACE_ERROR("MmcSelectCard, wrong state %x\n\r", currState);
X                {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("MmcSelectCard, wrong state %x\n\r", currState); ShellPrintf("\n\r");};
N                return SD_ERROR_DRIVER;
X                return 1;
N            }
N            break;
N        }
N    }
N
N    // witch to TRAN mode to Select the current SD/MMC
N    // so that SD ACMD6 can process or EXT_CSD can read.
N    error = Cmd7(pSd, address);
N    if (error == SD_ERROR_NOT_INITIALIZED && address == 0) {}
X    if (error == 3 && address == 0) {}
N    else if (error) {
N        TRACE_ERROR("MmcSelectCard.Cmd7 (%d)\n\r", error);
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("MmcSelectCard.Cmd7 (%d)\n\r", error); ShellPrintf("\n\r");};
N    }
N
N    return error;
N}
N
N//------------------------------------------------------------------------------
N/// Get EXT_CSD information
N/// \param pSd      Pointer to a SD card driver instance.
N//------------------------------------------------------------------------------
Nstatic unsigned char MmcGetExtInformation(SdCard *pSd)
N{
N    unsigned char error;
N    unsigned int i;
N
N    // CSD 1.2 or Higher version
N    if(SD_CSD_STRUCTURE(pSd) >= 2) {
X    if(((((pSd)->csd)[3-(126)/32] >> ((126)%32)) & ((1 << (2)) - 1)) >= 2) {
N
N        /* Clear EXT_CSD data */
N        for (i = 0;i < 512/4; i ++) pSd->extData[i] = 0;
N        error = Cmd8(pSd, 0, pSd->extData);
N        if (error) {
N            TRACE_ERROR("MmcGetExt.Cmd8: %d\n\r", error);
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("MmcGetExt.Cmd8: %d\n\r", error); ShellPrintf("\n\r");};
N        }
N    }
N    return 0;
N}
N
N//------------------------------------------------------------------------------
N/// Get SCR and SD Status information
N/// \param pSd      Pointer to a SD card driver instance.
N//------------------------------------------------------------------------------
Nstatic unsigned char SdGetExtInformation(SdCard *pSd)
N{
N    unsigned char error;
N
N    // Reset data (64 + 512 bits, 8 + 64 bytes)
N    // memset(pSd->extData, 0x00, 512);
N
N    // SD Status
N    if (pSd->optCmdBitMap & SD_ACMD13_SUPPORT) {
X    if (pSd->optCmdBitMap & (1UL << 1)) {
N        error = Acmd13(pSd, &pSd->extData[SD_EXT_OFFSET_SD_STAT]);
X        error = Acmd13(pSd, &pSd->extData[2]);
N        if (error) {
N            TRACE_ERROR("SdGetExt.Acmd13: %d\n\r", error);
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SdGetExt.Acmd13: %d\n\r", error); ShellPrintf("\n\r");};
N            pSd->optCmdBitMap &= ~SD_ACMD13_SUPPORT;
X            pSd->optCmdBitMap &= ~(1UL << 1);
N        }
N    }
N
N    // SD SCR
N    error = Acmd51(pSd, &pSd->extData[SD_EXT_OFFSET_SD_SCR]);
X    error = Acmd51(pSd, &pSd->extData[0]);
N    if (error) {
N        TRACE_ERROR("SdGetExt.Acmd51: %d\n\r", error);
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SdGetExt.Acmd51: %d\n\r", error); ShellPrintf("\n\r");};
N    }
N
N    return 0;
N}
N
N//------------------------------------------------------------------------------
N/// Update SD/MMC information.
N/// Update CSD for card speed switch.
N/// Update ExtDATA for any card function switch.
N/// \param pSd      Pointer to a SD card driver instance.
N/// \return error code when update CSD error.
N//------------------------------------------------------------------------------
Nstatic unsigned char SdMmcUpdateInformation(SdCard *pSd,
N                                            unsigned char csd,
N                                            unsigned char extData)
N{
N    unsigned char error;
N
N    // Update CSD for new TRAN_SPEED value
N    if (csd) {
N        MmcSelectCard(pSd, 0, 1);
N        Delay(800);
N        error = Cmd9(pSd);
N        if (error ) {
N            TRACE_ERROR("SdMmcUpdateInfo.Cmd9 (%d)\n\r", error);
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SdMmcUpdateInfo.Cmd9 (%d)\n\r", error); ShellPrintf("\n\r");};
N            return error;
N        }
N        error = MmcSelectCard(pSd, pSd->cardAddress, 1);
N    }
N    if (pSd->cardType >= CARD_MMC)     MmcGetExtInformation(pSd);
X    if (pSd->cardType >= ((0x2 << 1)))     MmcGetExtInformation(pSd);
N    else if (pSd->cardType >= CARD_SD) SdGetExtInformation(pSd);
X    else if (pSd->cardType >= ((0x1 << 1))) SdGetExtInformation(pSd);
N    GetTransSpeedValue(pSd);
N
N    return 0;
N}
N
N#if MCI_SDIO_ENABLE
X#if 0
S//------------------------------------------------------------------------------
S/// Find ManfID, Func0 tuple.
S//------------------------------------------------------------------------------
Sstatic unsigned char SdioFindTuples(SdCard * pSd,
S                                    unsigned int address, unsigned int size,
S                                    unsigned int *pAddrManfID,
S                                    unsigned int *pAddrFunc0)
S{
S    unsigned char error, tmp[3];
S    unsigned int addr = address;
S    unsigned char nbFound = 0;
S    for (;;) {
S        error = SDIO_ReadDirect(pSd, 0, addr, tmp, 3);
S        if (error)
S            return error;
S        // ManfID
S        if (tmp[0] == CISTPL_MANFID) {
S            if (pAddrManfID) *pAddrManfID = addr;
S            nbFound ++;
S        }
S        // Func0
S        if (tmp[0] == CISTPL_FUNCE && tmp[2] == 0x00) {
S            if (pAddrFunc0) *pAddrFunc0 = addr;
S            nbFound ++;
S        }
S        // END
S        if (tmp[0] == CISTPL_END) break;
S
S        // All found
S        if (nbFound >= 2)         break;
S        // Not tuple?
S        if (tmp[1] == 0)          break;
S
S        // Next address
S        addr += (tmp[1] + 2);
S        if (addr > (address + size))
S            break;
S    }
S    return 0;
S}
N#endif
N
N//------------------------------------------------------------------------------
N//         Global functions
N//------------------------------------------------------------------------------
N
N#if MCI_SDIO_ENABLE
X#if 0
S//------------------------------------------------------------------------------
S/// Read at least one byte from SDIO card, using RW_DIRECT command.
S/// \param pSd      Pointer to SdCard instance.
S/// \param funNb    Function number.
S/// \param address  First byte address of data in SDIO card.
S/// \param pBytes   Pointer to data buffer.
S/// \param size     Buffer size.
S//------------------------------------------------------------------------------
Sunsigned char SDIO_ReadDirect(SdCard *pSd,
S                              unsigned char funNb,
S                              unsigned int  address,
S                              unsigned char *pBytes,
S                              unsigned int  size)
S{
S    unsigned char error;
S    unsigned int status;
S    if (pSd->cardType < CARD_SDIO) {
S        return SD_ERROR_NOT_SUPPORT;
S    }
S    if (size == 0)
S        return SD_ERROR_DRIVER;
S
S    while(size --) {
S        status = 0;
S        error = Cmd52(pSd, funNb, 0, 0, address ++, &status);
S        if (pBytes) *pBytes ++ = (unsigned char)status;
S        if (error) {
S            TRACE_ERROR("SDIO_ReadDirect.Cmd52: %d, %x\n\r", error, status);
S            return SD_ERROR_DRIVER;
S        }
S    }
S
S    return 0;
S}
S
S//------------------------------------------------------------------------------
S/// Write one byte to SDIO card, using RW_DIRECT command.
S/// \param pSd      Pointer to SdCard instance.
S/// \param funNb    Function number.
S/// \param address  First byte address of data in SDIO card.
S/// \param pBytes   Pointer to data buffer.
S/// \param size     Buffer size.
S//------------------------------------------------------------------------------
Sunsigned char SDIO_WriteDirect(SdCard *pSd,
S                               unsigned char funNb,
S                               unsigned int address,
S                               unsigned char byte)
S{
S    if (pSd->cardType < CARD_SDIO) {
S        return SD_ERROR_NOT_SUPPORT;
S    }
S    unsigned char error;
S    unsigned int status;
S    status = byte;
S    error = Cmd52(pSd, funNb, 1, 0, address, &status);
S    if (error) {
S        TRACE_ERROR("SDIO_ReadDirect.Cmd52: %d, %x\n\r", error, status);
S        return SD_ERROR_DRIVER;
S    }
S
S    return 0;
S}
S
S//------------------------------------------------------------------------------
S/// Read byte by byte from SDIO card, using RW_EXT command.
S/// \param pSd          Pointer to SdCard instance.
S/// \param funNb        Function number.
S/// \param address      First byte address of data in SDIO card.
S/// \param isFixedAddr  Address not increased.
S/// \param pBytes       Pointer to data buffer.
S/// \param size         Buffer size.
S//------------------------------------------------------------------------------
Sunsigned char SDIO_ReadBytes(SdCard *pSd,
S                             unsigned char funNb,
S                             unsigned int  address,
S                             unsigned char isFixedAddr,
S                             unsigned char *pBytes,
S                             unsigned int   size)
S{
S    unsigned char error;
S    unsigned int status;
S    if (pSd->cardType < CARD_SDIO) {
S        return SD_ERROR_NOT_SUPPORT;
S    }
S
S    if (size == 0)
S        return SD_ERROR_DRIVER;
S
S    error = Cmd53(pSd, funNb,
S                  0, 0, !isFixedAddr,
S                  address, pBytes, size, &status);
S    if (error || (status & STATUS_SDIO_CMD52)) {
S        TRACE_ERROR("SDIO_ReadBytes.Cmd53: %d, %x\n\r", error, status);
S        return SD_ERROR_DRIVER;
S    }
S
S    return 0;
S}
S
S//------------------------------------------------------------------------------
S/// Write byte by byte to SDIO card, using RW_EXT command.
S/// \param pSd          Pointer to SdCard instance.
S/// \param funNb        Function number.
S/// \param address      First byte address of data in SDIO card.
S/// \param isFixedAddr  Address not increased.
S/// \param pBytes       Pointer to data buffer.
S/// \param size         Buffer size.
S//------------------------------------------------------------------------------
Sunsigned char SDIO_WriteBytes(SdCard *pSd,
S                              unsigned char funNb,
S                              unsigned int  address,
S                              unsigned char isFixedAddr,
S                              unsigned char *pBytes,
S                              unsigned int   size)
S{
S    unsigned char error;
S    unsigned int status;
S    if (pSd->cardType < CARD_SDIO) {
S        return SD_ERROR_NOT_SUPPORT;
S    }
S    if (size == 0)
S        return SD_ERROR_DRIVER;
S
S    error = Cmd53(pSd, funNb,
S                  1, 0, !isFixedAddr,
S                  address, pBytes, size, &status);
S    if (error || (status & STATUS_SDIO_CMD52)) {
S        TRACE_ERROR("SDIO_ReadBytes.Cmd53: %d, %x\n\r", error, status);
S        return SD_ERROR_DRIVER;
S    }
S
S    return 0;
S}
N#endif
N
N//------------------------------------------------------------------------------
N/// Read Block of data in a buffer pointed by pData. The buffer size must be at
N/// least 512 byte long. This function checks the SD card status register and
N/// address the card if required before sending the read command.
N/// Returns 0 if successful; otherwise returns an code describing the error.
N/// \param pSd      Pointer to a SD card driver instance.
N/// \param address  Address of the block to read.
N/// \param pData    Data buffer whose size is at least the block size, it can
N///            be 1,2 or 4-bytes aligned when used with DMA.
N/// \param length   Number of blocks to be read.
N/// \param pCallback Pointer to callback function that invoked when read done.
N///                  0 to start a blocked read.
N/// \param pArgs     Pointer to callback function arguments.
N//------------------------------------------------------------------------------
Nunsigned char SD_Read(SdCard        *pSd,
N                      unsigned int   address,
N                      void          *pData,
N                      unsigned short length,
N                      SdCallback     pCallback,
N                      void          *pArgs)
N{
N    unsigned char error;
N
N    // If callback is defined, performe none blocked reading
N    if (pCallback) {
N        if (MCI_IsTxComplete((Mci *)pSd) == 0) {
N            return SD_ERROR_BUSY;
X            return 4;
N        }
N    }
N
N    if (   pSd->state != SD_STATE_READ
X    if (   pSd->state != 0x10
N        || pSd->preBlock + 1 != address ) {
N        // Start infinite block reading
N        error = MoveToTransferState(pSd, address, 0, 0, 1);
N    }
N    else    error = 0;
N    if (!error) {
N        pSd->state = SD_STATE_READ;
X        pSd->state = 0x10;
N        pSd->preBlock = address + (length - 1);
N        error = ContinuousRead(pSd,
N                               length,
N                               pData,
N                               pCallback, pArgs);
N    }
N    TRACE_DEBUG("SDrd(%u,%u):%u\n\r", address, length, error);
X    { };
N
N    return 0;    
N}
N
N//------------------------------------------------------------------------------
N/// Write Block of data in a buffer pointed by pData. The buffer size must be at
N/// least 512 byte long. This function checks the SD card status register and
N/// address the card if required before sending the read command.
N/// Returns 0 if successful; otherwise returns an code describing the error.
N/// \param pSd      Pointer to a SD card driver instance.
N/// \param address  Address of the block to read.
N/// \param pData    Data buffer whose size is at least the block size, it can
N///            be 1,2 or 4-bytes aligned when used with DMA.
N/// \param length   Number of blocks to be read.
N/// \param pCallback Pointer to callback function that invoked when read done.
N///                  0 to start a blocked read.
N/// \param pArgs     Pointer to callback function arguments.
N//------------------------------------------------------------------------------
Nunsigned char SD_Write(SdCard        *pSd,
N                       unsigned int   address,
N                       void          *pData,
N                       unsigned short length,
N                       SdCallback     pCallback,
N                       void          *pArgs)
N{
N    unsigned char error;
N    // If callback is defined, performe none blocked writing
N    if (pCallback) {
N        if (MCI_IsTxComplete((Mci *)pSd) == 0) {
N            return SD_ERROR_BUSY;
X            return 4;
N        }
N    }
N    if (   pSd->state != SD_STATE_WRITE
X    if (   pSd->state != 0x20
N        || pSd->preBlock + 1 != address ) {
N        // Start infinite block writing
N        error = MoveToTransferState(pSd, address, 0, 0, 0);
N    }
N    else    error = 0;
N    if (!error) {
N        pSd->state = SD_STATE_WRITE;
X        pSd->state = 0x20;
N        error = ContinuousWrite(pSd,
N                                length,
N                                pData,
N                                pCallback, pArgs);
N        pSd->preBlock = address + (length - 1);
N    }
N    TRACE_DEBUG("SDwr(%u,%u):%u\n\r", address, length, error);
X    { };
N    
N    return 0;
N}
N
N//------------------------------------------------------------------------------
N/// Read Block of data in a buffer pointed by pData. The buffer size must be at
N/// least 512 byte long. This function checks the SD card status register and
N/// address the card if required before sending the read command.
N/// Returns 0 if successful; otherwise returns an code describing the error.
N/// \param pSd  Pointer to a SD card driver instance.
N/// \param address  Address of the block to read.
N/// \param nbBlocks Number of blocks to be read.
N/// \param pData    Data buffer whose size is at least the block size, it can
N///            be 1,2 or 4-bytes aligned when used with DMA.
N//------------------------------------------------------------------------------
Nunsigned char SD_ReadBlock(SdCard *pSd,
N                           unsigned int address,
N                           unsigned short nbBlocks,
N                           unsigned char *pData)
N{
N    unsigned char error = 0;
N
N    SANITY_CHECK(pSd);
X    ;
N    SANITY_CHECK(pData);
X    ;
N    SANITY_CHECK(nbBlocks);
X    ;
N
N    TRACE_DEBUG("ReadBlk(%d,%d)", address, nbBlocks);
X    { };
N#if defined(SINGLE_READ)
X#if 0L
S    while(nbBlocks --) {
S        error = PerformSingleTransfer(pSd, address, pData, 1);
S        if (error)
S            break;
S        // SDHC
S        if (pSd->totalSize == 0xFFFFFFFF) {
S            address += 1;
S            pData = &pData[512];
S        }
S        else {
S            address += 1;
S            pData = &pData[512];
S        }
S    }
S    return error;
N#endif
N#if !defined(MCI2_INTERFACE)
X#if !1L
S  #if !defined(AT91C_MCI_RDPROOF)
S    error = MoveToTransferState(pSd, address, nbBlocks, pData, 1);
S    pSd->state = SD_STATE_READ;
S  #else
S    if((pSd->state == SD_STATE_READ)
S        && ((pSd->preBlock + 1) == address)) {
S
S      #if defined(at91rm9200)
S        error = Cmd12(pSd, 0);
S        if (error) {
S            return error;
S        }
S      #else
S        TRACE_DEBUG("SD_ReadBlock:ContinuousRead\n\r");
S        error = ContinuousRead(pSd,
S                               nbBlocks,
S                               pData,
S                               0, 0);
S        pSd->preBlock = address + (nbBlocks-1);
S      #endif
S    }
S    else {
S        error = MoveToTransferState(pSd, address, nbBlocks, pData, 1);
S        pSd->state = SD_STATE_READ;
S    }
S  #endif
N#else
N    if (   pSd->state != SD_STATE_READ
X    if (   pSd->state != 0x10
N        || pSd->preBlock + 1 != address ) {
N        // Start infinite block reading
N        error = MoveToTransferState(pSd, address, 0, 0, 1);
N    }
N    if (!error) {
N        pSd->state = SD_STATE_READ;
X        pSd->state = 0x10;
N        error = ContinuousRead(pSd,
N                               nbBlocks,
N                               pData,
N                               0, 0);
N        if (!error) pSd->preBlock = address + (nbBlocks - 1);
N    }
N#endif
N    return error;
N}
N
N//------------------------------------------------------------------------------
N/// Write Block of data pointed by pData. The buffer size must be at
N/// least 512 byte long. This function checks the SD card status register and
N/// address the card if required before sending the read command.
N/// Returns 0 if successful; otherwise returns an SD_ERROR code.
N/// \param pSd  Pointer to a SD card driver instance.
N/// \param address  Address of block to write.
N/// \param nbBlocks Number of blocks to be read
N/// \param pData    Data buffer whose size is at least the block size, it can
N///            be 1,2 or 4-bytes aligned when used with DMA.
N//------------------------------------------------------------------------------
Nunsigned char SD_WriteBlock(SdCard *pSd,
N                            unsigned int address,
N                            unsigned short nbBlocks,
N                            const unsigned char *pData)
N{
N    unsigned char error = 0;
N
N    SANITY_CHECK(pSd);
X    ;
N    SANITY_CHECK(pData);
X    ;
N    SANITY_CHECK(nbBlocks);
X    ;
N
N    TRACE_DEBUG("WriteBlk(%d,%d)\n\r", address, nbBlocks);
X    { };
N
N#if defined(SINGLE_WRITE)
X#if 0L
S    unsigned char *pB = (unsigned char*)pData;
S    while(nbBlocks --) {
S        error = PerformSingleTransfer(pSd, address, pB, 0);
S        if (error)
S            break;
S        // SDHC
S        if (pSd->totalSize == 0xFFFFFFFF) {
S            address += 1;
S            pB = &pB[512];
S        }
S        else {
S            address += 1;
S            pB = &pB[512];
S        }
S    }
S    return error;
N#endif
N#if !defined(MCI2_INTERFACE)
X#if !1L
S  #if !defined(AT91C_MCI_WRPROOF)
S    error = MoveToTransferState(pSd, address, nbBlocks,
S                                (unsigned char *)pData, 0);
S    pSd->state = SD_STATE_WRITE;
S  #else
S    if((pSd->state == SD_STATE_WRITE)
S        && ((pSd->preBlock + 1) == address)) {
S
S        TRACE_DEBUG("SD_WriteBlock:ContinuousWrite\n\r");
S        error = ContinuousWrite(pSd,
S                                nbBlocks,
S                                pData,
S                                0, 0);
S        pSd->preBlock = address + (nbBlocks-1);
S    }
S    else {
S
S        //TRACE_FATAL("SD_WriteBlock:MoveToTransferState\n\r");
S        error = MoveToTransferState(pSd, address, nbBlocks,
S                                    (unsigned char *)pData, 0);
S        pSd->state = SD_STATE_WRITE;
S    }
S  #endif
N#else
N    if (   pSd->state != SD_STATE_WRITE
X    if (   pSd->state != 0x20
N        || pSd->preBlock + 1 != address ) {
N        // Start infinite block writing
N        error = MoveToTransferState(pSd, address, 0, 0, 0);
N    }
N    if (!error) {
N        pSd->state = SD_STATE_WRITE;
X        pSd->state = 0x20;
N        error = ContinuousWrite(pSd,
N                                nbBlocks,
N                                pData,
N                                0, 0);
N        if (!error) pSd->preBlock = address + (nbBlocks - 1);
N    }
N#endif
N
N    return error;
N}
N
N//------------------------------------------------------------------------------
N/// Run the SDcard SD/MMC/SDIO Mode initialization sequence.
N/// This function resets both IO and memory controller, runs the initialisation
N/// procedure and the identification process. Then it leaves the card in ready
N/// state. The following command must check the card type and continue to put
N/// the card into tran(for memory card) or cmd(for io card) state for data
N/// exchange.
N/// Returns 0 if successful; otherwise returns an SD_ERROR code.
N/// \param pSd  Pointer to a SD card driver instance.
N//------------------------------------------------------------------------------
Nstatic unsigned char SdMmcIdentify(SdCard *pSd)
N{
N    unsigned char mem = 0, io = 0, f8 = 0, mp = 1, ccs = 0;
N    unsigned char error = 0;
N#if MCI_SDIO_ENABLE
X#if 0
S    unsigned int  status;
N#endif
N
N    // Reset HC to default HS and BusMode
N    MCI_EnableHsMode(pSd->pSdDriver, 0);
N    MCI_SetBusWidth(pSd->pSdDriver, MCI_SDCBUS_1BIT);
X    MCI_SetBusWidth(pSd->pSdDriver, (0 << 7));
N
N#if MCI_SDIO_ENABLE
X#if 0
S    // Reset SDIO
S    // CMD52, write 1 to RES bit in the CCCR (bit 3 of register 6)
S    status = (0x1 << 3);
S    error = Cmd52(pSd, 0, 1, 0, 6, &status);
S    if (!error && ((status & STATUS_SDIO_CMD52) == 0)) {}
S    else if (error == MCI_STATUS_NORESPONSE) {}
S    else {
S        TRACE_DEBUG("SdMmcIdentify.Cmd52 fail: %d, %x", error, status);
S    }
N#endif
N
N    // Reset MEM
N    error = SwReset(pSd, 1);
N    if (error) {
N        TRACE_DEBUG("SdMmcIdentify.SwReset: %d", error)
X        { }
N    }
N
N    // CMD8 is newly added in the Physical Layer Specification Version 2.00 to
N    // support multiple voltage ranges and used to check whether the card
N    // supports supplied voltage. The version 2.00 host shall issue CMD8 and
N    // verify voltage before card initialization.
N    // The host that does not support CMD8 shall supply high voltage range...
N    error = Cmd8(pSd, 1, (void*)1);
N    if (error == 0) {
N        f8 = 1;
N    }
N    else if (error != SD_ERROR_NORESPONSE) {
X    else if (error != 2) {
N        TRACE_ERR("SdMmcIdentify.Cmd8: %d", error);
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SdMmcIdentify.Cmd8: %d", error); ShellPrintf("\n\r");};
N        return SD_ERROR_DRIVER;
X        return 1;
N    }
N    else {
N        // Delay after "no response"
N        Delay(800);
N    }
N
N#if MCI_SDIO_ENABLE
X#if 0
S    // CMD5 is added for SDIO OCR check
S    status = 0;
S    error = Cmd5(pSd, &status);
S    if (error)
S	{
S        DEBUG_MSG("SdMmcIdentify.Cmd5: %d", error);
S    }
S    // SDIO or SD COMBO: FN > 0
S    else if ((status & AT91C_SDIO_NF) > 0) {
S        // Set New Voltage
S        unsigned int   cmd5Retries = 10000;
S        do {
S            status &= AT91C_MMC_HOST_VOLTAGE_RANGE;
S            error = Cmd5(pSd, &status);
S            if (status & AT91C_CARD_POWER_UP_BUSY)
S                break;
S        } while(!error && cmd5Retries --);
S        if (error) {
S            TRACE_ERROR("SdMmcIdentify.Cmd5 V: %d\n\r", error);
S            return SD_ERROR_DRIVER;
S        }
S        TRACE_INFO("SDIO\n\r");
S        io = 1;
S        // SDIO only?
S        if ((status & AT91C_SDIO_MP) == 0) mp = 0;
S    }
N#endif
N    // SD or MMC or COMBO: mp is 1
N    if (mp) {
N        // Try SD memory initialize
N        error = Acmd41(pSd, f8, &ccs);
N        if (error) {
N            unsigned int   cmd1Retries = 10000;
N            TRACE_DEBUG("SdMmcIdentify.Acmd41: %d, try MMC\n\r", error);
X            { };
N
N            // Try MMC initialize
N            error = SwReset(pSd, 10);
N            if (error) {
N                TRACE_ERROR("SdMmcIdentify.Mmc.SwReset: %d\n\r", error);
X                {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SdMmcIdentify.Mmc.SwReset: %d\n\r", error); ShellPrintf("\n\r");};
N                return SD_ERROR_DRIVER;
X                return 1;
N            }
N            // - Set Voltage
N            do {
N                error = Cmd1(pSd, 1, &ccs);
N            }
N            while ((error) && (cmd1Retries-- > 0));
N            if (error) {
N                TRACE_ERROR("SdMmcIdentify.Cmd1: %d\n\r", error);
X                {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SdMmcIdentify.Cmd1: %d\n\r", error); ShellPrintf("\n\r");};
N                return SD_ERROR_DRIVER;
X                return 1;
N            }
N            else if (ccs) {
N                pSd->cardType = CARD_MMCHD;
X                pSd->cardType = ((0x2 << 1)|(1 << 0));
N            }
N            else {
N                pSd->cardType = CARD_MMC;
X                pSd->cardType = ((0x2 << 1));
N            }
N
N            // MMC Identified OK
N            return 0;
N        }
N        else if (ccs) {
N            DEBUG_MSG("SDHC MEM\n\r");
X            { };
N        }
N        else {
N            DEBUG_MSG("SD MEM\n\r");
X            { };
N        }
N        mem = 1;
N    }
N
N    // SD(IO)+MEM ?
N    if (!mem) {
N        // SDIO only
N        if (io) {
N            pSd->cardType = CARD_SDIO;
X            pSd->cardType = ((1 << 3));
N            return 0;
N        }
N    }
N    // SD COMBO, continue with memory initialize
N    else if (io) {
N        if (ccs) pSd->cardType = CARD_SDHCCOMBO;
X        if (ccs) pSd->cardType = ((1 << 3)|((0x1 << 1)|(1 << 0)));
N        else     pSd->cardType = CARD_SDCOMBO;
X        else     pSd->cardType = ((1 << 3)|((0x1 << 1)));
N    }
N    // SD(HC), continue with memory initialize
N    else {
N        if (ccs) pSd->cardType = CARD_SDHC;
X        if (ccs) pSd->cardType = ((0x1 << 1)|(1 << 0));
N        else     pSd->cardType = CARD_SD;
X        else     pSd->cardType = ((0x1 << 1));
N    }
N    return 0;
N}
N
N//------------------------------------------------------------------------------
N/// Run the SDcard SD Mode enumeration sequence. This function runs after the
N/// initialisation procedure and the identification process. It sets the
N/// SD card in transfer state to set the block length and the bus width.
N/// Returns 0 if successful; otherwise returns an SD_ERROR code.
N/// \param pSd  Pointer to a SD card driver instance.
N//------------------------------------------------------------------------------
Nstatic unsigned char SdMmcEnum(SdCard *pSd)
N{
N    unsigned char mem = 0, io = 0;
N    unsigned int   status;
N    unsigned short error;
N    unsigned char  isHsSupport = 0;
N    unsigned char  updateInformation = 0;
N
N    if (pSd->cardType & CARD_TYPE_bmSDMMC) mem = 1;
X    if (pSd->cardType & (0x3 << 1)) mem = 1;
N    if (pSd->cardType & CARD_TYPE_bmSDIO)  io = 1;
X    if (pSd->cardType & (1 << 3))  io = 1;
N
N    // For MEM
N    // The host then issues the command ALL_SEND_CID (CMD2) to the card to get
N    // its unique card identification (CID) number.
N    // Card that is unidentified (i.e. which is in Ready State) sends its CID
N    // number as the response (on the CMD line).
N    if (mem) {
N        error = Cmd2(pSd);
N        if (error) {
N            TRACE_ERROR("SdMmcEnum.Cmd2: %d\n\r", error);
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SdMmcEnum.Cmd2: %d\n\r", error); ShellPrintf("\n\r");};
N            return SD_ERROR_DRIVER;
X            return 1;
N        }
N    }
N
N    // For SDIO & MEM
N    // Thereafter, the host issues CMD3 (SEND_RELATIVE_ADDR) asks the
N    // card to publish a new relative card address (RCA), which is shorter than
N    // CID and which is used to address the card in the future data transfer
N    // mode. Once the RCA is received the card state changes to the Stand-by
N    // State. At this point, if the host wants to assign another RCA number, it
N    // can ask the card to publish a new number by sending another CMD3 command
N    // to the card. The last published RCA is the actual RCA number of the card.
N    error = Cmd3(pSd);
N    if (error) {
N        TRACE_ERROR("SdMmcInit.Cmd3 %d\n\r", error);
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SdMmcInit.Cmd3 %d\n\r", error); ShellPrintf("\n\r");};
N        return SD_ERROR_DRIVER;
X        return 1;
N    }
N
N    // For MEM
N    // SEND_CSD (CMD9) to obtain the Card Specific Data (CSD register),
N    // e.g. block length, card storage capacity, etc...
N    if (mem) {
N        error = Cmd9(pSd);
N        if (error) {
N            TRACE_ERROR("SdMmcInit.Cmd9 %d\n\r", error);
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SdMmcInit.Cmd9 %d\n\r", error); ShellPrintf("\n\r");};
N            return SD_ERROR_DRIVER;
X            return 1;
N        }
N    }
N
N    // For SDIO & MEM
N    // Now select the card, to TRAN state
N    error = MmcSelectCard(pSd, pSd->cardAddress, 0);
N    if (error) {
N        TRACE_ERROR("SdMmcInit.Sel %d\n\r", error);
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SdMmcInit.Sel %d\n\r", error); ShellPrintf("\n\r");};
N        return SD_ERROR_DRIVER;
X        return 1;
N    }
N    // SDIO only card, enumeration done
N    if (!mem && io) {
N        // Default tranSpeed: 25MHz
N        pSd->transSpeed = 25000000;
N        return 0;
N    }
N
N    // For MEM cards or combo
N    // If the card support EXT_CSD, read it!
N    DEBUG_MSG("Card Type %d, CSD_STRUCTURE %d\n\r",
N               pSd->cardType, SD_CSD_STRUCTURE(pSd));
X    { };
N
N    // Get extended information of the card
N    SdMmcUpdateInformation(pSd, 0, 0);
N
N    // Advanced settings for HD & HS card
N    if (pSd->cardType >= CARD_MMC){
X    if (pSd->cardType >= ((0x2 << 1))){
N
N        MmcCmd6Arg cmd6Arg;
N
N        // MMC4 or later
N        if (SD_CSD_SPEC_VERS(pSd) >= 4) {
X        if (((((pSd)->csd)[3-(122)/32] >> ((122)%32)) & ((1 << (4)) - 1)) >= 4) {
N
N            unsigned char busWidth, widthMode;
N
N            // Calculate MMC busWidth (limited by slot information)
N            switch (pSd->pSdDriver->mciMode & AT91C_MCI_SCDBUS) {
X            switch (pSd->pSdDriver->mciMode & (0x3 << 6)) {
N              #if defined(AT91C_MCI_SCDBUS_8BITS)
X              #if 1L
N                case AT91C_MCI_SCDBUS_8BITS:
X                case (0x3 << 6):
N                    busWidth = 8;
N                    widthMode = MCI_SDCBUS_8BIT;
X                    widthMode = (3 << 6);
N                    break;
N              #endif
N
N              #if defined(AT91C_MCI_SCDBUS_4BITS)
X              #if 1L
N                case AT91C_MCI_SCDBUS_4BITS:
X                case (0x2 << 6):
N                    busWidth = 4;
N                    widthMode = MCI_SDCBUS_4BIT;
X                    widthMode = (1 << 7);
N                    break;
N              #endif
N
N                default:
N                    busWidth = 1;
N                    widthMode = MCI_SDCBUS_1BIT;
X                    widthMode = (0 << 7);
N            }
N
N            // Switch to max bus width (4 now)
N            cmd6Arg.access = 0x1;
N            cmd6Arg.index  = SD_EXTCSD_BUS_WIDTH_INDEX;
X            cmd6Arg.index  = 183;
N            cmd6Arg.value  = SD_EXTCSD_BUS_WIDTH_4BIT;
X            cmd6Arg.value  = (0x1UL);
N            cmd6Arg.cmdSet = 0;
N            error = Cmd6(pSd, &cmd6Arg, 0, &status);
N            if (!error) {
N                
N              TRACE_WARNING_WP("-I- MMC %d-BIT BUS\n\r", busWidth);
X              {ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("-I- MMC %d-BIT BUS\n\r", busWidth);};
N              if (status
N                  & (STATUS_MMC_SWITCH
X                  & (( (1UL << 25) | (1UL << 23) | (1UL << 22) | (1UL << 20) | (1UL << 19) | (1UL << 13) | (0xFUL << 9) | (1UL << 8) | (1UL << 7) )
N                     & ~(STATUS_STATE | STATUS_READY_FOR_DATA))) {
X                     & ~((0xFUL << 9) | (1UL << 8)))) {
N                  TRACE_ERROR("-E- Status %x\n\r", status);
X                  {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("-E- Status %x\n\r", status); ShellPrintf("\n\r");};
N              }
N              else {
N                  MCI_SetBusWidth(pSd->pSdDriver, widthMode);
N                  updateInformation = 1;
N              }
N            }
N            else {
N                TRACE_WARNING("MMC %d-BIT not supported\n\r", busWidth)
X                {ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("MMC %d-BIT not supported\n\r", busWidth); ShellPrintf("\n\r");}
N            }
N        }
N        
N        // CARD_TYPE 3
N        if (SD_CSD_STRUCTURE(pSd) >= 2
X        if (((((pSd)->csd)[3-(126)/32] >> ((126)%32)) & ((1 << (2)) - 1)) >= 2
N            && (SD_EXTCSD_CARD_TYPE(pSd) & 0x2)) {
X            && ((((unsigned char*)((pSd)->extData))[196]) & 0x2)) {
N
N            #if !defined(OP_BOOTSTRAP_MCI_on)
X            #if !0L
N            // Switch to HS mode
N            if (gSdmmcAutoHsEnable) {
N                cmd6Arg.access = 0x3;
N                cmd6Arg.index  = SD_EXTCSD_HS_TIMING_INDEX;
X                cmd6Arg.index  = 185;
N                cmd6Arg.value  = SD_EXTCSD_HS_TIMING_ENABLE;
X                cmd6Arg.value  = (0x1UL);
N                cmd6Arg.cmdSet = 0;
N                error = Cmd6(pSd, &cmd6Arg, 0, &status);
N                if (error
N                    || (status
N                        & (STATUS_MMC_SWITCH
X                        & (( (1UL << 25) | (1UL << 23) | (1UL << 22) | (1UL << 20) | (1UL << 19) | (1UL << 13) | (0xFUL << 9) | (1UL << 8) | (1UL << 7) )
N                            & ~(STATUS_STATE | STATUS_READY_FOR_DATA)))) {
X                            & ~((0xFUL << 9) | (1UL << 8))))) {
N                    TRACE_WARNING("MMC HS Fail, st %x\n\r", status);
X                    {ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("MMC HS Fail, st %x\n\r", status); ShellPrintf("\n\r");};
N                }
N                else {
N                    MCI_EnableHsMode(pSd->pSdDriver, 1);
N                    TRACE_WARNING_WP("-I- MMC HS Enabled\n\r");
X                    {ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("-I- MMC HS Enabled\n\r");};
N                    isHsSupport = 1;
N                    updateInformation = 1;
N                }
N            }
N            #endif // end of OP_BOOTSTRAP_MCI_on
N        }
N    }
N    else if (pSd->cardType >= CARD_SD) {
X    else if (pSd->cardType >= ((0x1 << 1))) {
N      #if 1
N        // Switch to 4-bits bus width
N        // (All SD Card shall support 1-bit, 4 bitswidth)
N        error = Acmd6(pSd, 4);
N        DEBUG_MSG("SD 4-BITS BUS");
X        { };
N        if (error) {
N            TRACE_ERROR("SdMmcInit.12 (%d)\n\r", error);
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SdMmcInit.12 (%d)\n\r", error); ShellPrintf("\n\r");};
N            return error;
N        }
N        MCI_SetBusWidth(pSd->pSdDriver, MCI_SDCBUS_4BIT);
X        MCI_SetBusWidth(pSd->pSdDriver, (1 << 7));
N
N        #if !defined(OP_BOOTSTRAP_MCI_on)
X        #if !0L
N        // SD Spec V1.10 or higher, switch to high-speed mode
N        if (gSdmmcAutoHsEnable) {
N            if (SD_SCR_SD_SPEC(pSd) >= SD_SCR_SD_SPEC_1_10) {
X            if (( ((char*)(pSd)->extData)[7 - ((56)/8)] >> ((56)%8) & ((1 << (4)) - 1) ) >= 1) {
N                SdCmd6Arg cmd6Arg;
N                unsigned int switchStatus[512/32];
N                cmd6Arg.mode = 1;
N                cmd6Arg.reserved = 0;
N                cmd6Arg.reserveFG6 = 0xF;
N                cmd6Arg.reserveFG5 = 0xF;
N                cmd6Arg.reserveFG4 = 0xF;
N                cmd6Arg.reserveFG3 = 0xF;
N                cmd6Arg.command = 0;
N                cmd6Arg.accessMode = 1;
N                error = Cmd6(pSd,
N                             &cmd6Arg,
N                             switchStatus,
N                             &status);
N              #if 0
S                unsigned int i;
S                printf("SD Switch status:");
S                for(i = 0; i < 512 / 8; i ++) {
S                    if ((i % 8) == 0) printf("\n\r[%3d]", i);
S                    printf(" %02x", ((char*)switchStatus)[i]);
S                }
S                printf("\n\r");
S                printf(" _FG1_INFO %x\n\r",
S                    SD_SW_STAT_FUN_GRP1_INFO(switchStatus));
S                printf(" _FG1_RC   %x\n\r",
S                    SD_SW_STAT_FUN_GRP1_RC(switchStatus));
S                printf(" _FG1_BUSY %x\n\r",
S                    SD_SW_STAT_FUN_GRP1_BUSY(switchStatus));
S                printf(" _FG1_DS_V %x\n\r",
S                    SD_SW_STAT_DATA_STRUCT_VER(switchStatus));
N              #endif
N                if (error || (status & STATUS_SWITCH_ERROR)) {
X                if (error || (status & (1UL << 7))) {
N                    TRACE_WARNING("SD HS Fail\n\r");
X                    {ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SD HS Fail\n\r"); ShellPrintf("\n\r");};
N                }
N                else if (SD_SW_STAT_FUN_GRP1_RC(switchStatus)
X                else if (( ((char*)(switchStatus))[63 - ((376)/8)] >> ((376)%8) & ((1 << (4)) - 1) )
N                                == SD_SW_STAT_FUN_GRP_RC_ERROR) {
X                                == 0xF) {
N                    TRACE_ERROR_WP("-I- SD HS Not Supported\n\r");
X                    {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("-I- SD HS Not Supported\n\r");};
N                }
N                else if (SD_SW_STAT_FUN_GRP1_BUSY(switchStatus)) {
X                else if (( ( ((char*)(switchStatus))[63 - ((272)/8)] >> ((272)%8) & ((1 << (8)) - 1) ) + (( ((char*)(switchStatus))[63 - ((280)/8)] >> ((280)%8) & ((1 << (8)) - 1) ) << 8) )) {
N                    DEBUG_MSG("SD HS Busy");
X                    { };
N                }
N                else {
N                    MCI_EnableHsMode(pSd->pSdDriver, 1);
N                    DEBUG_MSG("SD HS Enable");
X                    { };
N                    isHsSupport = 1;
N                }
N            }
N        }
N        #endif
N        // Update
N        updateInformation = 1;
N      #endif
N    }
N
N    if (updateInformation) {
N
N        SdMmcUpdateInformation(pSd, isHsSupport, 1);
N    }
N    return 0;
N}
N
N//------------------------------------------------------------------------------
N/// Run the SDcard initialization sequence. This function runs the
N/// initialisation procedure and the identification process, then it sets the
N/// SD card in transfer state to set the block length and the bus width.
N/// Returns 0 if successful; otherwise returns an SD_ERROR code.
N/// \param pSd  Pointer to a SD card driver instance.
N/// \param pSdDriver  Pointer to SD driver already initialized.
N//------------------------------------------------------------------------------
Nunsigned char SD_Init(SdCard *pSd, SdDriver *pSdDriver)
N{
N    unsigned char error;
N
N    //TRACE_DEBUG("SD_Init()\n\r");
N
N    // Initialize SdCard structure
N    pSd->pSdDriver = pSdDriver;
N    pSd->cardAddress = 0;
N    pSd->preBlock = 0xffffffff;
N    pSd->state = SD_STATE_INIT;
X    pSd->state = 1;
N    pSd->cardType = CARD_UNKNOWN;
X    pSd->cardType = (0);
N    pSd->optCmdBitMap = 0xFFFFFFFF;
N    pSd->mode = 0;
N    ResetCommand(&pSd->command);
N
N    // Initialization delay: The maximum of 1 msec, 74 clock cycles and supply
N    // ramp up time. Supply ramp up time provides the time that the power is
N    // built up to the operating level (the bus master supply voltage) and the
N    // time to wait until the SD card can accept the first command.
N
N    // Power On Init Special Command
N
N    error = Pon(pSd);
N    if (error) {
N        TRACE_ERROR("SD_Init.1 (%d)\n\r", error);
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SD_Init.1 (%d)\n\r", error); ShellPrintf("\n\r");};
N        return error;
N    }
N    // After power-on or CMD0, all cards?CMD lines are in input mode, waiting
N    // for start bit of the next command.
N    // The cards are initialized with a default relative card address
N    // (RCA=0x0000) and with a default driver stage register setting
N    // (lowest speed, highest driving current capability).
N    error = SdMmcIdentify(pSd);
N    if (error) {
N        TRACE_ERROR("SD_Init.Identify\n\r");
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SD_Init.Identify\n\r"); ShellPrintf("\n\r");};
N        return error;
N    }
N    error = SdMmcEnum(pSd);
N    if (error) {
N        TRACE_ERROR("SD_Init.Enum\n\r");
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SD_Init.Enum\n\r"); ShellPrintf("\n\r");};
N        return error;
N    }
N
N    // In the case of a Standard Capacity SD Memory Card, this command sets the
N    // block length (in bytes) for all following block commands
N    // (read, write, lock).
N    // Default block length is fixed to 512 Bytes.
N    // Set length is valid for memory access commands only if partial block read
N    // operation are allowed in CSD.
N    // In the case of a High Capacity SD Memory Card, block length set by CMD16
N    // command does not affect the memory read and write commands. Always 512
N    // Bytes fixed block length is used. This command is effective for
N    // LOCK_UNLOCK command.
N    // In both cases, if block length is set larger than 512Bytes, the card sets
N    // the BLOCK_LEN_ERROR bit.
N    if (pSd->cardType == CARD_SD) {
X    if (pSd->cardType == ((0x1 << 1))) {
N        error = Cmd16(pSd, SD_BLOCK_SIZE);
X        error = Cmd16(pSd, 512);
N        if (error) {
N            pSd->optCmdBitMap &= ~SD_CMD16_SUPPORT;
X            pSd->optCmdBitMap &= ~(1UL << 8);
N            TRACE_INFO("SD_Init.Cmd16 (%d)\n\r", error);
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SD_Init.Cmd16 (%d)\n\r", error); ShellPrintf("\n\r");};
N            TRACE_INFO("Fail to set BLK_LEN, default is 512\n\r");
X            {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("Fail to set BLK_LEN, default is 512\n\r"); ShellPrintf("\n\r");};
N        }
N    }
N
N    // Reset status for R/W
N    pSd->state = SD_STATE_READY;
X    pSd->state = 2;
N
N    // If SDIO Card
N    if (pSd->cardType == CARD_SDIO) {
X    if (pSd->cardType == ((1 << 3))) {
N        pSd->blockNr = 0;
N        pSd->totalSize = 0;
N    }
N    // If MMC Card & get size from EXT_CSD
N    else if (pSd->cardType >= CARD_MMC && SD_CSD_C_SIZE(pSd) == 0xFFF) {
X    else if (pSd->cardType >= ((0x2 << 1)) && ((((((pSd)->csd)[3-(72)/32] >> ((72)%32)) & ((1 << (2)) - 1)) << 10) + (((((pSd)->csd)[3-(64)/32] >> ((64)%32)) & ((1 << (8)) - 1)) << 2) + ((((pSd)->csd)[3-(62)/32] >> ((62)%32)) & ((1 << (2)) - 1))) == 0xFFF) {
N        pSd->blockNr = SD_EXTCSD_BLOCKNR(pSd);
X        pSd->blockNr = (((((unsigned char*)((pSd)->extData))[212]) + (((unsigned char*)((pSd)->extData))[212+1] << 8 ) + (((unsigned char*)((pSd)->extData))[212+2] << 16 ) + (((unsigned char*)((pSd)->extData))[212+3] << 24 )));
N        // Block number less than 0x100000000/512
N        if (pSd->blockNr > 0x800000)
N            pSd->totalSize = 0xFFFFFFFF;
N        else
N            pSd->totalSize = SD_EXTCSD_TOTAL_SIZE(pSd);
X            pSd->totalSize = (((((unsigned char*)((pSd)->extData))[212]) + (((unsigned char*)((pSd)->extData))[212+1] << 8 ) + (((unsigned char*)((pSd)->extData))[212+2] << 16 ) + (((unsigned char*)((pSd)->extData))[212+3] << 24 ))*512);
N    }
N    // If SD CSD v2.0
N    else if(pSd->cardType >= CARD_SD
X    else if(pSd->cardType >= ((0x1 << 1))
N            && pSd->cardType < CARD_MMC
X            && pSd->cardType < ((0x2 << 1))
N            && SD_CSD_STRUCTURE(pSd) >= 1) {
X            && ((((pSd)->csd)[3-(126)/32] >> ((126)%32)) & ((1 << (2)) - 1)) >= 1) {
N        pSd->blockNr   = SD_CSD_BLOCKNR_HC(pSd);
X        pSd->blockNr   = ((((((((pSd)->csd)[3-(64)/32] >> ((64)%32)) & ((1 << (6)) - 1)) << 16) + (((((pSd)->csd)[3-(56)/32] >> ((56)%32)) & ((1 << (8)) - 1)) << 8) + ((((pSd)->csd)[3-(48)/32] >> ((48)%32)) & ((1 << (8)) - 1))) + 1) * 1024);
N        pSd->totalSize = 0xFFFFFFFF;
N    }
N    // Normal card
N    else {
N        pSd->totalSize = SD_CSD_TOTAL_SIZE(pSd);
X        pSd->totalSize = (((((((((pSd)->csd)[3-(72)/32] >> ((72)%32)) & ((1 << (2)) - 1)) << 10) + (((((pSd)->csd)[3-(64)/32] >> ((64)%32)) & ((1 << (8)) - 1)) << 2) + ((((pSd)->csd)[3-(62)/32] >> ((62)%32)) & ((1 << (2)) - 1))) + 1) * (1 << (((((pSd)->csd)[3-(47)/32] >> ((47)%32)) & ((1 << (3)) - 1)) + 2))) * (1 << ((((pSd)->csd)[3-(80)/32] >> ((80)%32)) & ((1 << (4)) - 1))));
N        pSd->blockNr = SD_CSD_BLOCKNR(pSd);
X        pSd->blockNr = ((((((((pSd)->csd)[3-(72)/32] >> ((72)%32)) & ((1 << (2)) - 1)) << 10) + (((((pSd)->csd)[3-(64)/32] >> ((64)%32)) & ((1 << (8)) - 1)) << 2) + ((((pSd)->csd)[3-(62)/32] >> ((62)%32)) & ((1 << (2)) - 1))) + 1) * (1 << (((((pSd)->csd)[3-(47)/32] >> ((47)%32)) & ((1 << (3)) - 1)) + 2)));
N    }
N
N    if (pSd->cardType == CARD_UNKNOWN) {
X    if (pSd->cardType == (0)) {
N        return SD_ERROR_NOT_INITIALIZED;
X        return 3;
N    }
N    else {
N        return 0;
N    }
N}
N
N//------------------------------------------------------------------------------
N/// Stop the SDcard. This function stops all SD operations.
N/// Returns 0 if successful; otherwise returns an SD_ERROR code.
N/// \param pSd  Pointer to a SD card driver instance.
N/// \param pSdDriver  Pointer to MCI driver already initialized.
N//------------------------------------------------------------------------------
Nunsigned char SD_Stop(SdCard *pSd, SdDriver *pSdDriver)
N{
N    unsigned char error;
N    SdCmd *pCommand = &(pSd->command);
N
N    if (pSd == 0 || pSdDriver == 0)
N        return 0;
N
N    if(pCommand->tranType == MCI_CONTINUE_TRANSFER)
X    if(pCommand->tranType == 1)
N    {
N        TRACE_DEBUG("SD_StopTransmission()\n\r");
X        { };
N
N        error = Cmd12(pSd, (pSd->state != SD_STATE_WRITE), 0);
X        error = Cmd12(pSd, (pSd->state != 0x20), 0);
N        if(error) {
N            return error;
N        }
N    }
N
N    MCI_Close((Mci *)pSdDriver);
N    return 0;
N}
N
N//------------------------------------------------------------------------------
N/// Switch the SD/MMC card to High-Speed mode.
N/// pSd->transSpeed will change to new speed limit.
N/// Invoke MCI_SetSpeed() and MCI_EnableHsMode() to change MCI timing after.
N/// For SD/MMC card, the speed mode will not change back until another init.
N/// \param pSd      Pointer to a SD card driver instance.
N/// \param hsMode   1 to enable HS mode, 0 to disable
N///                 0xFF to return current mode.
N/// \return current mode is hsMode is 0xFF;
N///         error code if hsMode is 0 or 1.
N//------------------------------------------------------------------------------
Nunsigned char SD_HighSpeedMode(SdCard *pSd,
N                               unsigned char hsMode)
N{
N    unsigned char error = 0;
N
N    if (hsMode == 0xFF)
N        return pSd->mode;
N    if (hsMode == 0) {
N        TRACE_WARNING("Can not switch, do re-init to disable HS mode\n\r");
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("Can not switch, do re-init to disable HS mode\n\r"); ShellPrintf("\n\r");};
N        return SD_ERROR_DRIVER;
X        return 1;
N    }
N
N    // Quit transfer state
N    error = MoveToTranState(pSd);
N    if (error) {
N        TRACE_ERROR("SD_HighSpeedMode.Tran: %d\n\r", error);
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("SD_HighSpeedMode.Tran: %d\n\r", error); ShellPrintf("\n\r");};
N        return error;
N    }
N
N    if (pSd->mode != hsMode) {
N        error = SdMmcSwitchHsMode(pSd, hsMode);
N        if (error == 0)
N            error = SdMmcUpdateInformation(pSd, 1, 1);
N    }
N    // Reset state for data R/W
N    pSd->state = SD_STATE_READY;
X    pSd->state = 2;
N
N    return error;
N}
N
Nunsigned char SD_BusWidth(SdCard *pSd,
N                          unsigned char busWidth)
N{
N    return 0;
N}
N
N#if defined(MCI2_INTERFACE) && defined(AT91C_MCI_SPCMD_BOOTREQ)
X#if 1L && 0L
S//------------------------------------------------------------------------------
S/// Read Block of data in a buffer pointed by pData. The buffer size must be at
S/// least 512 byte long. This function checks the SD card status register and
S/// address the card if required before sending the read command.
S/// Returns 0 if successful; otherwise returns an code describing the error.
S/// \param pSd  Pointer to a SD card driver instance.
S/// \param address  Address of the block to read.
S/// \param nbBlocks Number of blocks to be read.
S/// \param pData  Data buffer whose size is at least the block size.
S//------------------------------------------------------------------------------
Sunsigned char MMC_BootRead(SdCard *pSd,
S                           unsigned int   nbBlocks,
S                           unsigned char *pData)
S{
S    unsigned char error;
S    unsigned char bootAck  = 0;
S    unsigned char busWidth = MCI_SDCBUS_4BIT;
S
S    SANITY_CHECK(pSd);
S
S    if (pSd->state != SD_STATE_BOOT)
S        return SD_ERROR_DRIVER;
S
S  #if 0
S    switch(SD_EXTCSD_BOOT_BUS_WIDTH(pSd)) {
S        case SD_EXTCSD_BOOT_BUS_1BIT:
S            busWidth = MCI_SDCBUS_1BIT;
S            break;
S        case SD_EXTCSD_BOOT_BUS_8BIT:
S            busWidth = MCI_SDCBUS_8BIT;
S            break;
S    }
S
S    if (SD_EXTCSD_BOOT_CONFIG(pSd) & SD_EXTCSD_BOOT_PARTITION_ACK)
S        bootAck = 1;
S  #endif
S
S    MCI_SetBusWidth((Mci*)pSd->pSdDriver, busWidth);
S    error = BootREQ(pSd, pData, nbBlocks, bootAck);
S    pSd->state = SD_STATE_BOOT;
S
S    return error;
S}
S
S//------------------------------------------------------------------------------
S/// In boot operation mode, the master can read boot data from the slave.
S/// By keeping CMD line low after power-on
S/// \param pSd  Pointer to a SD card driver instance.
S//------------------------------------------------------------------------------
Sunsigned char MMC_BootInit(SdCard *pSd)
S{
S    unsigned char error = 0;
S
S    SANITY_CHECK(pSd);
S
S    error = PonBoot(pSd);
S
S    if (!error) {
S
S        //error = BootREQ(pSd, 0, 0, 0);
S
S        if (!error)
S            pSd->state = SD_STATE_BOOT;
S        else {
S            TRACE_ERROR("MMC_BootInit.BootREQ: %d\n\r", error);
S        }
S    }
S    else {
S        TRACE_ERROR("MMC_BootInit.PonBoot: %d\n\r", error);
S    }
S
S    return error;
S}
S
S//------------------------------------------------------------------------------
S/// In boot operation mode, the master can read boot data from the slave.
S/// By sending CMD0 with argument + 0xFFFFFFFA
S/// \param pSd  Pointer to a SD card driver instance.
S//------------------------------------------------------------------------------
Sunsigned char MMC_BootStart(SdCard *pSd)
S{
S    unsigned char error;
S
S    SANITY_CHECK(pSd);
S
S    if (pSd->state == SD_STATE_BOOT)
S        return 0;
S
S    if (pSd->cardType >= CARD_MMC
S        && SD_CSD_STRUCTURE(pSd) >= 2
S        && SD_CID_BGA(pSd) == 1
S        && SD_EXTCSD_BOOT_INFO(pSd) == 1) {}
S    else
S        return SD_ERROR_NOT_SUPPORT;
S
S    error = Cmd0(pSd, 0xFFFFFFFA);
S    pSd->state = SD_STATE_BOOT;
S
S    return 0;
S}
S
S//------------------------------------------------------------------------------
S/// Terminate the boot operation mode
S/// \param pSd  Pointer to a SD card driver instance.
S//------------------------------------------------------------------------------
Sunsigned char MMC_BootStop(SdCard *pSd)
S{
S    unsigned char error;
S
S    SANITY_CHECK(pSd);
S
S    if (pSd->state != SD_STATE_BOOT)
S        return 0;
S
S    error = BootEnd(pSd);
S
S    if(!error)
S        pSd->state = SD_STATE_IDLE;
S
S    return error;
S}
S
S//------------------------------------------------------------------------------
S/// Setup Boot Settings
S/// \param resetBus Wether bus width is reset to 1-bit after quit boot mode.
S/// \param busWidth The bus width in boot operation.
S/// \param bootPart The partition used for boot operation.
S/// \param accPart  The partition to access with normal read/write.
S/// \param bootAck  Enable boot acknoledge.
S/// \return 0 or error code.
S//------------------------------------------------------------------------------
Sunsigned char MMC_SetupBootMode(SdCard *pSd,
S                                unsigned char resetBus,
S                                unsigned char busWidth,
S                                unsigned char bootPart,
S                                unsigned char accPart,
S                                unsigned char bootAck)
S{
S    unsigned int   status;
S    unsigned short error;
S    const MmcCmd6Arg bootArgs[] = {
S        // BOOT_CONFIG
S        {3, 179, (bootAck << 6)|(bootPart << 3)|(accPart << 0), 0},
S        // BOOT_BUS_WIDTH
S        {3, 177, (busWidth << 2)|(resetBus << 0), 0}
S    };
S
S    SANITY_CHECK(pSd);
S    if (    pSd->cardType >= CARD_MMC
S        &&  SD_CSD_STRUCTURE(pSd) >= 2
S        &&  SD_CID_CBS(pSd) == 1) {}
S    else return SD_ERROR_NOT_SUPPORT;
S    //if (MMC_GetBootSizeKB(pSd) == 0) return SD_ERROR_NOT_SUPPORT;
S
S    // Quit transfer state
S    error = MoveToTranState(pSd);
S    if (error) {
S        TRACE_ERROR("MMC_SetupBootMode.Tran: %d\n\r", error);
S        return error;
S    }
S
S    // Setup all boot informations
S    error = MmcSwitchSettings(pSd,
S                              bootArgs,
S                              sizeof(bootArgs)/sizeof(MmcCmd6Arg),
S                              &status);
S    if (error) {
S        TRACE_ERROR("MMC_SetupBootMode.Cmd6: 0x%x, %x\n\r", error, status);
S        return (unsigned char)error;
S    }
S
S    // Update the EXT_CSD
S  #if 1
S    error = Cmd8(pSd, 0, pSd->extData);
S    if (error) {
S        TRACE_ERROR("MMC_SetupBootMode.Cmd8 (%d)\n\r", error);
S    }
S
S   #if 0
S    if (   SD_EXTCSD_BOOT_BUS_WIDTH(pSd) != bootArgs[0].value
S        || SD_EXTCSD_BOOT_CONFIG(pSd) != bootArgs[1].value ) {
S
S        TRACE_ERROR("MMC_SetupBootMode: ExtCSD not changed\n\r");
S
S      #if 1
S        Cmd13(pSd, &status);
S        TRACE_INFO("  CARD status: 0x%x\n\r", status);
S      #endif
S        return SD_ERROR_DRIVER;
S    }
S   #endif
S  #endif
S
S    // Reset state for data R/W
S    pSd->state = SD_STATE_READY;
S
S    return 0;
S}
S
S//------------------------------------------------------------------------------
S/// \return 0 or error code.
S//------------------------------------------------------------------------------
Sunsigned char MMC_StopBootMode()
S{
S    return 0;
S}
N#endif
N
N
N//------------------------------------------------------------------------------
N/// \return size of the card in KB
N//------------------------------------------------------------------------------
Nunsigned int MMC_GetTotalSizeKB(SdCard *pSd)
N{
N    SANITY_CHECK(pSd);
X    ;
N
N    if (pSd->totalSize == 0xFFFFFFFF) {
N
N        return pSd->blockNr / 2;
N    }
N    
N    return pSd->totalSize / 1024;
N}
N
N
N//------------------------------------------------------------------------------
N/// \return size of boot area if the card support boot operation.
N//------------------------------------------------------------------------------
Nunsigned int MMC_GetBootSizeKB(SdCard *pSd)
N{
N    SANITY_CHECK(pSd);
X    ;
N    if (   pSd->cardType >= CARD_MMC
X    if (   pSd->cardType >= ((0x2 << 1))
N        && SD_CSD_STRUCTURE(pSd) >= 2) {
X        && ((((pSd)->csd)[3-(126)/32] >> ((126)%32)) & ((1 << (2)) - 1)) >= 2) {
N
N        return SD_EXTCSD_BOOT_SIZE_MULTI(pSd) * 128;
X        return (((unsigned char*)((pSd)->extData))[226]) * 128;
N    }
N    return 0;
N}
N
N#if MCI_SDIO_ENABLE
X#if 0
S//------------------------------------------------------------------------------
S/// Display the content of the CCCR
S//------------------------------------------------------------------------------
Svoid SDIO_DisplayCardInformation(SdCard *pSd)
S{
S    unsigned int  tmp = 0, addrCIS = 0, addrManfID = 0, addrFunc0 = 0;
S    unsigned char* p = (unsigned char*)&tmp;
S    unsigned char  buf[8];
S
S    switch(pSd->cardType) {
S        case CARD_SDIO:
S            TRACE_INFO("** SDIO ONLY card\n\r");
S            break;
S        case CARD_SDCOMBO:
S        case CARD_SDHCCOMBO:
S            TRACE_INFO("** SDIO Combo card\n\r");
S            break;
S        default:
S            TRACE_INFO("** NO SDIO, CCCR not supported\n\r");
S            return;
S    }
S    // CCCR
S    TRACE_INFO("====== CCCR ======\n\r");
S    SDIO_ReadDirect(pSd, SDIO_CIA, SDIO_CCCR_REG, p, 1);
S    TRACE_INFO(".SDIO       %02X\n\r", (tmp & SDIO_SDIO) >> 4);
S    TRACE_INFO(".CCCR       %02X\n\r", (tmp & SDIO_CCCR) >> 0);
S    SDIO_ReadDirect(pSd, SDIO_CIA, SDIO_SD_REV_REG, p, 1);
S    TRACE_INFO(".SD         %02X\n\r", (tmp & SDIO_SD) >> 0);
S    SDIO_ReadDirect(pSd, SDIO_CIA, SDIO_IOE_REG, p, 1);
S    TRACE_INFO(".IOE        %02X\n\r", (tmp & SDIO_IOE) >> 0);
S    SDIO_ReadDirect(pSd, SDIO_CIA, SDIO_IOR_REG, p, 1);
S    TRACE_INFO(".IOR        %02X\n\r", (tmp & SDIO_IOR) >> 0);
S    SDIO_ReadDirect(pSd, SDIO_CIA, SDIO_IEN_REG, p, 1);
S    TRACE_INFO(".IEN        %02X\n\r", (tmp & SDIO_IEN) >> 0);
S    SDIO_ReadDirect(pSd, SDIO_CIA, SDIO_INT_REG, p, 1);
S    TRACE_INFO(".INT        %02X\n\r", (tmp & SDIO_INT) >> 0);
S    SDIO_ReadDirect(pSd, SDIO_CIA, SDIO_BUS_CTRL_REG, p, 1);
S    TRACE_INFO(".CD         %x\n\r", (tmp & SDIO_CD) >> 7);
S    TRACE_INFO(".SCSI       %x\n\r", (tmp & SDIO_SCSI) >> 6);
S    TRACE_INFO(".ECSI       %x\n\r", (tmp & SDIO_ECSI) >> 5);
S    TRACE_INFO(".BUS_WIDTH  %x\n\r", (tmp & SDIO_BUSWIDTH) >> 0);
S    SDIO_ReadDirect(pSd, SDIO_CIA, SDIO_CAP_REG, p, 1);
S    TRACE_INFO(".4BLS       %x\n\r", (tmp & SDIO_4BLS) >> 7);
S    TRACE_INFO(".LSC        %x\n\r", (tmp & SDIO_LSC) >> 6);
S    TRACE_INFO(".E4MI       %x\n\r", (tmp & SDIO_E4MI) >> 5);
S    TRACE_INFO(".S4MI       %x\n\r", (tmp & SDIO_S4MI) >> 4);
S    TRACE_INFO(".SBS        %x\n\r", (tmp & SDIO_SBS) >> 3);
S    TRACE_INFO(".SRW        %x\n\r", (tmp & SDIO_SRW) >> 2);
S    TRACE_INFO(".SMB        %x\n\r", (tmp & SDIO_SMB) >> 1);
S    TRACE_INFO(".SDC        %x\n\r", (tmp & SDIO_SDC) >> 0);
S    SDIO_ReadDirect(pSd, SDIO_CIA, SDIO_CIS_PTR_REG, p, 3);
S    TRACE_INFO(".CIS_PTR    %06X\n\r", tmp);
S    addrCIS = tmp; tmp = 0;
S    SDIO_ReadDirect(pSd, SDIO_CIA, SDIO_BUS_SUSP_REG, p, 1);
S    TRACE_INFO(".BR         %x\n\r", (tmp & SDIO_BR) >> 1);
S    TRACE_INFO(".BS         %x\n\r", (tmp & SDIO_BS) >> 0);
S    SDIO_ReadDirect(pSd, SDIO_CIA, SDIO_FUN_SEL_REG, p, 1);
S    TRACE_INFO(".DF         %x\n\r", (tmp & SDIO_DF) >> 7);
S    TRACE_INFO(".FS         %x\n\r", (tmp & SDIO_FS) >> 0);
S    SDIO_ReadDirect(pSd, SDIO_CIA, SDIO_EXEC_REG, p, 1);
S    TRACE_INFO(".EX         %x\n\r", (tmp & SDIO_EX));
S    TRACE_INFO(".EXM        %x\n\r", (tmp & SDIO_EXM) >> 0);
S    SDIO_ReadDirect(pSd, SDIO_CIA, SDIO_READY_REG, p, 1);
S    TRACE_INFO(".RF         %x\n\r", (tmp & SDIO_RF));
S    TRACE_INFO(".RFM        %x\n\r", (tmp & SDIO_RFM) >> 0);
S    SDIO_ReadDirect(pSd, SDIO_CIA, SDIO_FN0_BLKSIZ_REG, p, 2);
S    TRACE_INFO(".FN0_SIZE   %d(%04X)\n\r", tmp, tmp);
S    tmp = 0;
S    SDIO_ReadDirect(pSd, SDIO_CIA, SDIO_POWER_REG, p, 1);
S    TRACE_INFO(".EMPC       %x\n\r", (tmp & SDIO_EMPC) >> 1);
S    TRACE_INFO(".SMPC       %x\n\r", (tmp & SDIO_SMPC) >> 0);
S    SDIO_ReadDirect(pSd, SDIO_CIA, SDIO_HS_REG, p, 1);
S    TRACE_INFO(".EHS        %x\n\r", (tmp & SDIO_EHS) >> 1);
S    TRACE_INFO(".SHS        %x\n\r", (tmp & SDIO_SHS) >> 0);
S    // Metaformat
S    SdioFindTuples(pSd, addrCIS, 128, &addrManfID, &addrFunc0);
S    if (addrManfID != 0) {
S        SDIO_ReadDirect(pSd, SDIO_CIA, addrManfID, buf, 6);
S        TRACE_INFO("==== CISTPL_MANFID ====\n\r");
S        TRACE_INFO("._MANF %04X\n\r", buf[2] + (buf[3] << 8));
S        TRACE_INFO("._CARD %04X\n\r", buf[4] + (buf[5] << 8));
S    }
S    if (addrFunc0 != 0) {
S        SDIO_ReadDirect(pSd, SDIO_CIA, addrFunc0, buf, 6);
S        TRACE_INFO("== CISTPL_FUNCE Fun0 ==\n\r");
S        TRACE_INFO("._FN0_BLK_SIZE   %d(0x%04X)\n\r",
S            buf[3] + (buf[4] << 8), buf[3] + (buf[4] << 8));
S        TRACE_INFO("._MAX_TRAN_SPEED %02X\n\r", buf[5]);
S    }
S}
N#endif
N
N//------------------------------------------------------------------------------
N/// Display the content of the CID register
N/// \param pCid  Pointer to the Cid register value
N//------------------------------------------------------------------------------
Nvoid SD_DisplayRegisterCID(SdCard *pSd)
N{
N    // CID for memory card only
N    if (pSd->cardType == CARD_UNKNOWN || pSd->cardType >= CARD_SDIO)
X    if (pSd->cardType == (0) || pSd->cardType >= ((1 << 3)))
N        return;
N
N    TRACE_INFO("======= CID =======\n\r");
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("======= CID =======\n\r"); ShellPrintf("\n\r");};
N  #if 0
S    TRACE_INFO(" .Card/BGA         %X\n\r", SD_CID_BGA(pSd));
N  #else
N    TRACE_INFO("CID MID Manufacturer ID       %02X\n\r",
N        SD_CID_MID(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("CID MID Manufacturer ID       %02X\n\r", ( (pSd->cid[3-(120)/32] >> ((120)%32)) & ((1 << (8)) - 1))); ShellPrintf("\n\r");};
N    
N    TRACE_INFO("CID OID OEM/Application ID    %c%c\n\r",
N        (char)SD_CID_OID_BYTE_1(pSd),
N        (char)SD_CID_OID_BYTE_0(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("CID OID OEM/Application ID    %c%c\n\r", (char)( (pSd->cid[3-(112)/32] >> ((112)%32)) & ((1 << (8)) - 1)), (char)( (pSd->cid[3-(104)/32] >> ((104)%32)) & ((1 << (8)) - 1))); ShellPrintf("\n\r");};
N    
N    TRACE_INFO("CID PNM Product revision      %c%c%c%c%c\n\r",
N        (char)SD_CID_PNM_BYTE_4(pSd),
N        (char)SD_CID_PNM_BYTE_3(pSd),
N        (char)SD_CID_PNM_BYTE_2(pSd),
N        (char)SD_CID_PNM_BYTE_1(pSd),
N        (char)SD_CID_PNM_BYTE_0(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("CID PNM Product revision      %c%c%c%c%c\n\r", (char)( (pSd->cid[3-(96)/32] >> ((96)%32)) & ((1 << (8)) - 1)), (char)( (pSd->cid[3-(88)/32] >> ((88)%32)) & ((1 << (8)) - 1)), (char)( (pSd->cid[3-(80)/32] >> ((80)%32)) & ((1 << (8)) - 1)), (char)( (pSd->cid[3-(72)/32] >> ((72)%32)) & ((1 << (8)) - 1)), (char)( (pSd->cid[3-(64)/32] >> ((64)%32)) & ((1 << (8)) - 1))); ShellPrintf("\n\r");};
N    
N    TRACE_INFO("CID PRV Product serial number %02X%04X\n\r", 
N         SD_CID_PRV_2(pSd),
N         SD_CID_PRV_1(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("CID PRV Product serial number %02X%04X\n\r", ( (pSd->cid[3-(32)/32] >> ((32)%32)) & ((1 << (24)) - 1)), ( (pSd->cid[3-(24)/32] >> ((24)%32)) & ((1 << (8)) - 1))); ShellPrintf("\n\r");};
N
N    TRACE_INFO("CID MDT Manufacturing date    %04d/%02d\n\r",
N        (unsigned short)SD_CID_MDT_YEAR(pSd),
N        (unsigned char)SD_CID_MDT_MONTH(pSd));               
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("CID MDT Manufacturing date    %04d/%02d\n\r", (unsigned short)(( (pSd->cid[3-(12)/32] >> ((12)%32)) & ((1 << (8)) - 1)))+2000, (unsigned char)( (pSd->cid[3-(8)/32] >> ((8)%32)) & ((1 << (4)) - 1))); ShellPrintf("\n\r");};               
N    
N    TRACE_INFO("CID CRC checksum              %02X\n\r",   
N         SD_CID_CRC(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("CID CRC checksum              %02X\n\r", ( (pSd->cid[3-(1)/32] >> ((1)%32)) & ((1 << (7)) - 1))); ShellPrintf("\n\r");};
N  #endif
N}
N
N//------------------------------------------------------------------------------
N/// Display the content of the CSD register
N/// \param pSd  
N//------------------------------------------------------------------------------
Nvoid SD_DisplayRegisterCSD(SdCard *pSd)
N{ 
N    // CID for memory card only
N    if (pSd->cardType == CARD_UNKNOWN || pSd->cardType >= CARD_SDIO)
X    if (pSd->cardType == (0) || pSd->cardType >= ((1 << 3)))
N        return;
N
N    TRACE_INFO("======== CSD ========");
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("======== CSD ========"); ShellPrintf("\n\r");};
N  #if 0
S  {
S    unsigned int i;
S    unsigned char *p = (unsigned char *)pSd->csd;
S    for(i = 0; i < 128 / 8; i++) {
S        if ((i % 16) == 0) TRACE_INFO_WP("\n\r [%3d]:", i);
S        TRACE_INFO_WP(" %2x", p[i]);
S    }
S    TRACE_INFO_WP("\n\r");
S    TRACE_INFO("------------------------\n\r");
S  }
N  #else
N    TRACE_INFO_WP("\n\r");
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("\n\r");};
N  #endif
N    TRACE_INFO(" .CSD_STRUCTURE      0x%x\r\n", SD_CSD_STRUCTURE(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .CSD_STRUCTURE      0x%x\r\n", ((((pSd)->csd)[3-(126)/32] >> ((126)%32)) & ((1 << (2)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .SPEC_VERS          0x%x\r\n", SD_CSD_SPEC_VERS(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .SPEC_VERS          0x%x\r\n", ((((pSd)->csd)[3-(122)/32] >> ((122)%32)) & ((1 << (4)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .TAAC               0x%X\r\n", SD_CSD_TAAC(pSd)              );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .TAAC               0x%X\r\n", ((((pSd)->csd)[3-(112)/32] >> ((112)%32)) & ((1 << (8)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .NSAC               0x%X\r\n", SD_CSD_NSAC(pSd)              );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .NSAC               0x%X\r\n", ((((pSd)->csd)[3-(104)/32] >> ((104)%32)) & ((1 << (8)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .TRAN_SPEED         0x%X\r\n", SD_CSD_TRAN_SPEED(pSd)        );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .TRAN_SPEED         0x%X\r\n", ((((pSd)->csd)[3-(96)/32] >> ((96)%32)) & ((1 << (8)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .CCC                0x%X\r\n", SD_CSD_CCC(pSd)               );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .CCC                0x%X\r\n", ((((pSd)->csd)[3-(84)/32] >> ((84)%32)) & ((1 << (12)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .READ_BL_LEN        0x%X\r\n", SD_CSD_READ_BL_LEN(pSd)       );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .READ_BL_LEN        0x%X\r\n", ((((pSd)->csd)[3-(80)/32] >> ((80)%32)) & ((1 << (4)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .READ_BL_PARTIAL    0x%X\r\n", SD_CSD_READ_BL_PARTIAL(pSd)   );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .READ_BL_PARTIAL    0x%X\r\n", ((((pSd)->csd)[3-(79)/32] >> ((79)%32)) & ((1 << (1)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .WRITE_BLK_MISALIGN 0x%X\r\n", SD_CSD_WRITE_BLK_MISALIGN(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .WRITE_BLK_MISALIGN 0x%X\r\n", ((((pSd)->csd)[3-(78)/32] >> ((78)%32)) & ((1 << (1)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .READ_BLK_MISALIGN  0x%X\r\n", SD_CSD_READ_BLK_MISALIGN(pSd) );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .READ_BLK_MISALIGN  0x%X\r\n", ((((pSd)->csd)[3-(77)/32] >> ((77)%32)) & ((1 << (1)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .DSR_IMP            0x%X\r\n", SD_CSD_DSR_IMP(pSd)           );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .DSR_IMP            0x%X\r\n", ((((pSd)->csd)[3-(76)/32] >> ((76)%32)) & ((1 << (1)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .C_SIZE             0x%X\r\n", SD_CSD_C_SIZE(pSd)            );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .C_SIZE             0x%X\r\n", ((((((pSd)->csd)[3-(72)/32] >> ((72)%32)) & ((1 << (2)) - 1)) << 10) + (((((pSd)->csd)[3-(64)/32] >> ((64)%32)) & ((1 << (8)) - 1)) << 2) + ((((pSd)->csd)[3-(62)/32] >> ((62)%32)) & ((1 << (2)) - 1)))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .C_SIZE_HC          0x%X\r\n", SD_CSD_C_SIZE_HC(pSd)         );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .C_SIZE_HC          0x%X\r\n", ((((((pSd)->csd)[3-(64)/32] >> ((64)%32)) & ((1 << (6)) - 1)) << 16) + (((((pSd)->csd)[3-(56)/32] >> ((56)%32)) & ((1 << (8)) - 1)) << 8) + ((((pSd)->csd)[3-(48)/32] >> ((48)%32)) & ((1 << (8)) - 1)))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .VDD_R_CURR_MIN     0x%X\r\n", SD_CSD_VDD_R_CURR_MIN(pSd)    );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .VDD_R_CURR_MIN     0x%X\r\n", ((((pSd)->csd)[3-(59)/32] >> ((59)%32)) & ((1 << (3)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .VDD_R_CURR_MAX     0x%X\r\n", SD_CSD_VDD_R_CURR_MAX(pSd)    );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .VDD_R_CURR_MAX     0x%X\r\n", ((((pSd)->csd)[3-(56)/32] >> ((56)%32)) & ((1 << (3)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .VDD_W_CURR_MIN     0x%X\r\n", SD_CSD_VDD_W_CURR_MIN(pSd)    );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .VDD_W_CURR_MIN     0x%X\r\n", ((((pSd)->csd)[3-(53)/32] >> ((53)%32)) & ((1 << (3)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .VDD_W_CURR_MAX     0x%X\r\n", SD_CSD_VDD_W_CURR_MAX(pSd)    );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .VDD_W_CURR_MAX     0x%X\r\n", ((((pSd)->csd)[3-(50)/32] >> ((50)%32)) & ((1 << (3)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .C_SIZE_MULT        0x%X\r\n", SD_CSD_C_SIZE_MULT(pSd)       );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .C_SIZE_MULT        0x%X\r\n", ((((pSd)->csd)[3-(47)/32] >> ((47)%32)) & ((1 << (3)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .ERASE_BLK_EN       0x%X\r\n", SD_CSD_ERASE_BLK_EN(pSd)      );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .ERASE_BLK_EN       0x%X\r\n", ((((pSd)->csd)[3-(46)/32] >> ((46)%32)) & ((1 << (1)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .SECTOR_SIZE        0x%X\r\n", SD_CSD_SECTOR_SIZE(pSd)       );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .SECTOR_SIZE        0x%X\r\n", ((((((pSd)->csd)[3-(40)/32] >> ((40)%32)) & ((1 << (6)) - 1)) << 1) + ((((pSd)->csd)[3-(39)/32] >> ((39)%32)) & ((1 << (1)) - 1)))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .WP_GRP_SIZE        0x%X\r\n", SD_CSD_WP_GRP_SIZE(pSd)       );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .WP_GRP_SIZE        0x%X\r\n", ((((pSd)->csd)[3-(32)/32] >> ((32)%32)) & ((1 << (7)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .WP_GRP_ENABLE      0x%X\r\n", SD_CSD_WP_GRP_ENABLE(pSd)     );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .WP_GRP_ENABLE      0x%X\r\n", ((((pSd)->csd)[3-(31)/32] >> ((31)%32)) & ((1 << (1)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .R2W_FACTOR         0x%X\r\n", SD_CSD_R2W_FACTOR(pSd)        );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .R2W_FACTOR         0x%X\r\n", ((((pSd)->csd)[3-(26)/32] >> ((26)%32)) & ((1 << (3)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .WRITE_BL_LEN       0x%X\r\n", SD_CSD_WRITE_BL_LEN(pSd)      );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .WRITE_BL_LEN       0x%X\r\n", ((((((pSd)->csd)[3-(24)/32] >> ((24)%32)) & ((1 << (2)) - 1)) << 2) + ((((pSd)->csd)[3-(22)/32] >> ((22)%32)) & ((1 << (2)) - 1)))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .WRITE_BL_PARTIAL   0x%X\r\n", SD_CSD_WRITE_BL_PARTIAL(pSd)  );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .WRITE_BL_PARTIAL   0x%X\r\n", ((((pSd)->csd)[3-(21)/32] >> ((21)%32)) & ((1 << (1)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .FILE_FORMAT_GRP    0x%X\r\n", SD_CSD_FILE_FORMAT_GRP(pSd)   );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .FILE_FORMAT_GRP    0x%X\r\n", ((((pSd)->csd)[3-(15)/32] >> ((15)%32)) & ((1 << (1)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .COPY               0x%X\r\n", SD_CSD_COPY(pSd)              );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .COPY               0x%X\r\n", ((((pSd)->csd)[3-(14)/32] >> ((14)%32)) & ((1 << (1)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .PERM_WRITE_PROTECT 0x%X\r\n", SD_CSD_PERM_WRITE_PROTECT(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .PERM_WRITE_PROTECT 0x%X\r\n", ((((pSd)->csd)[3-(13)/32] >> ((13)%32)) & ((1 << (1)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .TMP_WRITE_PROTECT  0x%X\r\n", SD_CSD_TMP_WRITE_PROTECT(pSd) );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .TMP_WRITE_PROTECT  0x%X\r\n", ((((pSd)->csd)[3-(12)/32] >> ((12)%32)) & ((1 << (1)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .FILE_FORMAT        0x%X\r\n", SD_CSD_FILE_FORMAT(pSd)       );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .FILE_FORMAT        0x%X\r\n", ((((pSd)->csd)[3-(10)/32] >> ((10)%32)) & ((1 << (2)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .ECC                0x%X\r\n", SD_CSD_ECC(pSd)               );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .ECC                0x%X\r\n", ((((pSd)->csd)[3-(8)/32] >> ((8)%32)) & ((1 << (2)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .CRC                0x%X\r\n", SD_CSD_CRC(pSd)               );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .CRC                0x%X\r\n", ((((pSd)->csd)[3-(1)/32] >> ((1)%32)) & ((1 << (7)) - 1))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .MULT               0x%X\r\n", SD_CSD_MULT(pSd)              );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .MULT               0x%X\r\n", (1 << (((((pSd)->csd)[3-(47)/32] >> ((47)%32)) & ((1 << (3)) - 1)) + 2))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .BLOCKNR            0x%X\r\n", SD_CSD_BLOCKNR(pSd)           );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .BLOCKNR            0x%X\r\n", ((((((((pSd)->csd)[3-(72)/32] >> ((72)%32)) & ((1 << (2)) - 1)) << 10) + (((((pSd)->csd)[3-(64)/32] >> ((64)%32)) & ((1 << (8)) - 1)) << 2) + ((((pSd)->csd)[3-(62)/32] >> ((62)%32)) & ((1 << (2)) - 1))) + 1) * (1 << (((((pSd)->csd)[3-(47)/32] >> ((47)%32)) & ((1 << (3)) - 1)) + 2)))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .BLOCKNR_HC         0x%X\r\n", SD_CSD_BLOCKNR_HC(pSd)        );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .BLOCKNR_HC         0x%X\r\n", ((((((((pSd)->csd)[3-(64)/32] >> ((64)%32)) & ((1 << (6)) - 1)) << 16) + (((((pSd)->csd)[3-(56)/32] >> ((56)%32)) & ((1 << (8)) - 1)) << 8) + ((((pSd)->csd)[3-(48)/32] >> ((48)%32)) & ((1 << (8)) - 1))) + 1) * 1024)); ShellPrintf("\n\r");};
N    TRACE_INFO(" .BLOCK_LEN          0x%X\r\n", SD_CSD_BLOCK_LEN(pSd)         );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .BLOCK_LEN          0x%X\r\n", (1 << ((((pSd)->csd)[3-(80)/32] >> ((80)%32)) & ((1 << (4)) - 1)))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .TOTAL_SIZE         0x%X\r\n", SD_CSD_TOTAL_SIZE(pSd)        );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .TOTAL_SIZE         0x%X\r\n", (((((((((pSd)->csd)[3-(72)/32] >> ((72)%32)) & ((1 << (2)) - 1)) << 10) + (((((pSd)->csd)[3-(64)/32] >> ((64)%32)) & ((1 << (8)) - 1)) << 2) + ((((pSd)->csd)[3-(62)/32] >> ((62)%32)) & ((1 << (2)) - 1))) + 1) * (1 << (((((pSd)->csd)[3-(47)/32] >> ((47)%32)) & ((1 << (3)) - 1)) + 2))) * (1 << ((((pSd)->csd)[3-(80)/32] >> ((80)%32)) & ((1 << (4)) - 1))))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .TOTAL_SIZE_HC      0x%X\r\n", SD_CSD_TOTAL_SIZE_HC(pSd)     );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .TOTAL_SIZE_HC      0x%X\r\n", ((((((((pSd)->csd)[3-(64)/32] >> ((64)%32)) & ((1 << (6)) - 1)) << 16) + (((((pSd)->csd)[3-(56)/32] >> ((56)%32)) & ((1 << (8)) - 1)) << 8) + ((((pSd)->csd)[3-(48)/32] >> ((48)%32)) & ((1 << (8)) - 1))) + 1) * 512* 1024)); ShellPrintf("\n\r");};
N    TRACE_INFO(" -SD_TOTAL_SIZE      0x%X\r\n", SD_TOTAL_SIZE(pSd)            );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" -SD_TOTAL_SIZE      0x%X\r\n", ((pSd)->totalSize)); ShellPrintf("\n\r");};
N    TRACE_INFO(" -SD_TOTAL_BLOCK     0x%X\r\n", SD_TOTAL_BLOCK(pSd)           );
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" -SD_TOTAL_BLOCK     0x%X\r\n", ((pSd)->blockNr)); ShellPrintf("\n\r");};
N}   
N
N//------------------------------------------------------------------------------
N/// Display the content of the EXT_CSD register
N/// \param pSd  
N//------------------------------------------------------------------------------
Nvoid SD_DisplayRegisterECSD(SdCard *pSd)
N{
N    if (pSd->cardType >= CARD_MMC && pSd->cardType <= CARD_MMCHD
X    if (pSd->cardType >= ((0x2 << 1)) && pSd->cardType <= ((0x2 << 1)|(1 << 0))
N        && SD_CSD_STRUCTURE(pSd) >= 2) {}
X        && ((((pSd)->csd)[3-(126)/32] >> ((126)%32)) & ((1 << (2)) - 1)) >= 2) {}
N    else {
N        TRACE_INFO("** EXT_CSD NOT SUPPORTED\n\r");
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("** EXT_CSD NOT SUPPORTED\n\r"); ShellPrintf("\n\r");};
N        return;
N    }
N    TRACE_INFO("======= EXT_CSD =======");
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("======= EXT_CSD ======="); ShellPrintf("\n\r");};
N  #if 0
S  {
S    unsigned int i;
S    unsigned char *p = (unsigned char *)pSd->extData;
S    for(i = 0; i < 512; i++) {
S        if ((i % 16) == 0) TRACE_INFO_WP("\n\r [%3d]:", i);
S        TRACE_INFO_WP(" %2x", p[i]);
S    }
S    TRACE_INFO_WP("\n\r");
S    TRACE_INFO("------------------------\n\r");
S  }
N  #else
N    TRACE_INFO_WP("\n\r");
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("\n\r");};
N  #endif
N    TRACE_INFO(" .S_CMD_SET            : 0x%X\n\r",
N        SD_EXTCSD_S_CMD_SET(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .S_CMD_SET            : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[504])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .BOOT_INFO            : 0x%X\n\r",
N        SD_EXTCSD_BOOT_INFO(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .BOOT_INFO            : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[228])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .BOOT_SIZE_MULTI      : 0x%X\n\r",
N        SD_EXTCSD_BOOT_SIZE_MULTI(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .BOOT_SIZE_MULTI      : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[226])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .ACC_SIZE             : 0x%X\n\r",
N        SD_EXTCSD_ACC_SIZE(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .ACC_SIZE             : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[225])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .HC_ERASE_GRP_SIZE    : 0x%X\n\r",
N        SD_EXTCSD_HC_ERASE_GRP_SIZE(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .HC_ERASE_GRP_SIZE    : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[224])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .ERASE_TIMEOUT_MULT   : 0x%X\n\r",
N        SD_EXTCSD_ERASE_TIMEOUT_MULT(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .ERASE_TIMEOUT_MULT   : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[223])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .REL_WR_SEC_C         : 0x%X\n\r",
N        SD_EXTCSD_REL_WR_SEC_C(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .REL_WR_SEC_C         : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[222])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .HC_WP_GRP_SIZE       : 0x%X\n\r",
N        SD_EXTCSD_HC_WP_GRP_SIZE(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .HC_WP_GRP_SIZE       : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[221])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .S_C_VCC              : 0x%X\n\r",
N        SD_EXTCSD_S_C_VCC(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .S_C_VCC              : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[220])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .S_C_VCCQ             : 0x%X\n\r",
N        SD_EXTCSD_S_C_VCCQ(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .S_C_VCCQ             : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[219])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .S_A_TIMEOUT          : 0x%X\n\r",
N        SD_EXTCSD_S_A_TIMEOUT(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .S_A_TIMEOUT          : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[217])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .SEC_COUNT            : 0x%X\n\r",
N        SD_EXTCSD_SEC_COUNT(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .SEC_COUNT            : 0x%X\n\r", ((((unsigned char*)((pSd)->extData))[212]) + (((unsigned char*)((pSd)->extData))[212+1] << 8 ) + (((unsigned char*)((pSd)->extData))[212+2] << 16 ) + (((unsigned char*)((pSd)->extData))[212+3] << 24 ))); ShellPrintf("\n\r");};
N    TRACE_INFO(" .MIN_PERF_W_8_52      : 0x%X\n\r",
N        SD_EXTCSD_MIN_PERF_W_8_52(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .MIN_PERF_W_8_52      : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[210])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .MIN_PERF_R_8_52      : 0x%X\n\r",
N        SD_EXTCSD_MIN_PERF_R_8_52(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .MIN_PERF_R_8_52      : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[209])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .MIN_PERF_W_8_26_4_52 : 0x%X\n\r",
N        SD_EXTCSD_MIN_PERF_W_8_26_4_52(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .MIN_PERF_W_8_26_4_52 : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[208])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .MIN_PERF_R_8_26_4_52 : 0x%X\n\r",
N        SD_EXTCSD_MIN_PERF_R_8_26_4_52(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .MIN_PERF_R_8_26_4_52 : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[207])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .MIN_PERF_W_4_26      : 0x%X\n\r",
N        SD_EXTCSD_MIN_PERF_W_4_26(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .MIN_PERF_W_4_26      : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[206])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .MIN_PERF_R_4_26      : 0x%X\n\r",
N        SD_EXTCSD_MIN_PERF_R_4_26(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .MIN_PERF_R_4_26      : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[205])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .PWR_CL_26_360        : 0x%X\n\r",
N        SD_EXTCSD_PWR_CL_26_360(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .PWR_CL_26_360        : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[203])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .PWR_CL_52_360        : 0x%X\n\r",
N        SD_EXTCSD_PWR_CL_52_360(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .PWR_CL_52_360        : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[202])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .PWR_CL_26_195        : 0x%X\n\r",
N        SD_EXTCSD_PWR_CL_26_195(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .PWR_CL_26_195        : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[201])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .PWR_CL_52_195        : 0x%X\n\r",
N        SD_EXTCSD_PWR_CL_52_195(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .PWR_CL_52_195        : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[200])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .CARD_TYPE            : 0x%X\n\r",
N        SD_EXTCSD_CARD_TYPE(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .CARD_TYPE            : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[196])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .CSD_STRUCTURE        : 0x%X\n\r",
N        SD_EXTCSD_CSD_STRUCTURE(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .CSD_STRUCTURE        : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[194])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .EXT_CSD_REV          : 0x%X\n\r",
N        SD_EXTCSD_EXT_CSD_REV(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .EXT_CSD_REV          : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[192])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .CMD_SET              : 0x%X\n\r",
N        SD_EXTCSD_CMD_SET(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .CMD_SET              : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[191])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .CMD_SET_REV          : 0x%X\n\r",
N        SD_EXTCSD_CMD_SET_REV(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .CMD_SET_REV          : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[189])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .POWER_CLASS          : 0x%X\n\r",
N        SD_EXTCSD_POWER_CLASS(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .POWER_CLASS          : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[187])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .HS_TIMING            : 0x%X\n\r",
N        SD_EXTCSD_HS_TIMING(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .HS_TIMING            : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[185])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .BUS_WIDTH            : 0x%X\n\r",
N        SD_EXTCSD_BUS_WIDTH(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .BUS_WIDTH            : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[183])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .ERASED_MEM_CONT      : 0x%X\n\r",
N        SD_EXTCSD_ERASED_MEM_CONT(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .ERASED_MEM_CONT      : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[181])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .BOOT_CONFIG          : 0x%X\n\r",
N        SD_EXTCSD_BOOT_CONFIG(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .BOOT_CONFIG          : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[179])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .BOOT_BUS_WIDTH       : 0x%X\n\r",
N        SD_EXTCSD_BOOT_BUS_WIDTH(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .BOOT_BUS_WIDTH       : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[177])); ShellPrintf("\n\r");};
N    TRACE_INFO(" .ERASE_GROUP_DEF      : 0x%X\n\r",
N        SD_EXTCSD_ERASE_GROUP_DEF(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .ERASE_GROUP_DEF      : 0x%X\n\r", (((unsigned char*)((pSd)->extData))[175])); ShellPrintf("\n\r");};
N}
N
N//------------------------------------------------------------------------------
N/// Display the content of the SCR register
N/// \param pSd  Pointer to SdCard instance.
N//------------------------------------------------------------------------------
Nvoid SD_DisplayRegisterSCR(SdCard *pSd)
N{ 
N    if (pSd->cardType >= CARD_SD && pSd->cardType <= CARD_SDHC) {}
X    if (pSd->cardType >= ((0x1 << 1)) && pSd->cardType <= ((0x1 << 1)|(1 << 0))) {}
N    else {
N        TRACE_INFO("** SCR NOT Supported!\n\r");
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("** SCR NOT Supported!\n\r"); ShellPrintf("\n\r");};
N        return;
N    }
N    TRACE_INFO("========== SCR ==========");
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("========== SCR =========="); ShellPrintf("\n\r");};
N  #if 0
S  {
S    unsigned int i;
S    unsigned char *p = (unsigned char*)pSd->extData;
S    //TRACE_INFO_WP("\n\r");
S    //TRACE_INFO("DATA @ 0x%X", (unsigned int)p);
S    for(i = 0; i < 16; i ++) {
S        if ((i % 8) == 0) TRACE_INFO_WP("\n\r [%3d]:", i);
S        TRACE_INFO_WP(" %02x", p[i]);
S    }
S    TRACE_INFO_WP("\n\r");
S    TRACE_INFO("------------------------\n\r");
S  }
N  #else
N    TRACE_INFO_WP("\n\r");
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("\n\r");};
N  #endif
N
N    TRACE_INFO(" .SCR_STRUCTURE         :0x%X\n\r",
N        SD_SCR_SCR_STRUCTURE(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .SCR_STRUCTURE         :0x%X\n\r", ( ((char*)(pSd)->extData)[7 - ((60)/8)] >> ((60)%8) & ((1 << (4)) - 1) )); ShellPrintf("\n\r");};
N    TRACE_INFO(" .SD_SPEC               :0x%X\n\r",
N        SD_SCR_SD_SPEC(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .SD_SPEC               :0x%X\n\r", ( ((char*)(pSd)->extData)[7 - ((56)/8)] >> ((56)%8) & ((1 << (4)) - 1) )); ShellPrintf("\n\r");};
N    TRACE_INFO(" .DATA_STAT_AFTER_ERASE :0x%X\n\r",
N        SD_SCR_DATA_STAT_AFTER_ERASE(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .DATA_STAT_AFTER_ERASE :0x%X\n\r", ( ((char*)(pSd)->extData)[7 - ((55)/8)] >> ((55)%8) & ((1 << (1)) - 1) )); ShellPrintf("\n\r");};
N    TRACE_INFO(" .SD_SECURITY           :0x%X\n\r",
N        SD_SCR_SD_SECURITY(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .SD_SECURITY           :0x%X\n\r", ( ((char*)(pSd)->extData)[7 - ((52)/8)] >> ((52)%8) & ((1 << (3)) - 1) )); ShellPrintf("\n\r");};
N    TRACE_INFO(" .SD_BUS_WIDTHS         :0x%X\n\r",
N        SD_SCR_SD_BUS_WIDTHS(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .SD_BUS_WIDTHS         :0x%X\n\r", ( ((char*)(pSd)->extData)[7 - ((48)/8)] >> ((48)%8) & ((1 << (4)) - 1) )); ShellPrintf("\n\r");};
N}
N
N//------------------------------------------------------------------------------
N/// Display the content of the SD Status
N/// \param pSd  Pointer to SdCard instance.
N//------------------------------------------------------------------------------
Nvoid SD_DisplaySdStatus(SdCard *pSd)
N{
N    if (   pSd->cardType >= CARD_SD
X    if (   pSd->cardType >= ((0x1 << 1))
N        && pSd->cardType <= CARD_SDHC
X        && pSd->cardType <= ((0x1 << 1)|(1 << 0))
N        && (pSd->optCmdBitMap & SD_ACMD13_SUPPORT) ) {}
X        && (pSd->optCmdBitMap & (1UL << 1)) ) {}
N    else {
N        TRACE_INFO("** SD Status NOT Supported!\n\r");
X        {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("** SD Status NOT Supported!\n\r"); ShellPrintf("\n\r");};
N        return;
N    }
N    TRACE_INFO("=========== STAT ============");
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("=========== STAT ============"); ShellPrintf("\n\r");};
N  #if 0
S  {
S    unsigned int i;
S    unsigned char *p = (unsigned char*)pSd->extData;
S    //TRACE_INFO_WP("\n\r");
S    //TRACE_INFO("DATA @ 0x%X", (unsigned int)p);
S    for(i = 0; i < 72; i ++) {
S        if ((i % 8) == 0) TRACE_INFO_WP("\n\r [%3d]:", i);
S        TRACE_INFO_WP(" %02x", p[i]);
S    }
S    TRACE_INFO_WP("\n\r");
S    TRACE_INFO("------------------------\n\r");
S  }
N  #else
N    TRACE_INFO_WP("\n\r");
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf("\n\r");};
N  #endif
N
N    TRACE_INFO(" .DAT_BUS_WIDTH          :0x%X\n\r",
N        SD_STAT_DAT_BUS_WIDTH(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .DAT_BUS_WIDTH          :0x%X\n\r", ( ((char*)&(pSd)->extData[2])[63 - ((510)/8)] >> ((510)%8) & ((1 << (2)) - 1) )); ShellPrintf("\n\r");};
N    TRACE_INFO(" .SECURED_MODE           :0x%X\n\r",
N        SD_STAT_SECURED_MODE(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .SECURED_MODE           :0x%X\n\r", ( ((char*)&(pSd)->extData[2])[63 - ((509)/8)] >> ((509)%8) & ((1 << (1)) - 1) )); ShellPrintf("\n\r");};
N    TRACE_INFO(" .SD_CARD_TYPE           :0x%X\n\r",
N        SD_STAT_SD_CARD_TYPE(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .SD_CARD_TYPE           :0x%X\n\r", (( ((char*)&(pSd)->extData[2])[63 - ((480)/8)] >> ((480)%8) & ((1 << (8)) - 1) ) + (( ((char*)&(pSd)->extData[2])[63 - ((488)/8)] >> ((488)%8) & ((1 << (8)) - 1) ) << 8) )); ShellPrintf("\n\r");};
N    TRACE_INFO(" .SIZE_OF_PROTECTED_AREA :0x%X\n\r",
N        SD_STAT_SIZE_OF_PROTECTED_AREA(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .SIZE_OF_PROTECTED_AREA :0x%X\n\r", (( ((char*)&(pSd)->extData[2])[63 - ((448)/8)] >> ((448)%8) & ((1 << (8)) - 1) ) + (( ((char*)&(pSd)->extData[2])[63 - ((456)/8)] >> ((456)%8) & ((1 << (8)) - 1) ) << 8) + (( ((char*)&(pSd)->extData[2])[63 - ((464)/8)] >> ((464)%8) & ((1 << (8)) - 1) ) << 16) + (( ((char*)&(pSd)->extData[2])[63 - ((472)/8)] >> ((472)%8) & ((1 << (8)) - 1) ) << 24) )); ShellPrintf("\n\r");};
N    TRACE_INFO(" .SPEED_CLASS            :0x%X\n\r",
N        SD_STAT_SPEED_CLASS(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .SPEED_CLASS            :0x%X\n\r", ( ((char*)&(pSd)->extData[2])[63 - ((440)/8)] >> ((440)%8) & ((1 << (8)) - 1) )); ShellPrintf("\n\r");};
N    TRACE_INFO(" .PERFORMANCE_MOVE       :0x%X\n\r",
N        SD_STAT_PERFORMANCE_MOVE(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .PERFORMANCE_MOVE       :0x%X\n\r", ( ((char*)&(pSd)->extData[2])[63 - ((432)/8)] >> ((432)%8) & ((1 << (8)) - 1) )); ShellPrintf("\n\r");};
N    TRACE_INFO(" .AU_SIZE                :0x%X\n\r",
N        SD_STAT_AU_SIZE(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .AU_SIZE                :0x%X\n\r", ( ((char*)&(pSd)->extData[2])[63 - ((428)/8)] >> ((428)%8) & ((1 << (4)) - 1) )); ShellPrintf("\n\r");};
N    TRACE_INFO(" .ERASE_SIZE             :0x%X\n\r",
N        SD_STAT_ERASE_SIZE(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .ERASE_SIZE             :0x%X\n\r", (( ((char*)&(pSd)->extData[2])[63 - ((408)/8)] >> ((408)%8) & ((1 << (8)) - 1) ) + (( ((char*)&(pSd)->extData[2])[63 - ((416)/8)] >> ((416)%8) & ((1 << (8)) - 1) ) << 8) )); ShellPrintf("\n\r");};
N    TRACE_INFO(" .ERASE_TIMEOUT          :0x%X\n\r",
N        SD_STAT_ERASE_TIMEOUT(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .ERASE_TIMEOUT          :0x%X\n\r", ( ((char*)&(pSd)->extData[2])[63 - ((402)/8)] >> ((402)%8) & ((1 << (6)) - 1) )); ShellPrintf("\n\r");};
N    TRACE_INFO(" .ERASE_OFFSET           :0x%X\n\r",
N        SD_STAT_ERASE_OFFSET(pSd));
X    {ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(" .ERASE_OFFSET           :0x%X\n\r", ( ((char*)&(pSd)->extData[2])[63 - ((400)/8)] >> ((400)%8) & ((1 << (2)) - 1) )); ShellPrintf("\n\r");};
N}
