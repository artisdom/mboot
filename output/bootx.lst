L 1 "bootx.c"
N/* ----------------------------------------------------------------------------
N *		 
N *        mboot for Lophilo embedded system
N *        I am so lazy that I will add something here later.
N *	
N * ----------------------------------------------------------------------------
N * GPLv2
N * ----------------------------------------------------------------------------
N */
N
N#include "def.h"
L 1 "def.h" 1
N/*
N *------------------------------------------------------------------------------
N *
N *------------------------------------------------------------------------------
N */
N
N#ifndef __DEF_H__
N#define __DEF_H__
N
Ntypedef float F32;
Ntypedef unsigned int U32;
Ntypedef int S32;
Ntypedef unsigned short U16;
Ntypedef short int S16;
Ntypedef unsigned char U8;
Ntypedef char S8;
N
Ntypedef enum { FALSE = 0, TRUE } BOOL;
N
N#endif /* __DEF_H__ */
L 12 "bootx.c" 2
N#include "trace.h"
L 1 "trace.h" 1
N/*
N *------------------------------------------------------------------------------
N *
N *------------------------------------------------------------------------------
N */
N
N#ifndef __TRACE_H__
N#define __TRACE_H__
N
N#include "shell.h"
L 1 "shell.h" 1
N/*
N *------------------------------------------------------------------------------
N *
N *------------------------------------------------------------------------------
N */
N
N#ifndef __SHELL_H__
N#define __SHELL_H__
N
N#include "def.h"
N
N#define SHELL_INF(...)		{ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N#define SHELL_DATA(...)		{ShellPrintf(__VA_ARGS__);}
N#define SHELL_EMPTY()		{ShellPrintf("\n\r");}
N#define SHELL_BNNER()		{ShellPrintf("==========================================\n\r");}
N
Nvoid ShellAllClear(void);
N
NU32 ShellPrintf(const char* format,...);
Nvoid ShellSendString(S8 *pt);
Nvoid ShellGetString(S8 *string);
NS32 ShellGetIntNum(void);
N
Nvoid ShellPutByte(S8 c);
NS8 ShellGetByte(void);
NS8 ShellGetKey(void);
N
N#endif /* __SHELL_H__ */
L 11 "trace.h" 2
N
N#define DEBUG_ENABLE		0
N
N#if (DEBUG_ENABLE == 1)
X#if (0 == 1)
S#define TRACE_DEBUG(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;34mD: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
S#define TRACE_DEBUG_WP(...)		{ShellPrintf(__VA_ARGS__);}
S#define DEBUG_MSG(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;34mD: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
S#define DEBUG_MSG_WP(...)	{ShellPutByte(0x1B); ShellPrintf("[1;1;34mD: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__);}
S
S#define ASSERT(condition, ...)  { \
S    if (!(condition)) { \
S        ShellPrintf("ASSERT: "); \
S        ShellPrintf(__VA_ARGS__); \
S        while (1); \
S    } \
S}
X#define ASSERT(condition, ...)  {     if (!(condition)) {         ShellPrintf("ASSERT: ");         ShellPrintf(__VA_ARGS__);         while (1);     } }
S#define SANITY_ERROR            "Sanity check failed at %s:%d\n\r"
S
S/// Performs the same duty as the ASSERT() macro, except a default error
S/// message is output if the condition is false.
S/// \param condition  Condition to verify.
S#define SANITY_CHECK(condition) ASSERT(condition, SANITY_ERROR, __FILE__, __LINE__)
S		
S
N#else
N#define TRACE_DEBUG(...)		{ }
N#define TRACE_DEBUG_WP(...)		{ShellPrintf(__VA_ARGS__);}
N#define DEBUG_MSG(...)		{ }
N#define DEBUG_MSG_WP(...)	{ }
N#define ASSERT(...)
N#define SANITY_CHECK(...)
N#endif
N
N
N#define PRINT_F(...)		{ShellPrintf(__VA_ARGS__);}
N#define TRACE_MSG(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N#define TRACE_FIN(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;32mF: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N#define TRACE_WRN(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N#define TRACE_ERR(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N
N
N
N#define TRACE_ERROR(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N#define TRACE_INFO(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N#define TRACE_WARNING(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__); ShellPrintf("\n\r");}
N#define TRACE_ERROR_WP(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;31mE: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__);}
N#define TRACE_INFO_WP(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;34mI: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__);}
N#define TRACE_WARNING_WP(...)		{ShellPutByte(0x1B); ShellPrintf("[1;1;33m!: "); ShellPutByte(0x1B); ShellPrintf("[m"); ShellPrintf(__VA_ARGS__);}
N
N#endif /* __TRACE_H__ */
L 13 "bootx.c" 2
N#include "soc.h"
L 1 "soc.h" 1
N/*
N *------------------------------------------------------------------------------
N *
N *------------------------------------------------------------------------------
N */
N
N#ifndef __SOC_H__
N#define __SOC_H__
N
N#define BOARD_MAINOSC	12000000
N#define BOARD_MCK		((unsigned long)((BOARD_MAINOSC / 3 / 2 / 3) * 200 )) // 133MHz
N
N#define rWDT_SR			(*(volatile U32 *)(0xFFFFFD44))
N#define rSHDW_MR		(*(volatile U32 *)(0xFFFFFD14))
N#define rSYS_RSTC		(*(volatile U32 *)(0xFFFFFD08))
N#define rSCKCR			(*(volatile U32 *)(0xFFFFFD50))
N
N#define rCKGR_MOR		(*(volatile U32 *)(0xFFFFFC20))
N#define rCKGR_PLLAR		(*(volatile U32 *)(0xFFFFFC28))
N#define rCKGR_UCKR		(*(volatile U32 *)(0xFFFFFC1C))
N
N#define rPMC_MCKR		(*(volatile U32 *)(0xFFFFFC30))
N#define rPMC_PLLICPR	(*(volatile U32 *)(0xFFFFFC80))
N#define rPMC_SR			(*(volatile U32 *)(0xFFFFFC68))
N#define rPMC_SCER		(*(volatile U32 *)(0xFFFFFC00))
N#define rPMC_SCDR		(*(volatile U32 *)(0xFFFFFC04))
N#define rPMC_SCSR		(*(volatile U32 *)(0xFFFFFC08))
N#define rPMC_USB		(*(volatile U32 *)(0xFFFFFC38))
N#define rPMC_PCER		(*(volatile U32 *)(0xFFFFFC10))
N#define rPMC_PCDR		(*(volatile U32 *)(0xFFFFFC14))
N#define rPMC_PCSR		(*(volatile U32 *)(0xFFFFFC18))
N#define rPMC_PCK0		(*(volatile U32 *)(0xFFFFFC40))
N#define rPMC_PCK1		(*(volatile U32 *)(0xFFFFFC44))
N
N#define rAIC_SMR(id)	(*(volatile U32 *)(0xFFFFF000+id*0x4))
N#define rAIC_SVR(id)	(*(volatile U32 *)(0xFFFFF000+id*0x4+0x80))
N#define rAIC_IECR		(*(volatile U32 *)(0xFFFFF120))
N#define rAIC_IDCR		(*(volatile U32 *)(0xFFFFF124))
N#define rAIC_ICCR		(*(volatile U32 *)(0xFFFFF128))
N#define rAIC_EOICR		(*(volatile U32 *)(0xFFFFF130))
N#define rAIC_SPU		(*(volatile U32 *)(0xFFFFF134))
N
N#define rRTT_MR			(*(volatile U32 *)(0xFFFFFD20)) // Mode Register Read-write 0x0000_8000
N#define rRTT_AR			(*(volatile U32 *)(0xFFFFFD24)) // Alarm Register Read-write 0xFFFF_FFFF
N#define rRTT_VR			(*(volatile U32 *)(0xFFFFFD28)) // Value Register Read-only 0x0000_0000
N#define rRTT_SR			(*(volatile U32 *)(0xFFFFFD2C)) // Status Register Read-only 0x0000_0000
N
N#define rPIT_MR			(*(volatile U32 *)(0xFFFFFD30)) // Mode Register Read-write 0x000F_FFFF
N#define rPIT_SR			(*(volatile U32 *)(0xFFFFFD34)) // Status Register Read-only 0x0000_0000
N#define rPIT_PIVR		(*(volatile U32 *)(0xFFFFFD38)) // Periodic Interval Value Register Read-only 0x0000_0000
N#define rPIT_PIIR		(*(volatile U32 *)(0xFFFFFD3C)) // Periodic Interval Image Register Read-only 0x0000_0000
N
N#define rMATRIX_MCFG0	(*(volatile U32 *)(0xFFFFEA00)) // Master Configuration Register 0  Read-write 0x00000001
N#define rMATRIX_MCFG1	(*(volatile U32 *)(0xFFFFEA04)) // Master Configuration Register 1 Read-write 0x00000000
N#define rMATRIX_MCFG2	(*(volatile U32 *)(0xFFFFEA08)) // Master Configuration Register 2 Read-write 0x00000000
N#define rMATRIX_MCFG3	(*(volatile U32 *)(0xFFFFEA0C)) // Master Configuration Register 3 Read-write 0x00000000
N#define rMATRIX_MCFG4	(*(volatile U32 *)(0xFFFFEA10)) // Master Configuration Register 4 Read-write 0x00000000
N#define rMATRIX_MCFG5	(*(volatile U32 *)(0xFFFFEA14)) // Master Configuration Register 5 Read-write 0x00000000
N#define rMATRIX_MCFG6	(*(volatile U32 *)(0xFFFFEA18)) // Master Configuration Register 6 Read-write 0x00000000
N#define rMATRIX_MCFG7	(*(volatile U32 *)(0xFFFFEA1C)) // Master Configuration Register 7 Read-write 0x00000000
N#define rMATRIX_MCFG8	(*(volatile U32 *)(0xFFFFEA20)) // Master Configuration Register 8 Read-write 0x00000000
N#define rMATRIX_MCFG9	(*(volatile U32 *)(0xFFFFEA24)) // Master Configuration Register 9 Read-write 0x00000000
N#define rMATRIX_MCFG10	(*(volatile U32 *)(0xFFFFEA28)) // Master Configuration Register 10 Read-write 0x00000000
N#define rMATRIX_MCFG11	(*(volatile U32 *)(0xFFFFEA2C)) // Master Configuration Register 11 Read-write 0x00000000
N#define rMATRIX_SCFG0	(*(volatile U32 *)(0xFFFFEA40)) // Slave Configuration Register 0 Read-write 0x000001FF
N#define rMATRIX_SCFG1	(*(volatile U32 *)(0xFFFFEA44)) // Slave Configuration Register 1 Read-write 0x000001FF
N#define rMATRIX_SCFG2	(*(volatile U32 *)(0xFFFFEA48)) // Slave Configuration Register 2 Read-write 0x000001FF
N#define rMATRIX_SCFG3	(*(volatile U32 *)(0xFFFFEA4C)) // Slave Configuration Register 3 Read-write 0x000001FF
N#define rMATRIX_SCFG4	(*(volatile U32 *)(0xFFFFEA50)) // Slave Configuration Register 4 Read-write 0x000001FF
N#define rMATRIX_SCFG5	(*(volatile U32 *)(0xFFFFEA54)) // Slave Configuration Register 5 Read-write 0x000001FF
N#define rMATRIX_SCFG6	(*(volatile U32 *)(0xFFFFEA58)) // Slave Configuration Register 6 Read-write 0x000001FF
N#define rMATRIX_SCFG7	(*(volatile U32 *)(0xFFFFEA5C)) // Slave Configuration Register 7 Read-write 0x000001FF
N#define rMATRIX_PRAS0	(*(volatile U32 *)(0xFFFFEA80)) // Priority Register A for Slave 0 Read-write 0x00000000
N#define rMATRIX_PRBS0	(*(volatile U32 *)(0xFFFFEA84)) // Priority Register B for Slave 0 Read-write 0x00000000
N#define rMATRIX_PRAS1	(*(volatile U32 *)(0xFFFFEA88)) // Priority Register A for Slave 1 Read-write 0x00000000
N#define rMATRIX_PRBS1	(*(volatile U32 *)(0xFFFFEA8C)) // Priority Register B for Slave 1 Read-write 0x00000000
N#define rMATRIX_PRAS2	(*(volatile U32 *)(0xFFFFEA90)) // Priority Register A for Slave 2 Read-write 0x00000000
N#define rMATRIX_PRBS2	(*(volatile U32 *)(0xFFFFEA94)) // Priority Register B for Slave 2 Read-write 0x00000000
N#define rMATRIX_PRAS3	(*(volatile U32 *)(0xFFFFEA98)) // Priority Register A for Slave 3 Read-write 0x00000000
N#define rMATRIX_PRBS3	(*(volatile U32 *)(0xFFFFEA9C)) // Priority Register B for Slave 3 Read-write 0x00000000
N#define rMATRIX_PRAS4	(*(volatile U32 *)(0xFFFFEAA0)) // Priority Register A for Slave 4 Read-write 0x00000000
N#define rMATRIX_PRBS4	(*(volatile U32 *)(0xFFFFEAA4)) // Priority Register B for Slave 4 Read-write 0x00000000
N#define rMATRIX_PRAS5	(*(volatile U32 *)(0xFFFFEAA8)) // Priority Register A for Slave 5 Read-write 0x00000000
N#define rMATRIX_PRBS5	(*(volatile U32 *)(0xFFFFEAAC)) // Priority Register B for Slave 5 Read-write 0x00000000
N#define rMATRIX_PRAS6	(*(volatile U32 *)(0xFFFFEAB0)) // Priority Register A for Slave 6 Read-write 0x00000000
N#define rMATRIX_PRBS6	(*(volatile U32 *)(0xFFFFEAB4)) // Priority Register B for Slave 6 Read-write 0x00000000
N#define rMATRIX_PRAS7	(*(volatile U32 *)(0xFFFFEAB8)) // Priority Register A for Slave 7 Read-write 0x00000000
N#define rMATRIX_PRBS7	(*(volatile U32 *)(0xFFFFEABC)) // Priority Register B for Slave 7 Read-write 0x00000000
N#define rMATRIX_MRCR	(*(volatile U32 *)(0xFFFFEB00)) // Master Remap Control Register Read-write 0x00000000
N#define rMATRIX_WPMR	(*(volatile U32 *)(0xFFFFEBE4)) // Write Protect Mode Register Read-write 0x00000000
N#define rMATRIX_WPSR	(*(volatile U32 *)(0xFFFFEBE8)) // Write Protect Status Register Read-only 0x00000000
N
N#define rDMAC_GCFG		(*(volatile U32 *)(0xFFFFEC00))
N#define rDMAC_EN		(*(volatile U32 *)(0xFFFFEC04))
N#define rDMAC_SREQ		(*(volatile U32 *)(0xFFFFEC08))
N#define rDMAC_CREQ		(*(volatile U32 *)(0xFFFFEC0C))
N#define rDMAC_LAST		(*(volatile U32 *)(0xFFFFEC10))
N#define rDMAC_EBCIER	(*(volatile U32 *)(0xFFFFEC18))
N#define rDMAC_EBCIDR	(*(volatile U32 *)(0xFFFFEC1C))
N#define rDMAC_EBCIMR	(*(volatile U32 *)(0xFFFFEC20))
N#define rDMAC_EBCISR	(*(volatile U32 *)(0xFFFFEC24))
N#define rDMAC_CHER		(*(volatile U32 *)(0xFFFFEC28))
N#define rDMAC_CHDR		(*(volatile U32 *)(0xFFFFEC2C))
N#define rDMAC_CHSR		(*(volatile U32 *)(0xFFFFEC30))
N#define rDMAC_SADDR(ch)	(*(volatile U32 *)(0xFFFFEC3C+ch*(0x28)+(0x0)))
N#define rDMAC_DADDR(ch)	(*(volatile U32 *)(0xFFFFEC3C+ch*(0x28)+(0x4)))
N#define rDMAC_DSCR(ch)	(*(volatile U32 *)(0xFFFFEC3C+ch*(0x28)+(0x8)))
N#define rDMAC_CTRLA(ch)	(*(volatile U32 *)(0xFFFFEC3C+ch*(0x28)+(0xC)))
N#define rDMAC_CTRLB(ch)	(*(volatile U32 *)(0xFFFFEC3C+ch*(0x28)+(0x10)))
N#define rDMAC_CFG(ch)	(*(volatile U32 *)(0xFFFFEC3C+ch*(0x28)+(0x14)))
N#define rDMAC_SPIP(ch)	(*(volatile U32 *)(0xFFFFEC3C+ch*(0x28)+(0x18)))
N#define rDMAC_DPIP(ch)	(*(volatile U32 *)(0xFFFFEC3C+ch*(0x28)+(0x1C)))
N
N#define rPIOA_PER		(*(volatile U32 *)(0xFFFFF200)) // PIO Enable Register Write-only
N#define rPIOA_PDR		(*(volatile U32 *)(0xFFFFF204)) // PIO Disable Register Write-only
N#define rPIOA_PSR		(*(volatile U32 *)(0xFFFFF208)) // PIO Status Register Read-only
N#define rPIOA_OER		(*(volatile U32 *)(0xFFFFF210)) // Output Enable Register Write-only
N#define rPIOA_ODR		(*(volatile U32 *)(0xFFFFF214)) // Output Disable Register Write-only
N#define rPIOA_OSR		(*(volatile U32 *)(0xFFFFF218)) // Output Status Register Read-only 0x00000000
N#define rPIOA_IFER		(*(volatile U32 *)(0xFFFFF220)) // Glitch Input Filter Enable Register Write-only
N#define rPIOA_IFDR		(*(volatile U32 *)(0xFFFFF224)) // Glitch Input Filter Disable Register Write-only
N#define rPIOA_IFSR		(*(volatile U32 *)(0xFFFFF228)) // Glitch Input Filter Status Register Read-only 0x00000000
N#define rPIOA_SODR		(*(volatile U32 *)(0xFFFFF230)) // Set Output Data Register Write-only
N#define rPIOA_CODR		(*(volatile U32 *)(0xFFFFF234)) // Clear Output Data Register Write-only
N#define rPIOA_ODSR		(*(volatile U32 *)(0xFFFFF238)) // Output Data Status Register 
N#define rPIOA_PDSR		(*(volatile U32 *)(0xFFFFF23C)) // Pin Data Status Register Read-only
N#define rPIOA_IER		(*(volatile U32 *)(0xFFFFF240)) // Interrupt Enable Register Write-only
N#define rPIOA_IDR		(*(volatile U32 *)(0xFFFFF244)) // Interrupt Disable Register Write-only
N#define rPIOA_IMR		(*(volatile U32 *)(0xFFFFF248)) // Interrupt Mask Register  Read-only 0x00000000
N#define rPIOA_ISR		(*(volatile U32 *)(0xFFFFF24C)) // Interrupt Status Register Read-only 0x00000000
N#define rPIOA_MDER		(*(volatile U32 *)(0xFFFFF250)) // Multi-driver Enable Register Write-only
N#define rPIOA_MDDR		(*(volatile U32 *)(0xFFFFF254)) // Multi-driver Disable Register Write-only
N#define rPIOA_MDSR		(*(volatile U32 *)(0xFFFFF258)) // Multi-driver Status Register Read-only 0x00000000
N#define rPIOA_PUDR		(*(volatile U32 *)(0xFFFFF260)) // Pull-up Disable Register Write-only
N#define rPIOA_PUER		(*(volatile U32 *)(0xFFFFF264)) // Pull-up Enable Register Write-only
N#define rPIOA_PUSR		(*(volatile U32 *)(0xFFFFF268)) // Pad Pull-up Status Register Read-only 0x00000000
N#define rPIOA_ASR		(*(volatile U32 *)(0xFFFFF270)) // Peripheral A Select Register Write-only
N#define rPIOA_BSR		(*(volatile U32 *)(0xFFFFF274)) // Peripheral B Select Register Write-only
N#define rPIOA_ABSR		(*(volatile U32 *)(0xFFFFF278)) // AB Status Register Read-only 0x00000000
N#define rPIOA_OWER		(*(volatile U32 *)(0xFFFFF2A0)) // Output Write Enable Write-only
N#define rPIOA_OWDR		(*(volatile U32 *)(0xFFFFF2A4)) // Output Write Disable Write-only
N#define rPIOA_OWSR		(*(volatile U32 *)(0xFFFFF2A8)) // Output Write Status Register Read-only 0x00000000
N#define rPIOA_DELAYR0	(*(volatile U32 *)(0xFFFFF2C0)) // I/O Delay Register 0 Read/Write 0x00000000
N#define rPIOA_DELAYR1	(*(volatile U32 *)(0xFFFFF2C4)) // I/O Delay Register 1 Read/Write 0x00000000
N#define rPIOA_DELAYR2	(*(volatile U32 *)(0xFFFFF2C8)) // I/O Delay Register 2 Read/Write 0x00000000
N#define rPIOA_DELAYR3	(*(volatile U32 *)(0xFFFFF2CC)) // I/O Delay Register 3 Read/Write 0x00000000
N#define rPIOA_WPMR		(*(volatile U32 *)(0xFFFFF2E4)) // Write Protect Mode Register  Read-write 0x00000000
N#define rPIOA_WPSR		(*(volatile U32 *)(0xFFFFF2E8)) // Write Protect Status Register 
N
N#define rPIOB_PER		(*(volatile U32 *)(0xFFFFF400)) // PIO Enable Register Write-only
N#define rPIOB_PDR		(*(volatile U32 *)(0xFFFFF404)) // PIO Disable Register Write-only
N#define rPIOB_PSR		(*(volatile U32 *)(0xFFFFF408)) // PIO Status Register Read-only
N#define rPIOB_OER		(*(volatile U32 *)(0xFFFFF410)) // Output Enable Register Write-only
N#define rPIOB_ODR		(*(volatile U32 *)(0xFFFFF414)) // Output Disable Register Write-only
N#define rPIOB_OSR		(*(volatile U32 *)(0xFFFFF418)) // Output Status Register Read-only 0x00000000
N#define rPIOB_IFER		(*(volatile U32 *)(0xFFFFF420)) // Glitch Input Filter Enable Register Write-only
N#define rPIOB_IFDR		(*(volatile U32 *)(0xFFFFF424)) // Glitch Input Filter Disable Register Write-only
N#define rPIOB_IFSR		(*(volatile U32 *)(0xFFFFF428)) // Glitch Input Filter Status Register Read-only 0x00000000
N#define rPIOB_SODR		(*(volatile U32 *)(0xFFFFF430)) // Set Output Data Register Write-only
N#define rPIOB_CODR		(*(volatile U32 *)(0xFFFFF434)) // Clear Output Data Register Write-only
N#define rPIOB_ODSR		(*(volatile U32 *)(0xFFFFF438)) // Output Data Status Register 
N#define rPIOB_PDSR		(*(volatile U32 *)(0xFFFFF43C)) // Pin Data Status Register Read-only
N#define rPIOB_IER		(*(volatile U32 *)(0xFFFFF440)) // Interrupt Enable Register Write-only
N#define rPIOB_IDR		(*(volatile U32 *)(0xFFFFF444)) // Interrupt Disable Register Write-only
N#define rPIOB_IMR		(*(volatile U32 *)(0xFFFFF448)) // Interrupt Mask Register  Read-only 0x00000000
N#define rPIOB_ISR		(*(volatile U32 *)(0xFFFFF44C)) // Interrupt Status Register Read-only 0x00000000
N#define rPIOB_MDER		(*(volatile U32 *)(0xFFFFF450)) // Multi-driver Enable Register Write-only
N#define rPIOB_MDDR		(*(volatile U32 *)(0xFFFFF454)) // Multi-driver Disable Register Write-only
N#define rPIOB_MDSR		(*(volatile U32 *)(0xFFFFF458)) // Multi-driver Status Register Read-only 0x00000000
N#define rPIOB_PUDR		(*(volatile U32 *)(0xFFFFF460)) // Pull-up Disable Register Write-only
N#define rPIOB_PUER		(*(volatile U32 *)(0xFFFFF464)) // Pull-up Enable Register Write-only
N#define rPIOB_PUSR		(*(volatile U32 *)(0xFFFFF468)) // Pad Pull-up Status Register Read-only 0x00000000
N#define rPIOB_ASR		(*(volatile U32 *)(0xFFFFF470)) // Peripheral A Select Register Write-only
N#define rPIOB_BSR		(*(volatile U32 *)(0xFFFFF474)) // Peripheral B Select Register Write-only
N#define rPIOB_ABSR		(*(volatile U32 *)(0xFFFFF478)) // AB Status Register Read-only 0x00000000
N#define rPIOB_OWER		(*(volatile U32 *)(0xFFFFF4A0)) // Output Write Enable Write-only
N#define rPIOB_OWDR		(*(volatile U32 *)(0xFFFFF4A4)) // Output Write Disable Write-only
N#define rPIOB_OWSR		(*(volatile U32 *)(0xFFFFF4A8)) // Output Write Status Register Read-only 0x00000000
N#define rPIOB_DELAYR0	(*(volatile U32 *)(0xFFFFF4C0)) // I/O Delay Register 0 Read/Write 0x00000000
N#define rPIOB_DELAYR1	(*(volatile U32 *)(0xFFFFF4C4)) // I/O Delay Register 1 Read/Write 0x00000000
N#define rPIOB_DELAYR2	(*(volatile U32 *)(0xFFFFF4C8)) // I/O Delay Register 2 Read/Write 0x00000000
N#define rPIOB_DELAYR3	(*(volatile U32 *)(0xFFFFF4CC)) // I/O Delay Register 3 Read/Write 0x00000000
N#define rPIOB_WPMR		(*(volatile U32 *)(0xFFFFF4E4)) // Write Protect Mode Register  Read-write 0x00000000
N#define rPIOB_WPSR		(*(volatile U32 *)(0xFFFFF4E8)) // Write Protect Status Register 
N
N#define rPIOC_PER		(*(volatile U32 *)(0xFFFFF600)) // PIO Enable Register Write-only
N#define rPIOC_PDR		(*(volatile U32 *)(0xFFFFF604)) // PIO Disable Register Write-only
N#define rPIOC_PSR		(*(volatile U32 *)(0xFFFFF608)) // PIO Status Register Read-only
N#define rPIOC_OER		(*(volatile U32 *)(0xFFFFF610)) // Output Enable Register Write-only
N#define rPIOC_ODR		(*(volatile U32 *)(0xFFFFF614)) // Output Disable Register Write-only
N#define rPIOC_OSR		(*(volatile U32 *)(0xFFFFF618)) // Output Status Register Read-only 0x00000000
N#define rPIOC_IFER		(*(volatile U32 *)(0xFFFFF620)) // Glitch Input Filter Enable Register Write-only
N#define rPIOC_IFDR		(*(volatile U32 *)(0xFFFFF624)) // Glitch Input Filter Disable Register Write-only
N#define rPIOC_IFSR		(*(volatile U32 *)(0xFFFFF628)) // Glitch Input Filter Status Register Read-only 0x00000000
N#define rPIOC_SODR		(*(volatile U32 *)(0xFFFFF630)) // Set Output Data Register Write-only
N#define rPIOC_CODR		(*(volatile U32 *)(0xFFFFF634)) // Clear Output Data Register Write-only
N#define rPIOC_ODSR		(*(volatile U32 *)(0xFFFFF638)) // Output Data Status Register 
N#define rPIOC_PDSR		(*(volatile U32 *)(0xFFFFF63C)) // Pin Data Status Register Read-only
N#define rPIOC_IER		(*(volatile U32 *)(0xFFFFF640)) // Interrupt Enable Register Write-only
N#define rPIOC_IDR		(*(volatile U32 *)(0xFFFFF644)) // Interrupt Disable Register Write-only
N#define rPIOC_IMR		(*(volatile U32 *)(0xFFFFF648)) // Interrupt Mask Register  Read-only 0x00000000
N#define rPIOC_ISR		(*(volatile U32 *)(0xFFFFF64C)) // Interrupt Status Register Read-only 0x00000000
N#define rPIOC_MDER		(*(volatile U32 *)(0xFFFFF650)) // Multi-driver Enable Register Write-only
N#define rPIOC_MDDR		(*(volatile U32 *)(0xFFFFF654)) // Multi-driver Disable Register Write-only
N#define rPIOC_MDSR		(*(volatile U32 *)(0xFFFFF658)) // Multi-driver Status Register Read-only 0x00000000
N#define rPIOC_PUDR		(*(volatile U32 *)(0xFFFFF660)) // Pull-up Disable Register Write-only
N#define rPIOC_PUER		(*(volatile U32 *)(0xFFFFF664)) // Pull-up Enable Register Write-only
N#define rPIOC_PUSR		(*(volatile U32 *)(0xFFFFF668)) // Pad Pull-up Status Register Read-only 0x00000000
N#define rPIOC_ASR		(*(volatile U32 *)(0xFFFFF670)) // Peripheral A Select Register Write-only
N#define rPIOC_BSR		(*(volatile U32 *)(0xFFFFF674)) // Peripheral B Select Register Write-only
N#define rPIOC_ABSR		(*(volatile U32 *)(0xFFFFF678)) // AB Status Register Read-only 0x00000000
N#define rPIOC_OWER		(*(volatile U32 *)(0xFFFFF6A0)) // Output Write Enable Write-only
N#define rPIOC_OWDR		(*(volatile U32 *)(0xFFFFF6A4)) // Output Write Disable Write-only
N#define rPIOC_OWSR		(*(volatile U32 *)(0xFFFFF6A8)) // Output Write Status Register Read-only 0x00000000
N#define rPIOC_DELAYR0	(*(volatile U32 *)(0xFFFFF6C0)) // I/O Delay Register 0 Read/Write 0x00000000
N#define rPIOC_DELAYR1	(*(volatile U32 *)(0xFFFFF6C4)) // I/O Delay Register 1 Read/Write 0x00000000
N#define rPIOC_DELAYR2	(*(volatile U32 *)(0xFFFFF6C8)) // I/O Delay Register 2 Read/Write 0x00000000
N#define rPIOC_DELAYR3	(*(volatile U32 *)(0xFFFFF6CC)) // I/O Delay Register 3 Read/Write 0x00000000
N#define rPIOC_WPMR		(*(volatile U32 *)(0xFFFFF6E4)) // Write Protect Mode Register  Read-write 0x00000000
N#define rPIOC_WPSR		(*(volatile U32 *)(0xFFFFF6E8)) // Write Protect Status Register 
N
N#define rPIOD_PER		(*(volatile U32 *)(0xFFFFF800)) // PIO Enable Register Write-only
N#define rPIOD_PDR		(*(volatile U32 *)(0xFFFFF804)) // PIO Disable Register Write-only
N#define rPIOD_PSR		(*(volatile U32 *)(0xFFFFF808)) // PIO Status Register Read-only
N#define rPIOD_OER		(*(volatile U32 *)(0xFFFFF810)) // Output Enable Register Write-only
N#define rPIOD_ODR		(*(volatile U32 *)(0xFFFFF814)) // Output Disable Register Write-only
N#define rPIOD_OSR		(*(volatile U32 *)(0xFFFFF818)) // Output Status Register Read-only 0x00000000
N#define rPIOD_IFER		(*(volatile U32 *)(0xFFFFF820)) // Glitch Input Filter Enable Register Write-only
N#define rPIOD_IFDR		(*(volatile U32 *)(0xFFFFF824)) // Glitch Input Filter Disable Register Write-only
N#define rPIOD_IFSR		(*(volatile U32 *)(0xFFFFF828)) // Glitch Input Filter Status Register Read-only 0x00000000
N#define rPIOD_SODR		(*(volatile U32 *)(0xFFFFF830)) // Set Output Data Register Write-only
N#define rPIOD_CODR		(*(volatile U32 *)(0xFFFFF834)) // Clear Output Data Register Write-only
N#define rPIOD_ODSR		(*(volatile U32 *)(0xFFFFF838)) // Output Data Status Register 
N#define rPIOD_PDSR		(*(volatile U32 *)(0xFFFFF83C)) // Pin Data Status Register Read-only
N#define rPIOD_IER		(*(volatile U32 *)(0xFFFFF840)) // Interrupt Enable Register Write-only
N#define rPIOD_IDR		(*(volatile U32 *)(0xFFFFF844)) // Interrupt Disable Register Write-only
N#define rPIOD_IMR		(*(volatile U32 *)(0xFFFFF848)) // Interrupt Mask Register  Read-only 0x00000000
N#define rPIOD_ISR		(*(volatile U32 *)(0xFFFFF84C)) // Interrupt Status Register Read-only 0x00000000
N#define rPIOD_MDER		(*(volatile U32 *)(0xFFFFF850)) // Multi-driver Enable Register Write-only
N#define rPIOD_MDDR		(*(volatile U32 *)(0xFFFFF854)) // Multi-driver Disable Register Write-only
N#define rPIOD_MDSR		(*(volatile U32 *)(0xFFFFF858)) // Multi-driver Status Register Read-only 0x00000000
N#define rPIOD_PUDR		(*(volatile U32 *)(0xFFFFF860)) // Pull-up Disable Register Write-only
N#define rPIOD_PUER		(*(volatile U32 *)(0xFFFFF864)) // Pull-up Enable Register Write-only
N#define rPIOD_PUSR		(*(volatile U32 *)(0xFFFFF868)) // Pad Pull-up Status Register Read-only 0x00000000
N#define rPIOD_ASR		(*(volatile U32 *)(0xFFFFF870)) // Peripheral A Select Register Write-only
N#define rPIOD_BSR		(*(volatile U32 *)(0xFFFFF874)) // Peripheral B Select Register Write-only
N#define rPIOD_ABSR		(*(volatile U32 *)(0xFFFFF878)) // AB Status Register Read-only 0x00000000
N#define rPIOD_OWER		(*(volatile U32 *)(0xFFFFF8A0)) // Output Write Enable Write-only
N#define rPIOD_OWDR		(*(volatile U32 *)(0xFFFFF8A4)) // Output Write Disable Write-only
N#define rPIOD_OWSR		(*(volatile U32 *)(0xFFFFF8A8)) // Output Write Status Register Read-only 0x00000000
N#define rPIOD_DELAYR0	(*(volatile U32 *)(0xFFFFF8C0)) // I/O Delay Register 0 Read/Write 0x00000000
N#define rPIOD_DELAYR1	(*(volatile U32 *)(0xFFFFF8C4)) // I/O Delay Register 1 Read/Write 0x00000000
N#define rPIOD_DELAYR2	(*(volatile U32 *)(0xFFFFF8C8)) // I/O Delay Register 2 Read/Write 0x00000000
N#define rPIOD_DELAYR3	(*(volatile U32 *)(0xFFFFF8CC)) // I/O Delay Register 3 Read/Write 0x00000000
N#define rPIOD_WPMR		(*(volatile U32 *)(0xFFFFF8E4)) // Write Protect Mode Register  Read-write 0x00000000
N#define rPIOD_WPSR		(*(volatile U32 *)(0xFFFFF8E8)) // Write Protect Status Register 
N
N#define rPIOE_PER		(*(volatile U32 *)(0xFFFFFA00)) // PIO Enable Register Write-only
N#define rPIOE_PDR		(*(volatile U32 *)(0xFFFFFA04)) // PIO Disable Register Write-only
N#define rPIOE_PSR		(*(volatile U32 *)(0xFFFFFA08)) // PIO Status Register Read-only
N#define rPIOE_OER		(*(volatile U32 *)(0xFFFFFA10)) // Output Enable Register Write-only
N#define rPIOE_ODR		(*(volatile U32 *)(0xFFFFFA14)) // Output Disable Register Write-only
N#define rPIOE_OSR		(*(volatile U32 *)(0xFFFFFA18)) // Output Status Register Read-only 0x00000000
N#define rPIOE_IFER		(*(volatile U32 *)(0xFFFFFA20)) // Glitch Input Filter Enable Register Write-only
N#define rPIOE_IFDR		(*(volatile U32 *)(0xFFFFFA24)) // Glitch Input Filter Disable Register Write-only
N#define rPIOE_IFSR		(*(volatile U32 *)(0xFFFFFA28)) // Glitch Input Filter Status Register Read-only 0x00000000
N#define rPIOE_SODR		(*(volatile U32 *)(0xFFFFFA30)) // Set Output Data Register Write-only
N#define rPIOE_CODR		(*(volatile U32 *)(0xFFFFFA34)) // Clear Output Data Register Write-only
N#define rPIOE_ODSR		(*(volatile U32 *)(0xFFFFFA38)) // Output Data Status Register 
N#define rPIOE_PDSR		(*(volatile U32 *)(0xFFFFFA3C)) // Pin Data Status Register Read-only
N#define rPIOE_IER		(*(volatile U32 *)(0xFFFFFA40)) // Interrupt Enable Register Write-only
N#define rPIOE_IDR		(*(volatile U32 *)(0xFFFFFA44)) // Interrupt Disable Register Write-only
N#define rPIOE_IMR		(*(volatile U32 *)(0xFFFFFA48)) // Interrupt Mask Register  Read-only 0x00000000
N#define rPIOE_ISR		(*(volatile U32 *)(0xFFFFFA4C)) // Interrupt Status Register Read-only 0x00000000
N#define rPIOE_MDER		(*(volatile U32 *)(0xFFFFFA50)) // Multi-driver Enable Register Write-only
N#define rPIOE_MDDR		(*(volatile U32 *)(0xFFFFFA54)) // Multi-driver Disable Register Write-only
N#define rPIOE_MDSR		(*(volatile U32 *)(0xFFFFFA58)) // Multi-driver Status Register Read-only 0x00000000
N#define rPIOE_PUDR		(*(volatile U32 *)(0xFFFFFA60)) // Pull-up Disable Register Write-only
N#define rPIOE_PUER		(*(volatile U32 *)(0xFFFFFA64)) // Pull-up Enable Register Write-only
N#define rPIOE_PUSR		(*(volatile U32 *)(0xFFFFFA68)) // Pad Pull-up Status Register Read-only 0x00000000
N#define rPIOE_ASR		(*(volatile U32 *)(0xFFFFFA70)) // Peripheral A Select Register Write-only
N#define rPIOE_BSR		(*(volatile U32 *)(0xFFFFFA74)) // Peripheral B Select Register Write-only
N#define rPIOE_ABSR		(*(volatile U32 *)(0xFFFFFA78)) // AB Status Register Read-only 0x00000000
N#define rPIOE_OWER		(*(volatile U32 *)(0xFFFFFAA0)) // Output Write Enable Write-only
N#define rPIOE_OWDR		(*(volatile U32 *)(0xFFFFFAA4)) // Output Write Disable Write-only
N#define rPIOE_OWSR		(*(volatile U32 *)(0xFFFFFAA8)) // Output Write Status Register Read-only 0x00000000
N#define rPIOE_DELAYR0	(*(volatile U32 *)(0xFFFFFAC0)) // I/O Delay Register 0 Read/Write 0x00000000
N#define rPIOE_DELAYR1	(*(volatile U32 *)(0xFFFFFAC4)) // I/O Delay Register 1 Read/Write 0x00000000
N#define rPIOE_DELAYR2	(*(volatile U32 *)(0xFFFFFAC8)) // I/O Delay Register 2 Read/Write 0x00000000
N#define rPIOE_DELAYR3	(*(volatile U32 *)(0xFFFFFACC)) // I/O Delay Register 3 Read/Write 0x00000000
N#define rPIOE_WPMR		(*(volatile U32 *)(0xFFFFFAE4)) // Write Protect Mode Register  Read-write 0x00000000
N#define rPIOE_WPSR		(*(volatile U32 *)(0xFFFFFAE8)) // Write Protect Status Register 
N
N#define rDDRSDRC_MR		(*(volatile U32 *)(0xFFFFE600)) // DDRSDRC Mode Register Read-write 0x00000000
N#define rDDRSDRC_RTR	(*(volatile U32 *)(0xFFFFE604)) // DDRSDRC Refresh Timer Register  Read-write 0x00000000
N#define rDDRSDRC_CR		(*(volatile U32 *)(0xFFFFE608)) // DDRSDRC Configuration Register  Read-write 0x7024
N#define rDDRSDRC_TPR0	(*(volatile U32 *)(0xFFFFE60C)) // DDRSDRC Timing Parameter 0 Register Read-write 0x20227225
N#define rDDRSDRC_TPR1	(*(volatile U32 *)(0xFFFFE610)) // DDRSDRC Timing Parameter 1 Register Read-write 0x3c80808
N#define rDDRSDRC_TPR2	(*(volatile U32 *)(0xFFFFE614)) // DDRSDRC Timing Parameter 2 Register Read-write 0x2062
N#define rDDRSDRC_LPR	(*(volatile U32 *)(0xFFFFE61C)) // DDRSDRC Low-power Register Read-write 0x10000
N#define rDDRSDRC_MD		(*(volatile U32 *)(0xFFFFE620)) // DDRSDRC Memory Device Register Read-write 0x10
N#define rDDRSDRC_DLL	(*(volatile U32 *)(0xFFFFE624)) // DDRSDRC DLL Information Register Read-only 0x00000001
N#define rDDRSDRC_HS		(*(volatile U32 *)(0xFFFFE62C)) // DDRSDRC High Speed Register Read-write 0x0
N#define rDDRSDRC_DELAY1	(*(volatile U32 *)(0xFFFFE640)) // DDRSDRC Delay I/O Register Read-write 0x00000000
N#define rDDRSDRC_DELAY2	(*(volatile U32 *)(0xFFFFE644)) // DDRSDRC Delay I/O Register Read-write 0x00000000
N#define rDDRSDRC_DELAY3	(*(volatile U32 *)(0xFFFFE648)) // DDRSDRC Delay I/O Register Read-write 0x00000000
N#define rDDRSDRC_DELAY4	(*(volatile U32 *)(0xFFFFE64C)) // DDRSDRC Delay I/O Register Read-write 0x00000000
N#define rDDRSDRC_WPMR	(*(volatile U32 *)(0xFFFFE6E4)) // DDRSDRC Write Protect Mode Register Read-write 0x00000000
N#define rDDRSDRC_WPSR	(*(volatile U32 *)(0xFFFFE6E8)) // DDRSDRC Write Protect Status Register
N#define rDDRSD_BASE0	(*(volatile U32 *)(0x70000000)) // DDRSDRC Write Protect Status Register
N#define rDDRSD_BASE1	(*(volatile U32 *)(0x72000000)) // DDRSDRC Write Protect Status Register
N#define rDDRSD_BASE2	(*(volatile U32 *)(0x74000000)) // DDRSDRC Write Protect Status Register
N#define rDDRSD_BASE3	(*(volatile U32 *)(0x76000000)) // DDRSDRC Write Protect Status Register
N
N#define rDBGU_CR		(*(volatile U32 *)(0xFFFFEE00)) // Control Register Write-only
N#define rDBGU_MR		(*(volatile U32 *)(0xFFFFEE04)) // Mode Register Read-write 0x0
N#define rDBGU_IER		(*(volatile U32 *)(0xFFFFEE08)) // Interrupt Enable Register Write-only
N#define rDBGU_IDR		(*(volatile U32 *)(0xFFFFEE0C)) // Interrupt Disable Register Write-only
N#define rDBGU_IMR		(*(volatile U32 *)(0xFFFFEE10)) // Interrupt Mask Register Read-only 0x0
N#define rDBGU_SR		(*(volatile U32 *)(0xFFFFEE14)) // Status Register Read-only
N#define rDBGU_RHR		(*(volatile U32 *)(0xFFFFEE18)) // Receive Holding Register Read-only 0x0
N#define rDBGU_THR		(*(volatile U32 *)(0xFFFFEE1C)) // Transmit Holding Register Write-only
N#define rDBGU_BRGR		(*(volatile U32 *)(0xFFFFEE20)) // Baud Rate Generator Register Read-write 0x0
N#define rDBGU_CIDR		(*(volatile U32 *)(0xFFFFEE40)) // Chip ID Register Read-only
N#define rDBGU_EXID		(*(volatile U32 *)(0xFFFFEE44)) // Chip ID Extension Register  Read-only
N#define rDBGU_FNR		(*(volatile U32 *)(0xFFFFEE48)) // Force NTRST Register Read-write 0x0
N#define rDBGU_RPR		(*(volatile U32 *)(0xFFFFEF00)) // Receive Pointer Register
N#define rDBGU_RCR		(*(volatile U32 *)(0xFFFFEF04)) // Receive Counter Register
N#define rDBGU_TPR		(*(volatile U32 *)(0xFFFFEF08)) // Transmit Pointer Register
N#define rDBGU_TCR		(*(volatile U32 *)(0xFFFFEF0C)) // Transmit Counter Register
N#define rDBGU_RNPR		(*(volatile U32 *)(0xFFFFEF10)) // Receive Next Pointer Register
N#define rDBGU_RNCR		(*(volatile U32 *)(0xFFFFEF14)) // Receive Next Counter Register
N#define rDBGU_TNPR		(*(volatile U32 *)(0xFFFFEF18)) // Transmit Next Pointer Register
N#define rDBGU_TNCR		(*(volatile U32 *)(0xFFFFEF1C)) // Transmit Next Counter Register
N#define rDBGU_PTCR		(*(volatile U32 *)(0xFFFFEF20)) // PDC Transfer Control Register
N#define rDBGU_PTSR		(*(volatile U32 *)(0xFFFFEF24))	// PDC Transfer Status Register
N
N#define rUS_CR(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0000))
N#define rUS_MR(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0004))
N#define rUS_IER(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0008))
N#define rUS_IDR(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x000C))
N#define rUS_IMR(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0010))
N#define rUS_CSR(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0014))
N#define rUS_RHR(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0018))
N#define rUS_THR(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x001C))
N#define rUS_BRGR(ch)	(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0020))
N#define rUS_RTOR(ch)	(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0024))
N#define rUS_TTGR(ch)	(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0028))
N#define rUS_FIDI(ch)	(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0040))
N#define rUS_NER(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0044))
N#define rUS_IF(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x004C))
N#define rUS_MAN(ch)		(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0050))
N#define rUS_LINMR(ch)	(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0054))
N#define rUS_LINIR(ch)	(*(volatile U32 *)(0xFFF8C000+ch*0x4000+0x0058))
N
N#define rSPI_CR(ch)		(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x00)) // Control Register  Write-only ---
N#define rSPI_MR(ch)		(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x04)) // Mode Register  Read-write 0x0
N#define rSPI_RDR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x08)) // Receive Data Register  Read-only 0x0
N#define rSPI_TDR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x0C)) // Transmit Data Register  Write-only ---
N#define rSPI_SR(ch)		(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x10)) // Status Register  Read-only 
N#define rSPI_IER(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x14)) // Interrupt Enable Register  Write-only ---
N#define rSPI_IDR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x18)) // Interrupt Disable Register  Write-only ---
N#define rSPI_IMR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x1C)) // Interrupt Mask Register  Read-only 0x0
N#define rSPI_CSR0(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x30)) // Chip Select Register 0  Read-write 0x0
N#define rSPI_RPR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x100)) // Receive Pointer Register
N#define rSPI_RCR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x104)) // Receive Counter Register
N#define rSPI_TPR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x108)) // Transmit Pointer Register
N#define rSPI_TCR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x10C)) // Transmit Counter Register
N#define rSPI_RNPR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x110)) // Receive Next Pointer Register
N#define rSPI_RNCR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x114)) // Receive Next Counter Register
N#define rSPI_TNPR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x118)) // Transmit Next Pointer Register
N#define rSPI_TNCR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x11C)) // Transmit Next Counter Register
N#define rSPI_PTCR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x120)) // PDC Transfer Control Register
N#define rSPI_PTSR(ch)	(*(volatile U32 *)(0xFFFA4000+ch*0x4000+0x124))	// PDC Transfer Status Register
N
N#define rHSMCI_CR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x00)) // Control Register 
N#define rHSMCI_MR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x04)) // Mode Register Read-write 0x0
N#define rHSMCI_DTOR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x08)) // Data Timeout Register Read-write 0x0
N#define rHSMCI_SDCR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x0C)) // SD/SDIO Card Register Read-write 0x0
N#define rHSMCI_ARGR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x10)) // Argument Register  Read-write 0x0
N#define rHSMCI_CMDR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x14)) // Command Register  Write
N#define rHSMCI_BLKR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x18)) // Block Register  Read-write 0x0
N#define rHSMCI_CSTOR(ch)	(*(volatile U32 *)(0xFFF80000+ch*50000+0x1C)) // Completion Signal Timeout Register  Read-write 0x0
N#define rHSMCI_RSPR0(ch)	(*(volatile U32 *)(0xFFF80000+ch*50000+0x20)) // Response Register Read 0x0
N#define rHSMCI_RSPR1(ch)	(*(volatile U32 *)(0xFFF80000+ch*50000+0x24)) // Response Register Read 0x0
N#define rHSMCI_RSPR2(ch)	(*(volatile U32 *)(0xFFF80000+ch*50000+0x28)) // Response Register Read 0x0
N#define rHSMCI_RSPR3(ch)	(*(volatile U32 *)(0xFFF80000+ch*50000+0x2C)) // Response Register Read 0x0
N#define rHSMCI_RDR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x30)) // Receive Data Register Read 0x0
N#define rHSMCI_TDR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x34)) // Transmit Data Register Write
N#define rHSMCI_SR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x40)) // Status Register Read 0xC0E5
N#define rHSMCI_IER(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x44)) // Interrupt Enable Register Write
N#define rHSMCI_IDR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x48)) // Interrupt Disable Register Write
N#define rHSMCI_IMR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x4C)) // Interrupt Mask Register Read 0x0
N#define rHSMCI_DMA(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x50)) // DMA Configuration Register Read-write 0x00
N#define rHSMCI_CFG(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0x54)) // Configuration Register Read-write 0x00
N#define rHSMCI_WPMR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0xE4)) // Write Protection Mode Register Read-write
N#define rHSMCI_WPSR(ch)		(*(volatile U32 *)(0xFFF80000+ch*50000+0xE8)) // Write Protection Status Register Read-only
N#define HSMCI_FIFO(ch)		(0xFFF80000+ch*50000+0x200) // FIFO Memory Aperture 0x200-0x3FFC
N
N#define rPWM_MR 		(*(volatile U32 *)(0xFFFB8000))
N#define rPWM_ENA		(*(volatile U32 *)(0xFFFB8000+0x04))
N#define rPWM_DIS		(*(volatile U32 *)(0xFFFB8000+0x08))
N#define rPWM_SR			(*(volatile U32 *)(0xFFFB8000+0x0C))
N#define rPWM_IER		(*(volatile U32 *)(0xFFFB8000+0x10))
N#define rPWM_IDR		(*(volatile U32 *)(0xFFFB8000+0x14))
N#define rPWM_IMR		(*(volatile U32 *)(0xFFFB8000+0x18))
N#define rPWM_ISR		(*(volatile U32 *)(0xFFFB8000+0x1C))
N#define rPWM_CMR(ch)	(*(volatile U32 *)(0xFFFB8000+0x200+ch*0x20+0x00))
N#define rPWM_CDTY(ch)	(*(volatile U32 *)(0xFFFB8000+0x200+ch*0x20+0x04))
N#define rPWM_CPRD(ch)	(*(volatile U32 *)(0xFFFB8000+0x200+ch*0x20+0x08))
N#define rPWM_CCNT(ch)	(*(volatile U32 *)(0xFFFB8000+0x200+ch*0x20+0x0C))
N#define rPWM_CUPD(ch)	(*(volatile U32 *)(0xFFFB8000+0x200+ch*0x20+0x10))
N
N#endif /*__SOC_H__*/
N
L 14 "bootx.c" 2
N#include "init_hw.h"
L 1 "init_hw.h" 1
N#ifndef __INIT_HW_H__
N#define __INIT_HW_H__
N
N#define PERIF_ID_FIQ    ( 0) // Advanced Interrupt Controller (FIQ)
N#define PERIF_ID_SYS    ( 1) // System Controller
N#define PERIF_ID_PIOA   ( 2) // Parallel IO Controller A
N#define PERIF_ID_PIOB   ( 3) // Parallel IO Controller B
N#define PERIF_ID_PIOC   ( 4) // Parallel IO Controller C
N#define PERIF_ID_PIOD_E ( 5) // Parallel IO Controller D and E
N#define PERIF_ID_TRNG   ( 6) // True Random Number Generator
N#define PERIF_ID_US0    ( 7) // USART 0
N#define PERIF_ID_US1    ( 8) // USART 1
N#define PERIF_ID_US2    ( 9) // USART 2
N#define PERIF_ID_US3    (10) // USART 2
N#define PERIF_ID_MCI0   (11) // Multimedia Card Interface 0
N#define PERIF_ID_TWI0   (12) // TWI 0
N#define PERIF_ID_TWI1   (13) // TWI 1
N#define PERIF_ID_SPI0   (14) // Serial Peripheral Interface
N#define PERIF_ID_SPI1   (15) // Serial Peripheral Interface
N#define PERIF_ID_SSC0   (16) // Serial Synchronous Controller 0
N#define PERIF_ID_SSC1   (17) // Serial Synchronous Controller 1
N#define PERIF_ID_TC     (18) // Timer Counter 0, 1, 2, 3, 4, 5
N#define PERIF_ID_PWMC   (19) // Pulse Width Modulation Controller
N#define PERIF_ID_TSADC  (20) // Touch Screen Controller
N#define PERIF_ID_HDMA   (21) // HDMA
N#define PERIF_ID_UHPHS  (22) // USB Host High Speed
N#define PERIF_ID_LCDC   (23) // LCD Controller
N#define PERIF_ID_AC97C  (24) // AC97 Controller
N#define PERIF_ID_EMAC   (25) // Ethernet MAC
N#define PERIF_ID_ISI    (26) // Image Sensor Interface
N#define PERIF_ID_UDPHS  (27) // USB Device HS
N
N#define PERIF_ID_MCI1   (29) // Multimedia Card Interface 1
N#define PERIF_ID_VDEC   (30) // Video Decoder
N#define PERIF_ID_IRQ0   (31) // Advanced Interrupt Controller (IRQ0)
N
Nvoid InitHW(void);
N
N#endif /* __INIT_HW_H__ */
L 15 "bootx.c" 2
N#include "system.h"
L 1 "system.h" 1
N/*
N *------------------------------------------------------------------------------
N *
N *------------------------------------------------------------------------------
N */
N
N#ifndef __SYSTEM_H__
N#define __SYSTEM_H__
N
N//------------------------------------------------------------------------------
N//         Global definitions
N//------------------------------------------------------------------------------
N/// DMA driver is currently busy.
N#define DMAD_ERROR_BUSY              1
N/// Using the default interrupt handler of the DMAD
N#define DMAD_USE_DEFAULT_IT          1
N#define DMAD_NO_DEFAULT_IT           0
N
N//------------------------------------------------------------------------------
N//         Types
N//------------------------------------------------------------------------------
N
N/// DMA driver callback function.
Ntypedef void (*DmaCallback)();
N
N//------------------------------------------------------------------------------
N/// DMA multi buffer transfer Linker List Item structure.
N//------------------------------------------------------------------------------
Ntypedef struct _DmaLinkList {
N    /// Source address.
N    U32 sourceAddress;
N    /// Destination address.
N    U32 destAddress;
N    /// Control A value.
N    U32 controlA;
N    /// Control B value.
N    U32 controlB;
N    /// Descriptor Address.
N    U32 descriptor;
N} DmaLinkList;
N
N//------------------------------------------------------------------------------
N/// DMA picture-in-picture mode configuration structure. 
N//------------------------------------------------------------------------------
Ntypedef struct _PictureInPicture {
N    /// Size in byte add to the source address in PIP.
N    U16 pipSourceHoleSize;
N    /// Number of transfer in byte to perform before the source address increase.
N    U16 pipSourceBoundarySize;
N    /// Size in byte add to the destination address in PIP.
N    U16 pipDestHoleSize;
N    /// Number of transfer in byte to perform before the destination address increase.
N    U16 pipDestBoundarySize;
N} PictureInPicture;
N
N
N//------------------------------------------------------------------------------
N//         Global functions
N//------------------------------------------------------------------------------
Nvoid DMAD_Initialize(U8 channel, U8 defaultHandler);
NU8 DMAD_Configure_Buffer(U8 channel, U8 sourceTransferMode, U8 destTransferMode, DmaLinkList *lli, PictureInPicture *pip);
NU8 DMAD_Configure_TransferController(U8 channel, U32 bufSize, U8 sourceWidth, U8 destWidth, U32 sourceAddress, U32 destAddress);                
NU8 DMAD_BufferTransfer(U8 channel, U32 size, DmaCallback callback, U8 polling);
NU8 DMAD_IsFinished(U8 channel);
N
Nvoid PMC_PeriEn(U32 id);
Nvoid PMC_PeriDis(U32 id);
Nvoid IRQ_PeriConf(U32 id, U32 mode, void( *handler )( void ));
Nvoid IRQ_PeriEn(U32 id);
Nvoid IRQ_PeriDis(U32 id);
N
Nvoid ResetOut(BOOL reset);
Nvoid SFR_WR32(U32 ioaddr, U32 data);
NU32 SFR_RD32(U32 ioaddr);
Nvoid SFR_WR16(U32 ioaddr, U16 data);
NU16 SFR_RD16(U32 ioaddr);
Nvoid SFR_WR8(U32 ioaddr, U8 data);
NU8 SFR_RD8(U32 ioaddr);
N
N#endif /* __SYSTEM_H__ */
L 16 "bootx.c" 2
N
N#include "bootx.h"
L 1 "bootx.h" 1
N/*
N *------------------------------------------------------------------------------
N *
N *------------------------------------------------------------------------------
N */
N
N#ifndef __BOOT_H__
N#define __BOOT_H__
N
Nvoid BootmSet_ParamAddr(U32 pm_addr);
Nvoid BootmSet_MachineID(U32 mach_id);
Nvoid TestBoot(void);
N
N#endif /* __BOOT_H__ */
L 18 "bootx.c" 2
N
Nvoid TestBoot(void)
N{
N	
N}
