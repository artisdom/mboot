L 1 "atmel\ff.c"
N/*----------------------------------------------------------------------------/
N/  FatFs - FAT file system module  R0.07e                    (C)ChaN, 2009
N/-----------------------------------------------------------------------------/
N/ FatFs module is a generic FAT file system module for small embedded systems.
N/ This is a free software that opened for education, research and commercial
N/ developments under license policy of following trems.
N/
N/  Copyright (C) 2009, ChaN, all right reserved.
N/
N/ * The FatFs module is a free software and there is NO WARRANTY.
N/ * No restriction on use. You can use, modify and redistribute it for
N/   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
N/ * Redistributions of source code must retain the above copyright notice.
N/
N/-----------------------------------------------------------------------------/
N/ Feb 26,'06 R0.00  Prototype.
N/
N/ Apr 29,'06 R0.01  First stable version.
N/
N/ Jun 01,'06 R0.02  Added FAT12 support.
N/                   Removed unbuffered mode.
N/                   Fixed a problem on small (<32M) patition.
N/ Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
N/
N/ Sep 22,'06 R0.03  Added f_rename().
N/                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
N/ Dec 11,'06 R0.03a Improved cluster scan algolithm to write files fast.
N/                   Fixed f_mkdir() creates incorrect directory on FAT32.
N/
N/ Feb 04,'07 R0.04  Supported multiple drive system.
N/                   Changed some interfaces for multiple drive system.
N/                   Changed f_mountdrv() to f_mount().
N/                   Added f_mkfs().
N/ Apr 01,'07 R0.04a Supported multiple partitions on a plysical drive.
N/                   Added a capability of extending file size to f_lseek().
N/                   Added minimization level 3.
N/                   Fixed an endian sensitive code in f_mkfs().
N/ May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
N/                   Added FSInfo support.
N/                   Fixed DBCS name can result FR_INVALID_NAME.
N/                   Fixed short seek (<= csize) collapses the file object.
N/
N/ Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
N/                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
N/                   Fixed f_mkdir() on FAT32 creates incorrect directory.
N/ Feb 03,'08 R0.05a Added f_truncate() and f_utime().
N/                   Fixed off by one error at FAT sub-type determination.
N/                   Fixed btr in f_read() can be mistruncated.
N/                   Fixed cached sector is not flushed when create and close
N/                   without write.
N/
N/ Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
N/                   Improved performance of f_lseek() on moving to the same
N/                   or following cluster.
N/
N/ Apr 01,'09 R0.07  Merged Tiny-FatFs as a buffer configuration option.
N/                   Added long file name support.
N/                   Added multiple code page support.
N/                   Added re-entrancy for multitask operation.
N/                   Added auto cluster size selection to f_mkfs().
N/                   Added rewind option to f_readdir().
N/                   Changed result code of critical errors.
N/                   Renamed string functions to avoid name collision.
N/ Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
N/                   Added multiple sector size support.
N/ Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
N/                   Fixed wrong cache control in f_lseek().
N/                   Added relative path feature.
N/                   Added f_chdir() and f_chdrive().
N/                   Added proper case conversion to extended char.
N/ Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
N/                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
N/                   Fixed name matching error on the 13 char boundary.
N/                   Added a configuration option, _LFN_UNICODE.
N/                   Changed f_readdir() to return the SFN with always upper
N/                   case on non-LFN cfg.
N/---------------------------------------------------------------------------*/
N
N#include "ff.h"			/* FatFs configurations and declarations */
L 1 "atmel\ff.h" 1
N/*---------------------------------------------------------------------------/
N/  FatFs - FAT file system module include file  R0.07e       (C)ChaN, 2009
N/----------------------------------------------------------------------------/
N/ FatFs module is a generic FAT file system module for small embedded systems.
N/ This is a free software that opened for education, research and commercial
N/ developments under license policy of following trems.
N/
N/  Copyright (C) 2009, ChaN, all right reserved.
N/
N/ * The FatFs module is a free software and there is NO WARRANTY.
N/ * No restriction on use. You can use, modify and redistribute it for
N/   personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
N/ * Redistributions of source code must retain the above copyright notice.
N/----------------------------------------------------------------------------*/
N
N#ifndef _FATFS
N#define _FATFS	0x007E
N
N#include "integer.h"	/* Basic integer types */
L 1 "atmel\integer.h" 1
N/*-------------------------------------------*/
N/* Integer type definitions for FatFs module */
N/*-------------------------------------------*/
N
N#ifndef _INTEGER
N
N#if 0
S#include <windows.h>
N#else
N
N/* These types must be 16-bit, 32-bit or larger integer */
Ntypedef int				INT;
Ntypedef unsigned int	UINT;
N
N/* These types must be 8-bit integer */
Ntypedef signed char		CHAR;
Ntypedef unsigned char	UCHAR;
Ntypedef unsigned char	BYTE;
N
N/* These types must be 16-bit integer */
Ntypedef short			SHORT;
Ntypedef unsigned short	USHORT;
Ntypedef unsigned short	WORD;
Ntypedef unsigned short	WCHAR;
N
N/* These types must be 32-bit integer */
Ntypedef long			LONG;
Ntypedef unsigned long	ULONG;
Ntypedef unsigned long	DWORD;
N
N/* Boolean type */
N//typedef enum { FALSE = 0, TRUE } BOOL;
N
N#endif
N
N#define _INTEGER
N#endif
L 20 "atmel\ff.h" 2
N#include "ffconf.h"		/* FatFs configuration options */
L 1 "atmel\ffconf.h" 1
N/*---------------------------------------------------------------------------/
N/  FatFs - FAT file system module configuration file  R0.07e  (C)ChaN, 2009
N/----------------------------------------------------------------------------/
N/
N/ CAUTION! Do not forget to make clean the project after any changes to
N/ the configuration options.
N/
N/----------------------------------------------------------------------------*/
N#include "fatfs_config.h"  /* ATMEL modification */
L 1 "atmel\fatfs_config.h" 1
N/* ----------------------------------------------------------------------------
N *         ATMEL Microcontroller Software Support
N * ----------------------------------------------------------------------------
N * Copyright (c) 2008, Atmel Corporation
N *
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N * - Redistributions of source code must retain the above copyright notice,
N * this list of conditions and the disclaimer below.
N *
N * Atmel's name may not be used to endorse or promote products derived from
N * this software without specific prior written permission.
N *
N * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
N * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
N * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
N * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
N * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
N * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
N * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
N * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * ----------------------------------------------------------------------------
N */
N
N#ifndef FATFS_CONFIG_H
N#define FATFS_CONFIG_H
N#include "integer.h"
N
N/*-----------------------------------------------------------------------*/
N/* Correspondence between drive number and physical drive                */
N/* Note that Tiny-FatFs supports only single drive and always            */
N/* accesses drive number 0.                                              */
N
N#define DRV_MMC          0
N#define DRV_NAND         1
N#define DRV_SDRAM        2
N#define DRV_ATA          3
N#define DRV_USB          4
N
N
N#define SECTOR_SIZE_DEFAULT 512
N#define SECTOR_SIZE_SDRAM  512
N#define SECTOR_SIZE_SDCARD 512
N
N/*---------------------------------------------------------------------------/
N/ FatFs Configuration Options
N/
N/ CAUTION! Do not forget to make clean the project after any changes to
N/ the configuration options.
N/
N/----------------------------------------------------------------------------*/
N#define _FFCONFIG 0x007E
N
N/*---------------------------------------------------------------------------/
N/ Function and Buffer Configurations
N/----------------------------------------------------------------------------*/
N
N#define	_FS_TINY	0		/* 0 or 1 */
N/* When _FS_TINY is set to 1, FatFs uses the sector buffer in the file system
N/  object instead of the sector buffer in the individual file object for file
N/  data transfer. This reduces memory consumption 512 bytes each file object. */
N
N#if _FS_TINY != 1
X#if 0 != 1
N#define _FS_READONLY	0
N/* Setting _FS_READONLY to 1 defines read only configuration. This removes
N/  writing functions, f_write, f_sync, f_unlink, f_mkdir, f_chmod, f_rename,
N/  f_truncate and useless f_getfree. */
N#else
S#define _FS_READONLY	1
S/* Setting _FS_READONLY to 1 defines read only configuration. This removes
S/  writing functions, f_write, f_sync, f_unlink, f_mkdir, f_chmod, f_rename,
S/  f_truncate and useless f_getfree. */
N#endif
N
N#define _FS_MINIMIZE	0	/* 0, 1, 2 or 3 */
N/* The _FS_MINIMIZE option defines minimization level to remove some functions.
N/
N/  0: Full function.
N/   1: f_stat, f_getfree, f_unlink, f_mkdir, f_chmod, f_truncate and f_rename
N/      are removed.
N/  2: f_opendir and f_readdir are removed in addition to level 1.
N/  3: f_lseek is removed in addition to level 2. */
N
N
N#define	_USE_STRFUNC	0	/* 0, 1 or 2 */
N/* To enable string functions, set _USE_STRFUNC to 1 or 2. */
N
N
N#define	_USE_MKFS	1		/* 0 or 1 */
N/* To enable f_mkfs function, set _USE_MKFS to 1 and set _FS_READONLY to 0 */
N
N
N#define	_USE_FORWARD	0	/* 0 or 1 */
N/* To enable f_forward function, set _USE_FORWARD to 1 and set _FS_TINY to 1. */
N
N
N
N/*---------------------------------------------------------------------------/
N/ Locale and Namespace Configurations
N/----------------------------------------------------------------------------*/
N
N#define _CODE_PAGE	850
N/* The _CODE_PAGE specifies the OEM code page to be used on the target system.
N/  Incorrect setting of the code page can cause a file open failure.
N/
N/   932  - Japanese Shift-JIS (DBCS, OEM, Windows)
N/   936  - Simplified Chinese GBK (DBCS, OEM, Windows)
N/   949  - Korean (DBCS, OEM, Windows)
N/   950  - Traditional Chinese Big5 (DBCS, OEM, Windows)
N/   1250 - Central Europe (Windows)
N/   1251 - Cyrillic (Windows)
N/   1252 - Latin 1 (Windows)
N/   1253 - Greek (Windows)
N/   1254 - Turkish (Windows)
N/   1255 - Hebrew (Windows)
N/   1256 - Arabic (Windows)
N/   1257 - Baltic (Windows)
N/   1258 - Vietnam (OEM, Windows)
N/   437  - U.S. (OEM)
N/   720  - Arabic (OEM)
N/   737  - Greek (OEM)
N/   775  - Baltic (OEM)
N/   850  - Multilingual Latin 1 (OEM)
N/   858  - Multilingual Latin 1 + Euro (OEM)
N/   852  - Latin 2 (OEM)
N/   855  - Cyrillic (OEM)
N/   866  - Russian (OEM)
N/   857  - Turkish (OEM)
N/   862  - Hebrew (OEM)
N/   874  - Thai (OEM, Windows)
N/	1    - ASCII only (Valid for non LFN cfg.)
N*/
N
N
N#define	_USE_LFN	0		/* 0, 1 or 2 */
N#define	_MAX_LFN	255		/* Maximum LFN length to handle (12 to 255) */
N/* The _USE_LFN option switches the LFN support.
N/
N/   0: Disable LFN. _MAX_LFN and _LFN_UNICODE have no effect.
N/   1: Enable LFN with static working buffer on the bss. NOT REENTRANT.
N/   2: Enable LFN with dynamic working buffer on the STACK.
N/
N/  The LFN working buffer occupies (_MAX_LFN + 1) * 2 bytes. When enable LFN,
N/  two Unicode handling functions ff_convert() and ff_wtoupper() must be added
N/  to the project. */
N
N
N#define	_LFN_UNICODE	0	/* 0 or 1 */
N/* To switch the character code set on FatFs API to Unicode,
N/  enable LFN feature and set _LFN_UNICODE to 1.
N*/
N
N
N#define _FS_RPATH	0		/* 0 or 1 */
N/* When _FS_RPATH is set to 1, relative path feature is enabled and f_chdir,
N/  f_chdrive function are available.
N/  Note that output of the f_readdir fnction is affected by this option. */
N
N
N
N/*---------------------------------------------------------------------------/
N/ Physical Drive Configurations
N/----------------------------------------------------------------------------*/
N
N#define _DRIVES		1
N/* Number of volumes (logical drives) to be used. */
N
N
N#define	_MAX_SS		512		/* 512, 1024, 2048 or 4096 */
N/* Maximum sector size to be handled.
N/  Always set 512 for memory card and hard disk but a larger value may be
N/  required for floppy disk (512/1024) and optical disk (512/2048).
N/  When _MAX_SS is larger than 512, GET_SECTOR_SIZE command must be implememted
N/  to the disk_ioctl function. */
N
N
N#define	_MULTI_PARTITION	0	/* 0 or 1 */
N/* When _MULTI_PARTITION is set to 0, each volume is bound to the same physical
N/ drive number and can mount only first primaly partition. When it is set to 1,
N/ each volume is tied to the partitions listed in Drives[]. */
N
N
N
N/*---------------------------------------------------------------------------/
N/ System Configurations
N/----------------------------------------------------------------------------*/
N
N#define _WORD_ACCESS	0	/* 0 or 1 */
N/* The _WORD_ACCESS option defines which access method is used to the word
N/  data on the FAT volume.
N/
N/   0: Byte-by-byte access. Always compatible with all platforms.
N/   1: Word access. Do not choose this unless following condition is met.
N/
N/  When the byte order on the memory is big-endian or address miss-aligned
N/  word access results incorrect behavior, the _WORD_ACCESS must be set to 0.
N/  If it is not the case, the value can also be set to 1 to improve the
N/  performance and code size. */
N
N
N#define _FS_REENTRANT	0		/* 0 or 1 */
N#define _FS_TIMEOUT		1000	/* Timeout period in unit of time ticks */
N#define	_SYNC_t			HANDLE	/* O/S dependent type of sync object. e.g. HANDLE, OS_EVENT*, ID and etc.. */
N/* The _FS_REENTRANT option switches the reentrancy of the FatFs module.
N/
N/   0: Disable reentrancy. _SYNC_t and _FS_TIMEOUT have no effect.
N/   1: Enable reentrancy. Also user provided synchronization handlers,
N/      ff_req_grant, ff_rel_grant, ff_del_syncobj and ff_cre_syncobj
N/      function must be added to the project. */
N
N#include "diskio.h"
L 1 "atmel\diskio.h" 1
N/*-----------------------------------------------------------------------
N/  Low level disk interface modlue include file  R0.07   (C)ChaN, 2009
N/-----------------------------------------------------------------------*/
N
N#ifndef _DISKIO
N
N#define _READONLY	0	/* 1: Read-only mode */
N#define _USE_IOCTL	1
N
N#include "integer.h"
N#include "def.h"
L 1 ".\def.h" 1
N/*
N *------------------------------------------------------------------------------
N *
N *------------------------------------------------------------------------------
N */
N
N#ifndef __DEF_H__
N#define __DEF_H__
N
Ntypedef float F32;
Ntypedef unsigned int U32;
Ntypedef int S32;
Ntypedef unsigned short U16;
Ntypedef short int S16;
Ntypedef unsigned char U8;
Ntypedef char S8;
N
Ntypedef enum { FALSE = 0, TRUE } BOOL;
N
N#endif /* __DEF_H__ */
L 12 "atmel\diskio.h" 2
N
N/* Status of Disk Functions */
Ntypedef BYTE	DSTATUS;
N
N/* Results of Disk Functions */
Ntypedef enum {
N	RES_OK = 0,		/* 0: Successful */
N	RES_ERROR,		/* 1: R/W Error */
N	RES_WRPRT,		/* 2: Write Protected */
N	RES_NOTRDY,		/* 3: Not Ready */
N	RES_PARERR		/* 4: Invalid Parameter */
N} DRESULT;
N
N
N/*---------------------------------------*/
N/* Prototypes for disk control functions */
N
NBOOL assign_drives (int argc, char *argv[]);
NDSTATUS disk_initialize (BYTE);
NDSTATUS disk_status (BYTE);
NDRESULT disk_read (BYTE, BYTE*, DWORD, BYTE);
N#if	_READONLY == 0
X#if	0 == 0
NDRESULT disk_write (BYTE, const BYTE*, DWORD, BYTE);
N#endif
NDRESULT disk_ioctl (BYTE, BYTE, void*);
N
N
N
N/* Disk Status Bits (DSTATUS) */
N
N#define STA_NOINIT		0x01	/* Drive not initialized */
N#define STA_NODISK		0x02	/* No medium in the drive */
N#define STA_PROTECT		0x04	/* Write protected */
N
N
N/* Command code for disk_ioctrl() */
N
N/* Generic command */
N#define CTRL_SYNC			0	/* Mandatory for write functions */
N#define GET_SECTOR_COUNT	1	/* Mandatory for only f_mkfs() */
N#define GET_SECTOR_SIZE		2
N#define GET_BLOCK_SIZE		3	/* Mandatory for only f_mkfs() */
N#define CTRL_POWER			4
N#define CTRL_LOCK			5
N#define CTRL_EJECT			6
N/* MMC/SDC command */
N#define MMC_GET_TYPE		10
N#define MMC_GET_CSD			11
N#define MMC_GET_CID			12
N#define MMC_GET_OCR			13
N#define MMC_GET_SDSTAT		14
N/* ATA/CF command */
N#define ATA_GET_REV			20
N#define ATA_GET_MODEL		21
N#define ATA_GET_SN			22
N
N
N#define _DISKIO
N#endif
L 217 "atmel\fatfs_config.h" 2
N#include "ff.h"
L 1 "atmel\ff.h" 1
N/*---------------------------------------------------------------------------/
N/  FatFs - FAT file system module include file  R0.07e       (C)ChaN, 2009
N/----------------------------------------------------------------------------/
N/ FatFs module is a generic FAT file system module for small embedded systems.
N/ This is a free software that opened for education, research and commercial
N/ developments under license policy of following trems.
N/
N/  Copyright (C) 2009, ChaN, all right reserved.
N/
N/ * The FatFs module is a free software and there is NO WARRANTY.
N/ * No restriction on use. You can use, modify and redistribute it for
N/   personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
N/ * Redistributions of source code must retain the above copyright notice.
N/----------------------------------------------------------------------------*/
N
N#ifndef _FATFS
S#define _FATFS	0x007E
S
S#include "integer.h"	/* Basic integer types */
S#include "ffconf.h"		/* FatFs configuration options */
S
S#if _FATFS != _FFCONFIG
S#error Wrong configuration file (ffconf.h).
S#endif
S
S
S/* DBCS code ranges and SBCS extend char conversion table */
S
S#if _CODE_PAGE == 932	/* Japanese Shift-JIS */
S#define _DF1S	0x81	/* DBC 1st byte range 1 start */
S#define _DF1E	0x9F	/* DBC 1st byte range 1 end */
S#define _DF2S	0xE0	/* DBC 1st byte range 2 start */
S#define _DF2E	0xFC	/* DBC 1st byte range 2 end */
S#define _DS1S	0x40	/* DBC 2nd byte range 1 start */
S#define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
S#define _DS2S	0x80	/* DBC 2nd byte range 2 start */
S#define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
S
S#elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
S#define _DF1S	0x81
S#define _DF1E	0xFE
S#define _DS1S	0x40
S#define _DS1E	0x7E
S#define _DS2S	0x80
S#define _DS2E	0xFE
S
S#elif _CODE_PAGE == 949	/* Korean */
S#define _DF1S	0x81
S#define _DF1E	0xFE
S#define _DS1S	0x41
S#define _DS1E	0x5A
S#define _DS2S	0x61
S#define _DS2E	0x7A
S#define _DS3S	0x81
S#define _DS3E	0xFE
S
S#elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
S#define _DF1S	0x81
S#define _DF1E	0xFE
S#define _DS1S	0x40
S#define _DS1E	0x7E
S#define _DS2S	0xA1
S#define _DS2E	0xFE
S
S#elif _CODE_PAGE == 437	/* U.S. (OEM) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 720	/* Arabic (OEM) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 737	/* Greek (OEM) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
S				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 775	/* Baltic (OEM) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
S				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
S				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
S
S#elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
S#define _DF1S	0
S#define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
S				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
S				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 857	/* Turkish (OEM) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
S				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
S				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 862	/* Hebrew (OEM) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 866	/* Russian (OEM) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
S				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
S
S#elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
S				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
X#define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
S
S#elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
S				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
S
S#elif _CODE_PAGE == 1253 /* Greek (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
S				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
S
S#elif _CODE_PAGE == 1254 /* Turkish (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
S				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
S
S#elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 1256 /* Arabic (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 1257 /* Baltic (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
S
S#elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
S				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
S
S#elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
S#define _DF1S	0
S
S#else
S#error Unknown code page
S
S#endif
S
S
S
S/* Character code support macros */
S
S#define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
S#define IsLower(c)	(((c)>='a')&&((c)<='z'))
S
S#if _DF1S		/* DBCS configuration */
S
S#ifdef _DF2S	/* Two 1st byte areas */
S#define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
S#else			/* One 1st byte area */
S#define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
S#endif
S
S#ifdef _DS3S	/* Three 2nd byte areas */
S#define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
S#else			/* Two 2nd byte areas */
S#define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
S#endif
S
S#else			/* SBCS configuration */
S
S#define IsDBCS1(c)	0
S#define IsDBCS2(c)	0
S
S#endif /* _DF1S */
S
S
S
S/* Definitions corresponds to multi partition */
S
S#if _MULTI_PARTITION		/* Multiple partition configuration */
S
Stypedef struct _PARTITION {
S	BYTE pd;	/* Physical drive# */
S	BYTE pt;	/* Partition # (0-3) */
S} PARTITION;
S
Sextern
Sconst PARTITION Drives[];			/* Logical drive# to physical location conversion table */
S#define LD2PD(drv) (Drives[drv].pd)	/* Get physical drive# */
S#define LD2PT(drv) (Drives[drv].pt)	/* Get partition# */
S
S#else						/* Single partition configuration */
S
S#define LD2PD(drv) (drv)	/* Physical drive# is equal to the logical drive# */
S#define LD2PT(drv) 0		/* Always mounts the 1st partition */
S
S#endif
S
S
S
S/* Definitions corresponds to multiple sector size */
S
S#if _MAX_SS == 512		/* Single sector size */
S#define	SS(fs)	512U
S
S#elif _MAX_SS == 1024 || _MAX_SS == 2048 || _MAX_SS == 4096	/* Multiple sector size */
S#define	SS(fs)	((fs)->s_size)
S
S#else
S#error Sector size must be 512, 1024, 2048 or 4096.
S
S#endif
S
S
S
S/* Type of file name on FatFs API */
S
S#if _LFN_UNICODE && _USE_LFN
Stypedef WCHAR XCHAR;	/* Unicode */
S#else
Stypedef char XCHAR;		/* SBCS, DBCS */
S#endif
S
S
S
S/* File system object structure */
S
Stypedef struct _FATFS_ {
S	BYTE	fs_type;	/* FAT sub type */
S	BYTE	drive;		/* Physical drive number */
S	BYTE	csize;		/* Number of sectors per cluster */
S	BYTE	n_fats;		/* Number of FAT copies */
S	BYTE	wflag;		/* win[] dirty flag (1:must be written back) */
S	BYTE	fsi_flag;	/* fsinfo dirty flag (1:must be written back) */
S	WORD	id;			/* File system mount ID */
S	WORD	n_rootdir;	/* Number of root directory entries (0 on FAT32) */
S#if _FS_REENTRANT
S	_SYNC_t	sobj;		/* Identifier of sync object */
S#endif
S#if _MAX_SS != 512
S	WORD	s_size;		/* Sector size */
S#endif
S#if !_FS_READONLY
S	DWORD	last_clust;	/* Last allocated cluster */
S	DWORD	free_clust;	/* Number of free clusters */
S	DWORD	fsi_sector;	/* fsinfo sector */
S#endif
S#if _FS_RPATH
S	DWORD	cdir;		/* Current directory (0:root)*/
S#endif
S	DWORD	sects_fat;	/* Sectors per fat */
S	DWORD	max_clust;	/* Maximum cluster# + 1. Number of clusters is max_clust - 2 */
S	DWORD	fatbase;	/* FAT start sector */
S	DWORD	dirbase;	/* Root directory start sector (Cluster# on FAT32) */
S	DWORD	database;	/* Data start sector */
S	DWORD	winsect;	/* Current sector appearing in the win[] */
S	BYTE	win[_MAX_SS];/* Disk access window for Directory/FAT */
S} FATFS;
S
S
S
S/* Directory object structure */
S
Stypedef struct _DIR_ {
S	FATFS*	fs;			/* Pointer to the owner file system object */
S	WORD	id;			/* Owner file system mount ID */
S	WORD	index;		/* Current read/write index number */
S	DWORD	sclust;		/* Table start cluster (0:Static table) */
S	DWORD	clust;		/* Current cluster */
S	DWORD	sect;		/* Current sector */
S	BYTE*	dir;		/* Pointer to the current SFN entry in the win[] */
S	BYTE*	fn;			/* Pointer to the SFN (in/out) {file[8],ext[3],status[1]} */
S#if _USE_LFN
S	WCHAR*	lfn;		/* Pointer to the LFN working buffer */
S	WORD	lfn_idx;	/* Last matched LFN index number (0xFFFF:No LFN) */
S#endif
S} DIR;
S
S
S
S/* File object structure */
S
Stypedef struct _FIL_ {
S	FATFS*	fs;			/* Pointer to the owner file system object */
S	WORD	id;			/* Owner file system mount ID */
S	BYTE	flag;		/* File status flags */
S	BYTE	csect;		/* Sector address in the cluster */
S	DWORD	fptr;		/* File R/W pointer */
S	DWORD	fsize;		/* File size */
S	DWORD	org_clust;	/* File start cluster */
S	DWORD	curr_clust;	/* Current cluster */
S	DWORD	dsect;		/* Current data sector */
S#if !_FS_READONLY
S	DWORD	dir_sect;	/* Sector containing the directory entry */
S	BYTE*	dir_ptr;	/* Ponter to the directory entry in the window */
S#endif
S#if !_FS_TINY
S	BYTE	buf[_MAX_SS];/* File R/W buffer */
S#endif
S} FIL;
S
S
S
S/* File status structure */
S
Stypedef struct _FILINFO_ {
S	DWORD	fsize;		/* File size */
S	WORD	fdate;		/* Last modified date */
S	WORD	ftime;		/* Last modified time */
S	BYTE	fattrib;	/* Attribute */
S	char	fname[13];	/* Short file name (8.3 format) */
S#if _USE_LFN
S	XCHAR*	lfname;		/* Pointer to the LFN buffer */
S	int 	lfsize;		/* Size of LFN buffer [chrs] */
S#endif
S} FILINFO;
S
S
S
S/* File function return code (FRESULT) */
S
Stypedef enum {
S	FR_OK = 0,			/* 0 */
S	FR_DISK_ERR,		/* 1 */
S	FR_INT_ERR,			/* 2 */
S	FR_NOT_READY,		/* 3 */
S	FR_NO_FILE,			/* 4 */
S	FR_NO_PATH,			/* 5 */
S	FR_INVALID_NAME,	/* 6 */
S	FR_DENIED,			/* 7 */
S	FR_EXIST,			/* 8 */
S	FR_INVALID_OBJECT,	/* 9 */
S	FR_WRITE_PROTECTED,	/* 10 */
S	FR_INVALID_DRIVE,	/* 11 */
S	FR_NOT_ENABLED,		/* 12 */
S	FR_NO_FILESYSTEM,	/* 13 */
S	FR_MKFS_ABORTED,	/* 14 */
S	FR_TIMEOUT			/* 15 */
S} FRESULT;
S
S
S
S/*--------------------------------------------------------------*/
S/* FatFs module application interface                           */
S
SFRESULT f_mount (BYTE, FATFS*);						/* Mount/Unmount a logical drive */
SFRESULT f_open (FIL*, const XCHAR*, BYTE);			/* Open or create a file */
SFRESULT f_read (FIL*, void*, UINT, UINT*);			/* Read data from a file */
SFRESULT f_write (FIL*, const void*, UINT, UINT*);	/* Write data to a file */
SFRESULT f_lseek (FIL*, DWORD);						/* Move file pointer of a file object */
SFRESULT f_close (FIL*);								/* Close an open file object */
SFRESULT f_opendir (DIR*, const XCHAR*);				/* Open an existing directory */
SFRESULT f_readdir (DIR*, FILINFO*);					/* Read a directory item */
SFRESULT f_stat (const XCHAR*, FILINFO*);			/* Get file status */
SFRESULT f_getfree (const XCHAR*, DWORD*, FATFS**);	/* Get number of free clusters on the drive */
SFRESULT f_truncate (FIL*);							/* Truncate file */
SFRESULT f_sync (FIL*);								/* Flush cached data of a writing file */
SFRESULT f_unlink (const XCHAR*);					/* Delete an existing file or directory */
SFRESULT	f_mkdir (const XCHAR*);						/* Create a new directory */
SFRESULT f_chmod (const XCHAR*, BYTE, BYTE);			/* Change attriburte of the file/dir */
SFRESULT f_utime (const XCHAR*, const FILINFO*);		/* Change timestamp of the file/dir */
SFRESULT f_rename (const XCHAR*, const XCHAR*);		/* Rename/Move a file or directory */
SFRESULT f_forward (FIL*, UINT(*)(const BYTE*,UINT), UINT, UINT*);	/* Forward data to the stream */
SFRESULT f_mkfs (BYTE, BYTE, WORD);					/* Create a file system on the drive */
SFRESULT f_chdir (const XCHAR*);						/* Change current directory */
SFRESULT f_chdrive (BYTE);							/* Change current drive */
S
S#if _USE_STRFUNC
Sint f_putc (int, FIL*);								/* Put a character to the file */
Sint f_puts (const char*, FIL*);						/* Put a string to the file */
Sint f_printf (FIL*, const char*, ...);				/* Put a formatted string to the file */
Schar* f_gets (char*, int, FIL*);					/* Get a string from the file */
S#define f_eof(fp) (((fp)->fptr == (fp)->fsize) ? 1 : 0)
S#define f_error(fp) (((fp)->flag & FA__ERROR) ? 1 : 0)
S#ifndef EOF
S#define EOF -1
S#endif
S#endif
S
S
S
S/*--------------------------------------------------------------*/
S/* User defined functions                                       */
S
S/* Real time clock */
S#if !_FS_READONLY
SDWORD get_fattime (void);	/* 31-25: Year(0-127 org.1980), 24-21: Month(1-12), 20-16: Day(1-31) */
S							/* 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) */
S#endif
S
S/* Unicode - OEM code conversion */
S#if _USE_LFN
SWCHAR ff_convert (WCHAR, UINT);
SWCHAR ff_wtoupper (WCHAR);
S#endif
S
S/* Sync functions */
S#if _FS_REENTRANT
SBOOL ff_cre_syncobj(BYTE, _SYNC_t*);
SBOOL ff_del_syncobj(_SYNC_t);
SBOOL ff_req_grant(_SYNC_t);
Svoid ff_rel_grant(_SYNC_t);
S#endif
S
S
S
S/*--------------------------------------------------------------*/
S/* Flags and offset address                                     */
S
S
S/* File access control and file status flags (FIL.flag) */
S
S#define	FA_READ				0x01
S#define	FA_OPEN_EXISTING	0x00
S#if _FS_READONLY == 0
S#define	FA_WRITE			0x02
S#define	FA_CREATE_NEW		0x04
S#define	FA_CREATE_ALWAYS	0x08
S#define	FA_OPEN_ALWAYS		0x10
S#define FA__WRITTEN			0x20
S#define FA__DIRTY			0x40
S#endif
S#define FA__ERROR			0x80
S
S
S/* FAT sub type (FATFS.fs_type) */
S
S#define FS_FAT12	1
S#define FS_FAT16	2
S#define FS_FAT32	3
S
S
S/* File attribute bits for directory entry */
S
S#define	AM_RDO	0x01	/* Read only */
S#define	AM_HID	0x02	/* Hidden */
S#define	AM_SYS	0x04	/* System */
S#define	AM_VOL	0x08	/* Volume label */
S#define AM_LFN	0x0F	/* LFN entry */
S#define AM_DIR	0x10	/* Directory */
S#define AM_ARC	0x20	/* Archive */
S#define AM_MASK	0x3F	/* Mask of defined bits */
S
S
S/* FatFs refers the members in the FAT structures with byte offset instead
S/ of structure member because there are incompatibility of the packing option
S/ between various compilers. */
S
S#define BS_jmpBoot			0
S#define BS_OEMName			3
S#define BPB_BytsPerSec		11
S#define BPB_SecPerClus		13
S#define BPB_RsvdSecCnt		14
S#define BPB_NumFATs			16
S#define BPB_RootEntCnt		17
S#define BPB_TotSec16		19
S#define BPB_Media			21
S#define BPB_FATSz16			22
S#define BPB_SecPerTrk		24
S#define BPB_NumHeads		26
S#define BPB_HiddSec			28
S#define BPB_TotSec32		32
S#define BS_55AA				510
S
S#define BS_DrvNum			36
S#define BS_BootSig			38
S#define BS_VolID			39
S#define BS_VolLab			43
S#define BS_FilSysType		54
S
S#define BPB_FATSz32			36
S#define BPB_ExtFlags		40
S#define BPB_FSVer			42
S#define BPB_RootClus		44
S#define BPB_FSInfo			48
S#define BPB_BkBootSec		50
S#define BS_DrvNum32			64
S#define BS_BootSig32		66
S#define BS_VolID32			67
S#define BS_VolLab32			71
S#define BS_FilSysType32		82
S
S#define	FSI_LeadSig			0
S#define	FSI_StrucSig		484
S#define	FSI_Free_Count		488
S#define	FSI_Nxt_Free		492
S
S#define MBR_Table			446
S
S#define	DIR_Name			0
S#define	DIR_Attr			11
S#define	DIR_NTres			12
S#define	DIR_CrtTime			14
S#define	DIR_CrtDate			16
S#define	DIR_FstClusHI		20
S#define	DIR_WrtTime			22
S#define	DIR_WrtDate			24
S#define	DIR_FstClusLO		26
S#define	DIR_FileSize		28
S#define	LDIR_Ord			0
S#define	LDIR_Attr			11
S#define	LDIR_Type			12
S#define	LDIR_Chksum			13
S#define	LDIR_FstClusLO		26
S
S
S
S/*--------------------------------*/
S/* Multi-byte word access macros  */
S
S#if _WORD_ACCESS == 1	/* Enable word access to the FAT structure */
S#define	LD_WORD(ptr)		(WORD)(*(WORD*)(BYTE*)(ptr))
S#define	LD_DWORD(ptr)		(DWORD)(*(DWORD*)(BYTE*)(ptr))
S#define	ST_WORD(ptr,val)	*(WORD*)(BYTE*)(ptr)=(WORD)(val)
S#define	ST_DWORD(ptr,val)	*(DWORD*)(BYTE*)(ptr)=(DWORD)(val)
S#else					/* Use byte-by-byte access to the FAT structure */
S#define	LD_WORD(ptr)		(WORD)(((WORD)*(BYTE*)((ptr)+1)<<8)|(WORD)*(BYTE*)(ptr))
S#define	LD_DWORD(ptr)		(DWORD)(((DWORD)*(BYTE*)((ptr)+3)<<24)|((DWORD)*(BYTE*)((ptr)+2)<<16)|((WORD)*(BYTE*)((ptr)+1)<<8)|*(BYTE*)(ptr))
S#define	ST_WORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *(BYTE*)((ptr)+1)=(BYTE)((WORD)(val)>>8)
S#define	ST_DWORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *(BYTE*)((ptr)+1)=(BYTE)((WORD)(val)>>8); *(BYTE*)((ptr)+2)=(BYTE)((DWORD)(val)>>16); *(BYTE*)((ptr)+3)=(BYTE)((DWORD)(val)>>24)
S#endif
S
S
N#endif /* _FATFS */
L 218 "atmel\fatfs_config.h" 2
N
N#endif // FATFS_CONFIG_H
L 10 "atmel\ffconf.h" 2
N
N#ifndef _FFCONFIG
S#define _FFCONFIG 0x007E
S
S#error
S/*---------------------------------------------------------------------------/
S/ Function and Buffer Configurations
S/----------------------------------------------------------------------------*/
S
S#define	_FS_TINY	0		/* 0 or 1 */
S/* When _FS_TINY is set to 1, FatFs uses the sector buffer in the file system
S/  object instead of the sector buffer in the individual file object for file
S/  data transfer. This reduces memory consumption 512 bytes each file object. */
S
S
S#define _FS_READONLY	0	/* 0 or 1 */
S/* Setting _FS_READONLY to 1 defines read only configuration. This removes
S/  writing functions, f_write, f_sync, f_unlink, f_mkdir, f_chmod, f_rename,
S/  f_truncate and useless f_getfree. */
S
S
S#define _FS_MINIMIZE	0	/* 0, 1, 2 or 3 */
S/* The _FS_MINIMIZE option defines minimization level to remove some functions.
S/
S/   0: Full function.
S/   1: f_stat, f_getfree, f_unlink, f_mkdir, f_chmod, f_truncate and f_rename
S/      are removed.
S/   2: f_opendir and f_readdir are removed in addition to level 1.
S/   3: f_lseek is removed in addition to level 2. */
S
S
S#define	_USE_STRFUNC	0	/* 0, 1 or 2 */
S/* To enable string functions, set _USE_STRFUNC to 1 or 2. */
S
S
S#define	_USE_MKFS	0		/* 0 or 1 */
S/* To enable f_mkfs function, set _USE_MKFS to 1 and set _FS_READONLY to 0 */
S
S
S#define	_USE_FORWARD	0	/* 0 or 1 */
S/* To enable f_forward function, set _USE_FORWARD to 1 and set _FS_TINY to 1. */
S
S
S
S/*---------------------------------------------------------------------------/
S/ Locale and Namespace Configurations
S/----------------------------------------------------------------------------*/
S
S#define _CODE_PAGE	932
S/* The _CODE_PAGE specifies the OEM code page to be used on the target system.
S/  Incorrect setting of the code page can cause a file open failure.
S/
S/   932  - Japanese Shift-JIS (DBCS, OEM, Windows)
S/   936  - Simplified Chinese GBK (DBCS, OEM, Windows)
S/   949  - Korean (DBCS, OEM, Windows)
S/   950  - Traditional Chinese Big5 (DBCS, OEM, Windows)
S/   1250 - Central Europe (Windows)
S/   1251 - Cyrillic (Windows)
S/   1252 - Latin 1 (Windows)
S/   1253 - Greek (Windows)
S/   1254 - Turkish (Windows)
S/   1255 - Hebrew (Windows)
S/   1256 - Arabic (Windows)
S/   1257 - Baltic (Windows)
S/   1258 - Vietnam (OEM, Windows)
S/   437  - U.S. (OEM)
S/   720  - Arabic (OEM)
S/   737  - Greek (OEM)
S/   775  - Baltic (OEM)
S/   850  - Multilingual Latin 1 (OEM)
S/   858  - Multilingual Latin 1 + Euro (OEM)
S/   852  - Latin 2 (OEM)
S/   855  - Cyrillic (OEM)
S/   866  - Russian (OEM)
S/   857  - Turkish (OEM)
S/   862  - Hebrew (OEM)
S/   874  - Thai (OEM, Windows)
S/	1    - ASCII only (Valid for non LFN cfg.)
S*/
S
S
S#define	_USE_LFN	0		/* 0, 1 or 2 */
S#define	_MAX_LFN	255		/* Maximum LFN length to handle (12 to 255) */
S/* The _USE_LFN option switches the LFN support.
S/
S/   0: Disable LFN. _MAX_LFN and _LFN_UNICODE have no effect.
S/   1: Enable LFN with static working buffer on the bss. NOT REENTRANT.
S/   2: Enable LFN with dynamic working buffer on the STACK.
S/
S/  The LFN working buffer occupies (_MAX_LFN + 1) * 2 bytes. When enable LFN,
S/  two Unicode handling functions ff_convert() and ff_wtoupper() must be added
S/  to the project. */
S
S
S#define	_LFN_UNICODE	0	/* 0 or 1 */
S/* To switch the character code set on FatFs API to Unicode,
S/  enable LFN feature and set _LFN_UNICODE to 1.
S*/
S
S
S#define _FS_RPATH	0		/* 0 or 1 */
S/* When _FS_RPATH is set to 1, relative path feature is enabled and f_chdir,
S/  f_chdrive function are available.
S/  Note that output of the f_readdir fnction is affected by this option. */
S
S
S
S/*---------------------------------------------------------------------------/
S/ Physical Drive Configurations
S/----------------------------------------------------------------------------*/
S
S#define _DRIVES		1
S/* Number of volumes (logical drives) to be used. */
S
S
S#define	_MAX_SS		512		/* 512, 1024, 2048 or 4096 */
S/* Maximum sector size to be handled.
S/  Always set 512 for memory card and hard disk but a larger value may be
S/  required for floppy disk (512/1024) and optical disk (512/2048).
S/  When _MAX_SS is larger than 512, GET_SECTOR_SIZE command must be implememted
S/  to the disk_ioctl function. */
S
S
S#define	_MULTI_PARTITION	0	/* 0 or 1 */
S/* When _MULTI_PARTITION is set to 0, each volume is bound to the same physical
S/ drive number and can mount only first primaly partition. When it is set to 1,
S/ each volume is tied to the partitions listed in Drives[]. */
S
S
S
S/*---------------------------------------------------------------------------/
S/ System Configurations
S/----------------------------------------------------------------------------*/
S
S#define _WORD_ACCESS	0	/* 0 or 1 */
S/* The _WORD_ACCESS option defines which access method is used to the word
S/  data on the FAT volume.
S/
S/   0: Byte-by-byte access. Always compatible with all platforms.
S/   1: Word access. Do not choose this unless following condition is met.
S/
S/  When the byte order on the memory is big-endian or address miss-aligned
S/  word access results incorrect behavior, the _WORD_ACCESS must be set to 0.
S/  If it is not the case, the value can also be set to 1 to improve the
S/  performance and code size. */
S
S
S#define _FS_REENTRANT	0		/* 0 or 1 */
S#define _FS_TIMEOUT		1000	/* Timeout period in unit of time ticks */
S#define	_SYNC_t			HANDLE	/* O/S dependent type of sync object. e.g. HANDLE, OS_EVENT*, ID and etc.. */
S/* The _FS_REENTRANT option switches the reentrancy of the FatFs module.
S/
S/   0: Disable reentrancy. _SYNC_t and _FS_TIMEOUT have no effect.
S/   1: Enable reentrancy. Also user provided synchronization handlers,
S/      ff_req_grant, ff_rel_grant, ff_del_syncobj and ff_cre_syncobj
S/      function must be added to the project. */
S
S
N#endif /* _FFCONFIG */
L 21 "atmel\ff.h" 2
N
N#if _FATFS != _FFCONFIG
X#if 0x007E != 0x007E
S#error Wrong configuration file (ffconf.h).
N#endif
N
N
N/* DBCS code ranges and SBCS extend char conversion table */
N
N#if _CODE_PAGE == 932	/* Japanese Shift-JIS */
X#if 850 == 932	 
S#define _DF1S	0x81	/* DBC 1st byte range 1 start */
S#define _DF1E	0x9F	/* DBC 1st byte range 1 end */
S#define _DF2S	0xE0	/* DBC 1st byte range 2 start */
S#define _DF2E	0xFC	/* DBC 1st byte range 2 end */
S#define _DS1S	0x40	/* DBC 2nd byte range 1 start */
S#define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
S#define _DS2S	0x80	/* DBC 2nd byte range 2 start */
S#define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
S
S#elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
X#elif 850 == 936	 
S#define _DF1S	0x81
S#define _DF1E	0xFE
S#define _DS1S	0x40
S#define _DS1E	0x7E
S#define _DS2S	0x80
S#define _DS2E	0xFE
S
S#elif _CODE_PAGE == 949	/* Korean */
X#elif 850 == 949	 
S#define _DF1S	0x81
S#define _DF1E	0xFE
S#define _DS1S	0x41
S#define _DS1E	0x5A
S#define _DS2S	0x61
S#define _DS2E	0x7A
S#define _DS3S	0x81
S#define _DS3E	0xFE
S
S#elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
X#elif 850 == 950	 
S#define _DF1S	0x81
S#define _DF1E	0xFE
S#define _DS1S	0x40
S#define _DS1E	0x7E
S#define _DS2S	0xA1
S#define _DS2E	0xFE
S
S#elif _CODE_PAGE == 437	/* U.S. (OEM) */
X#elif 850 == 437	 
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 720	/* Arabic (OEM) */
X#elif 850 == 720	 
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 737	/* Greek (OEM) */
X#elif 850 == 737	 
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
S				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 775	/* Baltic (OEM) */
X#elif 850 == 775	 
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
N#elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
X#elif 850 == 850	 
N#define _DF1S	0
N#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
N				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
N				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
N				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
N
N#elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
S				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
S
S#elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
S#define _DF1S	0
S#define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
S				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
S				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 857	/* Turkish (OEM) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
S				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
S				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 862	/* Hebrew (OEM) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 866	/* Russian (OEM) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
S				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
S
S#elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
S				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
X#define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
S
S#elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
S				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
S
S#elif _CODE_PAGE == 1253 /* Greek (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
S				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
S
S#elif _CODE_PAGE == 1254 /* Turkish (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
S				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
S
S#elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 1256 /* Arabic (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 1257 /* Baltic (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
S
S#elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
S				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
S
S#elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
S#define _DF1S	0
S
S#else
S#error Unknown code page
S
N#endif
N
N
N
N/* Character code support macros */
N
N#define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
N#define IsLower(c)	(((c)>='a')&&((c)<='z'))
N
N#if _DF1S		/* DBCS configuration */
X#if 0		 
S
S#ifdef _DF2S	/* Two 1st byte areas */
S#define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
S#else			/* One 1st byte area */
S#define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
S#endif
S
S#ifdef _DS3S	/* Three 2nd byte areas */
S#define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
S#else			/* Two 2nd byte areas */
S#define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
S#endif
S
N#else			/* SBCS configuration */
N
N#define IsDBCS1(c)	0
N#define IsDBCS2(c)	0
N
N#endif /* _DF1S */
N
N
N
N/* Definitions corresponds to multi partition */
N
N#if _MULTI_PARTITION		/* Multiple partition configuration */
X#if 0		 
S
Stypedef struct _PARTITION {
S	BYTE pd;	/* Physical drive# */
S	BYTE pt;	/* Partition # (0-3) */
S} PARTITION;
S
Sextern
Sconst PARTITION Drives[];			/* Logical drive# to physical location conversion table */
S#define LD2PD(drv) (Drives[drv].pd)	/* Get physical drive# */
S#define LD2PT(drv) (Drives[drv].pt)	/* Get partition# */
S
N#else						/* Single partition configuration */
N
N#define LD2PD(drv) (drv)	/* Physical drive# is equal to the logical drive# */
N#define LD2PT(drv) 0		/* Always mounts the 1st partition */
N
N#endif
N
N
N
N/* Definitions corresponds to multiple sector size */
N
N#if _MAX_SS == 512		/* Single sector size */
X#if 512 == 512		 
N#define	SS(fs)	512U
N
N#elif _MAX_SS == 1024 || _MAX_SS == 2048 || _MAX_SS == 4096	/* Multiple sector size */
S#define	SS(fs)	((fs)->s_size)
S
S#else
S#error Sector size must be 512, 1024, 2048 or 4096.
S
N#endif
N
N
N
N/* Type of file name on FatFs API */
N
N#if _LFN_UNICODE && _USE_LFN
X#if 0 && 0
Stypedef WCHAR XCHAR;	/* Unicode */
N#else
Ntypedef char XCHAR;		/* SBCS, DBCS */
N#endif
N
N
N
N/* File system object structure */
N
Ntypedef struct _FATFS_ {
N	BYTE	fs_type;	/* FAT sub type */
N	BYTE	drive;		/* Physical drive number */
N	BYTE	csize;		/* Number of sectors per cluster */
N	BYTE	n_fats;		/* Number of FAT copies */
N	BYTE	wflag;		/* win[] dirty flag (1:must be written back) */
N	BYTE	fsi_flag;	/* fsinfo dirty flag (1:must be written back) */
N	WORD	id;			/* File system mount ID */
N	WORD	n_rootdir;	/* Number of root directory entries (0 on FAT32) */
N#if _FS_REENTRANT
X#if 0
S	_SYNC_t	sobj;		/* Identifier of sync object */
N#endif
N#if _MAX_SS != 512
X#if 512 != 512
S	WORD	s_size;		/* Sector size */
N#endif
N#if !_FS_READONLY
X#if !0
N	DWORD	last_clust;	/* Last allocated cluster */
N	DWORD	free_clust;	/* Number of free clusters */
N	DWORD	fsi_sector;	/* fsinfo sector */
N#endif
N#if _FS_RPATH
X#if 0
S	DWORD	cdir;		/* Current directory (0:root)*/
N#endif
N	DWORD	sects_fat;	/* Sectors per fat */
N	DWORD	max_clust;	/* Maximum cluster# + 1. Number of clusters is max_clust - 2 */
N	DWORD	fatbase;	/* FAT start sector */
N	DWORD	dirbase;	/* Root directory start sector (Cluster# on FAT32) */
N	DWORD	database;	/* Data start sector */
N	DWORD	winsect;	/* Current sector appearing in the win[] */
N	BYTE	win[_MAX_SS];/* Disk access window for Directory/FAT */
X	BYTE	win[512]; 
N} FATFS;
N
N
N
N/* Directory object structure */
N
Ntypedef struct _DIR_ {
N	FATFS*	fs;			/* Pointer to the owner file system object */
N	WORD	id;			/* Owner file system mount ID */
N	WORD	index;		/* Current read/write index number */
N	DWORD	sclust;		/* Table start cluster (0:Static table) */
N	DWORD	clust;		/* Current cluster */
N	DWORD	sect;		/* Current sector */
N	BYTE*	dir;		/* Pointer to the current SFN entry in the win[] */
N	BYTE*	fn;			/* Pointer to the SFN (in/out) {file[8],ext[3],status[1]} */
N#if _USE_LFN
X#if 0
S	WCHAR*	lfn;		/* Pointer to the LFN working buffer */
S	WORD	lfn_idx;	/* Last matched LFN index number (0xFFFF:No LFN) */
N#endif
N} DIR;
N
N
N
N/* File object structure */
N
Ntypedef struct _FIL_ {
N	FATFS*	fs;			/* Pointer to the owner file system object */
N	WORD	id;			/* Owner file system mount ID */
N	BYTE	flag;		/* File status flags */
N	BYTE	csect;		/* Sector address in the cluster */
N	DWORD	fptr;		/* File R/W pointer */
N	DWORD	fsize;		/* File size */
N	DWORD	org_clust;	/* File start cluster */
N	DWORD	curr_clust;	/* Current cluster */
N	DWORD	dsect;		/* Current data sector */
N#if !_FS_READONLY
X#if !0
N	DWORD	dir_sect;	/* Sector containing the directory entry */
N	BYTE*	dir_ptr;	/* Ponter to the directory entry in the window */
N#endif
N#if !_FS_TINY
X#if !0
N	BYTE	buf[_MAX_SS];/* File R/W buffer */
X	BYTE	buf[512]; 
N#endif
N} FIL;
N
N
N
N/* File status structure */
N
Ntypedef struct _FILINFO_ {
N	DWORD	fsize;		/* File size */
N	WORD	fdate;		/* Last modified date */
N	WORD	ftime;		/* Last modified time */
N	BYTE	fattrib;	/* Attribute */
N	char	fname[13];	/* Short file name (8.3 format) */
N#if _USE_LFN
X#if 0
S	XCHAR*	lfname;		/* Pointer to the LFN buffer */
S	int 	lfsize;		/* Size of LFN buffer [chrs] */
N#endif
N} FILINFO;
N
N
N
N/* File function return code (FRESULT) */
N
Ntypedef enum {
N	FR_OK = 0,			/* 0 */
N	FR_DISK_ERR,		/* 1 */
N	FR_INT_ERR,			/* 2 */
N	FR_NOT_READY,		/* 3 */
N	FR_NO_FILE,			/* 4 */
N	FR_NO_PATH,			/* 5 */
N	FR_INVALID_NAME,	/* 6 */
N	FR_DENIED,			/* 7 */
N	FR_EXIST,			/* 8 */
N	FR_INVALID_OBJECT,	/* 9 */
N	FR_WRITE_PROTECTED,	/* 10 */
N	FR_INVALID_DRIVE,	/* 11 */
N	FR_NOT_ENABLED,		/* 12 */
N	FR_NO_FILESYSTEM,	/* 13 */
N	FR_MKFS_ABORTED,	/* 14 */
N	FR_TIMEOUT			/* 15 */
N} FRESULT;
N
N
N
N/*--------------------------------------------------------------*/
N/* FatFs module application interface                           */
N
NFRESULT f_mount (BYTE, FATFS*);						/* Mount/Unmount a logical drive */
NFRESULT f_open (FIL*, const XCHAR*, BYTE);			/* Open or create a file */
NFRESULT f_read (FIL*, void*, UINT, UINT*);			/* Read data from a file */
NFRESULT f_write (FIL*, const void*, UINT, UINT*);	/* Write data to a file */
NFRESULT f_lseek (FIL*, DWORD);						/* Move file pointer of a file object */
NFRESULT f_close (FIL*);								/* Close an open file object */
NFRESULT f_opendir (DIR*, const XCHAR*);				/* Open an existing directory */
NFRESULT f_readdir (DIR*, FILINFO*);					/* Read a directory item */
NFRESULT f_stat (const XCHAR*, FILINFO*);			/* Get file status */
NFRESULT f_getfree (const XCHAR*, DWORD*, FATFS**);	/* Get number of free clusters on the drive */
NFRESULT f_truncate (FIL*);							/* Truncate file */
NFRESULT f_sync (FIL*);								/* Flush cached data of a writing file */
NFRESULT f_unlink (const XCHAR*);					/* Delete an existing file or directory */
NFRESULT	f_mkdir (const XCHAR*);						/* Create a new directory */
NFRESULT f_chmod (const XCHAR*, BYTE, BYTE);			/* Change attriburte of the file/dir */
NFRESULT f_utime (const XCHAR*, const FILINFO*);		/* Change timestamp of the file/dir */
NFRESULT f_rename (const XCHAR*, const XCHAR*);		/* Rename/Move a file or directory */
NFRESULT f_forward (FIL*, UINT(*)(const BYTE*,UINT), UINT, UINT*);	/* Forward data to the stream */
NFRESULT f_mkfs (BYTE, BYTE, WORD);					/* Create a file system on the drive */
NFRESULT f_chdir (const XCHAR*);						/* Change current directory */
NFRESULT f_chdrive (BYTE);							/* Change current drive */
N
N#if _USE_STRFUNC
X#if 0
Sint f_putc (int, FIL*);								/* Put a character to the file */
Sint f_puts (const char*, FIL*);						/* Put a string to the file */
Sint f_printf (FIL*, const char*, ...);				/* Put a formatted string to the file */
Schar* f_gets (char*, int, FIL*);					/* Get a string from the file */
S#define f_eof(fp) (((fp)->fptr == (fp)->fsize) ? 1 : 0)
S#define f_error(fp) (((fp)->flag & FA__ERROR) ? 1 : 0)
S#ifndef EOF
S#define EOF -1
S#endif
N#endif
N
N
N
N/*--------------------------------------------------------------*/
N/* User defined functions                                       */
N
N/* Real time clock */
N#if !_FS_READONLY
X#if !0
NDWORD get_fattime (void);	/* 31-25: Year(0-127 org.1980), 24-21: Month(1-12), 20-16: Day(1-31) */
N							/* 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) */
N#endif
N
N/* Unicode - OEM code conversion */
N#if _USE_LFN
X#if 0
SWCHAR ff_convert (WCHAR, UINT);
SWCHAR ff_wtoupper (WCHAR);
N#endif
N
N/* Sync functions */
N#if _FS_REENTRANT
X#if 0
SBOOL ff_cre_syncobj(BYTE, _SYNC_t*);
SBOOL ff_del_syncobj(_SYNC_t);
SBOOL ff_req_grant(_SYNC_t);
Svoid ff_rel_grant(_SYNC_t);
N#endif
N
N
N
N/*--------------------------------------------------------------*/
N/* Flags and offset address                                     */
N
N
N/* File access control and file status flags (FIL.flag) */
N
N#define	FA_READ				0x01
N#define	FA_OPEN_EXISTING	0x00
N#if _FS_READONLY == 0
X#if 0 == 0
N#define	FA_WRITE			0x02
N#define	FA_CREATE_NEW		0x04
N#define	FA_CREATE_ALWAYS	0x08
N#define	FA_OPEN_ALWAYS		0x10
N#define FA__WRITTEN			0x20
N#define FA__DIRTY			0x40
N#endif
N#define FA__ERROR			0x80
N
N
N/* FAT sub type (FATFS.fs_type) */
N
N#define FS_FAT12	1
N#define FS_FAT16	2
N#define FS_FAT32	3
N
N
N/* File attribute bits for directory entry */
N
N#define	AM_RDO	0x01	/* Read only */
N#define	AM_HID	0x02	/* Hidden */
N#define	AM_SYS	0x04	/* System */
N#define	AM_VOL	0x08	/* Volume label */
N#define AM_LFN	0x0F	/* LFN entry */
N#define AM_DIR	0x10	/* Directory */
N#define AM_ARC	0x20	/* Archive */
N#define AM_MASK	0x3F	/* Mask of defined bits */
N
N
N/* FatFs refers the members in the FAT structures with byte offset instead
N/ of structure member because there are incompatibility of the packing option
N/ between various compilers. */
N
N#define BS_jmpBoot			0
N#define BS_OEMName			3
N#define BPB_BytsPerSec		11
N#define BPB_SecPerClus		13
N#define BPB_RsvdSecCnt		14
N#define BPB_NumFATs			16
N#define BPB_RootEntCnt		17
N#define BPB_TotSec16		19
N#define BPB_Media			21
N#define BPB_FATSz16			22
N#define BPB_SecPerTrk		24
N#define BPB_NumHeads		26
N#define BPB_HiddSec			28
N#define BPB_TotSec32		32
N#define BS_55AA				510
N
N#define BS_DrvNum			36
N#define BS_BootSig			38
N#define BS_VolID			39
N#define BS_VolLab			43
N#define BS_FilSysType		54
N
N#define BPB_FATSz32			36
N#define BPB_ExtFlags		40
N#define BPB_FSVer			42
N#define BPB_RootClus		44
N#define BPB_FSInfo			48
N#define BPB_BkBootSec		50
N#define BS_DrvNum32			64
N#define BS_BootSig32		66
N#define BS_VolID32			67
N#define BS_VolLab32			71
N#define BS_FilSysType32		82
N
N#define	FSI_LeadSig			0
N#define	FSI_StrucSig		484
N#define	FSI_Free_Count		488
N#define	FSI_Nxt_Free		492
N
N#define MBR_Table			446
N
N#define	DIR_Name			0
N#define	DIR_Attr			11
N#define	DIR_NTres			12
N#define	DIR_CrtTime			14
N#define	DIR_CrtDate			16
N#define	DIR_FstClusHI		20
N#define	DIR_WrtTime			22
N#define	DIR_WrtDate			24
N#define	DIR_FstClusLO		26
N#define	DIR_FileSize		28
N#define	LDIR_Ord			0
N#define	LDIR_Attr			11
N#define	LDIR_Type			12
N#define	LDIR_Chksum			13
N#define	LDIR_FstClusLO		26
N
N
N
N/*--------------------------------*/
N/* Multi-byte word access macros  */
N
N#if _WORD_ACCESS == 1	/* Enable word access to the FAT structure */
X#if 0 == 1	 
S#define	LD_WORD(ptr)		(WORD)(*(WORD*)(BYTE*)(ptr))
S#define	LD_DWORD(ptr)		(DWORD)(*(DWORD*)(BYTE*)(ptr))
S#define	ST_WORD(ptr,val)	*(WORD*)(BYTE*)(ptr)=(WORD)(val)
S#define	ST_DWORD(ptr,val)	*(DWORD*)(BYTE*)(ptr)=(DWORD)(val)
N#else					/* Use byte-by-byte access to the FAT structure */
N#define	LD_WORD(ptr)		(WORD)(((WORD)*(BYTE*)((ptr)+1)<<8)|(WORD)*(BYTE*)(ptr))
N#define	LD_DWORD(ptr)		(DWORD)(((DWORD)*(BYTE*)((ptr)+3)<<24)|((DWORD)*(BYTE*)((ptr)+2)<<16)|((WORD)*(BYTE*)((ptr)+1)<<8)|*(BYTE*)(ptr))
N#define	ST_WORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *(BYTE*)((ptr)+1)=(BYTE)((WORD)(val)>>8)
N#define	ST_DWORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *(BYTE*)((ptr)+1)=(BYTE)((WORD)(val)>>8); *(BYTE*)((ptr)+2)=(BYTE)((DWORD)(val)>>16); *(BYTE*)((ptr)+3)=(BYTE)((DWORD)(val)>>24)
N#endif
N
N
N#endif /* _FATFS */
L 80 "atmel\ff.c" 2
N#include "diskio.h"		/* Declarations of low level disk I/O functions */
N
N/*--------------------------------------------------------------------------
N
N   Module Private Definitions
N
N---------------------------------------------------------------------------*/
N
N#if _FATFS != 0x007E
X#if 0x007E != 0x007E
S#error Wrong include file (ff.h).
N#endif
N
N#if _FS_REENTRANT
X#if 0
S#if _USE_LFN == 1
S#error Static LFN work area must not be used in re-entrant configuration.
S#endif
S#define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
S#define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
S
N#else
N#define	ENTER_FF(fs)
N#define LEAVE_FF(fs, res)	return res
N
N#endif
N
N#define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
N
N#ifndef NULL
N#define	NULL	0
N#endif
N
N/* Name status flags */
N#define NS			11		/* Offset of name status byte */
N#define NS_LOSS		0x01	/* Out of 8.3 format */
N#define NS_LFN		0x02	/* Force to create LFN entry */
N#define NS_LAST		0x04	/* Last segment */
N#define NS_BODY		0x08	/* Lower case flag (body) */
N#define NS_EXT		0x10	/* Lower case flag (ext) */
N#define NS_DOT		0x20	/* Dot entry */
N
N
N
N
N/*--------------------------------------------------------------------------
N
N   Private Work Area
N
N---------------------------------------------------------------------------*/
N
N#if _DRIVES < 1 || _DRIVES > 9
X#if 1 < 1 || 1 > 9
S#error Number of drives must be 1-9.
N#endif
Nstatic
NFATFS *FatFs[_DRIVES];	/* Pointer to the file system objects (logical drives) */
XFATFS *FatFs[1];	 
N
Nstatic
NWORD Fsid;				/* File system mount ID */
N
N#if _FS_RPATH
X#if 0
Sstatic
SBYTE Drive;				/* Current drive */
N#endif
N
N
N#if _USE_LFN == 1	/* LFN with static LFN working buffer */
X#if 0 == 1	 
Sstatic
SWCHAR LfnBuf[_MAX_LFN + 1];
S#define	NAMEBUF(sp,lp)	BYTE sp[12]; WCHAR *lp = LfnBuf
S#define INITBUF(dj,sp,lp)	dj.fn = sp; dj.lfn = lp
S
S#elif _USE_LFN > 1	/* LFN with dynamic LFN working buffer */
X#elif 0 > 1	 
S#define	NAMEBUF(sp,lp)	BYTE sp[12]; WCHAR lbuf[_MAX_LFN + 1], *lp = lbuf
S#define INITBUF(dj,sp,lp)	dj.fn = sp; dj.lfn = lp
S
N#else				/* No LFN */
N#define	NAMEBUF(sp,lp)	BYTE sp[12]
N#define INITBUF(dj,sp,lp)	dj.fn = sp
N
N#endif
N
N
N
N
N/*--------------------------------------------------------------------------
N
N   Module Private Functions
N
N---------------------------------------------------------------------------*/
N
N
N/*-----------------------------------------------------------------------*/
N/* String functions                                                      */
N/*-----------------------------------------------------------------------*/
N
N/* Copy memory to memory */
Nstatic
Nvoid mem_cpy (void* dst, const void* src, int cnt) {
N	char *d = (char*)dst;
N	const char *s = (const char *)src;
N	while (cnt--) *d++ = *s++;
N}
N
N/* Fill memory */
Nstatic
Nvoid mem_set (void* dst, int val, int cnt) {
N	char *d = (char*)dst;
N	while (cnt--) *d++ = (char)val;
N}
N
N/* Compare memory to memory */
Nstatic
Nint mem_cmp (const void* dst, const void* src, int cnt) {
N	const char *d = (const char *)dst, *s = (const char *)src;
N	int r = 0;
N	while (cnt-- && (r = *d++ - *s++) == 0) ;
N	return r;
N}
N
N/* Check if chr is contained in the string */
Nstatic
Nint chk_chr (const char* str, int chr) {
N	while (*str && *str != chr) str++;
N	return *str;
N}
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Request/Release grant to access the volume                            */
N/*-----------------------------------------------------------------------*/
N#if _FS_REENTRANT
X#if 0
S
Sstatic
SBOOL lock_fs (
S	FATFS *fs		/* File system object */
S)
S{
S	return ff_req_grant(fs->sobj);
S}
S
S
Sstatic
Svoid unlock_fs (
S	FATFS *fs,		/* File system object */
S	FRESULT res		/* Result code to be returned */
S)
S{
S	if (res != FR_NOT_ENABLED &&
S		res != FR_INVALID_DRIVE &&
S		res != FR_INVALID_OBJECT &&
S		res != FR_TIMEOUT) {
S		ff_rel_grant(fs->sobj);
S	}
S}
N#endif
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Change window offset                                                  */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT move_window (
N	FATFS *fs,		/* File system object */
N	DWORD sector	/* Sector number to make apperance in the fs->win[] */
N)					/* Move to zero only writes back dirty window */
N{
N	DWORD wsect;
N
N
N	wsect = fs->winsect;
N	if (wsect != sector) {	/* Changed current window */
N#if !_FS_READONLY
X#if !0
N		if (fs->wflag) {	/* Write back dirty window if needed */
N			if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
N				return FR_DISK_ERR;
N			fs->wflag = 0;
N			if (wsect < (fs->fatbase + fs->sects_fat)) {	/* In FAT area */
N				BYTE nf;
N				for (nf = fs->n_fats; nf > 1; nf--) {	/* Refrect the change to all FAT copies */
N					wsect += fs->sects_fat;
N					disk_write(fs->drive, fs->win, wsect, 1);
N				}
N			}
N		}
N#endif
N		if (sector) {
N			if (disk_read(fs->drive, fs->win, sector, 1) != RES_OK)
N				return FR_DISK_ERR;
N			fs->winsect = sector;
N		}
N	}
N
N	return FR_OK;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Clean-up cached data                                                  */
N/*-----------------------------------------------------------------------*/
N#if !_FS_READONLY
X#if !0
Nstatic
NFRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
N	FATFS *fs	/* File system object */
N)
N{
N	FRESULT res;
N
N
N	res = move_window(fs, 0);
N	if (res == FR_OK) {
N		/* Update FSInfo sector if needed */
N		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
X		if (fs->fs_type == 3 && fs->fsi_flag) {
N			fs->winsect = 0;
N			mem_set(fs->win, 0, 512);
N			ST_WORD(fs->win+BS_55AA, 0xAA55);
X			*(BYTE*)(fs->win+510)=(BYTE)(0xAA55); *(BYTE*)((fs->win+510)+1)=(BYTE)((WORD)(0xAA55)>>8);
N			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
X			*(BYTE*)(fs->win+0)=(BYTE)(0x41615252); *(BYTE*)((fs->win+0)+1)=(BYTE)((WORD)(0x41615252)>>8); *(BYTE*)((fs->win+0)+2)=(BYTE)((DWORD)(0x41615252)>>16); *(BYTE*)((fs->win+0)+3)=(BYTE)((DWORD)(0x41615252)>>24);
N			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
X			*(BYTE*)(fs->win+484)=(BYTE)(0x61417272); *(BYTE*)((fs->win+484)+1)=(BYTE)((WORD)(0x61417272)>>8); *(BYTE*)((fs->win+484)+2)=(BYTE)((DWORD)(0x61417272)>>16); *(BYTE*)((fs->win+484)+3)=(BYTE)((DWORD)(0x61417272)>>24);
N			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
X			*(BYTE*)(fs->win+488)=(BYTE)(fs->free_clust); *(BYTE*)((fs->win+488)+1)=(BYTE)((WORD)(fs->free_clust)>>8); *(BYTE*)((fs->win+488)+2)=(BYTE)((DWORD)(fs->free_clust)>>16); *(BYTE*)((fs->win+488)+3)=(BYTE)((DWORD)(fs->free_clust)>>24);
N			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
X			*(BYTE*)(fs->win+492)=(BYTE)(fs->last_clust); *(BYTE*)((fs->win+492)+1)=(BYTE)((WORD)(fs->last_clust)>>8); *(BYTE*)((fs->win+492)+2)=(BYTE)((DWORD)(fs->last_clust)>>16); *(BYTE*)((fs->win+492)+3)=(BYTE)((DWORD)(fs->last_clust)>>24);
N			disk_write(fs->drive, fs->win, fs->fsi_sector, 1);
N			fs->fsi_flag = 0;
N		}
N		/* Make sure that no pending write process in the physical drive */
N		if (disk_ioctl(fs->drive, CTRL_SYNC, (void*)NULL) != RES_OK)
X		if (disk_ioctl(fs->drive, 0, (void*)0) != RES_OK)
N			res = FR_DISK_ERR;
N	}
N
N	return res;
N}
N#endif
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* FAT access - Read value of a FAT entry                                */
N/*-----------------------------------------------------------------------*/
N
N
NDWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Interal error, Else:Cluster status */
N	FATFS *fs,	/* File system object */
N	DWORD clst	/* Cluster# to get the link information */
N)
N{
N	UINT wc, bc;
N	DWORD fsect;
N
N
N	if (clst < 2 || clst >= fs->max_clust)	/* Range check */
N		return 1;
N
N	fsect = fs->fatbase;
N	switch (fs->fs_type) {
N	case FS_FAT12 :
X	case 1 :
N		bc = clst; bc += bc / 2;
N		if (move_window(fs, fsect + (bc / SS(fs)))) break;
X		if (move_window(fs, fsect + (bc / 512U))) break;
N		wc = fs->win[bc & (SS(fs) - 1)]; bc++;
X		wc = fs->win[bc & (512U - 1)]; bc++;
N		if (move_window(fs, fsect + (bc / SS(fs)))) break;
X		if (move_window(fs, fsect + (bc / 512U))) break;
N		wc |= (WORD)fs->win[bc & (SS(fs) - 1)] << 8;
X		wc |= (WORD)fs->win[bc & (512U - 1)] << 8;
N		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
N
N	case FS_FAT16 :
X	case 2 :
N		if (move_window(fs, fsect + (clst / (SS(fs) / 2)))) break;
X		if (move_window(fs, fsect + (clst / (512U / 2)))) break;
N		return LD_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)]);
X		return (WORD)(((WORD)*(BYTE*)((&fs->win[((WORD)clst * 2) & (512U - 1)])+1)<<8)|(WORD)*(BYTE*)(&fs->win[((WORD)clst * 2) & (512U - 1)]));
N
N	case FS_FAT32 :
X	case 3 :
N		if (move_window(fs, fsect + (clst / (SS(fs) / 4)))) break;
X		if (move_window(fs, fsect + (clst / (512U / 4)))) break;
N		return LD_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)]) & 0x0FFFFFFF;
X		return (DWORD)(((DWORD)*(BYTE*)((&fs->win[((WORD)clst * 4) & (512U - 1)])+3)<<24)|((DWORD)*(BYTE*)((&fs->win[((WORD)clst * 4) & (512U - 1)])+2)<<16)|((WORD)*(BYTE*)((&fs->win[((WORD)clst * 4) & (512U - 1)])+1)<<8)| *(BYTE*)(&fs->win[((WORD)clst * 4) & (512U - 1)])) & 0x0FFFFFFF;
N	}
N
N	return 0xFFFFFFFF;	/* An error occured at the disk I/O layer */
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* FAT access - Change value of a FAT entry                              */
N/*-----------------------------------------------------------------------*/
N#if !_FS_READONLY
X#if !0
N
NFRESULT put_fat (
N	FATFS *fs,	/* File system object */
N	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->max_clust - 1 */
N	DWORD val	/* New value to mark the cluster */
N)
N{
N	UINT bc;
N	BYTE *p;
N	DWORD fsect;
N	FRESULT res;
N
N
N	if (clst < 2 || clst >= fs->max_clust) {	/* Range check */
N		res = FR_INT_ERR;
N
N	} else {
N		fsect = fs->fatbase;
N		switch (fs->fs_type) {
N		case FS_FAT12 :
X		case 1 :
N			bc = clst; bc += bc / 2;
N			res = move_window(fs, fsect + (bc / SS(fs)));
X			res = move_window(fs, fsect + (bc / 512U));
N			if (res != FR_OK) break;
N			p = &fs->win[bc & (SS(fs) - 1)];
X			p = &fs->win[bc & (512U - 1)];
N			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
N			bc++;
N			fs->wflag = 1;
N			res = move_window(fs, fsect + (bc / SS(fs)));
X			res = move_window(fs, fsect + (bc / 512U));
N			if (res != FR_OK) break;
N			p = &fs->win[bc & (SS(fs) - 1)];
X			p = &fs->win[bc & (512U - 1)];
N			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
N			break;
N
N		case FS_FAT16 :
X		case 2 :
N			res = move_window(fs, fsect + (clst / (SS(fs) / 2)));
X			res = move_window(fs, fsect + (clst / (512U / 2)));
N			if (res != FR_OK) break;
N			ST_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)], (WORD)val);
X			*(BYTE*)(&fs->win[((WORD)clst * 2) & (512U - 1)])=(BYTE)((WORD)val); *(BYTE*)((&fs->win[((WORD)clst * 2) & (512U - 1)])+1)=(BYTE)((WORD)((WORD)val)>>8);
N			break;
N
N		case FS_FAT32 :
X		case 3 :
N			res = move_window(fs, fsect + (clst / (SS(fs) / 4)));
X			res = move_window(fs, fsect + (clst / (512U / 4)));
N			if (res != FR_OK) break;
N			ST_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)], val);
X			*(BYTE*)(&fs->win[((WORD)clst * 4) & (512U - 1)])=(BYTE)(val); *(BYTE*)((&fs->win[((WORD)clst * 4) & (512U - 1)])+1)=(BYTE)((WORD)(val)>>8); *(BYTE*)((&fs->win[((WORD)clst * 4) & (512U - 1)])+2)=(BYTE)((DWORD)(val)>>16); *(BYTE*)((&fs->win[((WORD)clst * 4) & (512U - 1)])+3)=(BYTE)((DWORD)(val)>>24);
N			break;
N
N		default :
N			res = FR_INT_ERR;
N		}
N		fs->wflag = 1;
N	}
N
N	return res;
N}
N#endif /* !_FS_READONLY */
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* FAT handling - Remove a cluster chain                                 */
N/*-----------------------------------------------------------------------*/
N#if !_FS_READONLY
X#if !0
Nstatic
NFRESULT remove_chain (
N	FATFS *fs,			/* File system object */
N	DWORD clst			/* Cluster# to remove a chain from */
N)
N{
N	FRESULT res;
N	DWORD nxt;
N
N
N	if (clst < 2 || clst >= fs->max_clust) {	/* Check the range of cluster# */
N		res = FR_INT_ERR;
N
N	} else {
N		res = FR_OK;
N		while (clst < fs->max_clust) {			/* Not a last link? */
N			nxt = get_fat(fs, clst);			/* Get cluster status */
N			if (nxt == 0) break;				/* Empty cluster? */
N			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
N			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
N			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
N			if (res != FR_OK) break;
N			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
N				fs->free_clust++;
N				fs->fsi_flag = 1;
N			}
N			clst = nxt;	/* Next cluster */
N		}
N	}
N
N	return res;
N}
N#endif
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* FAT handling - Stretch or Create a cluster chain                      */
N/*-----------------------------------------------------------------------*/
N#if !_FS_READONLY
X#if !0
Nstatic
NDWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
N	FATFS *fs,			/* File system object */
N	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
N)
N{
N	DWORD cs, ncl, scl, mcl;
N
N
N	mcl = fs->max_clust;
N	if (clst == 0) {		/* Create new chain */
N		scl = fs->last_clust;			/* Get suggested start point */
N		if (scl == 0 || scl >= mcl) scl = 1;
N	}
N	else {					/* Stretch existing chain */
N		cs = get_fat(fs, clst);			/* Check the cluster status */
N		if (cs < 2) return 1;			/* It is an invalid cluster */
N		if (cs < mcl) return cs;		/* It is already followed by next cluster */
N		scl = clst;
N	}
N
N	ncl = scl;				/* Start cluster */
N	for (;;) {
N		ncl++;							/* Next cluster */
N		if (ncl >= mcl) {				/* Wrap around */
N			ncl = 2;
N			if (ncl > scl) return 0;	/* No free custer */
N		}
N		cs = get_fat(fs, ncl);			/* Get the cluster status */
N		if (cs == 0) break;				/* Found a free cluster */
N		if (cs == 0xFFFFFFFF || cs == 1)/* An error occured */
N			return cs;
N		if (ncl == scl) return 0;		/* No free custer */
N	}
N
N	if (put_fat(fs, ncl, 0x0FFFFFFF))	/* Mark the new cluster "in use" */
N		return 0xFFFFFFFF;
N	if (clst != 0) {					/* Link it to the previous one if needed */
N		if (put_fat(fs, clst, ncl))
N			return 0xFFFFFFFF;
N	}
N
N	fs->last_clust = ncl;				/* Update FSINFO */
N	if (fs->free_clust != 0xFFFFFFFF) {
N		fs->free_clust--;
N		fs->fsi_flag = 1;
N	}
N
N	return ncl;		/* Return new cluster number */
N}
N#endif /* !_FS_READONLY */
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Get sector# from cluster#                                             */
N/*-----------------------------------------------------------------------*/
N
N
NDWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
N	FATFS *fs,		/* File system object */
N	DWORD clst		/* Cluster# to be converted */
N)
N{
N	clst -= 2;
N	if (clst >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
N	return clst * fs->csize + fs->database;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Directory handling - Seek directory index                             */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT dir_seek (
N	DIR *dj,		/* Pointer to directory object */
N	WORD idx		/* Directory index number */
N)
N{
N	DWORD clst;
N	WORD ic;
N
N
N	dj->index = idx;
N	clst = dj->sclust;
N	if (clst == 1 || clst >= dj->fs->max_clust)	/* Check start cluster range */
N		return FR_INT_ERR;
N	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
X	if (!clst && dj->fs->fs_type == 3)	 
N		clst = dj->fs->dirbase;
N
N	if (clst == 0) {	/* Static table */
N		dj->clust = clst;
N		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
N			return FR_INT_ERR;
N		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / 32);	/* Sector# */
X		dj->sect = dj->fs->dirbase + idx / (512U / 32);	 
N	}
N	else {				/* Dynamic table */
N		ic = SS(dj->fs) / 32 * dj->fs->csize;	/* Entries per cluster */
X		ic = 512U / 32 * dj->fs->csize;	 
N		while (idx >= ic) {	/* Follow cluster chain */
N			clst = get_fat(dj->fs, clst);				/* Get next cluster */
N			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
N			if (clst < 2 || clst >= dj->fs->max_clust)	/* Reached to end of table or int error */
N				return FR_INT_ERR;
N			idx -= ic;
N		}
N		dj->clust = clst;
N		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / 32);	/* Sector# */
X		dj->sect = clust2sect(dj->fs, clst) + idx / (512U / 32);	 
N	}
N
N	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / 32)) * 32;	/* Ptr to the entry in the sector */
X	dj->dir = dj->fs->win + (idx % (512U / 32)) * 32;	 
N
N	return FR_OK;	/* Seek succeeded */
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Directory handling - Move directory index next                        */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not streach */
N	DIR *dj,		/* Pointer to directory object */
N	BOOL streach	/* FALSE: Do not streach table, TRUE: Streach table if needed */
N)
N{
N	DWORD clst;
N	WORD i;
N
N
N	i = dj->index + 1;
N	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
N		return FR_NO_FILE;
N
N	if (!(i % (SS(dj->fs) / 32))) {	/* Sector changed? */
X	if (!(i % (512U / 32))) {	 
N		dj->sect++;					/* Next sector */
N
N		if (dj->clust == 0) {	/* Static table */
N			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
N				return FR_NO_FILE;
N		}
N		else {					/* Dynamic table */
N			if (((i / (SS(dj->fs) / 32)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
X			if (((i / (512U / 32)) & (dj->fs->csize - 1)) == 0) {	 
N				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
N				if (clst <= 1) return FR_INT_ERR;
N				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
N				if (clst >= dj->fs->max_clust) {				/* When it reached end of dynamic table */
N#if !_FS_READONLY
X#if !0
N					BYTE c;
N					if (!streach) return FR_NO_FILE;			/* When do not streach, report EOT */
N					clst = create_chain(dj->fs, dj->clust);		/* Streach cluster chain */
N					if (clst == 0) return FR_DENIED;			/* No free cluster */
N					if (clst == 1) return FR_INT_ERR;
N					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
N					/* Clean-up streached table */
N					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
N					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
X					mem_set(dj->fs->win, 0, 512U);			 
N					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
N					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
N						dj->fs->wflag = 1;
N						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
N						dj->fs->winsect++;
N					}
N					dj->fs->winsect -= c;						/* Rewind window address */
N#else
S					return FR_NO_FILE;			/* Report EOT */
N#endif
N				}
N				dj->clust = clst;				/* Initialize data for new cluster */
N				dj->sect = clust2sect(dj->fs, clst);
N			}
N		}
N	}
N
N	dj->index = i;
N	dj->dir = dj->fs->win + (i % (SS(dj->fs) / 32)) * 32;
X	dj->dir = dj->fs->win + (i % (512U / 32)) * 32;
N
N	return FR_OK;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
N/*-----------------------------------------------------------------------*/
N#if _USE_LFN
X#if 0
Sstatic
Sconst BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
S
S
Sstatic
SBOOL cmp_lfn (			/* TRUE:Matched, FALSE:Not matched */
S	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
S	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
S)
S{
S	int i, s;
S	WCHAR wc, uc;
S
S
S	i = ((dir[LDIR_Ord] & 0xBF) - 1) * 13;	/* Get offset in the LFN buffer */
S	s = 0; wc = 1;
S	do {
S		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
S		if (wc) {	/* Last char has not been processed */
S			wc = ff_wtoupper(uc);		/* Convert it to upper case */
S			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
S				return FALSE;			/* Not matched */
S		} else {
S			if (uc != 0xFFFF) return FALSE;	/* Check filler */
S		}
S	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
S
S	if ((dir[LDIR_Ord] & 0x40) && wc && lfnbuf[i])	/* Last segment matched but different length */
S		return FALSE;
S
S	return TRUE;					/* The part of LFN matched */
S}
S
S
S
Sstatic
SBOOL pick_lfn (			/* TRUE:Succeeded, FALSE:Buffer overflow */
S	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
S	BYTE *dir			/* Pointer to the directory entry */
S)
S{
S	int i, s;
S	WCHAR wc, uc;
S
S
S	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
S
S	s = 0; wc = 1;
S	do {
S		uc = LD_WORD(dir+LfnOfs[s]);			/* Pick an LFN character from the entry */
S		if (wc) {	/* Last char has not been processed */
S			if (i >= _MAX_LFN) return FALSE;	/* Buffer overflow? */
S			lfnbuf[i++] = wc = uc;				/* Store it */
S		} else {
S			if (uc != 0xFFFF) return FALSE;		/* Check filler */
S		}
S	} while (++s < 13);						/* Read all character in the entry */
S
S	if (dir[LDIR_Ord] & 0x40) {				/* Put terminator if it is the last LFN part */
S		if (i >= _MAX_LFN) return FALSE;	/* Buffer overflow? */
S		lfnbuf[i] = 0;
S	}
S
S	return TRUE;
S}
S
S
S#if !_FS_READONLY
Sstatic
Svoid fit_lfn (
S	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
S	BYTE *dir,				/* Pointer to the directory entry */
S	BYTE ord,				/* LFN order (1-20) */
S	BYTE sum				/* SFN sum */
S)
S{
S	int i, s;
S	WCHAR wc;
S
S
S	dir[LDIR_Chksum] = sum;			/* Set check sum */
S	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
S	dir[LDIR_Type] = 0;
S	ST_WORD(dir+LDIR_FstClusLO, 0);
S
S	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
S	s = wc = 0;
S	do {
S		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
S		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
S		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
S	} while (++s < 13);
S	if (wc == 0xFFFF || !lfnbuf[i]) ord |= 0x40;	/* Bottom LFN part is the start of LFN sequence */
S	dir[LDIR_Ord] = ord;			/* Set the LFN order */
S}
S
S#endif
N#endif
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Create numbered name                                                  */
N/*-----------------------------------------------------------------------*/
N#if _USE_LFN
X#if 0
Svoid gen_numname (
S	BYTE *dst,			/* Pointer to genartated SFN */
S	const BYTE *src,	/* Pointer to source SFN to be modified */
S	const WCHAR *lfn,	/* Pointer to LFN */
S	WORD num			/* Sequense number */
S)
S{
S	char ns[8];
S	int i, j;
S
S
S	mem_cpy(dst, src, 11);
S
S	if (num > 5) {	/* On many collisions, generate a hash number instead of sequencial number */
S		do num = (num >> 1) + (num << 15) + (WORD)*lfn++; while (*lfn);
S	}
S
S	/* itoa */
S	i = 7;
S	do {
S		ns[i--] = (num % 10) + '0';
S		num /= 10;
S	} while (num);
S	ns[i] = '~';
S
S	/* Append the number */
S	for (j = 0; j < i && dst[j] != ' '; j++) {
S		if (IsDBCS1(dst[j])) {
S			if (j == i - 1) break;
S			j++;
S		}
S	}
S	do {
S		dst[j++] = (i < 8) ? ns[i++] : ' ';
S	} while (j < 8);
S}
N#endif
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Calculate sum of an SFN                                               */
N/*-----------------------------------------------------------------------*/
N#if _USE_LFN
X#if 0
Sstatic
SBYTE sum_sfn (
S	const BYTE *dir		/* Ptr to directory entry */
S)
S{
S	BYTE sum = 0;
S	int n = 11;
S
S	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
S	return sum;
S}
N#endif
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Directory handling - Find an object in the directory                  */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT dir_find (
N	DIR *dj			/* Pointer to the directory object linked to the file name */
N)
N{
N	FRESULT res;
N	BYTE c, *dir;
N#if _USE_LFN
X#if 0
S	BYTE a, ord, sum;
N#endif
N
N	res = dir_seek(dj, 0);			/* Rewind directory object */
N	if (res != FR_OK) return res;
N
N#if _USE_LFN
X#if 0
S	ord = sum = 0xFF;
N#endif
N	do {
N		res = move_window(dj->fs, dj->sect);
N		if (res != FR_OK) break;
N		dir = dj->dir;					/* Ptr to the directory entry of current index */
N		c = dir[DIR_Name];
X		c = dir[0];
N		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
N#if _USE_LFN	/* LFN configuration */
X#if 0	 
S		a = dir[DIR_Attr] & AM_MASK;
S		if (c == 0xE5 || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
S			ord = 0xFF;
S		} else {
S			if (a == AM_LFN) {			/* An LFN entry is found */
S				if (dj->lfn) {
S					if (c & 0x40) {		/* Is it start of LFN sequence? */
S						sum = dir[LDIR_Chksum];
S						c &= 0xBF; ord = c;	/* LFN start order */
S						dj->lfn_idx = dj->index;
S					}
S					/* Check validity of the LFN entry and compare it with given name */
S					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
S				}
S			} else {					/* An SFN entry is found */
S				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
S				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
S				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
S			}
S		}
N#else		/* Non LFN configuration */
N		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
X		if (!(dir[11] & 0x08) && !mem_cmp(dir, dj->fn, 11))  
N			break;
N#endif
N		res = dir_next(dj, FALSE);		/* Next entry */
N	} while (res == FR_OK);
N
N	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Read an object from the directory                                     */
N/*-----------------------------------------------------------------------*/
N#if _FS_MINIMIZE <= 1
X#if 0 <= 1
Nstatic
NFRESULT dir_read (
N	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
N)
N{
N	FRESULT res;
N	BYTE c, *dir;
N#if _USE_LFN
X#if 0
S	BYTE a, ord = 0xFF, sum = 0xFF;
N#endif
N
N	res = FR_NO_FILE;
N	while (dj->sect) {
N		res = move_window(dj->fs, dj->sect);
N		if (res != FR_OK) break;
N		dir = dj->dir;					/* Ptr to the directory entry of current index */
N		c = dir[DIR_Name];
X		c = dir[0];
N		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
N#if _USE_LFN	/* LFN configuration */
X#if 0	 
S		a = dir[DIR_Attr] & AM_MASK;
S		if (c == 0xE5 || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
S			ord = 0xFF;
S		} else {
S			if (a == AM_LFN) {			/* An LFN entry is found */
S				if (c & 0x40) {			/* Is it start of LFN sequence? */
S					sum = dir[LDIR_Chksum];
S					c &= 0xBF; ord = c;
S					dj->lfn_idx = dj->index;
S				}
S				/* Check LFN validity and capture it */
S				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
S			} else {					/* An SFN entry is found */
S				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
S					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
S				break;
S			}
S		}
N#else		/* Non LFN configuration */
N		if (c != 0xE5 && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
X		if (c != 0xE5 && (0 || c != '.') && !(dir[11] & 0x08))	 
N			break;
N#endif
N		res = dir_next(dj, FALSE);				/* Next entry */
N		if (res != FR_OK) break;
N	}
N
N	if (res != FR_OK) dj->sect = 0;
N
N	return res;
N}
N#endif
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Register an object to the directory                                   */
N/*-----------------------------------------------------------------------*/
N#if !_FS_READONLY
X#if !0
Nstatic
NFRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
N	DIR *dj				/* Target directory with object name to be created */
N)
N{
N	FRESULT res;
N	BYTE c, *dir;
N#if _USE_LFN	/* LFN configuration */
X#if 0	 
S	WORD n, ne, is;
S	BYTE sn[12], *fn, sum;
S	WCHAR *lfn;
S
S
S	fn = dj->fn; lfn = dj->lfn;
S	mem_cpy(sn, fn, 12);
S
S	if (_FS_RPATH && (sn[NS] & NS_DOT)) return FR_INVALID_NAME;	/* Cannot create dot entry */
S
S	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
S		fn[NS] = 0; dj->lfn = NULL;			/* Find only SFN */
S		for (n = 1; n < 100; n++) {
S			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
S			res = dir_find(dj);				/* Check if the name collides with existing SFN */
S			if (res != FR_OK) break;
S		}
S		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
S		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
S		fn[NS] = sn[NS]; dj->lfn = lfn;
S	}
S
S	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve reserve an SFN + LFN entries. */
S		for (ne = 0; lfn[ne]; ne++) ;
S		ne = (ne + 25) / 13;
S	} else {						/* Otherwise reserve only an SFN entry. */
S		ne = 1;
S	}
S
S	/* Reserve contiguous entries */
S	res = dir_seek(dj, 0);
S	if (res != FR_OK) return res;
S	n = is = 0;
S	do {
S		res = move_window(dj->fs, dj->sect);
S		if (res != FR_OK) break;
S		c = *dj->dir;				/* Check the entry status */
S		if (c == 0xE5 || c == 0) {	/* Is it a blank entry? */
S			if (n == 0) is = dj->index;	/* First index of the contigulus entry */
S			if (++n == ne) break;	/* A contiguous entry that requiered count is found */
S		} else {
S			n = 0;					/* Not a blank entry. Restart to search */
S		}
S		res = dir_next(dj, TRUE);	/* Next entry with table streach */
S	} while (res == FR_OK);
S
S	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
S		res = dir_seek(dj, is);
S		if (res == FR_OK) {
S			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
S			ne--;
S			do {					/* Store LFN entries in bottom first */
S				res = move_window(dj->fs, dj->sect);
S				if (res != FR_OK) break;
S				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
S				dj->fs->wflag = 1;
S				res = dir_next(dj, FALSE);	/* Next entry */
S			} while (res == FR_OK && --ne);
S		}
S	}
S
N#else	/* Non LFN configuration */
N	res = dir_seek(dj, 0);
N	if (res == FR_OK) {
N		do {	/* Find a blank entry for the SFN */
N			res = move_window(dj->fs, dj->sect);
N			if (res != FR_OK) break;
N			c = *dj->dir;
N			if (c == 0xE5 || c == 0) break;	/* Is it a blank entry? */
N			res = dir_next(dj, TRUE);		/* Next entry with table streach */
N		} while (res == FR_OK);
N	}
N#endif
N
N	if (res == FR_OK) {		/* Initialize the SFN entry */
N		res = move_window(dj->fs, dj->sect);
N		if (res == FR_OK) {
N			dir = dj->dir;
N			mem_set(dir, 0, 32);		/* Clean the entry */
N			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
N			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
X			dir[12] = *(dj->fn+11) & (0x08 | 0x10);	 
N			dj->fs->wflag = 1;
N		}
N	}
N
N	return res;
N}
N#endif /* !_FS_READONLY */
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Remove an object from the directory                                   */
N/*-----------------------------------------------------------------------*/
N#if !_FS_READONLY && !_FS_MINIMIZE
X#if !0 && !0
Nstatic
NFRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
N	DIR *dj				/* Directory object pointing the entry to be removed */
N)
N{
N	FRESULT res;
N#if _USE_LFN	/* LFN configuration */
X#if 0	 
S	WORD i;
S
S	i = dj->index;	/* SFN index */
S	res = dir_seek(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
S	if (res == FR_OK) {
S		do {
S			res = move_window(dj->fs, dj->sect);
S			if (res != FR_OK) break;
S			*dj->dir = 0xE5;			/* Mark the entry "deleted" */
S			dj->fs->wflag = 1;
S			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
S			res = dir_next(dj, FALSE);	/* Next entry */
S		} while (res == FR_OK);
S		if (res == FR_NO_FILE) res = FR_INT_ERR;
S	}
S
N#else			/* Non LFN configuration */
N	res = dir_seek(dj, dj->index);
N	if (res == FR_OK) {
N		res = move_window(dj->fs, dj->sect);
N		if (res == FR_OK) {
N			*dj->dir = 0xE5;			/* Mark the entry "deleted" */
N			dj->fs->wflag = 1;
N		}
N	}
N#endif
N
N	return res;
N}
N#endif /* !_FS_READONLY */
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Pick a segment and create the object name in directory form           */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT create_name (
N	DIR *dj,			/* Pointer to the directory object */
N	const XCHAR **path	/* Pointer to pointer to the segment in the path string */
N)
N{
N#ifdef _EXCVT
N	static const BYTE cvt[] = _EXCVT;
X	static const BYTE cvt[] = {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, 0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF};
N#endif
N
N#if _USE_LFN	/* LFN configuration */
X#if 0	 
S	BYTE b, cf;
S	WCHAR w, *lfn;
S	int i, ni, si, di;
S	const XCHAR *p;
S
S	/* Create LFN in Unicode */
S	si = di = 0;
S	p = *path;
S	lfn = dj->lfn;
S	for (;;) {
S		w = p[si++];					/* Get a character */
S		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
S		if (di >= _MAX_LFN)				/* Reject too long name */
S			return FR_INVALID_NAME;
S#if !_LFN_UNICODE
S		w &= 0xFF;
S		if (IsDBCS1(w)) {				/* If it is a DBC 1st byte */
S			b = p[si++];				/* Get 2nd byte */
S			if (!IsDBCS2(b))			/* Reject invalid code for DBC */
S				return FR_INVALID_NAME;
S			w = (w << 8) + b;
S		}
S		w = ff_convert(w, 1);			/* Convert OEM to Unicode */
S		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
S#endif
S		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
S			return FR_INVALID_NAME;
S		lfn[di++] = w;					/* Store the Unicode char */
S	}
S	*path = &p[si];						/* Rerurn pointer to the next segment */
S	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
S#if _FS_RPATH
S	if ((di == 1 && lfn[di - 1] == '.') || /* Is this a dot entry? */
S		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {
S		lfn[di] = 0;
S		for (i = 0; i < 11; i++)
S			dj->fn[i] = (i < di) ? '.' : ' ';
S		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
S		return FR_OK;
S	}
S#endif
S	while (di) {						/* Strip trailing spaces and dots */
S		w = lfn[di - 1];
S		if (w != ' ' && w != '.') break;
S		di--;
S	}
S	if (!di) return FR_INVALID_NAME;	/* Reject null string */
S
S	lfn[di] = 0;						/* LFN is created */
S
S	/* Create SFN in directory form */
S	mem_set(dj->fn, ' ', 11);
S	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
S	if (si) cf |= NS_LOSS | NS_LFN;
S	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
S
S	b = i = 0; ni = 8;
S	for (;;) {
S		w = lfn[si++];					/* Get an LFN char */
S		if (!w) break;					/* Break on enf of the LFN */
S		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
S			cf |= NS_LOSS | NS_LFN; continue;
S		}
S
S		if (i >= ni || si == di) {		/* Extension or end of SFN */
S			if (ni == 11) {				/* Long extension */
S				cf |= NS_LOSS | NS_LFN; break;
S			}
S			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
S			if (si > di) break;			/* No extension */
S			si = di; i = 8; ni = 11;	/* Enter extension section */
S			b <<= 2; continue;
S		}
S
S		if (w >= 0x80) {				/* Non ASCII char */
S#ifdef _EXCVT
S			w = ff_convert(w, 0);		/* Unicode -> OEM code */
S			if (w) w = cvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
S#else
S			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
S#endif
S			cf |= NS_LFN;				/* Force create LFN entry */
S		}
S
S		if (_DF1S && w >= 0x100) {		/* Double byte char */
S			if (i >= ni - 1) {
S				cf |= NS_LOSS | NS_LFN; i = ni; continue;
S			}
S			dj->fn[i++] = (BYTE)(w >> 8);
S		} else {						/* Single byte char */
S			if (!w || chk_chr("+,;[=]", w)) {		/* Replace illegal chars for SFN */
S				w = '_'; cf |= NS_LOSS | NS_LFN;	/* Lossy conversion */
S			} else {
S				if (IsUpper(w)) {		/* ASCII large capital */
S					b |= 2;
S				} else {
S					if (IsLower(w)) {	/* ASCII small capital */
S						b |= 1; w -= 0x20;
S					}
S				}
S			}
S		}
S		dj->fn[i++] = (BYTE)w;
S	}
S
S	if (dj->fn[0] == 0xE5) dj->fn[0] = 0x05;	/* If the first char collides with deleted mark, replace it with 0x05 */
S
S	if (ni == 8) b <<= 2;
S	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
S		cf |= NS_LFN;
S	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
S		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
S		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
S	}
S
S	dj->fn[NS] = cf;	/* SFN is created */
S
S	return FR_OK;
S
S
N#else	/* Non-LFN configuration */
N	BYTE b, c, d, *sfn;
N	int ni, si, i;
N	const char *p;
N
N	/* Create file name in directory form */
N	sfn = dj->fn;
N	mem_set(sfn, ' ', 11);
N	si = i = b = 0; ni = 8;
N	p = *path;
N#if _FS_RPATH
X#if 0
S	if (p[si] == '.') { /* Is this a dot entry? */
S		for (;;) {
S			c = p[si++];
S			if (c != '.' || si >= 3) break;
S			sfn[i++] = c;
S		}
S		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
S		*path = &p[si];									/* Rerurn pointer to the next segment */
S		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
S		return FR_OK;
S	}
N#endif
N	for (;;) {
N		c = p[si++];
N		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
N		if (c == '.' || i >= ni) {
N			if (ni != 8 || c != '.') return FR_INVALID_NAME;
N			i = 8; ni = 11;
N			b <<= 2; continue;
N		}
N		if (c >= 0x80) {				/* Extended char */
N#ifdef _EXCVT
N			c = cvt[c - 0x80];			/* Convert extend char (SBCS) */
N#else
S			b |= 3;						/* Eliminate NT flag if ext char is exist */
S#if !_DF1S	/* ASCII only cfg */
S			return FR_INVALID_NAME;
S#endif
N#endif
N		}
N		if (IsDBCS1(c)) {				/* DBC 1st byte? */
X		if (0) {				 
N			d = p[si++];				/* Get 2nd byte */
N			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
X			if (!0 || i >= ni - 1)	 
N				return FR_INVALID_NAME;
N			sfn[i++] = c;
N			sfn[i++] = d;
N		} else {						/* Single byte code */
N			if (chk_chr(" \"*+,[=]|\x7F", c))	/* Reject illegal chrs for SFN */
N				return FR_INVALID_NAME;
N			if (IsUpper(c)) {			/* ASCII large capital? */
X			if ((((c)>= 'A')&&((c)<= 'Z'))) {			 
N				b |= 2;
N			} else {
N				if (IsLower(c)) {		/* ASCII small capital? */
X				if ((((c)>= 'a')&&((c)<= 'z'))) {		 
N					b |= 1; c -= 0x20;
N				}
N			}
N			sfn[i++] = c;
N		}
N	}
N	*path = &p[si];						/* Rerurn pointer to the next segment */
N	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
X	c = (c <= ' ') ? 0x04 : 0;		 
N
N	if (!i) return FR_INVALID_NAME;		/* Reject null string */
N	if (sfn[0] == 0xE5) sfn[0] = 0x05;	/* When first char collides with 0xE5, replace it with 0x05 */
N
N	if (ni == 8) b <<= 2;
N	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Extension has only small capital) */
X	if ((b & 0x03) == 0x01) c |= 0x10;	 
N	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Filename has only small capital) */
X	if ((b & 0x0C) == 0x04) c |= 0x08;	 
N
N	sfn[NS] = c;		/* Store NT flag, File name is created */
X	sfn[11] = c;		 
N
N	return FR_OK;
N#endif
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Get file information from directory entry                             */
N/*-----------------------------------------------------------------------*/
N#if _FS_MINIMIZE <= 1
X#if 0 <= 1
Nstatic
Nvoid get_fileinfo (		/* No return code */
N	DIR *dj,			/* Pointer to the directory object */
N	FILINFO *fno	 	/* Pointer to the file information to be filled */
N)
N{
N	int i;
N	BYTE c, nt, *dir;
N	char *p;
N
N
N	p = fno->fname;
N	if (dj->sect) {
N		dir = dj->dir;
N		nt = dir[DIR_NTres];		/* NT flag */
X		nt = dir[12];		 
N		for (i = 0; i < 8; i++) {	/* Copy name body */
N			c = dir[i];
N			if (c == ' ') break;
N			if (c == 0x05) c = 0xE5;
N			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
X			if (0 && (nt & 0x08) && (((c)>= 'A')&&((c)<= 'Z'))) c += 0x20;
N			*p++ = c;
N		}
N		if (dir[8] != ' ') {		/* Copy name extension */
N			*p++ = '.';
N			for (i = 8; i < 11; i++) {
N				c = dir[i];
N				if (c == ' ') break;
N				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
X				if (0 && (nt & 0x10) && (((c)>= 'A')&&((c)<= 'Z'))) c += 0x20;
N				*p++ = c;
N			}
N		}
N		fno->fattrib = dir[DIR_Attr];				/* Attribute */
X		fno->fattrib = dir[11];				 
N		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
X		fno->fsize = (DWORD)(((DWORD)*(BYTE*)((dir+28)+3)<<24)|((DWORD)*(BYTE*)((dir+28)+2)<<16)|((WORD)*(BYTE*)((dir+28)+1)<<8)| *(BYTE*)(dir+28));	 
N		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
X		fno->fdate = (WORD)(((WORD)*(BYTE*)((dir+24)+1)<<8)|(WORD)*(BYTE*)(dir+24));		 
N		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
X		fno->ftime = (WORD)(((WORD)*(BYTE*)((dir+22)+1)<<8)|(WORD)*(BYTE*)(dir+22));		 
N	}
N	*p = 0;
N
N#if _USE_LFN
X#if 0
S	if (fno->lfname) {
S		XCHAR *tp = fno->lfname;
S		WCHAR w, *lfn;
S
S		i = 0;
S		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
S			lfn = dj->lfn;
S			while ((w = *lfn++) != 0) {			/* Get an LFN char */
S#if !_LFN_UNICODE
S				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
S				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
S				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC */
S					tp[i++] = (XCHAR)(w >> 8);
S#endif
S				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overrun, no LFN */
S				tp[i++] = (XCHAR)w;
S			}
S		}
S		tp[i] = 0;	/* Terminator */
S	}
N#endif
N}
N#endif /* _FS_MINIMIZE <= 1 */
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Follow a file path                                                    */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
N	DIR *dj,			/* Directory object to return last directory and found object */
N	const XCHAR *path	/* Full-path string to find a file or directory */
N)
N{
N	FRESULT res;
N	BYTE *dir, last;
N
N
N	while (!_USE_LFN && *path == ' ') path++;	/* Skip leading spaces */
X	while (!0 && *path == ' ') path++;	 
N#if _FS_RPATH
X#if 0
S	if (*path == '/' || *path == '\\') { /* There is a heading separator */
S		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
S	} else {							/* No heading saparator */
S		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
S	}
N#else
N	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
N		path++;
N	dj->sclust = 0;						/* Start from the root dir */
N#endif
N
N	if ((UINT)*path < ' ') {			/* Null path means the start directory itself */
N		res = dir_seek(dj, 0);
N		dj->dir = NULL;
X		dj->dir = 0;
N
N	} else {							/* Follow path */
N		for (;;) {
N			res = create_name(dj, &path);	/* Get a segment */
N			if (res != FR_OK) break;
N			res = dir_find(dj);				/* Find it */
N			last = *(dj->fn+NS) & NS_LAST;
X			last = *(dj->fn+11) & 0x04;
N			if (res != FR_OK) {				/* Could not find the object */
N				if (res == FR_NO_FILE && !last)
N					res = FR_NO_PATH;
N				break;
N			}
N			if (last) break;				/* Last segment match. Function completed. */
N			dir = dj->dir;					/* There is next segment. Follow the sub directory */
N			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
X			if (!(dir[11] & 0x10)) {  
N				res = FR_NO_PATH; break;
N			}
N			dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
X			dj->sclust = ((DWORD)(WORD)(((WORD)*(BYTE*)((dir+20)+1)<<8)|(WORD)*(BYTE*)(dir+20)) << 16) | (WORD)(((WORD)*(BYTE*)((dir+26)+1)<<8)|(WORD)*(BYTE*)(dir+26));
N		}
N	}
N
N	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Load boot record and check if it is an FAT boot record                */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NBYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
N	FATFS *fs,	/* File system object */
N	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
N)
N{
N	if (disk_read(fs->drive, fs->win, sect, 1) != RES_OK)	/* Load boot record */
N		return 3;
N	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
X	if ((WORD)(((WORD)*(BYTE*)((&fs->win[510])+1)<<8)|(WORD)*(BYTE*)(&fs->win[510])) != 0xAA55)		 
N		return 2;
N
N	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
X	if (((DWORD)(((DWORD)*(BYTE*)((&fs->win[54])+3)<<24)|((DWORD)*(BYTE*)((&fs->win[54])+2)<<16)|((WORD)*(BYTE*)((&fs->win[54])+1)<<8)| *(BYTE*)(&fs->win[54])) & 0xFFFFFF) == 0x544146)	 
N		return 0;
N	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
X	if (((DWORD)(((DWORD)*(BYTE*)((&fs->win[82])+3)<<24)|((DWORD)*(BYTE*)((&fs->win[82])+2)<<16)|((WORD)*(BYTE*)((&fs->win[82])+1)<<8)| *(BYTE*)(&fs->win[82])) & 0xFFFFFF) == 0x544146)
N		return 0;
N
N	return 1;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Make sure that the file system is valid                               */
N/*-----------------------------------------------------------------------*/
N
N
NFRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occured */
N	const XCHAR **path,	/* Pointer to pointer to the path name (drive number) */
N	FATFS **rfs,		/* Pointer to pointer to the found file system object */
N	BYTE chk_wp			/* !=0: Check media write protection for write access */
N)
N{
N	BYTE fmt, *tbl;
N	UINT vol;
N	DSTATUS stat;
N	DWORD bsect, fsize, tsect, mclst;
N	const XCHAR *p = *path;
N	FATFS *fs;
N
N	/* Get logical drive number from the path name */
N	vol = p[0] - '0';				/* Is there a drive number? */
N	if (vol <= 9 && p[1] == ':') {	/* Found a drive number, get and strip it */
N		p += 2; *path = p;			/* Return pointer to the path name */
N	} else {						/* No drive number is given */
N#if _FS_RPATH
X#if 0
S		vol = Drive;				/* Use current drive */
N#else
N		vol = 0;					/* Use drive 0 */
N#endif
N	}
N
N	/* Check if the logical drive is valid or not */
N	if (vol >= _DRIVES) 			/* Is the drive number valid? */
X	if (vol >= 1) 			 
N		return FR_INVALID_DRIVE;
N	*rfs = fs = FatFs[vol];			/* Returen pointer to the corresponding file system object */
N	if (!fs) return FR_NOT_ENABLED;	/* Is the file system object available? */
N
N	ENTER_FF(fs);					/* Lock file system */
X	;					 
N
N	if (fs->fs_type) {				/* If the logical drive has been mounted */
N		stat = disk_status(fs->drive);
N		if (!(stat & STA_NOINIT)) {	/* and the physical drive is kept initialized (has not been changed), */
X		if (!(stat & 0x01)) {	 
N#if !_FS_READONLY
X#if !0
N			if (chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
X			if (chk_wp && (stat & 0x04))	 
N				return FR_WRITE_PROTECTED;
N#endif
N			return FR_OK;			/* The file system object is valid */
N		}
N	}
N
N	/* The logical drive must be mounted. Following code attempts to mount the volume */
N
N	fs->fs_type = 0;					/* Clear the file system object */
N	fs->drive = (BYTE)LD2PD(vol);		/* Bind the logical drive and a physical drive */
X	fs->drive = (BYTE)(vol);		 
N	stat = disk_initialize(fs->drive);	/* Initialize low level disk I/O layer */
N	if (stat & STA_NOINIT)				/* Check if the drive is ready */
X	if (stat & 0x01)				 
N		return FR_NOT_READY;
N#if _MAX_SS != 512						/* Get disk sector size if needed */
X#if 512 != 512						 
S	if (disk_ioctl(fs->drive, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
S		return FR_NO_FILESYSTEM;
N#endif
N#if !_FS_READONLY
X#if !0
N	if (chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
X	if (chk_wp && (stat & 0x04))	 
N		return FR_WRITE_PROTECTED;
N#endif
N	/* Search FAT partition on the drive */
N	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 as an SFD format */
N	if (fmt == 1) {						/* Not an FAT boot record, it may be patitioned */
N		/* Check a partition listed in top of the partition table */
N		tbl = &fs->win[MBR_Table + LD2PT(vol) * 16];	/* Partition table */
X		tbl = &fs->win[446 + 0 * 16];	 
N		if (tbl[4]) {									/* Is the partition existing? */
N			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
X			bsect = (DWORD)(((DWORD)*(BYTE*)((&tbl[8])+3)<<24)|((DWORD)*(BYTE*)((&tbl[8])+2)<<16)|((WORD)*(BYTE*)((&tbl[8])+1)<<8)| *(BYTE*)(&tbl[8]));					 
N			fmt = check_fs(fs, bsect);					/* Check the partition */
N		}
N	}
N	if (fmt == 3) return FR_DISK_ERR;
N	if (fmt || LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))	/* No valid FAT patition is found */
X	if (fmt || (WORD)(((WORD)*(BYTE*)((fs->win+11)+1)<<8)|(WORD)*(BYTE*)(fs->win+11)) != 512U)	 
N		return FR_NO_FILESYSTEM;
N
N	/* Initialize the file system object */
N	fsize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
X	fsize = (WORD)(((WORD)*(BYTE*)((fs->win+22)+1)<<8)|(WORD)*(BYTE*)(fs->win+22));				 
N	if (!fsize) fsize = LD_DWORD(fs->win+BPB_FATSz32);
X	if (!fsize) fsize = (DWORD)(((DWORD)*(BYTE*)((fs->win+36)+3)<<24)|((DWORD)*(BYTE*)((fs->win+36)+2)<<16)|((WORD)*(BYTE*)((fs->win+36)+1)<<8)| *(BYTE*)(fs->win+36));
N	fs->sects_fat = fsize;
N	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
X	fs->n_fats = fs->win[16];					 
N	fsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
N	fs->fatbase = bsect + LD_WORD(fs->win+BPB_RsvdSecCnt); /* FAT start sector (lba) */
X	fs->fatbase = bsect + (WORD)(((WORD)*(BYTE*)((fs->win+14)+1)<<8)|(WORD)*(BYTE*)(fs->win+14));  
N	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
X	fs->csize = fs->win[13];				 
N	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Nmuber of root directory entries */
X	fs->n_rootdir = (WORD)(((WORD)*(BYTE*)((fs->win+17)+1)<<8)|(WORD)*(BYTE*)(fs->win+17));	 
N	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
X	tsect = (WORD)(((WORD)*(BYTE*)((fs->win+19)+1)<<8)|(WORD)*(BYTE*)(fs->win+19));				 
N	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
X	if (!tsect) tsect = (DWORD)(((DWORD)*(BYTE*)((fs->win+32)+3)<<24)|((DWORD)*(BYTE*)((fs->win+32)+2)<<16)|((WORD)*(BYTE*)((fs->win+32)+1)<<8)| *(BYTE*)(fs->win+32));
N	fs->max_clust = mclst = (tsect						/* Last cluster# + 1 (Number of clusters + 2) */
N		- LD_WORD(fs->win+BPB_RsvdSecCnt) - fsize - fs->n_rootdir / (SS(fs)/32)
X		- (WORD)(((WORD)*(BYTE*)((fs->win+14)+1)<<8)|(WORD)*(BYTE*)(fs->win+14)) - fsize - fs->n_rootdir / (512U/32)
N		) / fs->csize + 2;
N
N	fmt = FS_FAT12;										/* Determine the FAT sub type */
X	fmt = 1;										 
N	if (mclst >= 0xFF7) fmt = FS_FAT16;					/* Number of clusters >= 0xFF5 */
X	if (mclst >= 0xFF7) fmt = 2;					 
N	if (mclst >= 0xFFF7) fmt = FS_FAT32;				/* Number of clusters >= 0xFFF5 */
X	if (mclst >= 0xFFF7) fmt = 3;				 
N
N	if (fmt == FS_FAT32)
X	if (fmt == 3)
N		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
X		fs->dirbase = (DWORD)(((DWORD)*(BYTE*)((fs->win+44)+3)<<24)|((DWORD)*(BYTE*)((fs->win+44)+2)<<16)|((WORD)*(BYTE*)((fs->win+44)+1)<<8)| *(BYTE*)(fs->win+44));	 
N	else
N		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
N	fs->database = fs->fatbase + fsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
X	fs->database = fs->fatbase + fsize + fs->n_rootdir / (512U/32);	 
N
N#if !_FS_READONLY
X#if !0
N	/* Initialize allocation information */
N	fs->free_clust = 0xFFFFFFFF;
N	fs->wflag = 0;
N	/* Get fsinfo if needed */
N	if (fmt == FS_FAT32) {
X	if (fmt == 3) {
N	 	fs->fsi_flag = 0;
N		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
X		fs->fsi_sector = bsect + (WORD)(((WORD)*(BYTE*)((fs->win+48)+1)<<8)|(WORD)*(BYTE*)(fs->win+48));
N		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
N			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
X			(WORD)(((WORD)*(BYTE*)((fs->win+510)+1)<<8)|(WORD)*(BYTE*)(fs->win+510)) == 0xAA55 &&
N			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
X			(DWORD)(((DWORD)*(BYTE*)((fs->win+0)+3)<<24)|((DWORD)*(BYTE*)((fs->win+0)+2)<<16)|((WORD)*(BYTE*)((fs->win+0)+1)<<8)| *(BYTE*)(fs->win+0)) == 0x41615252 &&
N			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
X			(DWORD)(((DWORD)*(BYTE*)((fs->win+484)+3)<<24)|((DWORD)*(BYTE*)((fs->win+484)+2)<<16)|((WORD)*(BYTE*)((fs->win+484)+1)<<8)| *(BYTE*)(fs->win+484)) == 0x61417272) {
N			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
X			fs->last_clust = (DWORD)(((DWORD)*(BYTE*)((fs->win+492)+3)<<24)|((DWORD)*(BYTE*)((fs->win+492)+2)<<16)|((WORD)*(BYTE*)((fs->win+492)+1)<<8)| *(BYTE*)(fs->win+492));
N			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
X			fs->free_clust = (DWORD)(((DWORD)*(BYTE*)((fs->win+488)+3)<<24)|((DWORD)*(BYTE*)((fs->win+488)+2)<<16)|((WORD)*(BYTE*)((fs->win+488)+1)<<8)| *(BYTE*)(fs->win+488));
N		}
N	}
N#endif
N	fs->fs_type = fmt;		/* FAT sub-type */
N	fs->winsect = 0;		/* Invalidate sector cache */
N#if _FS_RPATH
X#if 0
S	fs->cdir = 0;			/* Current directory (root dir) */
N#endif
N	fs->id = ++Fsid;		/* File system mount ID */
N
N	return FR_OK;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Check if the file/dir object is valid or not                          */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
N	FATFS *fs,		/* Pointer to the file system object */
N	WORD id			/* Member id of the target object to be checked */
N)
N{
N	if (!fs || !fs->fs_type || fs->id != id)
N		return FR_INVALID_OBJECT;
N
N	ENTER_FF(fs);		/* Lock file system */
X	;		 
N
N	if (disk_status(fs->drive) & STA_NOINIT)
X	if (disk_status(fs->drive) & 0x01)
N		return FR_NOT_READY;
N
N	return FR_OK;
N}
N
N
N
N
N/*--------------------------------------------------------------------------
N
N   Public Functions
N
N--------------------------------------------------------------------------*/
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Mount/Unmount a Locical Drive                                         */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_mount (
N	BYTE vol,		/* Logical drive number to be mounted/unmounted */
N	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
N)
N{
N	FATFS *rfs;
N
N
N	if (vol >= _DRIVES)				/* Check if the drive number is valid */
X	if (vol >= 1)				 
N		return FR_INVALID_DRIVE;
N	rfs = FatFs[vol];				/* Get current fs object */
N
N	if (rfs) {
N#if _FS_REENTRANT					/* Discard sync object of the current volume */
X#if 0					 
S		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
N#endif
N		rfs->fs_type = 0;			/* Clear old fs object */
N	}
N
N	if (fs) {
N		fs->fs_type = 0;			/* Clear new fs object */
N#if _FS_REENTRANT					/* Create sync object for the new volume */
X#if 0					 
S		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
N#endif
N	}
N	FatFs[vol] = fs;				/* Register new fs object */
N
N	return FR_OK;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Open or Create a File                                                 */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_open (
N	FIL *fp,			/* Pointer to the blank file object */
N	const XCHAR *path,	/* Pointer to the file name */
N	BYTE mode			/* Access mode and file open mode flags */
N)
N{
N	FRESULT res;
N	DIR dj;
N	NAMEBUF(sfn, lfn);
X	BYTE sfn[12];
N	BYTE *dir;
N
N
N	fp->fs = NULL;		/* Clear file object */
X	fp->fs = 0;		 
N#if !_FS_READONLY
X#if !0
N	mode &= (FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW);
X	mode &= (0x01 | 0x02 | 0x08 | 0x10 | 0x04);
N	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & (FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)));
X	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & (0x02 | 0x08 | 0x10 | 0x04)));
N#else
S	mode &= FA_READ;
S	res = chk_mounted(&path, &dj.fs, 0);
N#endif
N	if (res != FR_OK) LEAVE_FF(dj.fs, res);
X	if (res != FR_OK) return res;
N	INITBUF(dj, sfn, lfn);
X	dj . fn = sfn;
N	res = follow_path(&dj, path);	/* Follow the file path */
N
N#if !_FS_READONLY
X#if !0
N	/* Create or Open a file */
N	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
X	if (mode & (0x08 | 0x10 | 0x04)) {
N		DWORD ps, cl;
N
N		if (res != FR_OK) {			/* No file, create new */
N			if (res == FR_NO_FILE)	/* There is no file to open, create a new entry */
N				res = dir_register(&dj);
N			if (res != FR_OK) LEAVE_FF(dj.fs, res);
X			if (res != FR_OK) return res;
N			mode |= FA_CREATE_ALWAYS;
X			mode |= 0x08;
N			dir = dj.dir;			/* Created entry (SFN entry) */
N		}
N		else {						/* Any object is already existing */
N			if (mode & FA_CREATE_NEW)			/* Cannot create new */
X			if (mode & 0x04)			 
N				LEAVE_FF(dj.fs, FR_EXIST);
X				return FR_EXIST;
N			dir = dj.dir;
N			if (!dir || (dir[DIR_Attr] & (AM_RDO | AM_DIR)))	/* Cannot overwrite it (R/O or DIR) */
X			if (!dir || (dir[11] & (0x01 | 0x10)))	 
N				LEAVE_FF(dj.fs, FR_DENIED);
X				return FR_DENIED;
N			if (mode & FA_CREATE_ALWAYS) {		/* Resize it to zero on over write mode */
X			if (mode & 0x08) {		 
N				cl = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);	/* Get start cluster */
X				cl = ((DWORD)(WORD)(((WORD)*(BYTE*)((dir+20)+1)<<8)|(WORD)*(BYTE*)(dir+20)) << 16) | (WORD)(((WORD)*(BYTE*)((dir+26)+1)<<8)|(WORD)*(BYTE*)(dir+26));	 
N				ST_WORD(dir+DIR_FstClusHI, 0);	/* cluster = 0 */
X				*(BYTE*)(dir+20)=(BYTE)(0); *(BYTE*)((dir+20)+1)=(BYTE)((WORD)(0)>>8);	 
N				ST_WORD(dir+DIR_FstClusLO, 0);
X				*(BYTE*)(dir+26)=(BYTE)(0); *(BYTE*)((dir+26)+1)=(BYTE)((WORD)(0)>>8);
N				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
X				*(BYTE*)(dir+28)=(BYTE)(0); *(BYTE*)((dir+28)+1)=(BYTE)((WORD)(0)>>8); *(BYTE*)((dir+28)+2)=(BYTE)((DWORD)(0)>>16); *(BYTE*)((dir+28)+3)=(BYTE)((DWORD)(0)>>24);	 
N				dj.fs->wflag = 1;
N				ps = dj.fs->winsect;			/* Remove the cluster chain */
N				if (cl) {
N					res = remove_chain(dj.fs, cl);
N					if (res) LEAVE_FF(dj.fs, res);
X					if (res) return res;
N					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
N				}
N				res = move_window(dj.fs, ps);
N				if (res != FR_OK) LEAVE_FF(dj.fs, res);
X				if (res != FR_OK) return res;
N			}
N		}
N		if (mode & FA_CREATE_ALWAYS) {
X		if (mode & 0x08) {
N			dir[DIR_Attr] = 0;					/* Reset attribute */
X			dir[11] = 0;					 
N			ps = get_fattime();
N			ST_DWORD(dir+DIR_CrtTime, ps);		/* Created time */
X			*(BYTE*)(dir+14)=(BYTE)(ps); *(BYTE*)((dir+14)+1)=(BYTE)((WORD)(ps)>>8); *(BYTE*)((dir+14)+2)=(BYTE)((DWORD)(ps)>>16); *(BYTE*)((dir+14)+3)=(BYTE)((DWORD)(ps)>>24);		 
N			dj.fs->wflag = 1;
N			mode |= FA__WRITTEN;				/* Set file changed flag */
X			mode |= 0x20;				 
N		}
N	}
N	/* Open an existing file */
N	else {
N#endif /* !_FS_READONLY */
N		if (res != FR_OK) LEAVE_FF(dj.fs, res);	/* Follow failed */
X		if (res != FR_OK) return res;	 
N		dir = dj.dir;
N		if (!dir || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
X		if (!dir || (dir[11] & 0x10))	 
N			LEAVE_FF(dj.fs, FR_NO_FILE);
X			return FR_NO_FILE;
N#if !_FS_READONLY
X#if !0
N		if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
X		if ((mode & 0x02) && (dir[11] & 0x01))  
N			LEAVE_FF(dj.fs, FR_DENIED);
X			return FR_DENIED;
N	}
N	fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
N	fp->dir_ptr = dj.dir;
N#endif
N	fp->flag = mode;					/* File access mode */
N	fp->org_clust =						/* File start cluster */
N		((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
X		((DWORD)(WORD)(((WORD)*(BYTE*)((dir+20)+1)<<8)|(WORD)*(BYTE*)(dir+20)) << 16) | (WORD)(((WORD)*(BYTE*)((dir+26)+1)<<8)|(WORD)*(BYTE*)(dir+26));
N	fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
X	fp->fsize = (DWORD)(((DWORD)*(BYTE*)((dir+28)+3)<<24)|((DWORD)*(BYTE*)((dir+28)+2)<<16)|((WORD)*(BYTE*)((dir+28)+1)<<8)| *(BYTE*)(dir+28));	 
N	fp->fptr = 0; fp->csect = 255;		/* File pointer */
N	fp->dsect = 0;
N	fp->fs = dj.fs; fp->id = dj.fs->id;	/* Owner file system object of the file */
N
N	LEAVE_FF(dj.fs, FR_OK);
X	return FR_OK;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Read File                                                             */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_read (
N	FIL *fp, 		/* Pointer to the file object */
N	void *buff,		/* Pointer to data buffer */
N	UINT btr,		/* Number of bytes to read */
N	UINT *br		/* Pointer to number of bytes read */
N)
N{
N	FRESULT res;
N	DWORD clst, sect, remain;
N	UINT rcnt, cc;
N	BYTE *rbuff = buff;
N
N
N	*br = 0;	/* Initialize bytes read */
N
N	res = validate(fp->fs, fp->id);					/* Check validity of the object */
N	if (res != FR_OK) LEAVE_FF(fp->fs, res);
X	if (res != FR_OK) return res;
N	if (fp->flag & FA__ERROR)						/* Check abort flag */
X	if (fp->flag & 0x80)						 
N		LEAVE_FF(fp->fs, FR_INT_ERR);
X		return FR_INT_ERR;
N	if (!(fp->flag & FA_READ)) 						/* Check access mode */
X	if (!(fp->flag & 0x01)) 						 
N		LEAVE_FF(fp->fs, FR_DENIED);
X		return FR_DENIED;
N	remain = fp->fsize - fp->fptr;
N	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
N
N	for ( ;  btr;									/* Repeat until all data transferred */
N		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
N		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
X		if ((fp->fptr % 512U) == 0) {			 
N			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
N				clst = (fp->fptr == 0) ?			/* On the top of the file? */
N					fp->org_clust : get_fat(fp->fs, fp->curr_clust);
N				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
X				if (clst <= 1) { fp->flag |= 0x80; return FR_INT_ERR; };
N				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
X				if (clst == 0xFFFFFFFF) { fp->flag |= 0x80; return FR_DISK_ERR; };
N				fp->curr_clust = clst;				/* Update current cluster */
N				fp->csect = 0;						/* Reset sector offset in the cluster */
N			}
N			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
N			if (!sect) ABORT(fp->fs, FR_INT_ERR);
X			if (!sect) { fp->flag |= 0x80; return FR_INT_ERR; };
N			sect += fp->csect;
N			cc = btr / SS(fp->fs);					/* When remaining bytes >= sector size, */
X			cc = btr / 512U;					 
N			if (cc) {								/* Read maximum contiguous sectors directly */
N				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
N					cc = fp->fs->csize - fp->csect;
N				if (disk_read(fp->fs->drive, rbuff, sect, (BYTE)cc) != RES_OK)
N					ABORT(fp->fs, FR_DISK_ERR);
X					{ fp->flag |= 0x80; return FR_DISK_ERR; };
N#if !_FS_READONLY && _FS_MINIMIZE <= 2
X#if !0 && 0 <= 2
N#if _FS_TINY
X#if 0
S				if (fp->fs->wflag && fp->fs->winsect - sect < cc)		/* Replace one of the read sectors with cached data if it contains a dirty sector */
S					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
N#else
N				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)	/* Replace one of the read sectors with cached data if it contains a dirty sector */
X				if ((fp->flag & 0x40) && fp->dsect - sect < cc)	 
N					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
X					mem_cpy(rbuff + ((fp->dsect - sect) * 512U), fp->buf, 512U);
N#endif
N#endif
N				fp->csect += (BYTE)cc;				/* Next sector address in the cluster */
N				rcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
X				rcnt = 512U * cc;				 
N				continue;
N			}
N#if !_FS_TINY
X#if !0
N#if !_FS_READONLY
X#if !0
N			if (fp->flag & FA__DIRTY) {			/* Write sector I/O buffer if needed */
X			if (fp->flag & 0x40) {			 
N				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
N					ABORT(fp->fs, FR_DISK_ERR);
X					{ fp->flag |= 0x80; return FR_DISK_ERR; };
N				fp->flag &= ~FA__DIRTY;
X				fp->flag &= ~0x40;
N			}
N#endif
N			if (fp->dsect != sect) {			/* Fill sector buffer with file data */
N				if (disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
N					ABORT(fp->fs, FR_DISK_ERR);
X					{ fp->flag |= 0x80; return FR_DISK_ERR; };
N			}
N#endif
N			fp->dsect = sect;
N			fp->csect++;							/* Next sector address in the cluster */
N		}
N		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
X		rcnt = 512U - (fp->fptr % 512U);	 
N		if (rcnt > btr) rcnt = btr;
N#if _FS_TINY
X#if 0
S		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
S			ABORT(fp->fs, FR_DISK_ERR);
S		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
N#else
N		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
X		mem_cpy(rbuff, &fp->buf[fp->fptr % 512U], rcnt);	 
N#endif
N	}
N
N	LEAVE_FF(fp->fs, FR_OK);
X	return FR_OK;
N}
N
N
N
N
N#if !_FS_READONLY
X#if !0
N/*-----------------------------------------------------------------------*/
N/* Write File                                                            */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_write (
N	FIL *fp,			/* Pointer to the file object */
N	const void *buff,	/* Pointer to the data to be written */
N	UINT btw,			/* Number of bytes to write */
N	UINT *bw			/* Pointer to number of bytes written */
N)
N{
N	FRESULT res;
N	DWORD clst, sect;
N	UINT wcnt, cc;
N	const BYTE *wbuff = buff;
N
N
N	*bw = 0;	/* Initialize bytes written */
N
N	res = validate(fp->fs, fp->id);					/* Check validity of the object */
N	if (res != FR_OK) LEAVE_FF(fp->fs, res);
X	if (res != FR_OK) return res;
N	if (fp->flag & FA__ERROR)						/* Check abort flag */
X	if (fp->flag & 0x80)						 
N		LEAVE_FF(fp->fs, FR_INT_ERR);
X		return FR_INT_ERR;
N	if (!(fp->flag & FA_WRITE))						/* Check access mode */
X	if (!(fp->flag & 0x02))						 
N		LEAVE_FF(fp->fs, FR_DENIED);
X		return FR_DENIED;
N	if (fp->fsize + btw < fp->fsize) btw = 0;		/* File size cannot reach 4GB */
N
N	for ( ;  btw;									/* Repeat until all data transferred */
N		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
N		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
X		if ((fp->fptr % 512U) == 0) {			 
N			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
N				if (fp->fptr == 0) {				/* On the top of the file? */
N					clst = fp->org_clust;			/* Follow from the origin */
N					if (clst == 0)					/* When there is no cluster chain, */
N						fp->org_clust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
N				} else {							/* Middle or end of the file */
N					clst = create_chain(fp->fs, fp->curr_clust);			/* Follow or streach cluster chain */
N				}
N				if (clst == 0) break;				/* Could not allocate a new cluster (disk full) */
N				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
X				if (clst == 1) { fp->flag |= 0x80; return FR_INT_ERR; };
N				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
X				if (clst == 0xFFFFFFFF) { fp->flag |= 0x80; return FR_DISK_ERR; };
N				fp->curr_clust = clst;				/* Update current cluster */
N				fp->csect = 0;						/* Reset sector address in the cluster */
N			}
N#if _FS_TINY
X#if 0
S			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write back data buffer prior to following direct transfer */
S				ABORT(fp->fs, FR_DISK_ERR);
N#else
N			if (fp->flag & FA__DIRTY) {		/* Write back data buffer prior to following direct transfer */
X			if (fp->flag & 0x40) {		 
N				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
N					ABORT(fp->fs, FR_DISK_ERR);
X					{ fp->flag |= 0x80; return FR_DISK_ERR; };
N				fp->flag &= ~FA__DIRTY;
X				fp->flag &= ~0x40;
N			}
N#endif
N			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
N			if (!sect) ABORT(fp->fs, FR_INT_ERR);
X			if (!sect) { fp->flag |= 0x80; return FR_INT_ERR; };
N			sect += fp->csect;
N			cc = btw / SS(fp->fs);					/* When remaining bytes >= sector size, */
X			cc = btw / 512U;					 
N			if (cc) {								/* Write maximum contiguous sectors directly */
N				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
N					cc = fp->fs->csize - fp->csect;
N				if (disk_write(fp->fs->drive, wbuff, sect, (BYTE)cc) != RES_OK)
N					ABORT(fp->fs, FR_DISK_ERR);
X					{ fp->flag |= 0x80; return FR_DISK_ERR; };
N#if _FS_TINY
X#if 0
S				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets dirty by the direct write */
S					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
S					fp->fs->wflag = 0;
S				}
N#else
N				if (fp->dsect - sect < cc) {		/* Refill sector cache if it gets dirty by the direct write */
N					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
X					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * 512U), 512U);
N					fp->flag &= ~FA__DIRTY;
X					fp->flag &= ~0x40;
N				}
N#endif
N				fp->csect += (BYTE)cc;				/* Next sector address in the cluster */
N				wcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
X				wcnt = 512U * cc;				 
N				continue;
N			}
N#if _FS_TINY
X#if 0
S			if (fp->fptr >= fp->fsize) {			/* Avoid silly buffer filling at growing edge */
S				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
S				fp->fs->winsect = sect;
S			}
N#else
N			if (fp->dsect != sect) {				/* Fill sector buffer with file data */
N				if (fp->fptr < fp->fsize &&
N					disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
N						ABORT(fp->fs, FR_DISK_ERR);
X						{ fp->flag |= 0x80; return FR_DISK_ERR; };
N			}
N#endif
N			fp->dsect = sect;
N			fp->csect++;							/* Next sector address in the cluster */
N		}
N		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Put partial sector into file I/O buffer */
X		wcnt = 512U - (fp->fptr % 512U);	 
N		if (wcnt > btw) wcnt = btw;
N#if _FS_TINY
X#if 0
S		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
S			ABORT(fp->fs, FR_DISK_ERR);
S		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
S		fp->fs->wflag = 1;
N#else
N		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
X		mem_cpy(&fp->buf[fp->fptr % 512U], wbuff, wcnt);	 
N		fp->flag |= FA__DIRTY;
X		fp->flag |= 0x40;
N#endif
N	}
N
N	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
N	fp->flag |= FA__WRITTEN;						/* Set file changed flag */
X	fp->flag |= 0x20;						 
N
N	LEAVE_FF(fp->fs, FR_OK);
X	return FR_OK;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Synchronize the File Object                                           */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_sync (
N	FIL *fp		/* Pointer to the file object */
N)
N{
N	FRESULT res;
N	DWORD tim;
N	BYTE *dir;
N
N
N	res = validate(fp->fs, fp->id);		/* Check validity of the object */
N	if (res == FR_OK) {
N		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
X		if (fp->flag & 0x20) {	 
N#if !_FS_TINY	/* Write-back dirty buffer */
X#if !0	 
N			if (fp->flag & FA__DIRTY) {
X			if (fp->flag & 0x40) {
N				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
N					LEAVE_FF(fp->fs, FR_DISK_ERR);
X					return FR_DISK_ERR;
N				fp->flag &= ~FA__DIRTY;
X				fp->flag &= ~0x40;
N			}
N#endif
N			/* Update the directory entry */
N			res = move_window(fp->fs, fp->dir_sect);
N			if (res == FR_OK) {
N				dir = fp->dir_ptr;
N				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
X				dir[11] |= 0x20;					 
N				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
X				*(BYTE*)(dir+28)=(BYTE)(fp->fsize); *(BYTE*)((dir+28)+1)=(BYTE)((WORD)(fp->fsize)>>8); *(BYTE*)((dir+28)+2)=(BYTE)((DWORD)(fp->fsize)>>16); *(BYTE*)((dir+28)+3)=(BYTE)((DWORD)(fp->fsize)>>24);		 
N				ST_WORD(dir+DIR_FstClusLO, fp->org_clust);	/* Update start cluster */
X				*(BYTE*)(dir+26)=(BYTE)(fp->org_clust); *(BYTE*)((dir+26)+1)=(BYTE)((WORD)(fp->org_clust)>>8);	 
N				ST_WORD(dir+DIR_FstClusHI, fp->org_clust >> 16);
X				*(BYTE*)(dir+20)=(BYTE)(fp->org_clust >> 16); *(BYTE*)((dir+20)+1)=(BYTE)((WORD)(fp->org_clust >> 16)>>8);
N				tim = get_fattime();			/* Updated time */
N				ST_DWORD(dir+DIR_WrtTime, tim);
X				*(BYTE*)(dir+22)=(BYTE)(tim); *(BYTE*)((dir+22)+1)=(BYTE)((WORD)(tim)>>8); *(BYTE*)((dir+22)+2)=(BYTE)((DWORD)(tim)>>16); *(BYTE*)((dir+22)+3)=(BYTE)((DWORD)(tim)>>24);
N				fp->flag &= ~FA__WRITTEN;
X				fp->flag &= ~0x20;
N				fp->fs->wflag = 1;
N				res = sync(fp->fs);
N			}
N		}
N	}
N
N	LEAVE_FF(fp->fs, res);
X	return res;
N}
N
N#endif /* !_FS_READONLY */
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Close File                                                            */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_close (
N	FIL *fp		/* Pointer to the file object to be closed */
N)
N{
N	FRESULT res;
N
N
N#if _FS_READONLY
X#if 0
S    FATFS *fs = fp->fs;
S	res = validate(fp->fs, fp->id);
S	if (res == FR_OK) fp->fs = NULL;
S	LEAVE_FF(fs, res);
N#else
N	res = f_sync(fp);
N	if (res == FR_OK) fp->fs = NULL;
X	if (res == FR_OK) fp->fs = 0;
N	return res;
N#endif
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Change Current Drive/Directory                                        */
N/*-----------------------------------------------------------------------*/
N
N#if _FS_RPATH
X#if 0
S
SFRESULT f_chdrive (
S	BYTE drv		/* Drive number */
S)
S{
S	if (drv >= _DRIVES) return FR_INVALID_DRIVE;
S
S	Drive = drv;
S
S	return FR_OK;
S}
S
S
S
S
SFRESULT f_chdir (
S	const XCHAR *path	/* Pointer to the directory path */
S)
S{
S	FRESULT res;
S	DIR dj;
S	NAMEBUF(sfn, lfn);
S	BYTE *dir;
S
S
S	res = chk_mounted(&path, &dj.fs, 0);
S	if (res == FR_OK) {
S		INITBUF(dj, sfn, lfn);
S		res = follow_path(&dj, path);		/* Follow the file path */
S		if (res == FR_OK) {					/* Follow completed */
S			dir = dj.dir;					/* Pointer to the entry */
S			if (!dir) {
S				dj.fs->cdir = 0;			/* No entry (root dir) */
S			} else {
S				if (dir[DIR_Attr] & AM_DIR)	/* Reached to the dir */
S					dj.fs->cdir = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
S				else
S					res = FR_NO_PATH;		/* Could not reach the dir (it is a file) */
S			}
S		}
S		if (res == FR_NO_FILE) res = FR_NO_PATH;
S	}
S
S	LEAVE_FF(dj.fs, res);
S}
S
N#endif
N
N
N
N#if _FS_MINIMIZE <= 2
X#if 0 <= 2
N/*-----------------------------------------------------------------------*/
N/* Seek File R/W Pointer                                                 */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_lseek (
N	FIL *fp,		/* Pointer to the file object */
N	DWORD ofs		/* File pointer from top of file */
N)
N{
N	FRESULT res;
N	DWORD clst, bcs, nsect, ifptr;
N
N
N	res = validate(fp->fs, fp->id);		/* Check validity of the object */
N	if (res != FR_OK) LEAVE_FF(fp->fs, res);
X	if (res != FR_OK) return res;
N	if (fp->flag & FA__ERROR)			/* Check abort flag */
X	if (fp->flag & 0x80)			 
N		LEAVE_FF(fp->fs, FR_INT_ERR);
X		return FR_INT_ERR;
N	if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
N#if !_FS_READONLY
X#if !0
N		 && !(fp->flag & FA_WRITE)
X		 && !(fp->flag & 0x02)
N#endif
N		) ofs = fp->fsize;
N
N	ifptr = fp->fptr;
N	fp->fptr = nsect = 0; fp->csect = 255;
N	if (ofs > 0) {
N		bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
X		bcs = (DWORD)fp->fs->csize * 512U;	 
N		if (ifptr > 0 &&
N			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
N			fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
N			ofs -= fp->fptr;
N			clst = fp->curr_clust;
N		} else {									/* When seek to back cluster, */
N			clst = fp->org_clust;					/* start from the first cluster */
N#if !_FS_READONLY
X#if !0
N			if (clst == 0) {						/* If no cluster chain, create a new chain */
N				clst = create_chain(fp->fs, 0);
N				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
X				if (clst == 1) { fp->flag |= 0x80; return FR_INT_ERR; };
N				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
X				if (clst == 0xFFFFFFFF) { fp->flag |= 0x80; return FR_DISK_ERR; };
N				fp->org_clust = clst;
N			}
N#endif
N			fp->curr_clust = clst;
N		}
N		if (clst != 0) {
N			while (ofs > bcs) {						/* Cluster following loop */
N#if !_FS_READONLY
X#if !0
N				if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
X				if (fp->flag & 0x02) {			 
N					clst = create_chain(fp->fs, clst);	/* Force streached if in write mode */
N					if (clst == 0) {				/* When disk gets full, clip file size */
N						ofs = bcs; break;
N					}
N				} else
N#endif
N					clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
N				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
X				if (clst == 0xFFFFFFFF) { fp->flag |= 0x80; return FR_DISK_ERR; };
N				if (clst <= 1 || clst >= fp->fs->max_clust) ABORT(fp->fs, FR_INT_ERR);
X				if (clst <= 1 || clst >= fp->fs->max_clust) { fp->flag |= 0x80; return FR_INT_ERR; };
N				fp->curr_clust = clst;
N				fp->fptr += bcs;
N				ofs -= bcs;
N			}
N			fp->fptr += ofs;
N			fp->csect = (BYTE)(ofs / SS(fp->fs));	/* Sector offset in the cluster */
X			fp->csect = (BYTE)(ofs / 512U);	 
N			if (ofs % SS(fp->fs)) {
X			if (ofs % 512U) {
N				nsect = clust2sect(fp->fs, clst);	/* Current sector */
N				if (!nsect) ABORT(fp->fs, FR_INT_ERR);
X				if (!nsect) { fp->flag |= 0x80; return FR_INT_ERR; };
N				nsect += fp->csect;
N				fp->csect++;
N			}
N		}
N	}
N	if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {
X	if (fp->fptr % 512U && nsect != fp->dsect) {
N#if !_FS_TINY
X#if !0
N#if !_FS_READONLY
X#if !0
N		if (fp->flag & FA__DIRTY) {			/* Write-back dirty buffer if needed */
X		if (fp->flag & 0x40) {			 
N			if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
N				ABORT(fp->fs, FR_DISK_ERR);
X				{ fp->flag |= 0x80; return FR_DISK_ERR; };
N			fp->flag &= ~FA__DIRTY;
X			fp->flag &= ~0x40;
N		}
N#endif
N		if (disk_read(fp->fs->drive, fp->buf, nsect, 1) != RES_OK)
N			ABORT(fp->fs, FR_DISK_ERR);
X			{ fp->flag |= 0x80; return FR_DISK_ERR; };
N#endif
N		fp->dsect = nsect;
N	}
N#if !_FS_READONLY
X#if !0
N	if (fp->fptr > fp->fsize) {			/* Set changed flag if the file size is extended */
N		fp->fsize = fp->fptr;
N		fp->flag |= FA__WRITTEN;
X		fp->flag |= 0x20;
N	}
N#endif
N
N	LEAVE_FF(fp->fs, res);
X	return res;
N}
N
N
N
N
N#if _FS_MINIMIZE <= 1
X#if 0 <= 1
N/*-----------------------------------------------------------------------*/
N/* Create a Directroy Object                                             */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_opendir (
N	DIR *dj,			/* Pointer to directory object to create */
N	const XCHAR *path	/* Pointer to the directory path */
N)
N{
N	FRESULT res;
N	NAMEBUF(sfn, lfn);
X	BYTE sfn[12];
N	BYTE *dir;
N
N
N	res = chk_mounted(&path, &dj->fs, 0);
N	if (res == FR_OK) {
N		INITBUF((*dj), sfn, lfn);
X		(*dj). fn = sfn;
N		res = follow_path(dj, path);			/* Follow the path to the directory */
N		if (res == FR_OK) {						/* Follow completed */
N			dir = dj->dir;
N			if (dir) {							/* It is not the root dir */
N				if (dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
X				if (dir[11] & 0x10) {	 
N					dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
X					dj->sclust = ((DWORD)(WORD)(((WORD)*(BYTE*)((dir+20)+1)<<8)|(WORD)*(BYTE*)(dir+20)) << 16) | (WORD)(((WORD)*(BYTE*)((dir+26)+1)<<8)|(WORD)*(BYTE*)(dir+26));
N				} else {						/* The object is not a directory */
N					res = FR_NO_PATH;
N				}
N			}
N			if (res == FR_OK) {
N				dj->id = dj->fs->id;
N				res = dir_seek(dj, 0);			/* Rewind dir */
N			}
N		}
N		if (res == FR_NO_FILE) res = FR_NO_PATH;
N	}
N
N	LEAVE_FF(dj->fs, res);
X	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Read Directory Entry in Sequense                                      */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_readdir (
N	DIR *dj,			/* Pointer to the open directory object */
N	FILINFO *fno		/* Pointer to file information to return */
N)
N{
N	FRESULT res;
N	NAMEBUF(sfn, lfn);
X	BYTE sfn[12];
N
N
N	res = validate(dj->fs, dj->id);			/* Check validity of the object */
N	if (res == FR_OK) {
N		INITBUF((*dj), sfn, lfn);
X		(*dj). fn = sfn;
N		if (!fno) {
N			res = dir_seek(dj, 0);
N		} else {
N			res = dir_read(dj);
N			if (res == FR_NO_FILE) {
N				dj->sect = 0;
N				res = FR_OK;
N			}
N			if (res == FR_OK) {				/* A valid entry is found */
N				get_fileinfo(dj, fno);		/* Get the object information */
N				res = dir_next(dj, FALSE);	/* Increment index for next */
N				if (res == FR_NO_FILE) {
N					dj->sect = 0;
N					res = FR_OK;
N				}
N			}
N		}
N	}
N
N	LEAVE_FF(dj->fs, res);
X	return res;
N}
N
N
N
N#if _FS_MINIMIZE == 0
X#if 0 == 0
N/*-----------------------------------------------------------------------*/
N/* Get File Status                                                       */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_stat (
N	const XCHAR *path,	/* Pointer to the file path */
N	FILINFO *fno		/* Pointer to file information to return */
N)
N{
N	FRESULT res;
N	DIR dj;
N	NAMEBUF(sfn, lfn);
X	BYTE sfn[12];
N
N
N	res = chk_mounted(&path, &dj.fs, 0);
N	if (res == FR_OK) {
N		INITBUF(dj, sfn, lfn);
X		dj . fn = sfn;
N		res = follow_path(&dj, path);	/* Follow the file path */
N		if (res == FR_OK) {				/* Follwo completed */
N			if (dj.dir)	/* Found an object */
N				get_fileinfo(&dj, fno);
N			else		/* It is root dir */
N				res = FR_INVALID_NAME;
N		}
N	}
N
N	LEAVE_FF(dj.fs, res);
X	return res;
N}
N
N
N
N#if !_FS_READONLY
X#if !0
N/*-----------------------------------------------------------------------*/
N/* Get Number of Free Clusters                                           */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_getfree (
N	const XCHAR *path,	/* Pointer to the logical drive number (root dir) */
N	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
N	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
N)
N{
N	FRESULT res;
N	DWORD n, clst, sect, stat;
N	UINT i;
N	BYTE fat, *p;
N
N
N	/* Get drive number */
N	res = chk_mounted(&path, fatfs, 0);
N	if (res != FR_OK) LEAVE_FF(*fatfs, res);
X	if (res != FR_OK) return res;
N
N	/* If number of free cluster is valid, return it without cluster scan. */
N	if ((*fatfs)->free_clust <= (*fatfs)->max_clust - 2) {
N		*nclst = (*fatfs)->free_clust;
N		LEAVE_FF(*fatfs, FR_OK);
X		return FR_OK;
N	}
N
N	/* Get number of free clusters */
N	fat = (*fatfs)->fs_type;
N	n = 0;
N	if (fat == FS_FAT12) {
X	if (fat == 1) {
N		clst = 2;
N		do {
N			stat = get_fat(*fatfs, clst);
N			if (stat == 0xFFFFFFFF) LEAVE_FF(*fatfs, FR_DISK_ERR);
X			if (stat == 0xFFFFFFFF) return FR_DISK_ERR;
N			if (stat == 1) LEAVE_FF(*fatfs, FR_INT_ERR);
X			if (stat == 1) return FR_INT_ERR;
N			if (stat == 0) n++;
N		} while (++clst < (*fatfs)->max_clust);
N	} else {
N		clst = (*fatfs)->max_clust;
N		sect = (*fatfs)->fatbase;
N		i = 0; p = 0;
N		do {
N			if (!i) {
N				res = move_window(*fatfs, sect++);
N				if (res != FR_OK)
N					LEAVE_FF(*fatfs, res);
X					return res;
N				p = (*fatfs)->win;
N				i = SS(*fatfs);
X				i = 512U;
N			}
N			if (fat == FS_FAT16) {
X			if (fat == 2) {
N				if (LD_WORD(p) == 0) n++;
X				if ((WORD)(((WORD)*(BYTE*)((p)+1)<<8)|(WORD)*(BYTE*)(p)) == 0) n++;
N				p += 2; i -= 2;
N			} else {
N				if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
X				if (((DWORD)(((DWORD)*(BYTE*)((p)+3)<<24)|((DWORD)*(BYTE*)((p)+2)<<16)|((WORD)*(BYTE*)((p)+1)<<8)| *(BYTE*)(p)) & 0x0FFFFFFF) == 0) n++;
N				p += 4; i -= 4;
N			}
N		} while (--clst);
N	}
N	(*fatfs)->free_clust = n;
N	if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
X	if (fat == 3) (*fatfs)->fsi_flag = 1;
N	*nclst = n;
N
N	LEAVE_FF(*fatfs, FR_OK);
X	return FR_OK;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Truncate File                                                         */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_truncate (
N	FIL *fp		/* Pointer to the file object */
N)
N{
N	FRESULT res;
N	DWORD ncl;
N
N
N	res = validate(fp->fs, fp->id);		/* Check validity of the object */
N	if (res != FR_OK) LEAVE_FF(fp->fs, res);
X	if (res != FR_OK) return res;
N	if (fp->flag & FA__ERROR)			/* Check abort flag */
X	if (fp->flag & 0x80)			 
N		LEAVE_FF(fp->fs, FR_INT_ERR);
X		return FR_INT_ERR;
N	if (!(fp->flag & FA_WRITE))			/* Check access mode */
X	if (!(fp->flag & 0x02))			 
N		LEAVE_FF(fp->fs, FR_DENIED);
X		return FR_DENIED;
N
N	if (fp->fsize > fp->fptr) {
N		fp->fsize = fp->fptr;	/* Set file size to current R/W point */
N		fp->flag |= FA__WRITTEN;
X		fp->flag |= 0x20;
N		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
N			res = remove_chain(fp->fs, fp->org_clust);
N			fp->org_clust = 0;
N		} else {				/* When truncate a part of the file, remove remaining clusters */
N			ncl = get_fat(fp->fs, fp->curr_clust);
N			res = FR_OK;
N			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
N			if (ncl == 1) res = FR_INT_ERR;
N			if (res == FR_OK && ncl < fp->fs->max_clust) {
N				res = put_fat(fp->fs, fp->curr_clust, 0x0FFFFFFF);
N				if (res == FR_OK) res = remove_chain(fp->fs, ncl);
N			}
N		}
N	}
N	if (res != FR_OK) fp->flag |= FA__ERROR;
X	if (res != FR_OK) fp->flag |= 0x80;
N
N	LEAVE_FF(fp->fs, res);
X	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Delete a File or Directory                                            */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_unlink (
N	const XCHAR *path		/* Pointer to the file or directory path */
N)
N{
N	FRESULT res;
N	DIR dj, sdj;
N	NAMEBUF(sfn, lfn);
X	BYTE sfn[12];
N	BYTE *dir;
N	DWORD dclst;
N
N
N	res = chk_mounted(&path, &dj.fs, 1);
N	if (res != FR_OK) LEAVE_FF(dj.fs, res);
X	if (res != FR_OK) return res;
N
N	INITBUF(dj, sfn, lfn);
X	dj . fn = sfn;
N	res = follow_path(&dj, path);			/* Follow the file path */
N	if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
X	if (0 && res == FR_OK && (dj.fn[11] & 0x20))
N		res = FR_INVALID_NAME;
N	if (res != FR_OK) LEAVE_FF(dj.fs, res); /* Follow failed */
X	if (res != FR_OK) return res;  
N
N	dir = dj.dir;
N	if (!dir)								/* Is it the root directory? */
N		LEAVE_FF(dj.fs, FR_INVALID_NAME);
X		return FR_INVALID_NAME;
N	if (dir[DIR_Attr] & AM_RDO)				/* Is it a R/O object? */
X	if (dir[11] & 0x01)				 
N		LEAVE_FF(dj.fs, FR_DENIED);
X		return FR_DENIED;
N	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
X	dclst = ((DWORD)(WORD)(((WORD)*(BYTE*)((dir+20)+1)<<8)|(WORD)*(BYTE*)(dir+20)) << 16) | (WORD)(((WORD)*(BYTE*)((dir+26)+1)<<8)|(WORD)*(BYTE*)(dir+26));
N
N	if (dir[DIR_Attr] & AM_DIR) {			/* It is a sub-directory */
X	if (dir[11] & 0x10) {			 
N		if (dclst < 2) LEAVE_FF(dj.fs, FR_INT_ERR);
X		if (dclst < 2) return FR_INT_ERR;
N		mem_cpy(&sdj, &dj, sizeof(DIR));	/* Check if the sub-dir is empty or not */
N		sdj.sclust = dclst;
N		res = dir_seek(&sdj, 2);
N		if (res != FR_OK) LEAVE_FF(dj.fs, res);
X		if (res != FR_OK) return res;
N		res = dir_read(&sdj);
N		if (res == FR_OK) res = FR_DENIED;	/* Not empty sub-dir */
N		if (res != FR_NO_FILE) LEAVE_FF(dj.fs, res);
X		if (res != FR_NO_FILE) return res;
N	}
N
N	res = dir_remove(&dj);					/* Remove directory entry */
N	if (res == FR_OK) {
N		if (dclst)
N			res = remove_chain(dj.fs, dclst);	/* Remove the cluster chain */
N		if (res == FR_OK) res = sync(dj.fs);
N	}
N
N	LEAVE_FF(dj.fs, res);
X	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Create a Directory                                                    */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_mkdir (
N	const XCHAR *path		/* Pointer to the directory path */
N)
N{
N	FRESULT res;
N	DIR dj;
N	NAMEBUF(sfn, lfn);
X	BYTE sfn[12];
N	BYTE *dir, n;
N	DWORD dsect, dclst, pclst, tim;
N
N
N	res = chk_mounted(&path, &dj.fs, 1);
N	if (res != FR_OK) LEAVE_FF(dj.fs, res);
X	if (res != FR_OK) return res;
N
N	INITBUF(dj, sfn, lfn);
X	dj . fn = sfn;
N	res = follow_path(&dj, path);			/* Follow the file path */
N	if (res == FR_OK) res = FR_EXIST;		/* Any file or directory is already existing */
N	if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
X	if (0 && res == FR_NO_FILE && (dj.fn[11] & 0x20))
N		res = FR_INVALID_NAME;
N	if (res != FR_NO_FILE)					/* Any error occured */
N		LEAVE_FF(dj.fs, res);
X		return res;
N
N	dclst = create_chain(dj.fs, 0);			/* Allocate a new cluster for new directory table */
N	res = FR_OK;
N	if (dclst == 0) res = FR_DENIED;
N	if (dclst == 1) res = FR_INT_ERR;
N	if (dclst == 0xFFFFFFFF) res = FR_DISK_ERR;
N	if (res == FR_OK)
N		res = move_window(dj.fs, 0);
N	if (res != FR_OK) LEAVE_FF(dj.fs, res);
X	if (res != FR_OK) return res;
N	dsect = clust2sect(dj.fs, dclst);
N
N	dir = dj.fs->win;						/* Initialize the new directory table */
N	mem_set(dir, 0, SS(dj.fs));
X	mem_set(dir, 0, 512U);
N	mem_set(dir+DIR_Name, ' ', 8+3);		/* Create "." entry */
X	mem_set(dir+0, ' ', 8+3);		 
N	dir[DIR_Name] = '.';
X	dir[0] = '.';
N	dir[DIR_Attr] = AM_DIR;
X	dir[11] = 0x10;
N	tim = get_fattime();
N	ST_DWORD(dir+DIR_WrtTime, tim);
X	*(BYTE*)(dir+22)=(BYTE)(tim); *(BYTE*)((dir+22)+1)=(BYTE)((WORD)(tim)>>8); *(BYTE*)((dir+22)+2)=(BYTE)((DWORD)(tim)>>16); *(BYTE*)((dir+22)+3)=(BYTE)((DWORD)(tim)>>24);
N	ST_WORD(dir+DIR_FstClusLO, dclst);
X	*(BYTE*)(dir+26)=(BYTE)(dclst); *(BYTE*)((dir+26)+1)=(BYTE)((WORD)(dclst)>>8);
N	ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
X	*(BYTE*)(dir+20)=(BYTE)(dclst >> 16); *(BYTE*)((dir+20)+1)=(BYTE)((WORD)(dclst >> 16)>>8);
N	mem_cpy(dir+32, dir, 32); 			/* Create ".." entry */
N	dir[33] = '.';
N	pclst = dj.sclust;
N	if (dj.fs->fs_type == FS_FAT32 && pclst == dj.fs->dirbase)
X	if (dj.fs->fs_type == 3 && pclst == dj.fs->dirbase)
N		pclst = 0;
N	ST_WORD(dir+32+DIR_FstClusLO, pclst);
X	*(BYTE*)(dir+32+26)=(BYTE)(pclst); *(BYTE*)((dir+32+26)+1)=(BYTE)((WORD)(pclst)>>8);
N	ST_WORD(dir+32+DIR_FstClusHI, pclst >> 16);
X	*(BYTE*)(dir+32+20)=(BYTE)(pclst >> 16); *(BYTE*)((dir+32+20)+1)=(BYTE)((WORD)(pclst >> 16)>>8);
N	for (n = 0; n < dj.fs->csize; n++) {	/* Write dot entries and clear left sectors */
N		dj.fs->winsect = dsect++;
N		dj.fs->wflag = 1;
N		res = move_window(dj.fs, 0);
N		if (res) LEAVE_FF(dj.fs, res);
X		if (res) return res;
N		mem_set(dir, 0, SS(dj.fs));
X		mem_set(dir, 0, 512U);
N	}
N
N	res = dir_register(&dj);
N	if (res != FR_OK) {
N		remove_chain(dj.fs, dclst);
N	} else {
N		dir = dj.dir;
N		dir[DIR_Attr] = AM_DIR;					/* Attribute */
X		dir[11] = 0x10;					 
N		ST_DWORD(dir+DIR_WrtTime, tim);			/* Crated time */
X		*(BYTE*)(dir+22)=(BYTE)(tim); *(BYTE*)((dir+22)+1)=(BYTE)((WORD)(tim)>>8); *(BYTE*)((dir+22)+2)=(BYTE)((DWORD)(tim)>>16); *(BYTE*)((dir+22)+3)=(BYTE)((DWORD)(tim)>>24);			 
N		ST_WORD(dir+DIR_FstClusLO, dclst);		/* Table start cluster */
X		*(BYTE*)(dir+26)=(BYTE)(dclst); *(BYTE*)((dir+26)+1)=(BYTE)((WORD)(dclst)>>8);		 
N		ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
X		*(BYTE*)(dir+20)=(BYTE)(dclst >> 16); *(BYTE*)((dir+20)+1)=(BYTE)((WORD)(dclst >> 16)>>8);
N		dj.fs->wflag = 1;
N		res = sync(dj.fs);
N	}
N
N	LEAVE_FF(dj.fs, res);
X	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Change File Attribute                                                 */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_chmod (
N	const XCHAR *path,	/* Pointer to the file path */
N	BYTE value,			/* Attribute bits */
N	BYTE mask			/* Attribute mask to change */
N)
N{
N	FRESULT res;
N	DIR dj;
N	NAMEBUF(sfn, lfn);
X	BYTE sfn[12];
N	BYTE *dir;
N
N
N	res = chk_mounted(&path, &dj.fs, 1);
N	if (res == FR_OK) {
N		INITBUF(dj, sfn, lfn);
X		dj . fn = sfn;
N		res = follow_path(&dj, path);		/* Follow the file path */
N		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
X		if (0 && res == FR_OK && (dj.fn[11] & 0x20))
N			res = FR_INVALID_NAME;
N		if (res == FR_OK) {
N			dir = dj.dir;
N			if (!dir) {						/* Is it a root directory? */
N				res = FR_INVALID_NAME;
N			} else {						/* File or sub directory */
N				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
X				mask &= 0x01|0x02|0x04|0x20;	 
N				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
X				dir[11] = (value & mask) | (dir[11] & (BYTE)~mask);	 
N				dj.fs->wflag = 1;
N				res = sync(dj.fs);
N			}
N		}
N	}
N
N	LEAVE_FF(dj.fs, res);
X	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Change Timestamp                                                      */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_utime (
N	const XCHAR *path,	/* Pointer to the file/directory name */
N	const FILINFO *fno	/* Pointer to the timestamp to be set */
N)
N{
N	FRESULT res;
N	DIR dj;
N	NAMEBUF(sfn, lfn);
X	BYTE sfn[12];
N	BYTE *dir;
N
N
N	res = chk_mounted(&path, &dj.fs, 1);
N	if (res == FR_OK) {
N		INITBUF(dj, sfn, lfn);
X		dj . fn = sfn;
N		res = follow_path(&dj, path);	/* Follow the file path */
N		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
X		if (0 && res == FR_OK && (dj.fn[11] & 0x20))
N			res = FR_INVALID_NAME;
N		if (res == FR_OK) {
N			dir = dj.dir;
N			if (!dir) {				/* Root directory */
N				res = FR_INVALID_NAME;
N			} else {				/* File or sub-directory */
N				ST_WORD(dir+DIR_WrtTime, fno->ftime);
X				*(BYTE*)(dir+22)=(BYTE)(fno->ftime); *(BYTE*)((dir+22)+1)=(BYTE)((WORD)(fno->ftime)>>8);
N				ST_WORD(dir+DIR_WrtDate, fno->fdate);
X				*(BYTE*)(dir+24)=(BYTE)(fno->fdate); *(BYTE*)((dir+24)+1)=(BYTE)((WORD)(fno->fdate)>>8);
N				dj.fs->wflag = 1;
N				res = sync(dj.fs);
N			}
N		}
N	}
N
N	LEAVE_FF(dj.fs, res);
X	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Rename File/Directory                                                 */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_rename (
N	const XCHAR *path_old,	/* Pointer to the old name */
N	const XCHAR *path_new	/* Pointer to the new name */
N)
N{
N	FRESULT res;
N	DIR dj_old, dj_new;
N	NAMEBUF(sfn, lfn);
X	BYTE sfn[12];
N	BYTE buf[21], *dir;
N	DWORD dw;
N
N
N	INITBUF(dj_old, sfn, lfn);
X	dj_old . fn = sfn;
N	res = chk_mounted(&path_old, &dj_old.fs, 1);
N	if (res == FR_OK) {
N		dj_new.fs = dj_old.fs;
N		res = follow_path(&dj_old, path_old);	/* Check old object */
N		if (_FS_RPATH && res == FR_OK && (dj_old.fn[NS] & NS_DOT))
X		if (0 && res == FR_OK && (dj_old.fn[11] & 0x20))
N			res = FR_INVALID_NAME;
N	}
N	if (res != FR_OK) LEAVE_FF(dj_old.fs, res);	/* The old object is not found */
X	if (res != FR_OK) return res;	 
N
N	if (!dj_old.dir) LEAVE_FF(dj_old.fs, FR_NO_FILE);	/* Is root dir? */
X	if (!dj_old.dir) return FR_NO_FILE;	 
N	mem_cpy(buf, dj_old.dir+DIR_Attr, 21);		/* Save the object information */
X	mem_cpy(buf, dj_old.dir+11, 21);		 
N
N	mem_cpy(&dj_new, &dj_old, sizeof(DIR));
N	res = follow_path(&dj_new, path_new);		/* Check new object */
N	if (res == FR_OK) res = FR_EXIST;			/* The new object name is already existing */
N	if (res == FR_NO_FILE) { 					/* Is it a valid path and no name collision? */
N		res = dir_register(&dj_new);			/* Register the new object */
N		if (res == FR_OK) {
N			dir = dj_new.dir;					/* Copy object information into new entry */
N			mem_cpy(dir+13, buf+2, 19);
N			dir[DIR_Attr] = buf[0] | AM_ARC;
X			dir[11] = buf[0] | 0x20;
N			dj_old.fs->wflag = 1;
N			if (dir[DIR_Attr] & AM_DIR) {		/* Update .. entry in the directory if needed */
X			if (dir[11] & 0x10) {		 
N				dw = clust2sect(dj_new.fs, (DWORD)LD_WORD(dir+DIR_FstClusHI) | LD_WORD(dir+DIR_FstClusLO));
X				dw = clust2sect(dj_new.fs, (DWORD)(WORD)(((WORD)*(BYTE*)((dir+20)+1)<<8)|(WORD)*(BYTE*)(dir+20)) | (WORD)(((WORD)*(BYTE*)((dir+26)+1)<<8)|(WORD)*(BYTE*)(dir+26)));
N				if (!dw) {
N					res = FR_INT_ERR;
N				} else {
N					res = move_window(dj_new.fs, dw);
N					dir = dj_new.fs->win+32;
N					if (res == FR_OK && dir[1] == '.') {
N						dw = (dj_new.fs->fs_type == FS_FAT32 && dj_new.sclust == dj_new.fs->dirbase) ? 0 : dj_new.sclust;
X						dw = (dj_new.fs->fs_type == 3 && dj_new.sclust == dj_new.fs->dirbase) ? 0 : dj_new.sclust;
N						ST_WORD(dir+DIR_FstClusLO, dw);
X						*(BYTE*)(dir+26)=(BYTE)(dw); *(BYTE*)((dir+26)+1)=(BYTE)((WORD)(dw)>>8);
N						ST_WORD(dir+DIR_FstClusHI, dw >> 16);
X						*(BYTE*)(dir+20)=(BYTE)(dw >> 16); *(BYTE*)((dir+20)+1)=(BYTE)((WORD)(dw >> 16)>>8);
N						dj_new.fs->wflag = 1;
N					}
N				}
N			}
N			if (res == FR_OK) {
N				res = dir_remove(&dj_old);			/* Remove old entry */
N				if (res == FR_OK)
N					res = sync(dj_old.fs);
N			}
N		}
N	}
N
N	LEAVE_FF(dj_old.fs, res);
X	return res;
N}
N
N#endif /* !_FS_READONLY */
N#endif /* _FS_MINIMIZE == 0 */
N#endif /* _FS_MINIMIZE <= 1 */
N#endif /* _FS_MINIMIZE <= 2 */
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Forward data to the stream directly (Available on only _FS_TINY cfg)  */
N/*-----------------------------------------------------------------------*/
N#if _USE_FORWARD && _FS_TINY
X#if 0 && 0
S
SFRESULT f_forward (
S	FIL *fp, 						/* Pointer to the file object */
S	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
S	UINT btr,						/* Number of bytes to forward */
S	UINT *bf						/* Pointer to number of bytes forwarded */
S)
S{
S	FRESULT res;
S	DWORD remain, clst, sect;
S	UINT rcnt;
S
S
S	*bf = 0;
S
S	res = validate(fp->fs, fp->id);					/* Check validity of the object */
S	if (res != FR_OK) LEAVE_FF(fp->fs, res);
S	if (fp->flag & FA__ERROR)						/* Check error flag */
S		LEAVE_FF(fp->fs, FR_INT_ERR);
S	if (!(fp->flag & FA_READ))						/* Check access mode */
S		LEAVE_FF(fp->fs, FR_DENIED);
S
S	remain = fp->fsize - fp->fptr;
S	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
S
S	for ( ;  btr && (*func)(NULL, 0);				/* Repeat until all data transferred or stream becomes busy */
S		fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
S		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
S			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
S				clst = (fp->fptr == 0) ?			/* On the top of the file? */
S					fp->org_clust : get_fat(fp->fs, fp->curr_clust);
S				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
S				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
S				fp->curr_clust = clst;				/* Update current cluster */
S				fp->csect = 0;						/* Reset sector address in the cluster */
S			}
S			fp->csect++;							/* Next sector address in the cluster */
S		}
S		sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current data sector */
S		if (!sect) ABORT(fp->fs, FR_INT_ERR);
S		sect += fp->csect - 1;
S		if (move_window(fp->fs, sect))				/* Move sector window */
S			ABORT(fp->fs, FR_DISK_ERR);
S		fp->dsect = sect;
S		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
S		if (rcnt > btr) rcnt = btr;
S		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
S		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
S	}
S
S	LEAVE_FF(fp->fs, FR_OK);
S}
N#endif /* _USE_FORWARD */
N
N
N
N#if _USE_MKFS && !_FS_READONLY
X#if 1 && !0
N/*-----------------------------------------------------------------------*/
N/* Create File System on the Drive                                       */
N/*-----------------------------------------------------------------------*/
N#define N_ROOTDIR	512			/* Multiple of 32 and <= 2048 */
N#define N_FATS		1			/* 1 or 2 */
N#define MAX_SECTOR	131072000UL	/* Maximum partition size */
N#define MIN_SECTOR	2000UL		/* Minimum partition size */
N
N
NFRESULT f_mkfs (
N	BYTE drv,			/* Logical drive number */
N	BYTE partition,		/* Partitioning rule 0:FDISK, 1:SFD */
N	WORD allocsize		/* Allocation unit size [bytes] */
N)
N{
N	static const DWORD sstbl[] = { 2048000, 1024000, 512000, 256000, 128000, 64000, 32000, 16000, 8000, 4000,   0 };
N	static const WORD cstbl[] =  {   32768,   16384,   8192,   4096,   2048, 16384,  8192,  4096, 2048, 1024, 512 };
N	BYTE fmt, m, *tbl;
N	DWORD b_part, b_fat, b_dir, b_data;		/* Area offset (LBA) */
N	DWORD n_part, n_rsv, n_fat, n_dir;		/* Area size */
N	DWORD n_clst, d, n;
N	WORD as;
N	FATFS *fs;
N	DSTATUS stat;
N
N
N	/* Check validity of the parameters */
N	if (drv >= _DRIVES) return FR_INVALID_DRIVE;
X	if (drv >= 1) return FR_INVALID_DRIVE;
N	if (partition >= 2) return FR_MKFS_ABORTED;
N
N	/* Check mounted drive and clear work area */
N	fs = FatFs[drv];
N	if (!fs) return FR_NOT_ENABLED;
N	fs->fs_type = 0;
N	drv = LD2PD(drv);
X	drv = (drv);
N
N	/* Get disk statics */
N	stat = disk_initialize(drv);
N	if (stat & STA_NOINIT) return FR_NOT_READY;
X	if (stat & 0x01) return FR_NOT_READY;
N	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
X	if (stat & 0x04) return FR_WRITE_PROTECTED;
N#if _MAX_SS != 512						/* Get disk sector size */
X#if 512 != 512						 
S	if (disk_ioctl(drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
S		|| SS(fs) > _MAX_SS)
S		return FR_MKFS_ABORTED;
N#endif
N	if (disk_ioctl(drv, GET_SECTOR_COUNT, &n_part) != RES_OK || n_part < MIN_SECTOR)
X	if (disk_ioctl(drv, 1, &n_part) != RES_OK || n_part < 2000UL)
N		return FR_MKFS_ABORTED;
N	if (n_part > MAX_SECTOR) n_part = MAX_SECTOR;
X	if (n_part > 131072000UL) n_part = 131072000UL;
N	b_part = (!partition) ? 63 : 0;		/* Boot sector */
N	n_part -= b_part;
N	for (d = 512; d <= 32768U && d != allocsize; d <<= 1) ;	/* Check validity of the allocation unit size */
N	if (d != allocsize) allocsize = 0;
N	if (!allocsize) {					/* Auto selection of cluster size */
N		d = n_part;
N		for (as = SS(fs); as > 512U; as >>= 1) d >>= 1;
X		for (as = 512U; as > 512U; as >>= 1) d >>= 1;
N		for (n = 0; d < sstbl[n]; n++) ;
N		allocsize = cstbl[n];
N	}
N	if (allocsize < SS(fs)) allocsize = SS(fs);
X	if (allocsize < 512U) allocsize = 512U;
N
N	allocsize /= SS(fs);		/* Number of sectors per cluster */
X	allocsize /= 512U;		 
N
N	/* Pre-compute number of clusters and FAT type */
N	n_clst = n_part / allocsize;
N	fmt = FS_FAT12;
X	fmt = 1;
N	if (n_clst >= 0xFF5) fmt = FS_FAT16;
X	if (n_clst >= 0xFF5) fmt = 2;
N	if (n_clst >= 0xFFF5) fmt = FS_FAT32;
X	if (n_clst >= 0xFFF5) fmt = 3;
N
N	/* Determine offset and size of FAT structure */
N	switch (fmt) {
N	case FS_FAT12:
X	case 1:
N		n_fat = ((n_clst * 3 + 1) / 2 + 3 + SS(fs) - 1) / SS(fs);
X		n_fat = ((n_clst * 3 + 1) / 2 + 3 + 512U - 1) / 512U;
N		n_rsv = 1 + partition;
N		n_dir = N_ROOTDIR * 32 / SS(fs);
X		n_dir = 512 * 32 / 512U;
N		break;
N	case FS_FAT16:
X	case 2:
N		n_fat = ((n_clst * 2) + 4 + SS(fs) - 1) / SS(fs);
X		n_fat = ((n_clst * 2) + 4 + 512U - 1) / 512U;
N		n_rsv = 1 + partition;
N		n_dir = N_ROOTDIR * 32 / SS(fs);
X		n_dir = 512 * 32 / 512U;
N		break;
N	default:
N		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
X		n_fat = ((n_clst * 4) + 8 + 512U - 1) / 512U;
N		n_rsv = 33 - partition;
N		n_dir = 0;
N	}
N	b_fat = b_part + n_rsv;			/* FATs start sector */
N	b_dir = b_fat + n_fat * N_FATS;	/* Directory start sector */
X	b_dir = b_fat + n_fat * 1;	 
N	b_data = b_dir + n_dir;			/* Data start sector */
N
N	/* Align data start sector to erase block boundary (for flash memory media) */
N	if (disk_ioctl(drv, GET_BLOCK_SIZE, &n) != RES_OK) return FR_MKFS_ABORTED;
X	if (disk_ioctl(drv, 3, &n) != RES_OK) return FR_MKFS_ABORTED;
N	n = (b_data + n - 1) & ~(n - 1);
N	n_fat += (n - b_data) / N_FATS;
X	n_fat += (n - b_data) / 1;
N	/* b_dir and b_data are no longer used below */
N
N	/* Determine number of cluster and final check of validity of the FAT type */
N	n_clst = (n_part - n_rsv - n_fat * N_FATS - n_dir) / allocsize;
X	n_clst = (n_part - n_rsv - n_fat * 1 - n_dir) / allocsize;
N	if (   (fmt == FS_FAT16 && n_clst < 0xFF5)
X	if (   (fmt == 2 && n_clst < 0xFF5)
N		|| (fmt == FS_FAT32 && n_clst < 0xFFF5))
X		|| (fmt == 3 && n_clst < 0xFFF5))
N		return FR_MKFS_ABORTED;
N
N	/* Create partition table if needed */
N	if (!partition) {
N		DWORD n_disk = b_part + n_part;
N
N		mem_set(fs->win, 0, SS(fs));
X		mem_set(fs->win, 0, 512U);
N		tbl = fs->win+MBR_Table;
X		tbl = fs->win+446;
N		ST_DWORD(tbl, 0x00010180);		/* Partition start in CHS */
X		*(BYTE*)(tbl)=(BYTE)(0x00010180); *(BYTE*)((tbl)+1)=(BYTE)((WORD)(0x00010180)>>8); *(BYTE*)((tbl)+2)=(BYTE)((DWORD)(0x00010180)>>16); *(BYTE*)((tbl)+3)=(BYTE)((DWORD)(0x00010180)>>24);		 
N		if (n_disk < 63UL * 255 * 1024) {	/* Partition end in CHS */
N			n_disk = n_disk / 63 / 255;
N			tbl[7] = (BYTE)n_disk;
N			tbl[6] = (BYTE)((n_disk >> 2) | 63);
N		} else {
N			ST_WORD(&tbl[6], 0xFFFF);
X			*(BYTE*)(&tbl[6])=(BYTE)(0xFFFF); *(BYTE*)((&tbl[6])+1)=(BYTE)((WORD)(0xFFFF)>>8);
N		}
N		tbl[5] = 254;
N		if (fmt != FS_FAT32)			/* System ID */
X		if (fmt != 3)			 
N			tbl[4] = (n_part < 0x10000) ? 0x04 : 0x06;
N		else
N			tbl[4] = 0x0c;
N		ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
X		*(BYTE*)(tbl+8)=(BYTE)(63); *(BYTE*)((tbl+8)+1)=(BYTE)((WORD)(63)>>8); *(BYTE*)((tbl+8)+2)=(BYTE)((DWORD)(63)>>16); *(BYTE*)((tbl+8)+3)=(BYTE)((DWORD)(63)>>24);			 
N		ST_DWORD(tbl+12, n_part);		/* Partition size in LBA */
X		*(BYTE*)(tbl+12)=(BYTE)(n_part); *(BYTE*)((tbl+12)+1)=(BYTE)((WORD)(n_part)>>8); *(BYTE*)((tbl+12)+2)=(BYTE)((DWORD)(n_part)>>16); *(BYTE*)((tbl+12)+3)=(BYTE)((DWORD)(n_part)>>24);		 
N		ST_WORD(tbl+64, 0xAA55);		/* Signature */
X		*(BYTE*)(tbl+64)=(BYTE)(0xAA55); *(BYTE*)((tbl+64)+1)=(BYTE)((WORD)(0xAA55)>>8);		 
N		if (disk_write(drv, fs->win, 0, 1) != RES_OK)
N			return FR_DISK_ERR;
N		partition = 0xF8;
N	} else {
N		partition = 0xF0;
N	}
N
N	/* Create boot record */
N	tbl = fs->win;								/* Clear buffer */
N	mem_set(tbl, 0, SS(fs));
X	mem_set(tbl, 0, 512U);
N	ST_DWORD(tbl+BS_jmpBoot, 0x90FEEB);			/* Boot code (jmp $, nop) */
X	*(BYTE*)(tbl+0)=(BYTE)(0x90FEEB); *(BYTE*)((tbl+0)+1)=(BYTE)((WORD)(0x90FEEB)>>8); *(BYTE*)((tbl+0)+2)=(BYTE)((DWORD)(0x90FEEB)>>16); *(BYTE*)((tbl+0)+3)=(BYTE)((DWORD)(0x90FEEB)>>24);			 
N	ST_WORD(tbl+BPB_BytsPerSec, SS(fs));		/* Sector size */
X	*(BYTE*)(tbl+11)=(BYTE)(512U); *(BYTE*)((tbl+11)+1)=(BYTE)((WORD)(512U)>>8);		 
N	tbl[BPB_SecPerClus] = (BYTE)allocsize;		/* Sectors per cluster */
X	tbl[13] = (BYTE)allocsize;		 
N	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);			/* Reserved sectors */
X	*(BYTE*)(tbl+14)=(BYTE)(n_rsv); *(BYTE*)((tbl+14)+1)=(BYTE)((WORD)(n_rsv)>>8);			 
N	tbl[BPB_NumFATs] = N_FATS;					/* Number of FATs */
X	tbl[16] = 1;					 
N	ST_WORD(tbl+BPB_RootEntCnt, SS(fs) / 32 * n_dir); /* Number of rootdir entries */
X	*(BYTE*)(tbl+17)=(BYTE)(512U / 32 * n_dir); *(BYTE*)((tbl+17)+1)=(BYTE)((WORD)(512U / 32 * n_dir)>>8);  
N	if (n_part < 0x10000) {						/* Number of total sectors */
N		ST_WORD(tbl+BPB_TotSec16, n_part);
X		*(BYTE*)(tbl+19)=(BYTE)(n_part); *(BYTE*)((tbl+19)+1)=(BYTE)((WORD)(n_part)>>8);
N	} else {
N		ST_DWORD(tbl+BPB_TotSec32, n_part);
X		*(BYTE*)(tbl+32)=(BYTE)(n_part); *(BYTE*)((tbl+32)+1)=(BYTE)((WORD)(n_part)>>8); *(BYTE*)((tbl+32)+2)=(BYTE)((DWORD)(n_part)>>16); *(BYTE*)((tbl+32)+3)=(BYTE)((DWORD)(n_part)>>24);
N	}
N	tbl[BPB_Media] = partition;					/* Media descripter */
X	tbl[21] = partition;					 
N	ST_WORD(tbl+BPB_SecPerTrk, 63);				/* Number of sectors per track */
X	*(BYTE*)(tbl+24)=(BYTE)(63); *(BYTE*)((tbl+24)+1)=(BYTE)((WORD)(63)>>8);				 
N	ST_WORD(tbl+BPB_NumHeads, 255);				/* Number of heads */
X	*(BYTE*)(tbl+26)=(BYTE)(255); *(BYTE*)((tbl+26)+1)=(BYTE)((WORD)(255)>>8);				 
N	ST_DWORD(tbl+BPB_HiddSec, b_part);			/* Hidden sectors */
X	*(BYTE*)(tbl+28)=(BYTE)(b_part); *(BYTE*)((tbl+28)+1)=(BYTE)((WORD)(b_part)>>8); *(BYTE*)((tbl+28)+2)=(BYTE)((DWORD)(b_part)>>16); *(BYTE*)((tbl+28)+3)=(BYTE)((DWORD)(b_part)>>24);			 
N	n = get_fattime();							/* Use current time as a VSN */
N	if (fmt != FS_FAT32) {
X	if (fmt != 3) {
N		ST_DWORD(tbl+BS_VolID, n);				/* Volume serial number */
X		*(BYTE*)(tbl+39)=(BYTE)(n); *(BYTE*)((tbl+39)+1)=(BYTE)((WORD)(n)>>8); *(BYTE*)((tbl+39)+2)=(BYTE)((DWORD)(n)>>16); *(BYTE*)((tbl+39)+3)=(BYTE)((DWORD)(n)>>24);				 
N		ST_WORD(tbl+BPB_FATSz16, n_fat);		/* Number of secters per FAT */
X		*(BYTE*)(tbl+22)=(BYTE)(n_fat); *(BYTE*)((tbl+22)+1)=(BYTE)((WORD)(n_fat)>>8);		 
N		tbl[BS_DrvNum] = 0x80;					/* Drive number */
X		tbl[36] = 0x80;					 
N		tbl[BS_BootSig] = 0x29;					/* Extended boot signature */
X		tbl[38] = 0x29;					 
N		mem_cpy(tbl+BS_VolLab, "NO NAME    FAT     ", 19);	/* Volume lavel, FAT signature */
X		mem_cpy(tbl+43, "NO NAME    FAT     ", 19);	 
N	} else {
N		ST_DWORD(tbl+BS_VolID32, n);			/* Volume serial number */
X		*(BYTE*)(tbl+67)=(BYTE)(n); *(BYTE*)((tbl+67)+1)=(BYTE)((WORD)(n)>>8); *(BYTE*)((tbl+67)+2)=(BYTE)((DWORD)(n)>>16); *(BYTE*)((tbl+67)+3)=(BYTE)((DWORD)(n)>>24);			 
N		ST_DWORD(tbl+BPB_FATSz32, n_fat);		/* Number of secters per FAT */
X		*(BYTE*)(tbl+36)=(BYTE)(n_fat); *(BYTE*)((tbl+36)+1)=(BYTE)((WORD)(n_fat)>>8); *(BYTE*)((tbl+36)+2)=(BYTE)((DWORD)(n_fat)>>16); *(BYTE*)((tbl+36)+3)=(BYTE)((DWORD)(n_fat)>>24);		 
N		ST_DWORD(tbl+BPB_RootClus, 2);			/* Root directory cluster (2) */
X		*(BYTE*)(tbl+44)=(BYTE)(2); *(BYTE*)((tbl+44)+1)=(BYTE)((WORD)(2)>>8); *(BYTE*)((tbl+44)+2)=(BYTE)((DWORD)(2)>>16); *(BYTE*)((tbl+44)+3)=(BYTE)((DWORD)(2)>>24);			 
N		ST_WORD(tbl+BPB_FSInfo, 1);				/* FSInfo record offset (bs+1) */
X		*(BYTE*)(tbl+48)=(BYTE)(1); *(BYTE*)((tbl+48)+1)=(BYTE)((WORD)(1)>>8);				 
N		ST_WORD(tbl+BPB_BkBootSec, 6);			/* Backup boot record offset (bs+6) */
X		*(BYTE*)(tbl+50)=(BYTE)(6); *(BYTE*)((tbl+50)+1)=(BYTE)((WORD)(6)>>8);			 
N		tbl[BS_DrvNum32] = 0x80;				/* Drive number */
X		tbl[64] = 0x80;				 
N		tbl[BS_BootSig32] = 0x29;				/* Extended boot signature */
X		tbl[66] = 0x29;				 
N		mem_cpy(tbl+BS_VolLab32, "NO NAME    FAT32   ", 19);	/* Volume lavel, FAT signature */
X		mem_cpy(tbl+71, "NO NAME    FAT32   ", 19);	 
N	}
N	ST_WORD(tbl+BS_55AA, 0xAA55);				/* Signature */
X	*(BYTE*)(tbl+510)=(BYTE)(0xAA55); *(BYTE*)((tbl+510)+1)=(BYTE)((WORD)(0xAA55)>>8);				 
N	if (SS(fs) > 512U) {
X	if (512U > 512U) {
N		ST_WORD(tbl+SS(fs)-2, 0xAA55);
X		*(BYTE*)(tbl+512U-2)=(BYTE)(0xAA55); *(BYTE*)((tbl+512U-2)+1)=(BYTE)((WORD)(0xAA55)>>8);
N	}
N	if (disk_write(drv, tbl, b_part+0, 1) != RES_OK)
N		return FR_DISK_ERR;
N	if (fmt == FS_FAT32)
X	if (fmt == 3)
N		disk_write(drv, tbl, b_part+6, 1);
N
N	/* Initialize FAT area */
N	for (m = 0; m < N_FATS; m++) {
X	for (m = 0; m < 1; m++) {
N		mem_set(tbl, 0, SS(fs));		/* 1st sector of the FAT  */
X		mem_set(tbl, 0, 512U);		 
N		if (fmt != FS_FAT32) {
X		if (fmt != 3) {
N			n = (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
X			n = (fmt == 1) ? 0x00FFFF00 : 0xFFFFFF00;
N			n |= partition;
N			ST_DWORD(tbl, n);				/* Reserve cluster #0-1 (FAT12/16) */
X			*(BYTE*)(tbl)=(BYTE)(n); *(BYTE*)((tbl)+1)=(BYTE)((WORD)(n)>>8); *(BYTE*)((tbl)+2)=(BYTE)((DWORD)(n)>>16); *(BYTE*)((tbl)+3)=(BYTE)((DWORD)(n)>>24);				 
N		} else {
N			ST_DWORD(tbl+0, 0xFFFFFFF8);	/* Reserve cluster #0-1 (FAT32) */
X			*(BYTE*)(tbl+0)=(BYTE)(0xFFFFFFF8); *(BYTE*)((tbl+0)+1)=(BYTE)((WORD)(0xFFFFFFF8)>>8); *(BYTE*)((tbl+0)+2)=(BYTE)((DWORD)(0xFFFFFFF8)>>16); *(BYTE*)((tbl+0)+3)=(BYTE)((DWORD)(0xFFFFFFF8)>>24);	 
N			ST_DWORD(tbl+4, 0xFFFFFFFF);
X			*(BYTE*)(tbl+4)=(BYTE)(0xFFFFFFFF); *(BYTE*)((tbl+4)+1)=(BYTE)((WORD)(0xFFFFFFFF)>>8); *(BYTE*)((tbl+4)+2)=(BYTE)((DWORD)(0xFFFFFFFF)>>16); *(BYTE*)((tbl+4)+3)=(BYTE)((DWORD)(0xFFFFFFFF)>>24);
N			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
X			*(BYTE*)(tbl+8)=(BYTE)(0x0FFFFFFF); *(BYTE*)((tbl+8)+1)=(BYTE)((WORD)(0x0FFFFFFF)>>8); *(BYTE*)((tbl+8)+2)=(BYTE)((DWORD)(0x0FFFFFFF)>>16); *(BYTE*)((tbl+8)+3)=(BYTE)((DWORD)(0x0FFFFFFF)>>24);	 
N		}
N		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
N			return FR_DISK_ERR;
N		mem_set(tbl, 0, SS(fs));		/* Following FAT entries are filled by zero */
X		mem_set(tbl, 0, 512U);		 
N		for (n = 1; n < n_fat; n++) {
N			if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
N				return FR_DISK_ERR;
N		}
N	}
N
N	/* Initialize Root directory */
N	m = (BYTE)((fmt == FS_FAT32) ? allocsize : n_dir);
X	m = (BYTE)((fmt == 3) ? allocsize : n_dir);
N	do {
N		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
N			return FR_DISK_ERR;
N	} while (--m);
N
N	/* Create FSInfo record if needed */
N	if (fmt == FS_FAT32) {
X	if (fmt == 3) {
N		ST_WORD(tbl+BS_55AA, 0xAA55);
X		*(BYTE*)(tbl+510)=(BYTE)(0xAA55); *(BYTE*)((tbl+510)+1)=(BYTE)((WORD)(0xAA55)>>8);
N		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
X		*(BYTE*)(tbl+0)=(BYTE)(0x41615252); *(BYTE*)((tbl+0)+1)=(BYTE)((WORD)(0x41615252)>>8); *(BYTE*)((tbl+0)+2)=(BYTE)((DWORD)(0x41615252)>>16); *(BYTE*)((tbl+0)+3)=(BYTE)((DWORD)(0x41615252)>>24);
N		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
X		*(BYTE*)(tbl+484)=(BYTE)(0x61417272); *(BYTE*)((tbl+484)+1)=(BYTE)((WORD)(0x61417272)>>8); *(BYTE*)((tbl+484)+2)=(BYTE)((DWORD)(0x61417272)>>16); *(BYTE*)((tbl+484)+3)=(BYTE)((DWORD)(0x61417272)>>24);
N		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);
X		*(BYTE*)(tbl+488)=(BYTE)(n_clst - 1); *(BYTE*)((tbl+488)+1)=(BYTE)((WORD)(n_clst - 1)>>8); *(BYTE*)((tbl+488)+2)=(BYTE)((DWORD)(n_clst - 1)>>16); *(BYTE*)((tbl+488)+3)=(BYTE)((DWORD)(n_clst - 1)>>24);
N		ST_DWORD(tbl+FSI_Nxt_Free, 0xFFFFFFFF);
X		*(BYTE*)(tbl+492)=(BYTE)(0xFFFFFFFF); *(BYTE*)((tbl+492)+1)=(BYTE)((WORD)(0xFFFFFFFF)>>8); *(BYTE*)((tbl+492)+2)=(BYTE)((DWORD)(0xFFFFFFFF)>>16); *(BYTE*)((tbl+492)+3)=(BYTE)((DWORD)(0xFFFFFFFF)>>24);
N		disk_write(drv, tbl, b_part+1, 1);
N		disk_write(drv, tbl, b_part+7, 1);
N	}
N
N	return (disk_ioctl(drv, CTRL_SYNC, (void*)NULL) == RES_OK) ? FR_OK : FR_DISK_ERR;
X	return (disk_ioctl(drv, 0, (void*)0) == RES_OK) ? FR_OK : FR_DISK_ERR;
N}
N
N#endif /* _USE_MKFS && !_FS_READONLY */
N
N
N
N
N#if _USE_STRFUNC
X#if 0
S/*-----------------------------------------------------------------------*/
S/* Get a string from the file                                            */
S/*-----------------------------------------------------------------------*/
Schar* f_gets (
S	char* buff,	/* Pointer to the string buffer to read */
S	int len,	/* Size of string buffer */
S	FIL* fil	/* Pointer to the file object */
S)
S{
S	int i = 0;
S	char *p = buff;
S	UINT rc;
S
S
S	while (i < len - 1) {			/* Read bytes until buffer gets filled */
S		f_read(fil, p, 1, &rc);
S		if (rc != 1) break;			/* Break when no data to read */
S#if _USE_STRFUNC >= 2
S		if (*p == '\r') continue;	/* Strip '\r' */
S#endif
S		i++;
S		if (*p++ == '\n') break;	/* Break when reached end of line */
S	}
S	*p = 0;
S	return i ? buff : NULL;			/* When no data read (eof or error), return with error. */
S}
S
S
S
S#if !_FS_READONLY
S#include <stdarg.h>
S/*-----------------------------------------------------------------------*/
S/* Put a character to the file                                           */
S/*-----------------------------------------------------------------------*/
Sint f_putc (
S	int chr,	/* A character to be output */
S	FIL* fil	/* Ponter to the file object */
S)
S{
S	UINT bw;
S	char c;
S
S
S#if _USE_STRFUNC >= 2
S	if (chr == '\n') f_putc ('\r', fil);	/* LF -> CRLF conversion */
S#endif
S	if (!fil) {	/* Special value may be used to switch the destination to any other device */
S	/*	put_console(chr);	*/
S		return chr;
S	}
S	c = (char)chr;
S	f_write(fil, &c, 1, &bw);	/* Write a byte to the file */
S	return bw ? chr : EOF;		/* Return the result */
S}
S
S
S
S
S/*-----------------------------------------------------------------------*/
S/* Put a string to the file                                              */
S/*-----------------------------------------------------------------------*/
Sint f_puts (
S	const char* str,	/* Pointer to the string to be output */
S	FIL* fil			/* Pointer to the file object */
S)
S{
S	int n;
S
S
S	for (n = 0; *str; str++, n++) {
S		if (f_putc(*str, fil) == EOF) return EOF;
S	}
S	return n;
S}
S
S
S
S
S/*-----------------------------------------------------------------------*/
S/* Put a formatted string to the file                                    */
S/*-----------------------------------------------------------------------*/
Sint f_printf (
S	FIL* fil,			/* Pointer to the file object */
S	const char* str,	/* Pointer to the format string */
S	...					/* Optional arguments... */
S)
S{
S	va_list arp;
S	UCHAR c, f, r;
S	ULONG val;
S	char s[16];
S	int i, w, res, cc;
S
S
S	va_start(arp, str);
S
S	for (cc = res = 0; cc != EOF; res += cc) {
S		c = *str++;
S		if (c == 0) break;			/* End of string */
S		if (c != '%') {				/* Non escape cahracter */
S			cc = f_putc(c, fil);
S			if (cc != EOF) cc = 1;
S			continue;
S		}
S		w = f = 0;
S		c = *str++;
S		if (c == '0') {				/* Flag: '0' padding */
S			f = 1; c = *str++;
S		}
S		while (c >= '0' && c <= '9') {	/* Precision */
S			w = w * 10 + (c - '0');
S			c = *str++;
S		}
S		if (c == 'l') {				/* Prefix: Size is long int */
S			f |= 2; c = *str++;
S		}
S		if (c == 's') {				/* Type is string */
S			cc = f_puts(va_arg(arp, char*), fil);
S			continue;
S		}
S		if (c == 'c') {				/* Type is character */
S			cc = f_putc(va_arg(arp, int), fil);
S			if (cc != EOF) cc = 1;
S			continue;
S		}
S		r = 0;
S		if (c == 'd') r = 10;		/* Type is signed decimal */
S		if (c == 'u') r = 10;		/* Type is unsigned decimal */
S		if (c == 'X') r = 16;		/* Type is unsigned hexdecimal */
S		if (r == 0) break;			/* Unknown type */
S		if (f & 2) {				/* Get the value */
S			val = (ULONG)va_arg(arp, long);
S		} else {
S			val = (c == 'd') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int);
S		}
S		/* Put numeral string */
S		if (c == 'd') {
S			if (val & 0x80000000) {
S				val = 0 - val;
S				f |= 4;
S			}
S		}
S		i = sizeof(s) - 1; s[i] = 0;
S		do {
S			c = (UCHAR)(val % r + '0');
S			if (c > '9') c += 7;
S			s[--i] = c;
S			val /= r;
S		} while (i && val);
S		if (i && (f & 4)) s[--i] = '-';
S		w = sizeof(s) - 1 - w;
S		while (i && i > w) s[--i] = (f & 1) ? '0' : ' ';
S		cc = f_puts(&s[i], fil);
S	}
S
S	va_end(arp);
S	return (cc == EOF) ? cc : res;
S}
S
S#endif /* !_FS_READONLY */
N#endif /* _USE_STRFUNC */
