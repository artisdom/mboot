; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--thumb --list --debug -c --asm --interleave --gnu -o.\output\cp15.o --asm_dir=.\output\ --list_dir=.\output\ --depend=.\output\cp15.d --cpu=ARM926EJ-S --apcs=interwork -O1 -I.\atmel -I.\ -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\Atmel\SAM9M10 -Dat91sam9m10 -Dddram -DNOFPUT -DTRACE_LEVEL=4 --omf_browse=.\output\cp15.crf cp15.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  CP15_IsIcacheEnabled PROC
;;;96     unsigned int
;;;97     CP15_IsIcacheEnabled(void)
000000  b510              PUSH     {r4,lr}
;;;98     {
;;;99         unsigned int control;
;;;100    
;;;101        control = CP15_ReadControl();
000002  f7fffffe          BL       CP15_ReadControl
;;;102        return ((control & (1 << CP15_I_BIT)) != 0);
000006  04c0              LSLS     r0,r0,#19
000008  0fc0              LSRS     r0,r0,#31
;;;103    } 
00000a  bd10              POP      {r4,pc}
;;;104    
                          ENDP

                  CP15_EnableIcache PROC
;;;108    void
;;;109    CP15_EnableIcache(void)
00000c  b510              PUSH     {r4,lr}
;;;110    {
;;;111        unsigned int control;
;;;112    
;;;113        control = CP15_ReadControl();
00000e  f7fffffe          BL       CP15_ReadControl
;;;114    
;;;115        // Check if cache is disabled
;;;116        if ((control & (1 << CP15_I_BIT)) == 0) {
000012  04c1              LSLS     r1,r0,#19
000014  d404              BMI      |L1.32|
;;;117    
;;;118            control |= (1 << CP15_I_BIT);
000016  2101              MOVS     r1,#1
000018  0309              LSLS     r1,r1,#12
00001a  4308              ORRS     r0,r0,r1
;;;119            CP15_WriteControl(control);        
00001c  f7fffffe          BL       CP15_WriteControl
                  |L1.32|
;;;120            // TRACE_INFO("I cache enabled.\n\r");
;;;121        }
;;;122    #if !defined(OP_BOOTSTRAP_on)
;;;123        else {
;;;124    
;;;125            // TRACE_INFO("I cache is already enabled.\n\r");
;;;126        }
;;;127    #endif
;;;128    }
000020  bd10              POP      {r4,pc}
;;;129    
                          ENDP

                  CP15_DisableIcache PROC
;;;133    void
;;;134    CP15_DisableIcache(void)
000022  b510              PUSH     {r4,lr}
;;;135    {
;;;136        unsigned int control;
;;;137    
;;;138        control = CP15_ReadControl();
000024  f7fffffe          BL       CP15_ReadControl
;;;139    
;;;140        // Check if cache is enabled
;;;141        if ((control & (1 << CP15_I_BIT)) != 0) {
000028  04c1              LSLS     r1,r0,#19
00002a  d504              BPL      |L1.54|
;;;142    
;;;143            control &= ~(1 << CP15_I_BIT);
00002c  2101              MOVS     r1,#1
00002e  0309              LSLS     r1,r1,#12
000030  4388              BICS     r0,r0,r1
;;;144            CP15_WriteControl(control);        
000032  f7fffffe          BL       CP15_WriteControl
                  |L1.54|
;;;145            // TRACE_INFO("I cache disabled.\n\r");
;;;146        }
;;;147        else {
;;;148    
;;;149            // TRACE_INFO("I cache is already disabled.\n\r");
;;;150        }
;;;151    } 
000036  bd10              POP      {r4,pc}
;;;152    
                          ENDP

                  CP15_IsMMUEnabled PROC
;;;157    unsigned int
;;;158    CP15_IsMMUEnabled(void)
000038  b510              PUSH     {r4,lr}
;;;159    {
;;;160        unsigned int control;
;;;161    
;;;162        control = CP15_ReadControl();
00003a  f7fffffe          BL       CP15_ReadControl
;;;163        return ((control & (1 << CP15_M_BIT)) != 0);
00003e  07c0              LSLS     r0,r0,#31
000040  0fc0              LSRS     r0,r0,#31
;;;164    } 
000042  bd10              POP      {r4,pc}
;;;165    
                          ENDP

                  CP15_EnableMMU PROC
;;;169    void
;;;170    CP15_EnableMMU(void)
000044  b510              PUSH     {r4,lr}
;;;171    {
;;;172        unsigned int control;
;;;173    
;;;174        control = CP15_ReadControl();
000046  f7fffffe          BL       CP15_ReadControl
;;;175    
;;;176        // Check if MMU is disabled
;;;177        if ((control & (1 << CP15_M_BIT)) == 0) {
00004a  07c1              LSLS     r1,r0,#31
00004c  d103              BNE      |L1.86|
;;;178    
;;;179            control |= (1 << CP15_M_BIT);
00004e  2101              MOVS     r1,#1
000050  4308              ORRS     r0,r0,r1
;;;180            CP15_WriteControl(control);        
000052  f7fffffe          BL       CP15_WriteControl
                  |L1.86|
;;;181            // TRACE_INFO("MMU enabled.\n\r");
;;;182        }
;;;183        else {
;;;184    
;;;185            // TRACE_INFO("MMU is already enabled.\n\r");
;;;186        }
;;;187    }
000056  bd10              POP      {r4,pc}
;;;188    
                          ENDP

                  CP15_DisableMMU PROC
;;;192    void
;;;193    CP15_DisableMMU(void)
000058  b510              PUSH     {r4,lr}
;;;194    {
;;;195        unsigned int control;
;;;196    
;;;197        control = CP15_ReadControl();
00005a  f7fffffe          BL       CP15_ReadControl
;;;198    
;;;199        // Check if MMU is enabled
;;;200        if ((control & (1 << CP15_M_BIT)) != 0) {
00005e  07c1              LSLS     r1,r0,#31
000060  d005              BEQ      |L1.110|
;;;201    
;;;202            control &= ~(1 << CP15_M_BIT);
000062  0840              LSRS     r0,r0,#1
000064  0040              LSLS     r0,r0,#1
;;;203            control &= ~(1 << CP15_C_BIT);
000066  2104              MOVS     r1,#4
000068  4388              BICS     r0,r0,r1
;;;204            CP15_WriteControl(control);        
00006a  f7fffffe          BL       CP15_WriteControl
                  |L1.110|
;;;205            // TRACE_INFO("MMU disabled.\n\r");
;;;206        }
;;;207        else {
;;;208    
;;;209            // TRACE_INFO("MMU is already disabled.\n\r");
;;;210        }
;;;211    }
00006e  bd10              POP      {r4,pc}
;;;212    
                          ENDP

                  CP15_IsDcacheEnabled PROC
;;;217    unsigned int
;;;218    CP15_IsDcacheEnabled(void)
000070  b510              PUSH     {r4,lr}
;;;219    {
;;;220        unsigned int control;
;;;221    
;;;222        control = CP15_ReadControl();
000072  f7fffffe          BL       CP15_ReadControl
;;;223        return ((control & ((1 << CP15_C_BIT)||(1 << CP15_M_BIT))) != 0);
000076  07c0              LSLS     r0,r0,#31
000078  0fc0              LSRS     r0,r0,#31
;;;224    } 
00007a  bd10              POP      {r4,pc}
;;;225    
                          ENDP

                  CP15_EnableDcache PROC
;;;229    void
;;;230    CP15_EnableDcache(void)
00007c  b510              PUSH     {r4,lr}
;;;231    {
;;;232        unsigned int control;
;;;233    
;;;234        control = CP15_ReadControl();
00007e  f7fffffe          BL       CP15_ReadControl
000082  0004              MOVS     r4,r0
;;;235    
;;;236        if( !CP15_IsMMUEnabled() ) {
000084  f7fffffe          BL       CP15_IsMMUEnabled
000088  2800              CMP      r0,#0
00008a  d005              BEQ      |L1.152|
;;;237            // TRACE_ERROR("Do nothing: MMU not enabled\n\r");
;;;238        }
;;;239        else {
;;;240            // Check if cache is disabled
;;;241            if ((control & (1 << CP15_C_BIT)) == 0) {
00008c  0760              LSLS     r0,r4,#29
00008e  d403              BMI      |L1.152|
;;;242    
;;;243                control |= (1 << CP15_C_BIT);
000090  2004              MOVS     r0,#4
000092  4320              ORRS     r0,r0,r4
;;;244                CP15_WriteControl(control);        
000094  f7fffffe          BL       CP15_WriteControl
                  |L1.152|
;;;245                // TRACE_INFO("D cache enabled.\n\r");
;;;246            }
;;;247            else {
;;;248    
;;;249                // TRACE_INFO("D cache is already enabled.\n\r");
;;;250            }
;;;251        }
;;;252    }
000098  bd10              POP      {r4,pc}
;;;253    
                          ENDP

                  CP15_DisableDcache PROC
;;;257    void
;;;258    CP15_DisableDcache(void)
00009a  b510              PUSH     {r4,lr}
;;;259    {
;;;260        unsigned int control;
;;;261    
;;;262        control = CP15_ReadControl();
00009c  f7fffffe          BL       CP15_ReadControl
;;;263    
;;;264        // Check if cache is enabled
;;;265        if ((control & (1 << CP15_C_BIT)) != 0) {
0000a0  0741              LSLS     r1,r0,#29
0000a2  d503              BPL      |L1.172|
;;;266    
;;;267            control &= ~(1 << CP15_C_BIT);
0000a4  2104              MOVS     r1,#4
0000a6  4388              BICS     r0,r0,r1
;;;268            CP15_WriteControl(control);        
0000a8  f7fffffe          BL       CP15_WriteControl
                  |L1.172|
;;;269            // TRACE_INFO("D cache disabled.\n\r");
;;;270        }
;;;271        else {
;;;272    
;;;273            // TRACE_INFO("D cache is already disabled.\n\r");
;;;274        }
;;;275    }
0000ac  bd10              POP      {r4,pc}
;;;276    
                          ENDP

                  CP15_LockIcache PROC
;;;281    void
;;;282    CP15_LockIcache(unsigned int index)
0000ae  b510              PUSH     {r4,lr}
;;;283    {
0000b0  0004              MOVS     r4,r0
;;;284        unsigned int victim = 0;
;;;285    
;;;286        // invalidate all the cache (4 ways) 
;;;287        CP15_InvalidateIcache();
0000b2  f7fffffe          BL       CP15_InvalidateIcache
;;;288        
;;;289        // lockdown all the ways except this in parameter
;;;290        victim =  CP15_ReadIcacheLockdown();
0000b6  f7fffffe          BL       CP15_ReadIcacheLockdown
;;;291        victim = 0;
;;;292        victim |= ~index;
0000ba  43e0              MVNS     r0,r4
;;;293        victim &= 0xffff;
0000bc  0400              LSLS     r0,r0,#16
0000be  0c00              LSRS     r0,r0,#16
;;;294        CP15_WriteIcacheLockdown(victim);
0000c0  f7fffffe          BL       CP15_WriteIcacheLockdown
;;;295    }
0000c4  bd10              POP      {r4,pc}
;;;296    
                          ENDP

                  CP15_LockDcache PROC
;;;301    void
;;;302    CP15_LockDcache(unsigned int index)
0000c6  b510              PUSH     {r4,lr}
;;;303    {
0000c8  0004              MOVS     r4,r0
;;;304        unsigned int victim = 0;
;;;305    
;;;306        // invalidate all the cache (4 ways)    
;;;307        CP15_InvalidateDcache();
0000ca  f7fffffe          BL       CP15_InvalidateDcache
;;;308        
;;;309        // lockdown all the ways except this in parameter    
;;;310        victim =  CP15_ReadDcacheLockdown();
0000ce  f7fffffe          BL       CP15_ReadDcacheLockdown
;;;311        victim = 0;
;;;312        victim |= ~index;
0000d2  43e0              MVNS     r0,r4
;;;313        victim &= 0xffff;
0000d4  0400              LSLS     r0,r0,#16
0000d6  0c00              LSRS     r0,r0,#16
;;;314        CP15_WriteDcacheLockdown(victim);
0000d8  f7fffffe          BL       CP15_WriteDcacheLockdown
;;;315    }
0000dc  bd10              POP      {r4,pc}
;;;316    
                          ENDP

                  CP15_ShutdownDcache PROC
;;;321    void
;;;322    CP15_ShutdownDcache(void)
0000de  b510              PUSH     {r4,lr}
;;;323    { 
;;;324        CP15_TestCleanInvalidateDcache();  
0000e0  f7fffffe          BL       CP15_TestCleanInvalidateDcache
;;;325        CP15_DrainWriteBuffer();
0000e4  f7fffffe          BL       CP15_DrainWriteBuffer
;;;326        CP15_DisableDcache();
0000e8  f7fffffe          BL       CP15_DisableDcache
;;;327        CP15_InvalidateTLB();      
0000ec  f7fffffe          BL       CP15_InvalidateTLB
;;;328    }
0000f0  bd10              POP      {r4,pc}
                          ENDP

