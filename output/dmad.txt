; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--thumb --list --debug -c --asm --interleave --gnu -o.\output\dmad.o --asm_dir=.\output\ --list_dir=.\output\ --depend=.\output\dmad.d --cpu=ARM926EJ-S --apcs=interwork -O1 -I.\atmel -I.\ -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\Atmel\SAM9M10 -Dat91sam9m10 -Dddram -DNOFPUT -DTRACE_LEVEL=4 --omf_browse=.\output\dmad.crf atmel\dmad.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  DMAD_Handler PROC
;;;84     //------------------------------------------------------------------------------ 
;;;85     void DMAD_Handler()
000000  b5f8              PUSH     {r3-r7,lr}
;;;86     {
;;;87         unsigned int status;
;;;88         unsigned char channel;
;;;89         DmaTransfer *pTransfer;
;;;90         status = DMA_GetStatus();
000002  f7fffffe          BL       DMA_GetStatus
000006  0006              MOVS     r6,r0
;;;91         // Check if the buffer transfer completed is set.
;;;92         if(status & AT91C_BTC)
000008  0630              LSLS     r0,r6,#24
00000a  d01d              BEQ      |L1.72|
;;;93         {
;;;94             // Scan each channel status.
;;;95             for(channel = 0; channel < DMA_CHANNEL_NUM; channel++) {
00000c  2400              MOVS     r4,#0
                  |L1.14|
;;;96                 if(!(status & (DMA_BTC << channel))){
00000e  2701              MOVS     r7,#1
000010  40a7              LSLS     r7,r7,r4
000012  0038              MOVS     r0,r7
000014  4230              TST      r0,r6
000016  d012              BEQ      |L1.62|
;;;97                     continue;
;;;98                 }
;;;99                 
;;;100                dmad.transfers[channel].transferSize -= dmad.transfers[channel].bufSize;
000018  4882              LDR      r0,|L1.548|
00001a  0121              LSLS     r1,r4,#4
00001c  180d              ADDS     r5,r1,r0
00001e  68a9              LDR      r1,[r5,#8]
000020  6868              LDR      r0,[r5,#4]
000022  1a09              SUBS     r1,r1,r0
000024  60a9              STR      r1,[r5,#8]
;;;101                // if next buffer is to be the last buffer in the transfer, then clear the automatic mode bit.
;;;102                if(dmad.transfers[channel].transferSize <= dmad.transfers[channel].bufSize) {
000026  68a9              LDR      r1,[r5,#8]
000028  4281              CMP      r1,r0
00002a  d802              BHI      |L1.50|
;;;103                    DMA_ClearAutoMode(channel);
00002c  0020              MOVS     r0,r4
00002e  f7fffffe          BL       DMA_ClearAutoMode
                  |L1.50|
;;;104                }
;;;105                // Transfer finished
;;;106                if(dmad.transfers[channel].transferSize == 0) {
000032  68a8              LDR      r0,[r5,#8]
000034  2800              CMP      r0,#0
000036  d008              BEQ      |L1.74|
;;;107                    pTransfer = &(dmad.transfers[channel]);
;;;108                    pTransfer->callback();
;;;109                    DMA_DisableIt(DMA_BTC << channel); 
;;;110                    DMA_DisableChannel(channel);
;;;111                }
;;;112                else
;;;113                {
;;;114                    // Write the KEEPON field to clear the STALL states.
;;;115                    DMA_KeeponChannel(channel);
000038  0020              MOVS     r0,r4
00003a  f7fffffe          BL       DMA_KeeponChannel
                  |L1.62|
00003e  1c64              ADDS     r4,r4,#1              ;95
000040  0624              LSLS     r4,r4,#24             ;95
000042  0e24              LSRS     r4,r4,#24             ;95
000044  2c08              CMP      r4,#8                 ;95
000046  d3e2              BCC      |L1.14|
                  |L1.72|
;;;116                }
;;;117            }
;;;118        }
;;;119    }
000048  bdf8              POP      {r3-r7,pc}
                  |L1.74|
00004a  68e8              LDR      r0,[r5,#0xc]          ;108
00004c  4780              BLX      r0                    ;108
00004e  0038              MOVS     r0,r7                 ;109
000050  f7fffffe          BL       DMA_DisableIt
000054  0020              MOVS     r0,r4                 ;110
000056  f7fffffe          BL       DMA_DisableChannel
00005a  e7f0              B        |L1.62|
;;;120    
                          ENDP

                  DMAD_Initialize PROC
;;;125    //------------------------------------------------------------------------------
;;;126    void DMAD_Initialize(unsigned char channel, unsigned char defaultHandler)
00005c  b570              PUSH     {r4-r6,lr}
;;;127    {
00005e  0005              MOVS     r5,r0
000060  000c              MOVS     r4,r1
;;;128        unsigned int status;
;;;129        unsigned int flag;
;;;130         
;;;131        // Enable peripheral clock
;;;132    #if !defined(at91sam9rl64)    
;;;133        AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_HDMA;    
000062  4a71              LDR      r2,|L1.552|
000064  4871              LDR      r0,|L1.556|
000066  6102              STR      r2,[r0,#0x10]
;;;134    #endif    
;;;135        
;;;136        // Read the channel handler status to ensure the channel is a free channel.
;;;137        status = DMA_GetChannelStatus();
000068  f7fffffe          BL       DMA_GetChannelStatus
;;;138        DEBUG_MSG("DMAD_Initialize channel: 0x%x | status: 0x%x", channel, status);
;;;139        SANITY_CHECK(!(status & (1 << channel)));
;;;140        // Clear any pending interrupts on the channel.
;;;141        DMA_GetStatus();
00006c  f7fffffe          BL       DMA_GetStatus
;;;142        // Disble the channel.
;;;143        DMA_DisableChannel(channel);
000070  0028              MOVS     r0,r5
000072  f7fffffe          BL       DMA_DisableChannel
;;;144        // Disable the interrupt
;;;145        flag = 0xffffff;
000076  486e              LDR      r0,|L1.560|
;;;146        DMA_DisableIt(flag);
000078  f7fffffe          BL       DMA_DisableIt
;;;147        // Enable DMA.
;;;148        DMA_Enable();
00007c  f7fffffe          BL       DMA_Enable
;;;149        if(defaultHandler) 
000080  2c00              CMP      r4,#0
000082  d007              BEQ      |L1.148|
;;;150        {
;;;151            IRQ_ConfigureIT(AT91C_ID_HDMA, 0, DMAD_Handler);
000084  4a6b              LDR      r2,|L1.564|
000086  2100              MOVS     r1,#0
000088  2015              MOVS     r0,#0x15
00008a  f7fffffe          BL       IRQ_ConfigureIT
;;;152            IRQ_EnableIT(AT91C_ID_HDMA);
00008e  2015              MOVS     r0,#0x15
000090  f7fffffe          BL       IRQ_EnableIT
                  |L1.148|
;;;153        }
;;;154        // Initialize transfer instance.
;;;155        dmad.transfers[channel].transferSize = 0;
000094  4a63              LDR      r2,|L1.548|
000096  2100              MOVS     r1,#0
000098  0128              LSLS     r0,r5,#4
00009a  1880              ADDS     r0,r0,r2
00009c  6081              STR      r1,[r0,#8]
;;;156    }
00009e  bd70              POP      {r4-r6,pc}
;;;157     
                          ENDP

                  DMAD_Configure_Buffer PROC
;;;167    //------------------------------------------------------------------------------
;;;168    unsigned char DMAD_Configure_Buffer(unsigned char channel,
0000a0  b5f8              PUSH     {r3-r7,lr}
;;;169                               unsigned char sourceTransferMode,
;;;170                               unsigned char destTransferMode,
;;;171                               DmaLinkList *lli,
;;;172                               PictureInPicture *pip)
;;;173    {
0000a2  9c06              LDR      r4,[sp,#0x18]
0000a4  0005              MOVS     r5,r0
0000a6  0017              MOVS     r7,r2
0000a8  001e              MOVS     r6,r3
;;;174        DmaTransfer *pTransfer = &(dmad.transfers[channel]);
0000aa  4a5e              LDR      r2,|L1.548|
0000ac  0128              LSLS     r0,r5,#4
0000ae  1880              ADDS     r0,r0,r2
;;;175        // Check that no transfer is pending on the channel
;;;176        if (pTransfer-> transferSize > 0 ) {
0000b0  6880              LDR      r0,[r0,#8]
0000b2  2800              CMP      r0,#0
0000b4  d013              BEQ      |L1.222|
;;;177            TRACE_ERROR("DAM transfer is already pending\n\r");
0000b6  201b              MOVS     r0,#0x1b
0000b8  f7fffffe          BL       ShellPutByte
0000bc  a05e              ADR      r0,|L1.568|
0000be  f7fffffe          BL       ShellPrintf
0000c2  201b              MOVS     r0,#0x1b
0000c4  f7fffffe          BL       ShellPutByte
0000c8  a05e              ADR      r0,|L1.580|
0000ca  f7fffffe          BL       ShellPrintf
0000ce  a05e              ADR      r0,|L1.584|
0000d0  f7fffffe          BL       ShellPrintf
0000d4  a065              ADR      r0,|L1.620|
0000d6  f7fffffe          BL       ShellPrintf
;;;178            return DMAD_ERROR_BUSY;
0000da  2001              MOVS     r0,#1
;;;179        }
;;;180        // Configure source transfer mode.
;;;181        DMA_SetSourceBufferMode(channel, sourceTransferMode, 0);
;;;182        
;;;183        // Configure destination transfer mode.
;;;184        DMA_SetDestBufferMode(channel, destTransferMode, 0);
;;;185        
;;;186        if(lli){
;;;187            DMA_SetDescriptorAddr(channel, (unsigned int)(&lli[0]));
;;;188        }
;;;189        else {
;;;190            DMA_SetDescriptorAddr(channel, 0);
;;;191        }
;;;192        
;;;193        if(pip){
;;;194            #if defined(AT91C_SRC_PIP)
;;;195            // If source picture-in-picture mode is enabled, program the DMAC_SPIP.
;;;196            if(pip->pipSourceBoundarySize){
;;;197            // If destination picture-in-picture mode is enabled, program the DMAC_DPIP.
;;;198                DMA_SPIPconfiguration(channel, pip->pipSourceHoleSize, pip->pipSourceBoundarySize);
;;;199            }
;;;200            #endif
;;;201    
;;;202            #if defined(AT91C_DST_PIP)
;;;203            if(pip->pipDestBoundarySize){
;;;204                DMA_DPIPconfiguration(channel, pip->pipDestHoleSize, pip->pipDestBoundarySize);
;;;205            }
;;;206            #endif
;;;207        }
;;;208        return 0;
;;;209    }
0000dc  bdf8              POP      {r3-r7,pc}
                  |L1.222|
0000de  2200              MOVS     r2,#0                 ;181
0000e0  0028              MOVS     r0,r5                 ;181
0000e2  f7fffffe          BL       DMA_SetSourceBufferMode
0000e6  2200              MOVS     r2,#0                 ;184
0000e8  0039              MOVS     r1,r7                 ;184
0000ea  0028              MOVS     r0,r5                 ;184
0000ec  f7fffffe          BL       DMA_SetDestBufferMode
0000f0  2e00              CMP      r6,#0                 ;186
0000f2  d004              BEQ      |L1.254|
0000f4  0031              MOVS     r1,r6                 ;187
0000f6  0028              MOVS     r0,r5                 ;187
0000f8  f7fffffe          BL       DMA_SetDescriptorAddr
0000fc  e003              B        |L1.262|
                  |L1.254|
0000fe  2100              MOVS     r1,#0                 ;190
000100  0028              MOVS     r0,r5                 ;190
000102  f7fffffe          BL       DMA_SetDescriptorAddr
                  |L1.262|
000106  2c00              CMP      r4,#0                 ;193
000108  d00d              BEQ      |L1.294|
00010a  8862              LDRH     r2,[r4,#2]            ;196
00010c  2a00              CMP      r2,#0                 ;196
00010e  d003              BEQ      |L1.280|
000110  8821              LDRH     r1,[r4,#0]            ;198
000112  0028              MOVS     r0,r5                 ;198
000114  f7fffffe          BL       DMA_SPIPconfiguration
                  |L1.280|
000118  88e2              LDRH     r2,[r4,#6]            ;203
00011a  2a00              CMP      r2,#0                 ;203
00011c  d003              BEQ      |L1.294|
00011e  88a1              LDRH     r1,[r4,#4]            ;204
000120  0028              MOVS     r0,r5                 ;204
000122  f7fffffe          BL       DMA_DPIPconfiguration
                  |L1.294|
000126  2000              MOVS     r0,#0                 ;208
000128  bdf8              POP      {r3-r7,pc}
;;;210    
                          ENDP

                  DMAD_Configure_TransferController PROC
;;;219    //------------------------------------------------------------------------------
;;;220    unsigned char DMAD_Configure_TransferController(unsigned char channel,
00012a  b5f8              PUSH     {r3-r7,lr}
;;;221                                          unsigned int bufSize,
;;;222                                          unsigned char sourceWidth,
;;;223                                          unsigned char destWidth,
;;;224                                          unsigned int sourceAddress,
;;;225                                          unsigned int destAddress)
;;;226    {
00012c  9f07              LDR      r7,[sp,#0x1c]
00012e  9e06              LDR      r6,[sp,#0x18]
000130  0005              MOVS     r5,r0
;;;227        DmaTransfer *pTransfer = &(dmad.transfers[channel]);
000132  4c3c              LDR      r4,|L1.548|
000134  0128              LSLS     r0,r5,#4
000136  1904              ADDS     r4,r0,r4
;;;228        // Check that no transfer is pending on the channel
;;;229        if (pTransfer-> transferSize > 0 ) {
000138  68a0              LDR      r0,[r4,#8]
00013a  2800              CMP      r0,#0
00013c  d013              BEQ      |L1.358|
;;;230            TRACE_ERROR("DAM transfer is already pending\n\r");
00013e  201b              MOVS     r0,#0x1b
000140  f7fffffe          BL       ShellPutByte
000144  a03c              ADR      r0,|L1.568|
000146  f7fffffe          BL       ShellPrintf
00014a  201b              MOVS     r0,#0x1b
00014c  f7fffffe          BL       ShellPutByte
000150  a03c              ADR      r0,|L1.580|
000152  f7fffffe          BL       ShellPrintf
000156  a03c              ADR      r0,|L1.584|
000158  f7fffffe          BL       ShellPrintf
00015c  a043              ADR      r0,|L1.620|
00015e  f7fffffe          BL       ShellPrintf
;;;231            return DMAD_ERROR_BUSY;
000162  2001              MOVS     r0,#1
;;;232        }
;;;233        pTransfer->bufSize = bufSize; 
;;;234        
;;;235        // Set up the transfer width and transfer size.
;;;236        DMA_SetSourceBufferSize(channel, bufSize, sourceWidth, destWidth, 0);
;;;237    
;;;238        if(sourceAddress) {
;;;239            // Write the starting source address.
;;;240            DMA_SetSourceAddr(channel, sourceAddress);
;;;241        }
;;;242        if(destAddress){
;;;243            // Write the starting destination address.
;;;244            DMA_SetDestinationAddr(channel, destAddress);
;;;245        }
;;;246        return 0;
;;;247    }                                 
000164  bdf8              POP      {r3-r7,pc}
                  |L1.358|
000166  6061              STR      r1,[r4,#4]            ;233
000168  2000              MOVS     r0,#0                 ;236
00016a  9000              STR      r0,[sp,#0]            ;236
00016c  0028              MOVS     r0,r5                 ;236
00016e  f7fffffe          BL       DMA_SetSourceBufferSize
000172  2e00              CMP      r6,#0                 ;238
000174  d003              BEQ      |L1.382|
000176  0031              MOVS     r1,r6                 ;240
000178  0028              MOVS     r0,r5                 ;240
00017a  f7fffffe          BL       DMA_SetSourceAddr
                  |L1.382|
00017e  2f00              CMP      r7,#0                 ;242
000180  d003              BEQ      |L1.394|
000182  0039              MOVS     r1,r7                 ;244
000184  0028              MOVS     r0,r5                 ;244
000186  f7fffffe          BL       DMA_SetDestinationAddr
                  |L1.394|
00018a  2000              MOVS     r0,#0                 ;246
00018c  bdf8              POP      {r3-r7,pc}
;;;248                               
                          ENDP

                  DMAD_BufferTransfer PROC
;;;255    //------------------------------------------------------------------------------
;;;256    unsigned char DMAD_BufferTransfer(unsigned char channel, 
00018e  b5f8              PUSH     {r3-r7,lr}
;;;257                                      unsigned int size, 
;;;258                                      DmaCallback callback, 
;;;259                                      unsigned char polling)
;;;260    {
000190  0006              MOVS     r6,r0
000192  001f              MOVS     r7,r3
;;;261        DmaTransfer *pTransfer = &(dmad.transfers[channel]);
000194  4b23              LDR      r3,|L1.548|
000196  0130              LSLS     r0,r6,#4
000198  18c4              ADDS     r4,r0,r3
;;;262        // Check that no transfer is pending on the channel
;;;263        if (pTransfer-> transferSize > 0 ) {
00019a  68a0              LDR      r0,[r4,#8]
00019c  2800              CMP      r0,#0
00019e  d013              BEQ      |L1.456|
;;;264            TRACE_ERROR("DAM transfer is already pending\n\r");
0001a0  201b              MOVS     r0,#0x1b
0001a2  f7fffffe          BL       ShellPutByte
0001a6  a024              ADR      r0,|L1.568|
0001a8  f7fffffe          BL       ShellPrintf
0001ac  201b              MOVS     r0,#0x1b
0001ae  f7fffffe          BL       ShellPutByte
0001b2  a024              ADR      r0,|L1.580|
0001b4  f7fffffe          BL       ShellPrintf
0001b8  a023              ADR      r0,|L1.584|
0001ba  f7fffffe          BL       ShellPrintf
0001be  a02b              ADR      r0,|L1.620|
0001c0  f7fffffe          BL       ShellPrintf
;;;265            return DMAD_ERROR_BUSY;
0001c4  2001              MOVS     r0,#1
;;;266        }
;;;267        pTransfer->status = DMAD_ERROR_BUSY; 
;;;268        pTransfer->transferSize = size;
;;;269        pTransfer->callback = callback; 
;;;270        
;;;271        if(!polling){
;;;272            DMA_EnableIt(DMA_BTC << channel);
;;;273        }
;;;274        // Enable the channel.
;;;275        DMA_EnableChannel(channel);
;;;276        
;;;277        if(polling){
;;;278            while ((DMA_GetChannelStatus() & (DMA_ENA << channel)) == (DMA_ENA << channel));
;;;279            if (pTransfer->callback) {
;;;280                pTransfer->callback();
;;;281            }
;;;282            pTransfer->transferSize = 0;
;;;283            DMA_DisableChannel(channel);
;;;284        }
;;;285        return 0;
;;;286    }
0001c6  bdf8              POP      {r3-r7,pc}
                  |L1.456|
0001c8  2001              MOVS     r0,#1                 ;267
0001ca  7020              STRB     r0,[r4,#0]            ;267
0001cc  60a1              STR      r1,[r4,#8]            ;268
0001ce  60e2              STR      r2,[r4,#0xc]          ;269
0001d0  2501              MOVS     r5,#1                 ;265
0001d2  40b5              LSLS     r5,r5,r6              ;272
0001d4  2f00              CMP      r7,#0                 ;271
0001d6  d102              BNE      |L1.478|
0001d8  0028              MOVS     r0,r5                 ;272
0001da  f7fffffe          BL       DMA_EnableIt
                  |L1.478|
0001de  0030              MOVS     r0,r6                 ;275
0001e0  f7fffffe          BL       DMA_EnableChannel
0001e4  2f00              CMP      r7,#0                 ;277
0001e6  d00d              BEQ      |L1.516|
                  |L1.488|
0001e8  f7fffffe          BL       DMA_GetChannelStatus
0001ec  0029              MOVS     r1,r5                 ;278
0001ee  4381              BICS     r1,r1,r0              ;278
0001f0  d0fa              BEQ      |L1.488|
0001f2  68e0              LDR      r0,[r4,#0xc]          ;279
0001f4  2800              CMP      r0,#0                 ;279
0001f6  d000              BEQ      |L1.506|
0001f8  4780              BLX      r0                    ;280
                  |L1.506|
0001fa  2000              MOVS     r0,#0                 ;282
0001fc  60a0              STR      r0,[r4,#8]            ;282
0001fe  0030              MOVS     r0,r6                 ;283
000200  f7fffffe          BL       DMA_DisableChannel
                  |L1.516|
000204  2000              MOVS     r0,#0                 ;285
000206  bdf8              POP      {r3-r7,pc}
;;;287    
                          ENDP

                  DMAD_IsFinished PROC
;;;292    //------------------------------------------------------------------------------
;;;293    unsigned char DMAD_IsFinished(unsigned char channel)
000208  b510              PUSH     {r4,lr}
;;;294    {
;;;295        SANITY_CHECK(channel <= DMA_CHANNEL_NUM);
;;;296        if (dmad.transfers[channel].transferSize > 0) {
00020a  4a06              LDR      r2,|L1.548|
00020c  0101              LSLS     r1,r0,#4
00020e  1889              ADDS     r1,r1,r2
000210  6889              LDR      r1,[r1,#8]
000212  2900              CMP      r1,#0
000214  d001              BEQ      |L1.538|
;;;297            return 0;
000216  2000              MOVS     r0,#0
;;;298        }
;;;299        else {
;;;300            DMA_DisableChannel(channel);
;;;301            return 1;
;;;302        }
;;;303    }
000218  bd10              POP      {r4,pc}
                  |L1.538|
00021a  f7fffffe          BL       DMA_DisableChannel
00021e  2001              MOVS     r0,#1                 ;301
000220  bd10              POP      {r4,pc}
                          ENDP

000222  0000              DCW      0x0000
                  |L1.548|
                          DCD      ||.bss||
                  |L1.552|
                          DCD      0x00200000
                  |L1.556|
                          DCD      0xfffffc00
                  |L1.560|
                          DCD      0x00ffffff
                  |L1.564|
                          DCD      DMAD_Handler
                  |L1.568|
000238  5b313b31          DCB      "[1;1;31mE: ",0
00023c  3b33316d
000240  453a2000
                  |L1.580|
000244  5b6d00            DCB      "[m",0
000247  00                DCB      0
                  |L1.584|
000248  44414d20          DCB      "DAM transfer is already pending\n\r",0
00024c  7472616e
000250  73666572
000254  20697320
000258  616c7265
00025c  61647920
000260  70656e64
000264  696e670a
000268  0d00    
00026a  00                DCB      0
00026b  00                DCB      0
                  |L1.620|
00026c  0a0d00            DCB      "\n\r",0
00026f  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  dmad
                          %        128
